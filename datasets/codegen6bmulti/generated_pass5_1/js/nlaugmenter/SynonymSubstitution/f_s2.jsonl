{"task_id": "JavaScript/0", "prompt": "/* crack if in given list of numbers, are any two numbers closer to each early than \n   give threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "/* crack if in given list of numbers, are any two numbers closer to each early than \n   give threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const min = numbers[0]\n  const max = numbers[len - 1]\n  const diff = max - min\n  for (let i = 1; i < len - 1; i++) {\n    if (Math.abs(numbers[i] - min) < threshold && Math.abs(numbers[i] - max) < threshold) {\n      return true\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements2 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const min = numbers[0]\n  const max = numbers[len - 1]\n  const diff = max - min\n  for (let i = 1; i < len - 1; i++) {\n    if (Math.abs(numbers[i] - min) < threshold && Math.abs(numbers[i] - max) < threshold) {\n      return true\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements3 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const min = numbers[0]\n  const max = numbers[len - 1]\n  const diff = max - min\n  for (let i = 1; i < len - 1; i++) {\n    if (Math.abs(numbers[i] - min) < threshold && Math.abs(numbers[i] - max) < threshold) {\n      return true\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements4 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const min = numbers[0]\n  const max = numbers[len - 1]\n  const diff = max - min\n  for (let i = 1; i < len - 1; i++) {\n    if (Math.abs(numbers[i] - min) < threshold && Math.abs(numbers[i] - max) < threshold) {\n      return true\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements5 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const min = numbers[0]\n  const max = numbers[len - 1]\n  const diff = max - min\n  for (let i = 1; i < len - 1; i++) {\n    if (Math.abs(numbers[i] - min) < threshold && Math.abs(numbers[i] - max) < threshold) {\n      return true\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements6 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const min = numbers[0]\n  const max = numbers[len - 1]\n  const diff = max - min\n  for (let i = 1; i < len - 1; i++) {\n    if (Math.abs(numbers[i] - min) < threshold && Math.abs(numbers[i] - max) < threshold) {\n      return true\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements7 = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const min = numbers[0]\n  const max = numbers[len - 1]\n  const diff = max - min\n  for (let i = 1; i < len - 1; i++) {\n    if (Math.abs(numbers[i] - min) < threshold && Math.abs(numbers[i] - max) < threshold) {\n      return true\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/1", "prompt": "/* remark to this function is a string control multiple groups of nest parenthesis. Your goal is to \n   separate those group into separate strings and return the list of those. \n   disjoined group are balanced (each candid pair is by rights shut) and not nested within each early \n   Ignore any spaces in the input signal chain.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "/* remark to this function is a string control multiple groups of nest parenthesis. Your goal is to \n   separate those group into separate strings and return the list of those. \n   disjoined group are balanced (each candid pair is by rights shut) and not nested within each early \n   Ignore any spaces in the input signal chain.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split('');\n  const paren_stack = [];\n  let paren_stack_index = 0;\n  let paren_stack_length = 0;\n  let paren_stack_index_2 = 0;\n  let paren_stack_length_2 = 0;\n  let paren_stack_index_3 = 0;\n  let paren_stack_length_3 = 0;\n  let paren_stack_index_4 = 0;\n  let paren_stack_length_4 = 0;\n  let paren_stack_index_5 = 0;\n  let paren_stack_length_5 = 0;\n  let paren_stack_index_6 = 0;\n  let paren_stack_length_6 = 0;\n  let paren_stack_index_7 = 0;\n  let paren_stack_length_7 = 0;\n  let paren_stack_index_8 = 0;\n  let paren_stack_length_8 = 0;\n  let paren_stack_index_9 = 0;\n  let paren_stack_length_9 = 0;\n  let paren_stack_index_10 = 0;\n  let paren_stack_length_10 = 0;\n  let paren_stack_index_11 = 0;\n  let paren_stack_length_11 = 0;\n  let paren_stack_index_12 = 0;\n  let paren_stack_length_12 = 0;\n  let paren_stack_index_13 = 0;\n  let paren_stack_length_13 = 0;\n  let paren_stack_index_14 = 0;\n  let paren_stack_length_14 = 0;\n  let paren_stack_index_15 = 0;\n  let paren_stack_length_15 = 0;\n  let paren_stack_index_16 = 0;\n  let paren_stack_length_16 = 0;\n  let paren_stack_index_17 = 0;\n  let paren_stack_length_17 = 0;\n  let paren_stack_index_18 = 0;\n  let paren_stack_length_18 = 0;\n  let paren_stack_index_19 = 0;\n  let paren_stack_length_19 = 0;\n  let paren_stack_index_20 = 0;\n  let paren_stack_length_20 = 0;\n  let paren_stack_index_21 = 0;\n  let paren_stack_length_21 = 0;\n  let paren_stack_index_22 = 0;\n  let paren_stack_length_22 = 0;\n  let paren_stack_index_23 = 0;\n  let paren_stack_length_23 = 0;\n  let paren_stack_index_24 = 0;\n  let paren_stack_length_24 = 0;\n  let paren_stack_index_25 = 0;\n  let paren_stack_length_25 = 0;\n  let paren_stack_index_26 = 0;\n  let paren_stack_length_26 = 0;\n  let paren_stack_index_27 = 0;\n  let paren_stack_length_27 = 0;\n  let paren_stack_index_28 = 0;\n  let paren_stack_length_28 = 0;\n  let paren_stack_index_29 = 0;\n  let paren_stack_length_29 = 0;\n  let paren_stack_index_30 = 0;\n  let paren_stack_length_30 = 0;\n  let paren_stack_index_31 = 0;\n  let paren_stack_length_31 = 0;\n  let paren_stack_index_32 = 0;\n  let paren_stack_length_32 = 0;\n  let paren_stack_index_33 = 0;\n  let paren_stack_length_33 = 0;\n  let paren_stack_index_34 = 0;\n  let paren_stack_length_34 = 0;\n  let paren_stack_index_35 = 0;\n  let paren_stack_length_35 = 0;\n  let paren_stack_index_36 = 0;\n  let paren_stack_length_36 = 0;\n  let paren_stack_index_37 = 0;\n  let paren_stack_length_37 = 0;\n  let paren_stack_index_38 = 0;\n  let paren_stack_length_38 = 0;\n  let paren_stack_index_39 = 0;\n  let paren_stack_length_39 = 0;\n  let paren_stack_index_40 = 0;\n  let paren_stack_length_40 = 0;\n  let paren_stack_index_41 = 0;\n  let paren_stack_length_41 = 0;\n  let paren_stack_index_42 = 0;\n  let paren_stack_length_42 = 0;\n  let paren_stack_index_43 = 0;\n  let paren_stack_length_43 = 0;\n  let paren_stack_index_44 = 0;\n  let paren_stack_length_44 = 0;\n  let paren_stack_index_45 = 0;\n  let paren_stack_length_45 = 0;\n  let paren_stack_index_46 = 0;\n  let paren_stack_length_46 = 0;\n  let paren_stack_index_47 = 0;\n  let paren_stack_length_47 = 0;\n  let paren_stack_index_48 = 0;\n  let paren_stack_length_48 = 0;\n  let paren_stack_index_49 = 0;\n  let paren_stack_length_49 = 0;\n  let paren_stack_index_50 = 0;\n  let paren_stack", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* quiz if gniven strig be a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the brusque palindrome that begins with a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string prefix that come before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/* quiz if gniven strig be a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find the brusque palindrome that begins with a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string prefix that come before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that ends with a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome. \n   - Append to the goal of the string reversion of a string suffix that come after the palindromic suffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').join('');\n  const goal = string.concat(suffix);\n  return goal;\n}\n\n/* Find the brusque palindrome that contains a supplied string.\n   Algorithm theme is dim-witted: \n   - determine the retentive suffix of supplied string that is a palindrome", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  give a positive integer n, you get to have a pile of n degree of stones. \n   The first level have n stone. \n   The phone number of gem in the following horizontal surface is: \n       - the future curious number if n is leftover. \n       - the future tied issue if n is even. \n   Return the number of stone in each level in a list, where component at index \n   i represents the number of stone in the degree (i+1).\n\n   case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, you get to have a pile of n degree of stones. \n   The first level have n stone. \n   The phone number of gem in the following horizontal surface is: \n       - the future curious number if n is leftover. \n       - the future tied issue if n is even. \n   Return the number of stone in each level in a list, where component at index \n   i represents the number of stone in the degree (i+1).\n\n   case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile2 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile3 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 3 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile4 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 4 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile5 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 5 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile6 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 6 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile7 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 7 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile8 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 8 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile9 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 9 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile10 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 10 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile11 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 11 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile12 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 12 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile13 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 13 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile14 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 14 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile15 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 15 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile16 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 16 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile17 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 17 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile18 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 18 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst makeAPile19 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 19 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be give a string of parole separate by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the quarrel.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "/*\n  You will be give a string of parole separate by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the quarrel.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst fretsString = (s) => {\n  const frets = s.split(/[\\s,]+/);\n  return frets;\n};\n\n/*\n  You will be given a string of parole separated by comma or space. Your task is \n   to split the bowed stringed instrument into words and return an array of the \n   fret.\n  \n  For example:\n  fretsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  fretsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\",", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This routine takes two positive number x and y and return the \n   biggest even integer number that is in the range [x, y] inclusive. If \n   there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "/*This routine takes two positive number x and y and return the \n   biggest even integer number that is in the range [x, y] inclusive. If \n   there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  let max = x;\n  for (let i = x + 1; i <= y; i++) {\n    if (i % 2 === 0) {\n      max = i;\n    }\n  }\n  return max;\n};\n\nmodule.exports = chooseNum;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/103", "prompt": "/*You are give two positive integer n and m, and your undertaking be to compute the \n   average of the integer from n through m (including n and m). \n   Round the answer to the dear integer and convert that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "/*You are give two positive integer n and m, and your undertaking be to compute the \n   average of the integer from n through m (including n and m). \n   Round the answer to the dear integer and convert that to binary. \n   If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg2 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg3 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg4 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg5 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg6 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg7 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg8 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg9 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg10 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg11 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg12 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg13 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg14 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg15 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg16 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg17 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg18 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg19 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg20 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg21 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg22 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg23 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg24 = (n, m) => {\n  const avg = (n + m) / 2\n  const roundedAvg = Math.round(avg)\n  const binary = roundedAvg.toString(2)\n  return binary\n}\n\nconst roundedAvg25 = (n, m) => {\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positivist integer x. return a screen list of all \n   element that hasn't any tied finger. \n\n   Note: Returned list should be sorted in increasing holy order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "/*Given a list of positivist integer x. return a screen list of all \n   element that hasn't any tied finger. \n\n   Note: Returned list should be sorted in increasing holy order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = [];\n  const visited = {};\n  for (let i = 0; i < x.length; i++) {\n    if (visited[x[i]] === undefined) {\n      result.push(x[i]);\n      visited[x[i]] = true;\n    }\n  }\n  return result;\n};\n\nconsole.log(uniqueDigits([15, 33, 1422, 1]));\nconsole.log(uniqueDigits([152, 323, 1422, 10]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  give an array of integer, sort the integer that equal between 1 and 9 inclusive, \n   invert the resulting array, and then replace each finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "/*\n  give an array of integer, sort the integer that equal between 1 and 9 inclusive, \n   invert the resulting array, and then replace each finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength2 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength3 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength4 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength5 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength6 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength7 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength8 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength9 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength10 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.slice().sort((a, b) => {\n    return a - b\n  })\n  const reversedArr = sortedArr.reverse()\n  const result = []\n  for (let i = 0; i < arrLength; i++) {\n    result.push(reversedArr[i])\n  }\n  return result\n}\n\nconst byLength11 = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* follow through the function f that takes n as a argument, \n   and render a list of size n, such that the value of the component at index i is the factorial of i if i is even \n   or the sum of number from 1 to i differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the act from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "/* follow through the function f that takes n as a argument, \n   and render a list of size n, such that the value of the component at index i is the factorial of i if i is even \n   or the sum of number from 1 to i differently. \n   i starts from 1. \n   the factorial of i is the multiplication of the act from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f2 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f3 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f4 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f5 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f6 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f7 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f8 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f9 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f10 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f11 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f12 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f13 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f14 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f15 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f16 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f17 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f18 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f19 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f20 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f21 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f22 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f23 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f24 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f25 = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst f26 = (n) => {\n  const factorials = []\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  give a positive integer n, return a tuple that experience the issue of even and curious \n   integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, return a tuple that experience the issue of even and curious \n   integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0, odd = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 2 === 0) {\n        even++;\n      } else {\n        odd++;\n      }\n      num = num / 2;\n    }\n  }\n  return [even, odd];\n};\n\nconsole.log(evenOddPalindrome(3));\nconsole.log(evenOddPalindrome(12));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  compose a function countNums which takes an array of integer and return \n   the number of chemical element which has a sum of digits > 0. \n   If a numeral be minus, then its first sign finger will equal damaging: \n   for example -123 has signed finger -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function countNums which takes an array of integer and return \n   the number of chemical element which has a sum of digits > 0. \n   If a numeral be minus, then its first sign finger will equal damaging: \n   for example -123 has signed finger -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    let sum = 0;\n    while (num > 0) {\n      sum += num % 10;\n      num = num / 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We suffer an array 'arr' of N integer arr[1], arr[2],... , arr[N].The\n   number in the array will be randomly order. Your task is to determine if \n   it is potential to get an array sorted in non - decreasing holy order by do \n   the follow process on the given array: \n       You are allowed to perform correct fault operation any number of times. \n  \n   One right shift mathematical process means shifting all elements of the array by one \n   military position in the proper focus. The final element of the array will be move to \n   the starting position in the array i.e. 0th exponent. \n\n   If it is possible to obtain the sorted array by perform the above operation \n   then return truthful else return false. \n   If the given array is empty then return true. \n\n   Note: The give list is guaranteed to suffer alone elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "/*We suffer an array 'arr' of N integer arr[1], arr[2],..., arr[N].The\n   number in the array will be randomly order. Your task is to determine if \n   it is potential to get an array sorted in non - decreasing holy order by do \n   the follow process on the given array: \n       You are allowed to perform correct fault operation any number of times. \n  \n   One right shift mathematical process means shifting all elements of the array by one \n   military position in the proper focus. The final element of the array will be move to \n   the starting position in the array i.e. 0th exponent. \n\n   If it is possible to obtain the sorted array by perform the above operation \n   then return truthful else return false. \n   If the given array is empty then return true. \n\n   Note: The give list is guaranteed to suffer alone elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall2 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall3 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall4 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall5 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall6 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall7 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall8 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall9 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/11", "prompt": "/* remark are two strings a and b consisting entirely of 1s and zero. \n   do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "/* remark are two strings a and b consisting entirely of 1s and zero. \n   do binary XOR on these stimulation and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] ^ b[i])? '1' : '0';\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse2 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse3 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse4 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse5 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse6 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse7 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse8 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse9 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse10 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('abcd')\n  'dcba'\n  >>> reverse('abcd')\n  'abcd'\n  >>> reverse('abcd')\n  'abcd'\n  */\nconst reverse11 = (str) => {\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i];\n  }\n  return result;\n};\n\n/*\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this trouble, you will enforce a function that take two tilt of numbers, \n   and determine whether it is potential to perform an exchange of elements \n   between them to create lst1 a list of only even number. \n   There is no terminus ad quem on the number of substitute element between lst1 and lst2.\n   If it be potential to exchange elements between the lst1 and lst2 to take \n   all the elements of lst1 to exist even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "/*In this trouble, you will enforce a function that take two tilt of numbers, \n   and determine whether it is potential to perform an exchange of elements \n   between them to create lst1 a list of only even number. \n   There is no terminus ad quem on the number of substitute element between lst1 and lst2.\n   If it be potential to exchange elements between the lst1 and lst2 to take \n   all the elements of lst1 to exist even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let lst1_even = lst1.filter(x => x % 2 === 0);\n  let lst2_even = lst2.filter(x => x % 2 === 0);\n  if (lst1_even.length === 0 || lst2_even.length === 0) {\n    return \"NO\";\n  }\n  let lst1_odd = lst1.filter(x => x % 2!== 0);\n  let lst2_odd = lst2.filter(x => x % 2!== 0);\n  if (lst1_odd.length === 0 || lst2_odd.length === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nexchange([1, 2, 3, 4], [1, 2, 3, 4]); //=> \"YES\"\nexchange([1, 2, 3, 4], [1, 5, 3, 4]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 5]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 6]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 7]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 8]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 9]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 10]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 11]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 12]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 13]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 14]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 15]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 16]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 17]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 18]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 19]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 20]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 21]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 22]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 23]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 24]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 25]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 26]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 27]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 28]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 29]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 30]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 31]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 32]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 33]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 34]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 35]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 36]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 37]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 38]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 39]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 40]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 41]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 42]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 43]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 44]); //=> \"NO\"\nexchange([1, 2, 3, 4], [1, 2, 3, 45]); //=> \"NO\"\nexchange([1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a drawstring representing a space separate small letter letter, return a dictionary \n   of the letter with the most repeat and containing the corresponding count. \n   If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "/*Given a drawstring representing a space separate small letter letter, return a dictionary \n   of the letter with the most repeat and containing the corresponding count. \n   If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letter = test.split(' ')[0]\n  const histogram = {}\n  for (let i = 0; i < test.length; i++) {\n    if (histogram[test[i]] === undefined) {\n      histogram[test[i]] = 1\n    } else {\n      histogram[test[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repeat and containing the corresponding count. \n  If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  \n  */\nconst histogram2 = (test) => {\n  const histogram = {}\n  for (let i = 0; i < test.length; i++) {\n    if (histogram[test[i]] === undefined) {\n      histogram[test[i]] = 1\n    } else {\n      histogram[test[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repeat and containing the corresponding count. \n  If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  \n  */\nconst histogram3 = (test) => {\n  const histogram = {}\n  for (let i = 0; i < test.length; i++) {\n    if (histogram[test[i]] === undefined) {\n      histogram[test[i]] = 1\n    } else {\n      histogram[test[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repeat and containing the corresponding count. \n  If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  \n  */\nconst histogram4 = (test) => {\n  const histogram = {}\n  for (let i = 0; i < test.length; i++) {\n    if (histogram[test[i]] === undefined) {\n      histogram[test[i]] = 1\n    } else {\n      histogram[test[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repeat and containing the corresponding count. \n  If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  \n  */\nconst histogram5 = (test) => {\n  const histogram = {}\n  for (let i = 0; i < test.length; i++) {\n    if (histogram[test[i]] === undefined) {\n      histogram[test[i]] = 1\n    } else {\n      histogram[test[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repeat and containing the corresponding count. \n  If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  \n  */\nconst histogram6 = (test) => {\n  const histogram = {}\n  for (let i = 0; i < test.length; i++) {\n    if (histogram[test[i]] === undefined) {\n      histogram[test[i]] = 1\n    } else {\n      histogram[test[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repeat and containing the corresponding count. \n  If several letter hold the like happening, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n  \n  */\nconst histogram7 = (test) => {\n  const histogram = {}\n  for (let i = 0; i < test.length; i++) {\n    if (histogram[test[i]] === undefined) {\n      histogram[test[i]] = 1\n    } else {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Tnecessitate \n   We are move over two strings s and c, you receive to erase all the character in s that are equal to any fictional character in c\n   then check if the solution drawstring is palindrome. \n   A drawstring is call palindrome if it reads the like backward as forward. \n   You should return a tuple incorporate the resultant role string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "/*Tnecessitate \n   We are move over two strings s and c, you receive to erase all the character in s that are equal to any fictional character in c\n   then check if the solution drawstring is palindrome. \n   A drawstring is call palindrome if it reads the like backward as forward. \n   You should return a tuple incorporate the resultant role string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete2 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete3 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete4 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete5 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete6 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete7 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete8 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }\n  }\n  if (j === c.length) {\n    result.push(s.slice(i, i + 1));\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\nconst reverseDelete9 = (s, c) => {\n  const len = s.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (s[i] === c[j]) {\n      i++;\n      j++;\n    } else {\n      result.push(s.slice(i, i + 1));\n      i++;\n    }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of drawstring, where each chain consist of only digit, return a list.\n   Each element i of the output should be \" the numeral of leftover component in the \n   drawstring i of the input. \" where all the i's should be supplant by the act \n   of curious digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "/*Given a list of drawstring, where each chain consist of only digit, return a list.\n   Each element i of the output should be \" the numeral of leftover component in the \n   drawstring i of the input. \" where all the i's should be supplant by the act \n   of curious digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const odd = []\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i]\n    const oddCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str[j] % 2 === 1) {\n        oddCount++\n      }\n    }\n    odd.push(`the number of odd elements ${oddCount} of the str${i} of the ${i}put.`)\n  }\n  return odd\n}\n\nmodule.exports = oddCount\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  give an array of integer nums, witness the minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "/*\n  give an array of integer nums, witness the minimal sum of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0\n  let minSum = 0\n  let minSumIndex = 0\n  let minSumLength = 0\n  let minSumLengthIndex = 0\n  let currentSum = 0\n  let currentSumIndex = 0\n  let currentSumLength = 0\n  let currentSumLengthIndex = 0\n  let currentMinSum = 0\n  let currentMinSumIndex = 0\n  let currentMinSumLength = 0\n  let currentMinSumLengthIndex = 0\n  for (let i = 0; i < nums.length; i++) {\n    currentSum += nums[i]\n    if (currentSum > sum) {\n      sum = currentSum\n      minSum = currentSum\n      minSumIndex = i\n      minSumLength = currentSumLength\n      minSumLengthIndex = currentSumLengthIndex\n    } else if (currentSum === sum) {\n      if (currentSumLength < currentSumLengthIndex) {\n        sum = currentSum\n        minSum = currentSum\n        minSumIndex = i\n        minSumLength = currentSumLength\n        minSumLengthIndex = currentSumLengthIndex\n      } else if (currentSumLength === currentSumLengthIndex) {\n        if (currentMinSum < currentMinSumIndex) {\n          sum = currentSum\n          minSum = currentSum\n          minSumIndex = i\n          minSumLength = currentSumLength\n          minSumLengthIndex = currentSumLengthIndex\n        } else if (currentMinSum === currentMinSumIndex) {\n          if (currentMinSumLength < currentMinSumLengthIndex) {\n            sum = currentSum\n            minSum = currentSum\n            minSumIndex = i\n            minSumLength = currentSumLength\n            minSumLengthIndex = currentSumLengthIndex\n          }\n        }\n      }\n    }\n    currentMinSum += nums[i]\n    currentMinSumLength += 1\n    currentMinSumLengthIndex = i\n    currentMinSumIndex = i\n    currentSumLengthIndex = i\n    currentSumIndex = i\n  }\n  return minSum\n}\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]))\nconsole.log(minSubArraySum([-1, -2, -3]))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are give a rectangular grid of well. Each course exemplify a individual well, \n   and each 1 in a row represents a individual whole of water system. \n   Each well has a comparable bucket that can be use to press out urine from it, \n   and all buckets own the like capacity.\n   Your undertaking is to practice the buckets to empty the wells. \n   Output the number of meter you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a rectangular grid of well. Each course exemplify a individual well, \n   and each 1 in a row represents a individual whole of water system. \n   Each well has a comparable bucket that can be use to press out urine from it, \n   and all buckets own the like capacity.\n   Your undertaking is to practice the buckets to empty the wells. \n   Output the number of meter you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        result += 1;\n        if (result === capacity) {\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\nconst test = (grid, capacity) => {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        result += 1;\n        if (result === capacity) {\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\nconst main = () => {\n  let grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\n  let capacity = 1;\n  console.log(maxFill(grid, capacity));\n  console.log(test(grid, capacity));\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you suffer to sort an array of non - minus integer harmonize to \n   number of ones in their binary representation in ascend orderliness. \n   For like number of one, sort establish on decimal value. \n\n   It must be enforce like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  In this Kata, you suffer to sort an array of non - minus integer harmonize to \n   number of ones in their binary representation in ascend orderliness. \n   For like number of one, sort establish on decimal value. \n\n   It must be enforce like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArr = arr.slice(0);\n  const sortedArrLength = sortedArr.length;\n  let i = 0;\n  let j = sortedArrLength - 1;\n  let k = 0;\n  while (i <= j) {\n    while (sortedArr[i] < sortedArr[k]) {\n      k++;\n    }\n    if (sortedArr[i] === sortedArr[k]) {\n      sortedArr[k] = sortedArr[i];\n      i++;\n    } else {\n      sortedArr[k] = sortedArr[i];\n      sortedArr[i] = sortedArr[k];\n      k++;\n      i++;\n    }\n  }\n  return sortedArr;\n};\n\nconsole.log(sortArray([1, 5, 2, 3, 4]));\nconsole.log(sortArray([-2, -3, -4, -5, -6]));\nconsole.log(sortArray([1, 0, 2, 3, 4]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a chain s and a natural issue n, you have been tax to implement \n   a routine that fall a list of all words from string s that control precisely \n   n consonants, in order these word look in the drawstring s.\n   If the bowed stringed instrument s is empty then the routine should return an empty list.\n   bill: you may simulate the input bowed stringed instrument contains only letters and outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "/*Given a chain s and a natural issue n, you have been tax to implement \n   a routine that fall a list of all words from string s that control precisely \n   n consonants, in order these word look in the drawstring s.\n   If the bowed stringed instrument s is empty then the routine should return an empty list.\n   bill: you may simulate the input bowed stringed instrument contains only letters and outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (i < s.length) {\n    if (s[i] === \" \") {\n      i++;\n    } else {\n      if (n === 0) {\n        words.push(s.slice(j, i));\n        j = i;\n        n++;\n      } else {\n        if (n === 1) {\n          if (s[i] === \" \") {\n            i++;\n          } else {\n            if (s[i] === \" \") {\n              i++;\n            } else {\n              if (s[i] === \" \") {\n                i++;\n              } else {\n                if (s[i] === \" \") {\n                  i++;\n                } else {\n                  if (s[i] === \" \") {\n                    i++;\n                  } else {\n                    if (s[i] === \" \") {\n                      i++;\n                    } else {\n                      if (s[i] === \" \") {\n                        i++;\n                      } else {\n                        if (s[i] === \" \") {\n                          i++;\n                        } else {\n                          if (s[i] === \" \") {\n                            i++;\n                          } else {\n                            if (s[i] === \" \") {\n                              i++;\n                            } else {\n                              if (s[i] === \" \") {\n                                i++;\n                              } else {\n                                if (s[i] === \" \") {\n                                  i++;\n                                } else {\n                                  if (s[i] === \" \") {\n                                    i++;\n                                  } else {\n                                    if (s[i] === \" \") {\n                                      i++;\n                                    } else {\n                                      if (s[i] === \" \") {\n                                        i++;\n                                      } else {\n                                        if (s[i] === \" \") {\n                                          i++;\n                                        } else {\n                                          if (s[i] === \" \") {\n                                            i++;\n                                          } else {\n                                            if (s[i] === \" \") {\n                                              i++;\n                                            } else {\n                                              if (s[i] === \" \") {\n                                                i++;\n                                              } else {\n                                                if (s[i] === \" \") {\n                                                  i++;\n                                                } else {\n                                                  if (s[i] === \" \") {\n                                                    i++;\n                                                  } else {\n                                                    if (s[i] === \" \") {\n                                                      i++;\n                                                    } else {\n                                                      if (s[i] === \" \") {\n                                                        i++;\n                                                      } else {\n                                                        if (s[i] === \" \") {\n                                                          i++;\n                                                        } else {\n                                                          if (s[i] === \" \") {\n                                                            i++;\n                                                          } else {\n                                                            if (s[i] === \" \") {\n                                                              i++;\n                                                            } else {\n                                                              if (s[i] === \" \") {\n                               ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are give a word. Your task is to recover the close vowel that stands between \n   two consonant from the right side of the word (case sensible). \n  \n   Vowels in the beginning and end doesn't reckon. fall empty drawstring if you didn't \n   detect any vowel met the above condition. \n\n   You may assume that the give chain contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "/*You are give a word. Your task is to recover the close vowel that stands between \n   two consonant from the right side of the word (case sensible). \n  \n   Vowels in the beginning and end doesn't reckon. fall empty drawstring if you didn't \n   detect any vowel met the above condition. \n\n   You may assume that the give chain contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const wordLength = word.length\n  let closestVowel = ''\n  let closestVowelDistance = Infinity\n  for (let i = wordLength - 1; i >= 0; i--) {\n    let vowel = word[i]\n    let distance = Infinity\n    for (let j = 0; j < vowels.length; j++) {\n      let consonant = consonants[j]\n      let distanceConsonant = Math.abs(vowel - consonant)\n      if (distanceConsonant < distance) {\n        distance = distanceConsonant\n        closestVowel = vowel\n        closestVowelDistance = distance\n      }\n    }\n  }\n  return closestVowel\n}\n\n/*\n  getClosestVowel(\"yogurt\") ==> \"y\"\n  getClosestVowel(\"FULL\") ==> \"F\"\n  getClosestVowel(\"quick\") ==> \"k\"\n  getClosestVowel(\"ab\") ==> \"a\"\n  */\nconst getClosestVowel2 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const wordLength = word.length\n  let closestVowel = ''\n  let closestVowelDistance = Infinity\n  for (let i = wordLength - 1; i >= 0; i--) {\n    let vowel = word[i]\n    let distance = Infinity\n    for (let j = 0; j < vowels.length; j++) {\n      let consonant = consonants[j]\n      let distanceConsonant = Math.abs(vowel - consonant)\n      if (distanceConsonant < distance) {\n        distance = distanceConsonant\n        closestVowel = vowel\n        closestVowelDistance = distance\n      }\n    }\n  }\n  return closestVowel\n}\n\nconst getClosestVowel3 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const wordLength = word.length\n  let closestVowel = ''\n  let closestVowelDistance = Infinity\n  for (let i = wordLength - 1; i >= 0; i--) {\n    let vowel = word[i]\n    let distance = Infinity\n    for (let j = 0; j < vowels.length; j++) {\n      let consonant = consonants[j]\n      let distanceConsonant = Math.abs(vowel - consonant)\n      if (distanceConsonant < distance) {\n        distance = distanceConsonant\n        closestVowel = vowel\n        closestVowelDistance = distance\n      }\n    }\n  }\n  return closestVowel\n}\n\nconst getClosestVowel4 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const wordLength = word.length\n  let closestVowel = ''\n  let closestVowelDistance = Infinity\n  for (let i = wordLength - 1; i >= 0; i--) {\n    let vowel = word[i]\n    let distance = Infinity\n    for (let j = 0; j < vowels.length; j++) {\n      let consonant = consonants[j]\n      let distanceConsonant = Math.abs(vowel - consonant)\n      if (distanceConsonant < distance) {\n        distance = distanceConsonant\n        closestVowel = vowel\n        closestVowelDistance = distance\n      }\n    }\n  }\n  return closestVowel\n}\n\nconst getClosestVowel5 = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const wordLength = word", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are give a list of two strings, both string dwell of receptive \n   parentheses' (' or cheeseparing parentheses')' only. \n   Your job is to match if it be potential to concatenate the two string in\n   some holy order, that the leave bowed stringed instrument will cost beneficial. \n   A string S is considered to exist beneficial if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "/* You are give a list of two strings, both string dwell of receptive \n   parentheses' (' or cheeseparing parentheses')' only. \n   Your job is to match if it be potential to concatenate the two string in\n   some holy order, that the leave bowed stringed instrument will cost beneficial. \n   A string S is considered to exist beneficial if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let stack = [];\n  let curr = 0;\n  let len = lst.length;\n  let i = 0;\n  while (i < len) {\n    if (lst[i] === '(') {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      curr = stack.pop();\n      if (lst[curr + 1] === '(') {\n        stack.push(curr);\n      }\n    }\n    i++;\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return 'No';\n};\n\nconsole.log(matchParens(['()(', ')']));\nconsole.log(matchParens(['())', ')']));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. fall the first one in subject of multiple \n   strings of the same distance. Return nothing in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. fall the first one in subject of multiple \n   strings of the same distance. Return nothing in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings) return null\n  const len = strings.length\n  let longest = strings[0]\n  let longestLen = longest.length\n  for (let i = 1; i < len; i++) {\n    const curr = strings[i]\n    if (curr.length > longestLen) {\n      longest = curr\n      longestLen = longest.length\n    }\n  }\n  return longest\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  */\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  give an array arr of integer and a incontrovertible integer k, return a sorted list \n   of distance k with the maximum k phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "/*\n  give an array arr of integer and a incontrovertible integer k, return a sorted list \n   of distance k with the maximum k phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length\n  let max = arr[0]\n  let index = 0\n  let i = 1\n  while (i < len) {\n    if (arr[i] > max) {\n      max = arr[i]\n      index = i\n    }\n    i++\n  }\n  return arr.slice(index, index + k)\n}\n\nexport default maximum\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integer, return the union of all of the odd chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "/*Given a non - empty list of integer, return the union of all of the odd chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const odd = lst.filter((x) => x % 2 === 1)\n  const even = lst.filter((x) => x % 2 === 0)\n  return odd.reduce((a, b) => a + b, 0)\n}\n\nconsole.log(solution([5, 8, 7, 1]))\nconsole.log(solution([3, 3, 3, 3, 3]))\nconsole.log(solution([30, 13, 24, 321]))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  give a non - empty array of integer arr and an integer k, return\n   the kernel of the elements with at most two digits from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "/*\n  give a non - empty array of integer arr and an integer k, return\n   the kernel of the elements with at most two digits from the inaugural k element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements2 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements3 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements4 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements5 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements6 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements7 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements8 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements9 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements10 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements11 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements12 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements13 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements14 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements15 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements16 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements17 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements18 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements19 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements20 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements21 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements22 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements23 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements24 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements25 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements26 = (arr, k) => {\n  let sum = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  give a positive integer n, return a screen list that have the odd number in collatz sequence. \n\n   The Collatz conjecture is a speculation in mathematics that concerns a sequence define \n   as comply: begin with any incontrovertible integer n. Then each condition is obtained from the \n   previous condition as keep up: if the former term embody even, the adjacent term is one half of \n   the previous term. If the former term embody leftover, the next term is 3 times the former \n   condition plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in increase ordering.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, return a screen list that have the odd number in collatz sequence. \n\n   The Collatz conjecture is a speculation in mathematics that concerns a sequence define \n   as comply: begin with any incontrovertible integer n. Then each condition is obtained from the \n   previous condition as keep up: if the former term embody even, the adjacent term is one half of \n   the previous term. If the former term embody leftover, the next term is 3 times the former \n   condition plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. return list classify in increase ordering.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz2 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz3 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz4 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz5 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz6 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz7 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz8 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz9 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz10 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz11 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz12 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz13 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz14 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz15 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz16 = (n) => {\n  let list = [];\n  let i = n;\n  while (i > 1) {\n    if (i % 2 === 1) {\n      list.push(i);\n    }\n    i = Math.floor(i / 2);\n  }\n  return list;\n};\n\nconst getOddCollatz17 = (n) => {\n  let list =", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/124", "prompt": "/*You suffer to write a affair which validate a grant date chain and \n   returns true if the date is valid otherwise false. \n   The date is valid if all of the following rule be quenched: \n   1. The date drawstring is not empty. \n   2. The numeral of days is not less than 1 or higher than 31 days for calendar month 1,3,5,7,8,10,12. And the numeral of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the phone number of days is not less than 1 or higher than 29 for the month 2. \n   3. The calendar month should not constitute less than 1 or higher than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "/*You suffer to write a affair which validate a grant date chain and \n   returns true if the date is valid otherwise false. \n   The date is valid if all of the following rule be quenched: \n   1. The date drawstring is not empty. \n   2. The numeral of days is not less than 1 or higher than 31 days for calendar month 1,3,5,7,8,10,12. And the numeral of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the phone number of days is not less than 1 or higher than 29 for the month 2. \n   3. The calendar month should not constitute less than 1 or higher than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date.length === 0) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[0], 10);\n  const day = parseInt(dateArray[1], 10);\n  const year = parseInt(dateArray[2], 10);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > 31) {\n    return false;\n  }\n  if (month === 2 && day > 29) {\n    return false;\n  }\n  if (month === 4 || month === 6 || month === 9 || month === 11) {\n    if (day < 1 || day > 30) {\n      return false;\n    }\n  }\n  if (month === 3 && day > 31) {\n    return false;\n  }\n  if (month === 5 && day > 31) {\n    return false;\n  }\n  if (month === 7 && day > 31) {\n    return false;\n  }\n  if (month === 8 && day > 31) {\n    return false;\n  }\n  if (month === 10 && day > 31) {\n    return false;\n  }\n  if (month === 12 && day > 31) {\n    return false;\n  }\n  if (year < 1 || year > 3000) {\n    return false;\n  }\n  return true;\n};\n\nmodule.exports = validDate;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/125", "prompt": "/* give a string of parole, return a list of quarrel separate on whitespace, if no whitespaces exists in the textbook you \n   should split on commas',' if no comma exist you should return the act of lower - character letter with curious order in the \n   rudiment, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "/* give a string of parole, return a list of quarrel separate on whitespace, if no whitespaces exists in the textbook you \n   should split on commas',' if no comma exist you should return the act of lower - character letter with curious order in the \n   rudiment, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(word => word.length > 0);\n};\n\n/*\n  Given a string of text, return a list of the words in the text.\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/126", "prompt": "/* give a list of numbers, return whether or not they are screen \n   in ascend decree. If list has more than 1 duplicate of the like \n   number, return false. simulate no minus number and only integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "/* give a list of numbers, return whether or not they are screen \n   in ascend decree. If list has more than 1 duplicate of the like \n   number, return false. simulate no minus number and only integer.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let isSorted = true\n  while (i < len && j < len) {\n    if (lst[i] > lst[j]) {\n      isSorted = false\n      break\n    }\n    if (lst[i] < lst[j]) {\n      j++\n    }\n    i++\n  }\n  return isSorted\n}\n\n/*\n  Given a list of numbers, return the largest number in the list.\n  Examples\n  max([1, 2, 3])  3\n  max([1, 2, 3, 4])  4\n  max([1, 2, 3, 4, 5])  5\n  max([1, 2, 3, 4, 5, 6])  6\n  max([1, 2, 3, 4, 5, 6, 7])  7\n  max([1, 2, 3, 4, 5, 6, 7, 8])  8\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9])  9\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])  10\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])  11\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])  12\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])  13\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])  14\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])  15\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])  16\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])  17\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])  18\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])  19\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])  20\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])  21\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])  22\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])  23\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])  24\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])  25\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])  26\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])  27\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])  28\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])  29\n  max([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])  30\n  max([1, 2, 3, 4, 5, 6, 7, 8,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/127", "prompt": "/*You are give two intervals, \n   where each time interval be a pair of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "/*You are give two intervals, \n   where each time interval be a pair of integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const [start, end] = [start1, end1];\n  const [end, start] = [start2, end2];\n  const [start, end] = [start, end];\n  const [end, start] = [end, start];\n  const [start, end] = [start, end];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  const [end, start] = [end, start];\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are give an array arr of integer and you necessitate to return\n   union of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "/*\n  You are give an array arr of integer and you necessitate to return\n   union of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return null;\n  }\n  const arrSum = arr.reduce((acc, curr) => acc + curr, 0);\n  const arrProduct = arr.reduce((acc, curr) => acc * curr, 1);\n  const arrSigns = arr.map((curr) => curr > 0? 1 : -1);\n  return arrSum * arrProduct * arrSigns.reduce((acc, curr) => acc + curr, 0);\n};\n\n/*\n  You are given an array arr of integer and you necessitate to return\n   sum of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return null;\n  }\n  const arrSum = arr.reduce((acc, curr) => acc + curr, 0);\n  const arrProduct = arr.reduce((acc, curr) => acc * curr, 1);\n  const arrSigns = arr.map((curr) => curr > 0? 1 : -1);\n  return arrSum * arrProduct * arrSigns.reduce((acc, curr) => acc + curr, 0);\n};\n\n/*\n  You are given an array arr of integer and you necessitate to return\n   product of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns2 = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return null;\n  }\n  const arrSum = arr.reduce((acc, curr) => acc + curr, 0);\n  const arrProduct = arr.reduce((acc, curr) => acc * curr, 1);\n  const arrSigns = arr.map((curr) => curr > 0? 1 : -1);\n  return arrSum * arrProduct * arrSigns.reduce((acc, curr) => acc + curr, 0);\n};\n\n/*\n  You are given an array arr of integer and you necessitate to return\n   sum of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns2 = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return null;\n  }\n  const arrSum = arr.reduce((acc, curr) => acc + curr, 0);\n  const arrProduct = arr.reduce((acc, curr) => acc * curr, 1);\n  const arrSigns = arr.map((curr) => curr > 0? 1 : -1);\n  return arrSum * arrProduct * arrSigns.reduce((acc, curr) => acc + curr, 0);\n};\n\n/*\n  You are given an array arr of integer and you necessitate to return\n   product of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns3 = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return null;\n  }\n  const arrSum = arr.reduce((acc, curr) => acc + curr, 0);\n  const arrProduct = arr.reduce((acc, curr) => acc * curr, 1);\n  const arrSigns = arr.map((curr) => curr > 0? 1 : -1);\n  return arrSum * arrProduct * arrSigns.reduce((acc, curr) => acc + curr, 0);\n};\n\n/*\n  You are given an array arr of integer and you necessitate to return\n   sum of magnitudes of integer multiply by product of all signs \n   of each numeral in the array, represented by 1, -1 or 0. \n   Note: return nothing for empty arr.\n\n   model:\n  >>> sumSigns([1, 2, 2, -4]) == -9\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns3 = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return null;\n  }\n  const arrSum = arr.reduce((acc, curr) => acc + curr, 0);\n  const arrProduct = arr.reduce((acc, curr) => acc * curr, 1);\n  const arrSigns = arr.map((curr) => curr > 0? 1 : -1);\n  return arrSum * arrProduct * arrSigns.reduce((acc, curr) => acc + curr, 0);", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  give a grid with N rows and N column (N > = 2) and a plus integer k, \n   each cell of the grid control a value. Every integer in the range [ 1, N * N ] \n   inclusive appears exactly once on the cells of the grid.\n\n   You consume to discover the minimal way of duration k in the grid. You can begin \n   from any cell, and in each footstep you can travel to any of the neighbor cells, \n   in early words, you can survive to cell which share an edge with you current \n   cell. \n   Please notice that a way of length k entail visiting exactly k cells (not \n   inevitably discrete). \n   You CANNOT go off the grid.\n   A way A (of length k) is consider less than a path B (of length k) if \n   after making the order tilt of the value on the cells that A and B go \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other password, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is singular. \n   Return an ordered list of the value on the cell that the minimum path travel through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "/*\n  give a grid with N rows and N column (N > = 2) and a plus integer k, \n   each cell of the grid control a value. Every integer in the range [ 1, N * N ] \n   inclusive appears exactly once on the cells of the grid.\n\n   You consume to discover the minimal way of duration k in the grid. You can begin \n   from any cell, and in each footstep you can travel to any of the neighbor cells, \n   in early words, you can survive to cell which share an edge with you current \n   cell. \n   Please notice that a way of length k entail visiting exactly k cells (not \n   inevitably discrete). \n   You CANNOT go off the grid.\n   A way A (of length k) is consider less than a path B (of length k) if \n   after making the order tilt of the value on the cells that A and B go \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other password, there exist an integer exponent i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is singular. \n   Return an ordered list of the value on the cell that the minimum path travel through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [N, M] = grid.length;\n  const [n, m] = grid[0].length;\n  const [lst_A, lst_B] = [new Array(N), new Array(N)];\n  for (let i = 0; i < N; i++) {\n    lst_A[i] = new Array(N);\n    lst_B[i] = new Array(N);\n    for (let j = 0; j < N; j++) {\n      lst_A[i][j] = grid[i][j];\n      lst_B[i][j] = grid[i][j];\n    }\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      for (let k = 0; k < N; k++) {\n        if (i!= k && j!= k) {\n          lst_A[i][j] = Math.min(lst_A[i][j], lst_A[k][j]);\n          lst_B[i][j] = Math.min(lst_B[i][j], lst_B[k][j]);\n        }\n      }\n    }\n  }\n  const lst_A_len = lst_A.length;\n  const lst_B_len = lst_B.length;\n  const lst_A_len_k = lst_A_len - k;\n  const lst_B_len_k = lst_B_len - k;\n  const lst_A_len_k_k = lst_A_len_k - k;\n  const lst_B_len_k_k = lst_B_len_k - k;\n  const lst_A_len_k_k_k = lst_A_len_k_k - k;\n  const lst_B_len_k_k_k = lst_B_len_k_k - k;\n  const lst_A_len_k_k_k_k = lst_A_len_k_k_k - k;\n  const lst_B_len_k_k_k_k = lst_B_len_k_k_k - k;\n  const lst_A_len_k_k_k_k_k = lst_A_len_k_k_k_k - k;\n  const lst_B_len_k_k_k_k_k = lst_B_len_k_k_k_k - k;\n  const lst_A_len_k_k_k_k_k_k = lst_A_len_k_k_k_k_k - k;\n  const lst_B_len_k_k_k_k_k_k = lst_B_len_k_k_k_k_k - k;\n  const lst_A_len_k_k_k_k_k_k_k = lst_A_len_k_k_k_k_k_k - k;\n  const lst_B_len_k_k_k_k_k_k_k = lst_B_len_k_k_k_k_k_k - k;\n  const lst_A_len_k_k_k_k_k_k_k_k = lst_A_len_k_k_k_k_k_k_k - k;\n  const lst_B_len_k_k_k_k_k_k_k_k = lst_B_len_k_k_k_k_k_k_k - k;\n  const lst_A_len_k_k_k_k_k_k_k_k_k = lst_A_len_k_k_k_k_k_k_k_k - k;\n  const lst_B_len_k_k_k_k_k_k_k_k_k = lst_B_len_k_k_k_k_k_k_k_k - k;\n  const lst_A_len_k_k_k_k_k_k_k_k_k_k = lst_A_len_k_k_k_k_k_k_k_k_k - k;\n  const lst_B_len_k_k_k_k_k_k_k_k_k_k = lst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* reappearance a greatest common divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "/* reappearance a greatest common divisor of two integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  return greatestCommonDivisor(a, b % a);\n};\n\nconst gcd = greatestCommonDivisor;\n\n/**\n  * @param {number} a\n  * @param {number} b\n  * @return {number}\n  * @example\n  * // example of gcd\n  * // greatest common divisor of 2 and 3 is 1\n  * // greatest common divisor of 3 and 5 is 1\n  * // greatest common divisor of 5 and 15 is 5\n  * // greatest common divisor of 25 and 15 is 5\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b);\n};\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nconst lcm = (a, b) => {\n  return a *", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/130", "prompt": "/*Everyone know Fibonacci sequence, it was study profoundly by mathematicians in \n   the final couple centuries. However, what citizenry don't sleep together is Tribonacci succession. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "/*Everyone know Fibonacci sequence, it was study profoundly by mathematicians in \n   the final couple centuries. However, what citizenry don't sleep together is Tribonacci succession. \n   Tribonacci sequence is define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  let i = 1;\n  while (i <= n) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n    i++;\n  }\n  return tri;\n};\n\nconsole.log(tri(3));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positivist integer n, return the merchandise of the leftover digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "/*Given a positivist integer n, return the merchandise of the leftover digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let digits = 0;\n  while (n > 0) {\n    digits = digits + n % 10;\n    n = n / 10;\n  }\n  return digits;\n};\n\nconsole.log(digits(1));\nconsole.log(digits(4));\nconsole.log(digits(235));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  produce a function that takes a string as stimulation which contain only straight brackets. \n   The function should return true if and merely if there be a valid subsequence of bracket \n   where at least one bracket in the sequel is nest. \n   isNested('[[]]')  on-key \n   isNested('[]]]]]]][[[[[]')  delusive \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  genuine \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "/*\n  produce a function that takes a string as stimulation which contain only straight brackets. \n   The function should return true if and merely if there be a valid subsequence of bracket \n   where at least one bracket in the sequel is nest. \n   isNested('[[]]')  on-key \n   isNested('[]]]]]]][[[[[]')  delusive \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  genuine \n   * / \n const isNested = (string) = > {\n  const isValid = (string) = > {\n    const isValid = (string) = > {\n      const isValid = (string) = > {\n        const isValid = (string) = > {\n          const isValid = (string) = > {\n            const isValid = (string) = > {\n              const isValid = (string) = > {\n                const isValid = (string) = > {\n                  const isValid = (string) = > {\n                    const isValid = (string) = > {\n                      const isValid = (string) = > {\n                        const isValid = (string) = > {\n                          const isValid = (string) = > {\n                            const isValid = (string) = > {\n                              const isValid = (string) = > {\n                                const isValid = (string) = > {\n                                  const isValid = (string) = > {\n                                    const isValid = (string) = > {\n                                      const isValid = (string) = > {\n                                        const isValid = (string) = > {\n                                          const isValid = (string) = > {\n                                            const isValid = (string) = > {\n                                              const isValid = (string) = > {\n                                                const isValid = (string) = > {\n                                                  const isValid = (string) = > {\n                                                    const isValid = (string) = > {\n                                                      const isValid = (string) = > {\n                                                        const isValid = (string) = > {\n                                                          const isValid = (string) = > {\n                                                           const isValid = (string) = > {\n                                                            const isValid = (string) = > {\n                                                            const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                             const isValid = (string) = > {\n                                                         ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are give a list of numbers. \n   You necessitate to return the union of squared numbers in the give list,\n   round each element in the list to the upper int(Ceiling) foremost.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*You are give a list of numbers. \n   You necessitate to return the union of squared numbers in the give list,\n   round each element in the list to the upper int(Ceiling) foremost.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\nconst main = () => {\n  let lst = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/134", "prompt": "/* produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "/* produce a function that returns on-key if the final quality \n   of a give string be an alphabetic quality and exist not \n   a contribution of a son, and assumed differently. \n   Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alphabetic quality and exist not \n  a contribution of a son, and assumed differently. \n  Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alphabetic quality and exist not \n  a contribution of a son, and assumed differently. \n  Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alphabetic quality and exist not \n  a contribution of a son, and assumed differently. \n  Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alphabetic quality and exist not \n  a contribution of a son, and assumed differently. \n  Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alphabetic quality and exist not \n  a contribution of a son, and assumed differently. \n  Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alphabetic quality and exist not \n  a contribution of a son, and assumed differently. \n  Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alphabetic quality and exist not \n  a contribution of a son, and assumed differently. \n  Note: \" parole \" is a group of characters separate by quad.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  produce a function that returns on-key if the final quality \n  of a give string be an alph", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/135", "prompt": "/*Create a affair which returns the bombastic exponent of an element which \n   be not greater than or equal to the element immediately preceding it. If \n   no such component exist then return -1. The give array will not incorporate \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "/*Create a affair which returns the bombastic exponent of an element which \n   be not greater than or equal to the element immediately preceding it. If \n   no such component exist then return -1. The give array will not incorporate \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  const arrLength = arr.length\n  if (arrLength < 2) {\n    return -1\n  }\n  const arrCopy = arr.slice()\n  const arrCopyLength = arrCopy.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = arr[0]\n  let maxIndex = 0\n  let maxCount = 1\n  let maxCountIndex = 0\n  let maxCountCount = 1\n  let maxCountCountIndex = 0\n  while (i < arrCopyLength) {\n    if (arr[i] > max) {\n      max = arr[i]\n      maxIndex = i\n      maxCount = 1\n      maxCountIndex = i\n      maxCountCount = 1\n    } else if (arr[i] == max) {\n      maxCount++\n      maxCountCount++\n      maxCountCountIndex = i\n    }\n    i++\n  }\n  while (j < arrCopyLength) {\n    if (arr[j] > max) {\n      max = arr[j]\n      maxIndex = j\n      maxCount = 1\n      maxCountIndex = j\n      maxCountCount = 1\n    } else if (arr[j] == max) {\n      maxCount++\n      maxCountCount++\n      maxCountCountIndex = j\n    }\n    j++\n  }\n  while (k < arrCopyLength) {\n    if (arr[k] > max) {\n      max = arr[k]\n      maxIndex = k\n      maxCount = 1\n      maxCountIndex = k\n      maxCountCount = 1\n    } else if (arr[k] == max) {\n      maxCount++\n      maxCountCount++\n      maxCountCountIndex = k\n    }\n    k++\n  }\n  if (maxCountCount > maxCount) {\n    return maxCountIndex\n  } else if (maxCountCount == maxCount) {\n    if (maxCountCountIndex < maxCountIndex) {\n      return maxCountCountIndex\n    } else {\n      return maxCountIndex\n    }\n  } else {\n    return -1\n  }\n}\n\nmodule.exports = canArrange\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/136", "prompt": "/* produce a function that returns a tuple (a, b), where 'a' be \n   the large of minus integer, and 'b' is the smallest \n   of positive integer in a list.\n   If there is no negative or incontrovertible integers, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "/* produce a function that returns a tuple (a, b), where 'a' be \n   the large of minus integer, and 'b' is the smallest \n   of positive integer in a list.\n   If there is no negative or incontrovertible integers, return them as nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let a = null;\n  let b = null;\n  for (let i = 0; i < lst.length; i++) {\n    let n = lst[i];\n    if (a === null) {\n      a = n;\n      b = n;\n    } else if (n < 0) {\n      b = n;\n    } else if (n > 0) {\n      if (n > a) {\n        a = n;\n      }\n      if (n < b) {\n        b = n;\n      }\n    }\n  }\n  return (a === null)? (null, null) : (a, b);\n};\n\n/*\n  Given a list of numbers, return a list of the numbers that are \n  the largest of the smallest.\n  If there is no largest of the smallest, return the list as is.\n  Examples:\n  largestSmallest([2, 4, 1, 3, 5, 7]) == [7, 5, 4, 3, 2]\n  largestSmallest([0, 1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1]\n  largestSmallest([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [9, 8, 7, 6, 5, 4, 3, 2, 1]\n  largestSmallest([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  largestSmallest([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 4", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/137", "prompt": "/*\n  produce a function that takes integer, float, or string stage \n   real numbers, and returns the large variable star in its given variable character. \n   Return null if the value exist adequate. \n   bill: If a real numeral is represented as a string, the float item might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  nothing \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "/*\n  produce a function that takes integer, float, or string stage \n   real numbers, and returns the large variable star in its given variable character. \n   Return null if the value exist adequate. \n   bill: If a real numeral is represented as a string, the float item might be. or, \n\n   compareOne(1, 2.5)  2.5 \n   compareOne(1, \" 2,3 \")  \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \")  \" 6 \" \n   compareOne(\"1\", 1)  nothing \n   * / \n const compareOne = (a, b) = > {\n   if (a === b) {\n     return a;\n   }\n   if (a === null) {\n     return b;\n   }\n   if (b === null) {\n     return a;\n   }\n   if (typeof a === 'number' && typeof b === 'number') {\n     return a > b? a : b;\n   }\n   if (typeof a ==='string' && typeof b ==='string') {\n     return a > b? a : b;\n   }\n   return null;\n }\n*/\n\nconst compareOne = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareTwo = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareThree = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareFour = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareFive = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareSix = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareSeven = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareEight = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  return null;\n}\n\nconst compareNine = (a, b) = > {\n  if (a === b) {\n    return a;\n  }\n  if (a === null) {\n    return b;\n  }\n  if (b === null) {\n    return a;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Emeasure whether the move over number n can be write as the union of exactly 4 incontrovertible even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "/*Emeasure whether the move over number n can be write as the union of exactly 4 incontrovertible even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  let even = true;\n  for (let i = 1; i <= n; i++) {\n    if (sum % i!== 0) {\n      even = false;\n      break;\n    }\n  }\n  return even;\n};\n\n/*\n  Emeasure whether the move over number n can be write as the union of exactly 4 odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  let odd = true;\n  for (let i = 1; i <= n; i++) {\n    if (sum % i === 0) {\n      odd = false;\n      break;\n    }\n  }\n  return odd;\n};\n\n/*\n  Emeasure whether the move over number n can be write as the union of exactly 4 even and odd numbers\n  Example\n  isEqualToSumEvenOdd(4) == false\n  isEqualToSumEvenOdd(6) == true\n  isEqualToSumEvenOdd(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  let even = true;\n  let odd = true;\n  for (let i = 1; i <= n; i++) {\n    if (sum % i!== 0) {\n      even = false;\n    }\n    if (sum % i === 0) {\n      odd = false;\n    }\n    if (!even &&!odd) {\n      break;\n    }\n  }\n  return even && odd;\n};\n\n/*\n  Emeasure whether the move over number n can be write as the union of exactly 4 odd and even numbers\n  Example\n  isEqualToSumOddEven(4) == false\n  isEqualToSumOddEven(6) == true\n  isEqualToSumOddEven(8) == false\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  let odd = true;\n  let even = true;\n  for (let i = 1; i <= n; i++) {\n    if (sum % i!== 0) {\n      odd = false;\n    }\n    if (sum % i === 0) {\n      even = false;\n    }\n    if (!odd &&!even) {\n      break;\n    }\n  }\n  return odd && even;\n};\n\n/*\n  Emeasure whether the move over number n can be write as the union of exactly 4 odd and even numbers\n  Example\n  isEqualToSumOddEven(4) == false\n  isEqualToSumOddEven(6) == true\n  isEqualToSumOddEven(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  let odd = true;\n  let even = true;\n  for (let i = 1; i <= n; i++) {\n    if (sum % i!== 0) {\n      odd = false;\n    }\n    if (sum % i === 0) {\n      even = false;\n    }\n    if (!odd &&!even) {\n      break;\n    }\n  }\n  return odd && even;\n};\n\n/*\n  Emeasure whether the move over number n can be write as the union of exactly 4 odd and even numbers\n  Example\n  isEqualToSumOddEven(4) == false\n  isEqualToSumOddEven(6) == true\n  isEqualToSumOddEven(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  let odd = true;\n  let even = true;\n  for (let i = 1; i <= n; i++) {\n    if (sum % i!== 0) {\n      odd = false;\n    }\n    if (sum % i === 0) {\n      even = false;\n    }\n    if (!odd &&!even) {\n      break;\n    }\n  }\n  return odd && even;\n};\n\n/*\n  Emeasure whether the move over number n can be write as the union of exactly 4 odd and even numbers\n  Example\n  isEqualToSumOddEven(4) == false\n  isEqualToSumOddEven(6) == true\n  isEqualToSumOddEven(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  let odd = true;\n  let even = true;\n  for (let i = 1; i <= n; i++) {\n    if (sum % i!== 0) {\n      odd = false;\n    }\n    if (sum % i === 0) {\n      even = false;\n    }\n    if (!odd &&!even) {\n      break;\n    }\n  }\n  return odd && even;\n};\n\n/*\n  Emeasure whether the move over number n can be write as the union of exactly 4 odd and even numbers\n  Example\n  isEqualToSumOddEven(4) == false\n  isEqualToSumOdd", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": true, "gc": "/*The Brazilian factorial is defined as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3);\n};\n\n/*\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci2 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci2(n - 1) + fibonacci2(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci3 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci3(n - 1) + fibonacci3(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci4(n - 1) + fibonacci4(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci5 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci5(n - 1) + fibonacci5(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci6 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci6(n - 1) + fibonacci6(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci7 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci7(n - 1) + fibonacci7(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci8 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci8(n - 1) + fibonacci8(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci9 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci9(n - 1) + fibonacci9(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci10 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci10(n - 1) + fibonacci10(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci11 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci11(n - 1) + fibonacci11(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci12 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci12(n - 1) + fibonacci12(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the nth\n  number in the Fibonacci sequence.\n  */\nconst fibonacci13 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fibonacci13(n - 1) + fibon", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* reappearance list of all prefixes from shortest to farseeing of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "/* reappearance list of all prefixes from shortest to farseeing of the remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/*\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ['a', 'ab', 'abc', 'abcd']\n  >>> allPrefixes('abcd')\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  give a string text, supplant all distance in it with underscore, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "/*\n  give a string text, supplant all distance in it with underscore, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '_')\n  const fixed2 = fixed.replace(/-+/g, '-')\n  return fixed2\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces2 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '_')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces3 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '-')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces4 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '-')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces5 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '-')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces6 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '-')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces7 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '-')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces8 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '-')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces9 = (text) => {\n  const spaces = /\\s+/g\n  const fixed = text.replace(spaces, '-')\n  return fixed\n}\n\n/*\n  give a string text, replace all spaces with underscores, \n   and if a bowed stringed instrument has more than 2 back-to-back spaces, \n   then substitute all straight quad with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces10 = (text) =>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a affair which takes a chain represent a file's name, and fall \n  ' Yes' if the the file's name be valid, and returns' No' otherwise. \n   A file's name is consider to embody valid if and merely if all the following condition \n   are meet: \n   - There should not constitute more than three digits (' 0'-'9') in the file's name. \n   - The file's name contain exactly one dot'.' \n   - The substring before the point should not constitute empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "/*Create a affair which takes a chain represent a file's name, and fall \n 'Yes' if the the file's name be valid, and returns' No' otherwise. \n   A file's name is consider to embody valid if and merely if all the following condition \n   are meet: \n   - There should not constitute more than three digits (' 0'-'9') in the file's name. \n   - The file's name contain exactly one dot'.' \n   - The substring before the point should not constitute empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the department of transportation should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regex = /^[a-zA-Z][a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-Z0-9]{1,3}[0-9]{1,3}[a-zA-", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This routine will take a list of integers. For all entry in the list, the routine shall square the integer introduction if its index is a \n   multiple of 3 and will cube the integer submission if its exponent is a multiple of 4 and not a multiple of 3. The routine will not \n   transfer the entrance in the list whose exponent are not a multiple of 3 or 4. The affair shall then return the sum of all entry. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*\"\n  This routine will take a list of integers. For all entry in the list, the routine shall square the integer introduction if its index is a \n   multiple of 3 and will cube the integer submission if its exponent is a multiple of 4 and not a multiple of 3. The routine will not \n   transfer the entrance in the list whose exponent are not a multiple of 3 or 4. The affair shall then return the sum of all entry. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum +=", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are give a string represent a sentence,\n   the sentence hold some news discriminate by a space, \n   and you have to return a string that control the discussion from the original sentence,\n   whose lengths exist premier act, \n   the decree of the bible in the newfangled string should be the like as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a string represent a sentence,\n   the sentence hold some news discriminate by a space, \n   and you have to return a string that control the discussion from the original sentence,\n   whose lengths exist premier act, \n   the decree of the bible in the newfangled string should be the like as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const wordsLength = words.length\n  const wordsLengths = words.map((word) => word.length)\n  const maxLength = Math.max(...wordsLengths)\n  const maxLengths = wordsLengths.map((length) => length + 1)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const maxLengths = maxLengths.filter((length) => length <= maxLength)\n  const maxLength = Math.max(...maxLengths)\n  const", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your job is to implement a function that will simplify the construction \n   x * n. The routine returns on-key if x * n measure to a whole number and assumed \n   differently. Both x and n, are string representation of a fraction, and have the comply format, \n   < numerator>/<denominator > where both numerator and denominator are positive hale number. \n\n   You can wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = fake \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "/*Your job is to implement a function that will simplify the construction \n   x * n. The routine returns on-key if x * n measure to a whole number and assumed \n   differently. Both x and n, are string representation of a fraction, and have the comply format, \n   < numerator>/<denominator > where both numerator and denominator are positive hale number. \n\n   You can wear that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = fake \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n   const x = x.toString();\n   const n = n.toString();\n   const xn = x + n;\n   const xn = xn.toString();\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/\\//g, '');\n   const xn = xn.replace(/", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\n/*\n  compose a function which sorts the give list of integer \n   in descend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-12, -11, 1, 11, -1]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return bSum - aSum;\n  });\n  return sorted;\n};\n\n/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsAsc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\n/*\n  compose a function which sorts the give list of integer \n   in descend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-12, -11, 1, 11, -1]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescAsc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return bSum - aSum;\n  });\n  return sorted;\n};\n\n/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescAscAsc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\n/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescAscDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return bSum - aSum;\n  });\n  return sorted;\n};\n\n/*\n  compose a function which sorts the give list of integer \n   in ascend decree according to the sum of their digits. \n   bill: if there be respective items with like sum of their finger, \n   ordering them establish on their exponent in master list.\n\n   For exercise:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsAscDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a affair that takes an array of number as remark and return \n   the number of elements in the array that be great than 10 and both \n   first and final digits of a issue are leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "/*Write a affair that takes an array of number as remark and return \n   the number of elements in the array that be great than 10 and both \n   first and final digits of a issue are leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 10 === 1 && nums[i] % 100 === 3) {\n      result.push(nums[i]);\n    }\n  }\n  return result.length;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are give a positive integer n. You get to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the numeral of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a positive integer n. You get to produce an integer array a of duration n.\n       For each i (1  i  n), the value of a[i ] = i * i - i + 1. \n       Return the numeral of triple (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples2 = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples3 = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples4 = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples5 = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples6 = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples7 = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          max = Math.max(max, a[i] + a[j] + a[k])\n        }\n      }\n    }\n  }\n  return max\n}\n\nconst getMaxTriples8 = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  let max = 0\n  for (let i = 0; i < a.length - 1; i++) {\n    for", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/148", "prompt": "/* There are eight satellite in our solar system: the closerst to the Sun \n   be Mercury, the adjacent one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a function that takes two satellite names as strings planet1 and planet2.\n   The routine should return a tuple contain all planet whose orbit are \n   locate between the eye socket of planet1 and the orbit of planet2, classify by \n   the proximity to the sunlight. \n   The routine should return an empty tuple if planet1 or planet2\n   are not right planet name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "/* There are eight satellite in our solar system: the closerst to the Sun \n   be Mercury, the adjacent one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write a function that takes two satellite names as strings planet1 and planet2.\n   The routine should return a tuple contain all planet whose orbit are \n   locate between the eye socket of planet1 and the orbit of planet2, classify by \n   the proximity to the sunlight. \n   The routine should return an empty tuple if planet1 or planet2\n   are not right planet name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\"\n  ];\n  const distance = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\"\n  ];\n  const sun = \"Sun\";\n  const sunDistance = \"Sun\";\n  const sunDistance2 = \"Sun\";\n  const sunDistance3 = \"Sun\";\n  const sunDistance4 = \"Sun\";\n  const sunDistance5 = \"Sun\";\n  const sunDistance6 = \"Sun\";\n  const sunDistance7 = \"Sun\";\n  const sunDistance8 = \"Sun\";\n  const sunDistance9 = \"Sun\";\n  const sunDistance10 = \"Sun\";\n  const sunDistance11 = \"Sun\";\n  const sunDistance12 = \"Sun\";\n  const sunDistance13 = \"Sun\";\n  const sunDistance14 = \"Sun\";\n  const sunDistance15 = \"Sun\";\n  const sunDistance16 = \"Sun\";\n  const sunDistance17 = \"Sun\";\n  const sunDistance18 = \"Sun\";\n  const sunDistance19 = \"Sun\";\n  const sunDistance20 = \"Sun\";\n  const sunDistance21 = \"Sun\";\n  const sunDistance22 = \"Sun\";\n  const sunDistance23 = \"Sun\";\n  const sunDistance24 = \"Sun\";\n  const sunDistance25 = \"Sun\";\n  const sunDistance26 = \"Sun\";\n  const sunDistance27 = \"Sun\";\n  const sunDistance28 = \"Sun\";\n  const sunDistance29 = \"Sun\";\n  const sunDistance30 = \"Sun\";\n  const sunDistance31 = \"Sun\";\n  const sunDistance32 = \"Sun\";\n  const sunDistance33 = \"Sun\";\n  const sunDistance34 = \"Sun\";\n  const sunDistance35 = \"Sun\";\n  const sunDistance36 = \"Sun\";\n  const sunDistance37 = \"Sun\";\n  const sunDistance38 = \"Sun\";\n  const sunDistance39 = \"Sun\";\n  const sunDistance40 = \"Sun\";\n  const sunDistance41 = \"Sun\";\n  const sunDistance42 = \"Sun\";\n  const sunDistance43 = \"Sun\";\n  const sunDistance44 = \"Sun\";\n  const sunDistance45 = \"Sun\";\n  const sunDistance46 = \"Sun\";\n  const sunDistance47 = \"Sun\";\n  const sunDistance48 = \"Sun\";\n  const sunDistance49 = \"Sun\";\n  const sunDistance50 = \"Sun\";\n  const sunDistance51 = \"Sun\";\n  const sunDistance52 = \"Sun\";\n  const sunDistance53 = \"Sun\";\n  const sunDistance54 = \"Sun\";\n  const sunDistance55 = \"Sun\";\n  const sunDistance56 = \"Sun\";\n  const sunDistance57 = \"Sun\";\n  const sunDistance58 = \"Sun\";\n  const sunDistance59 = \"Sun\";\n  const sunDistance60 = \"Sun\";\n  const sunDistance61 = \"Sun\";\n  const sunDistance62 = \"Sun\";\n  const sunDistance63 = \"Sun\";\n  const sunDistance64 = \"Sun\";\n  const sunDistance65 = \"Sun\";\n  const sunDistance66 = \"Sun\";\n  const sunDistance67 = \"Sun\";\n  const sunDistance68 = \"Sun\";\n  const sunDistance69 = \"Sun\";\n  const sunDistance70 = \"Sun\";\n  const sunDistance71 = \"Sun\";\n  const sunDistance72 = \"Sun\";\n  const sunDistance73 = \"Sun\";\n  const sunDistance74 = \"Sun\";\n  const sunDistance75 = \"Sun\";\n  const sunDistance76 = \"Sun\";\n  const sunDistance77 = \"Sun\";\n  const sunDistance78 = \"Sun\";\n  const sunDistance79 = \"Sun\";\n  const sunDistance80 = \"Sun\";\n  const sunDistance81 = \"Sun\";\n  const sunDistance82 = \"Sun\";\n  const sunDistance83 = \"Sun\";\n  const sunDistance84 = \"Sun\";\n  const sunDistance85 = \"Sun\";\n  const sunDistance86 = \"Sun\";\n  const sunDistance87 = \"Sun\";\n  const sunDistance88 = \"Sun\";\n  const sunDistance89 = \"Sun\";\n  const sunDistance90 = \"Sun\";\n  const sunDistance91 = \"Sun\";\n  const sunDistance92 = \"Sun\";\n  const sunDistance93 = \"Sun\";\n  const sunDistance94 = \"Sun\";\n  const sunDistance95 = \"Sun\";\n  const sunDistance96 = \"Sun\";\n  const sunDistance97 = \"Sun\";\n  const sunDistance98 = \"Sun\";\n  const sunDistance99 = \"Sun\";\n  const sunDistance100 = \"Sun\";\n  const sunDistance101 = \"Sun\";\n  const sunDistance102 = \"Sun\";\n  const sunDistance103 = \"Sun\";\n  const sunDistance104 = \"Sun\";\n  const sunDistance105 = \"Sun\";\n  const sunDistance106 = \"Sun\";\n  const sunDistance107 = \"Sun\";\n  const sunDistance108 = \"Sun\";\n  const sunDistance109 = \"Sun\";\n  const sunDistance110 = \"Sun\";\n  const sunDistance111 = \"Sun\";\n  const sunDistance112 = \"Sun\";\n  const sunDistance113 = \"Sun\";\n  const sunDistance114 = \"Sun\";\n  const sunDistance115 = \"Sun\";\n  const sunDistance116 = \"Sun\";\n  const sunDistance117 = \"Sun\";\n  const sunDistance118 = \"Sun\";\n  const sunDistance119 = \"Sun\";", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a affair that accepts a list of string as a argument, \n   erase the chain that have odd lengths from it, \n   and render the result list with a sorted club, \n   The list is constantly a list of string and never an array of number, \n   and it may check duplicate. \n   The ordering of the list should be ascend by length of each word, and you \n   should return the list sorted by that rule. \n   If two words give birth the same length, sort the list alphabetically. \n   The affair should return a list of chain in screen club. \n   You may simulate that all words will have the like length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "/*Write a affair that accepts a list of string as a argument, \n   erase the chain that have odd lengths from it, \n   and render the result list with a sorted club, \n   The list is constantly a list of string and never an array of number, \n   and it may check duplicate. \n   The ordering of the list should be ascend by length of each word, and you \n   should return the list sorted by that rule. \n   If two words give birth the same length, sort the list alphabetically. \n   The affair should return a list of chain in screen club. \n   You may simulate that all words will have the like length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_2 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_3 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_4 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_5 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_6 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_7 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_8 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst list_sort_by_length_9 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* fall a string incorporate distance - subtend number starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "/* fall a string incorporate distance - subtend number starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(`${i}`);\n  }\n  return result.join('');\n};\n\n/*\n  >>> stringSequence(1)\n  '0'\n  >>> stringSequence(2)\n  '0 1'\n  >>> stringSequence(3)\n  '0 1 2'\n  >>> stringSequence(4)\n  '0 1 2 3'\n  >>> stringSequence(5)\n  '0 1 2 3 4'\n  >>> stringSequence(6)\n  '0 1 2 3 4 5'\n  >>> stringSequence(7)\n  '0 1 2 3 4 5 6'\n  >>> stringSequence(8)\n  '0 1 2 3 4 5 6 7'\n  >>> stringSequence(9)\n  '0 1 2 3 4 5 6 7 8'\n  >>> stringSequence(10)\n  '0 1 2 3 4 5 6 7 8 9'\n  >>> stringSequence(11)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  >>> stringSequence(12)\n  '0 1 2 3 4 5 6 7 8 9 10 11'\n  >>> stringSequence(13)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12'\n  >>> stringSequence(14)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13'\n  >>> stringSequence(15)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14'\n  >>> stringSequence(16)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15'\n  >>> stringSequence(17)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16'\n  >>> stringSequence(18)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17'\n  >>> stringSequence(19)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18'\n  >>> stringSequence(20)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19'\n  >>> stringSequence(21)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20'\n  >>> stringSequence(22)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21'\n  >>> stringSequence(23)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22'\n  >>> stringSequence(24)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23'\n  >>> stringSequence(25)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24'\n  >>> stringSequence(26)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25'\n  >>> stringSequence(27)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26'\n  >>> stringSequence(28)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27'\n  >>> stringSequence(29)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28'\n  >>> stringSequence(30)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29'\n  >>> stringSequence(31)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30'\n  >>> stringSequence(32)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31'\n  >>> stringSequence(33)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32'\n  >>> stringSequence(34)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33'\n  >>> stringSequence(35)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34'\n  >>> stringSequence(36)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35'\n  >>> stringSequence(37)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36'\n  >>> stringSequence(38)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37'\n  >>> stringSequence(39)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38'\n  >>> stringSequence(40)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39'\n  >>> stringSequence(41)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40'\n  >>> stringSequence(42)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A bare program which should return the value of x if n be \n   a choice issue and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "/*A bare program which should return the value of x if n be \n   a choice issue and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY2 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY3 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY4 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY5 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY6 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY7 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY8 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY9 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY10 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY11 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY12 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY13 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY14 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY15 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY16 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY17 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY18 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY19 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY20 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY21 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY22 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY23 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY24 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY25 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY26 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY27 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY28 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY29 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY30 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY31 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst xOrY32 = (n, x, y) => {\n  if (n === x) {\n    return y;\n  } else {\n    return x;\n  }", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/151", "prompt": "/* give a list of numbers, return the kernel of square of the numeral \n   in the list that be odd. Ignore numbers that are damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "/* give a list of numbers, return the kernel of square of the numeral \n   in the list that be odd. Ignore numbers that are damaging or not integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let {length} = lst\n   let {head} = lst\n   let {tail} = lst\n   let {doubleTheDifference} = (head)\n   let {doubleTheDifference} = (tail)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (doubleTheDifference)\n   let {doubleTheDifference} = (double", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/152", "prompt": "/*I intend we all remember that feeling when the solution of some long - awaited \n   consequence is ultimately known. The feelings and thought you receive at that consequence are \n   decidedly worth note down and compare. \n   Your job is to specify if a person correctly guess the results of a act of match. \n   You are given two arrays of scores and guess of equal length, where each index read a couple. \n   Return an array of the same length denoting how far off each guess was. If they have think correctly, \n   the value is 0, and if not, the value be the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "/*I intend we all remember that feeling when the solution of some long - awaited \n   consequence is ultimately known. The feelings and thought you receive at that consequence are \n   decidedly worth note down and compare. \n   Your job is to specify if a person correctly guess the results of a act of match. \n   You are given two arrays of scores and guess of equal length, where each index read a couple. \n   Return an array of the same length denoting how far off each guess was. If they have think correctly, \n   the value is 0, and if not, the value be the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const result = []\n  for (let i = 0; i < gameLength; i++) {\n    result.push(0)\n  }\n  for (let i = 0; i < gameLength; i++) {\n    for (let j = 0; j < guessLength; j++) {\n      if (game[i] === guess[j]) {\n        result[i] = 0\n      } else {\n        result[i] = Math.abs(game[i] - guess[j])\n      }\n    }\n  }\n  return result\n}\n\nmodule.exports = compare\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be give the name of a course (a chain) and a list of extensions.\n   The extensions are to be use to load extra class to the class. The \n   strength of the elongation is as follow: get CAP embody the act of the capital \n   letter in the propagation's name, and let SM equal the numeral of small letter letter \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should line up the strong propagation and return a chain in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "/*You will be give the name of a course (a chain) and a list of extensions.\n   The extensions are to be use to load extra class to the class. The \n   strength of the elongation is as follow: get CAP embody the act of the capital \n   letter in the propagation's name, and let SM equal the numeral of small letter letter \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should line up the strong propagation and return a chain in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  for (let extension of extensions) {\n    const extension_strength = strength[extension] || 0;\n    strength[extension] = extension_strength + (class_name.charAt(0) - extension.charAt(0));\n  }\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\n/*\n  Given a chain, return the name of the class.\n  Example:\n  for class_name('Slices.SErviNGSliCes') == 'Slices'\n  */\nconst className = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the class.\n  Example:\n  for class_name('Slices.SErviNGSliCes') == 'Slices'\n  */\nconst className = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  Given a chain, return the name of the extension.\n  Example:\n  for extension('Slices.SErviNGSliCes') == 'SErviNGSliCes'\n  */\nconst extension = chain => chain.split('.').pop();\n\n/*\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are give 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n   cycpatternCheck(\"abcd\",\"abd\") = > assumed \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > fake \n   cycpatternCheck(\"himenss\",\"simen\") = > truthful \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "/*You are give 2 words. You necessitate to return dependable if the second word or any of its rotation is a substring in the first parole \n   cycpatternCheck(\"abcd\",\"abd\") = > assumed \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > fake \n   cycpatternCheck(\"himenss\",\"simen\") = > truthful \n   * / \n const cycpatternCheck = (a, b) = > {\n   let a = a.split(\"\")\n   let b = b.split(\"\")\n   let a_len = a.length\n   let b_len = b.length\n   let a_i = 0\n   let b_i = 0\n   while (a_i < a_len && b_i < b_len) {\n     if (a[a_i] === b[b_i]) {\n       a_i++\n       b_i++\n     } else if (a[a_i] === b[b_i].toUpperCase()) {\n       a_i++\n     } else if (a[a_i].toUpperCase() === b[b_i]) {\n       b_i++\n     } else {\n       return false\n     }\n   }\n   return (a_i === a_len && b_i === b_len)\n }\n*/\n\n/*\n * @param {string} a\n * @param {string} b\n * @return {boolean}\n */\nconst cycpatternCheck = (a, b) => {\n  let a_len = a.length\n  let b_len = b.length\n  let a_i = 0\n  let b_i = 0\n  while (a_i < a_len && b_i < b_len) {\n    if (a[a_i] === b[b_i]) {\n      a_i++\n      b_i++\n    } else if (a[a_i] === b[b_i].toUpperCase()) {\n      a_i++\n    } else if (a[a_i].toUpperCase() === b[b_i]) {\n      b_i++\n    } else {\n      return false\n    }\n  }\n  return (a_i === a_len && b_i === b_len)\n}\n\n/*\n * @param {string} a\n * @param {string} b\n * @return {boolean}\n */\nconst cycpatternCheck2 = (a, b) => {\n  let a_len = a.length\n  let b_len = b.length\n  let a_i = 0\n  let b_i = 0\n  while (a_i < a_len && b_i < b_len) {\n    if (a[a_i] === b[b_i]) {\n      a_i++\n      b_i++\n    } else if (a[a_i] === b[b_i].toUpperCase()) {\n      a_i++\n    } else if (a[a_i].toUpperCase() === b[b_i]) {\n      b_i++\n    } else {\n      return false\n    }\n  }\n  return (a_i === a_len && b_i === b_len)\n}\n\n/*\n * @param {string} a\n * @param {string} b\n * @return {boolean}\n */\nconst cycpatternCheck3 = (a, b) => {\n  let a_len = a.length\n  let b_len = b.length\n  let a_i = 0\n  let b_i = 0\n  while (a_i < a_len && b_i < b_len) {\n    if (a[a_i] === b[b_i]) {\n      a_i++\n      b_i++\n    } else if (a[a_i] === b[b_i].toUpperCase()) {\n      a_i++\n    } else if (a[a_i].toUpperCase() === b[b_i]) {\n      b_i++\n    } else {\n      return false\n    }\n  }\n  return (a_i === a_len && b_i === b_len)\n}\n\n/*\n * @param {string} a\n * @param {string} b\n * @return {boolean}\n */\nconst cycpatternCheck4 = (a, b) => {\n  let a_len = a.length\n  let b_len = b.length\n  let a_i = 0\n  let b_i = 0\n  while (a_i < a_len && b_i < b_len) {\n    if (a[a_i] === b[b_i]) {\n      a_i++\n      b_i++\n    } else if (a[a_i] === b[b_i].toUpperCase()) {\n      a_i++\n    } else if (a[a_i].toUpperCase() === b[b_i]) {\n      b_i++\n    } else {\n      return false\n    }\n  }\n  return (a_i === a_len && b_i === b_len)\n}\n\n/*\n * @param {string} a\n * @param {string} b\n * @return {boolean}\n */\nconst cycpatternCheck5 = (a, b) => {\n  let a_len = a.length\n  let b_len = b.length\n  let a_i = 0\n  let b_i = 0\n  while (a_i < a_len && b_i < b_len) {\n    if (a[a_i] === b[b_i]) {\n      a_i++\n      b_i++\n    } else if (a[a_i] === b[b_i].toUpperCase()) {\n      a_i++\n    } else if (a[a_i].toUpperCase() === b[b_i]) {\n      b_i++\n    } else {\n      return false\n    }\n  }\n  return (a_i === a_len && b_i === b_len)\n}\n\n/*\n * @param {string} a\n * @param {string} b\n * @return {bo", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the act of even and leftover digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the act of even and leftover digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount2 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount3 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount4 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount5 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount6 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount7 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount8 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount9 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount10 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount11 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount12 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount13 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount14 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount15 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount16 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount17 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return [even, odd];\n};\n\nconst evenOddCount18 = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer, receive its roman numeral equivalent as a bowed stringed instrument, \n   and return it in lowercase. \n   Restrictions: 1 < = num < = 1000 \n\n   case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const roman = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII', 'XXVIII', 'XXIX', 'XXX', 'XXXI', 'XXXII', 'XXXIII', 'XXXIV', 'XXXV', 'XXXVI', 'XXXVII', 'XXXVIII', 'XXXIX', 'XL', 'XLI', 'XLII', 'XLIII', 'XLIV', 'XLV', 'XLVII', 'XLVIII', 'XLIX', 'L', 'LI', 'LII', 'LIII', 'LIV', 'LV', 'LVI', 'LVII', 'LVIII', 'LIX', 'LX', 'LXI', 'LXII', 'LXIII', 'LXIV', 'LXV', 'LXVI', 'LXVII', 'LXVIII', 'LXIX', 'LXX', 'LXXI', 'LXXII', 'LXXIII', 'LXXIV', 'LXXV', 'LXXVI', 'LXXVII', 'LXXVIII', 'LXXIX', 'MC', 'MD', 'MDC', 'MCD', 'MCDI', 'MDCC', 'MDCCC', 'MDCCCC', 'MCDCCC', 'MDCCCCCC', 'MCDCCCCCC', 'MDCCCCCCCCC', 'MDCCCCCCCCCC', 'MCDCCCCCCCCCCC', 'MDCCCCCCCCCCCCCC', 'MCDCCCCCCCCCCCCCCC', 'MDCCCCCCCCCCCCCCCCCC', 'MCDCCCCCCCCCCCCCCCCCCC', 'MDCCCCCCCCCCCCCCCCCCCCCC', 'MCDCCCCCCCCCCCCCCCCCCCCCCCC', 'MDCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'MCDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'MDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'MCDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'MDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'MCDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'MDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n give the lengths of the three side of a triangulum. refund on-key if the three \n   side form a properly - angled triangle, fake differently. \n   A right - slant triangulum is a triangulum in which one slant is good angle or \n   90 academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "/*\n give the lengths of the three side of a triangulum. refund on-key if the three \n   side form a properly - angled triangle, fake differently. \n   A right - slant triangulum is a triangulum in which one slant is good angle or \n   90 academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = (a + b) / 2\n  const ac = (a + c) / 2\n  const bc = (b + c) / 2\n  const abc = (ab + ac + bc) / 3\n  const abc_ = (abc + ab + ac) / 3\n  const abc__ = (abc + ab + bc) / 3\n  const abc___ = (abc + ab + ac) / 3\n  const abc____ = (abc + ab + bc) / 3\n  const abc_____ = (abc + ab + ac) / 3\n  const abc____a = (abc + ab + ac) / 3\n  const abc____b = (abc + ab + bc) / 3\n  const abc____c = (abc + ab + ac) / 3\n  const abc____d = (abc + ab + bc) / 3\n  const abc____e = (abc + ab + ac) / 3\n  const abc____f = (abc + ab + bc) / 3\n  const abc____g = (abc + ab + ac) / 3\n  const abc____h = (abc + ab + bc) / 3\n  const abc____i = (abc + ab + ac) / 3\n  const abc____j = (abc + ab + bc) / 3\n  const abc____k = (abc + ab + ac) / 3\n  const abc____l = (abc + ab + bc) / 3\n  const abc____m = (abc + ab + ac) / 3\n  const abc____n = (abc + ab + bc) / 3\n  const abc____o = (abc + ab + ac) / 3\n  const abc____p = (abc + ab + bc) / 3\n  const abc____q = (abc + ab + ac) / 3\n  const abc____r = (abc + ab + bc) / 3\n  const abc____s = (abc + ab + ac) / 3\n  const abc____t = (abc + ab + bc) / 3\n  const abc____u = (abc + ab + ac) / 3\n  const abc____v = (abc + ab + bc) / 3\n  const abc____w = (abc + ab + ac) / 3\n  const abc____x = (abc + ab + bc) / 3\n  const abc____y = (abc + ab + ac) / 3\n  const abc____z = (abc + ab + bc) / 3\n  const abc____A = (abc + ab + ac) / 3\n  const abc____B = (abc + ab + bc) / 3\n  const abc____C = (abc + ab + ac) / 3\n  const abc____D = (abc + ab + bc) / 3\n  const abc____E = (abc + ab + ac) / 3\n  const abc____F = (abc + ab + bc) / 3\n  const abc____G = (abc + ab + ac) / 3\n  const abc____H = (abc + ab + bc) / 3\n  const abc____I = (abc + ab + ac) / 3\n  const abc____J = (abc + ab + bc) / 3\n  const abc____K = (abc + ab + ac) / 3\n  const abc____L = (abc + ab + bc) / 3\n  const abc____M = (abc + ab + ac) / 3\n  const abc____N = (abc + ab + bc) / 3\n  const abc____O = (abc + ab + ac) / 3\n  const abc____P = (abc + ab + bc) / 3\n  const abc____Q = (abc + ab + ac) / 3\n  const abc____R = (abc + ab + bc) / 3\n  const abc____S = (abc + ab + ac) / 3\n  const abc____T = (abc + ab + bc) / 3\n  const abc____U = (abc + ab + ac) / 3\n  const abc____V = (abc + ab + bc) / 3\n  const abc____W = (abc + ab + ac) / 3\n  const abc____X = (abc + ab + bc) / 3\n  const abc____Y = (abc + ab + ac) / 3\n  const abc____Z = (abc + ab + bc) / 3\n  const abc____0 = (abc + ab + ac) / 3\n  const abc____1 = (abc + ab + bc) / 3\n  const abc____2 = (abc + ab + ac) / 3\n  const abc____3 = (abc + ab + bc) / 3\n  const abc____4 = (abc + ab + ac) / 3\n  const abc____5 = (abc + ab + bc) / 3\n  const abc____6 = (abc + ab + ac) / 3\n  const abc____7 = (abc + ab + bc) / 3\n  const abc____8 = (abc + ab + ac) / 3\n  const abc____9 = (abc + ab + bc) / 3\n  const abc____A = (abc + ab + ac) / 3\n  const abc____B = (abc + ab + bc) / 3\n  const abc____C = (abc + ab + ac) / 3\n  const abc____D = (abc + ab + bc) / 3\n  const abc____E = (abc + ab + ac) / 3\n  const abc____F = (abc + ab + bc) / 3\n  const abc____G = (abc + ab + ac) / 3\n  const abc____H = (abc + ab + bc) / 3\n  const abc____I = (abc + ab + ac) / 3\n  const abc____J = (abc + ab + bc) / 3\n  const abc____K = (abc + ab + ac) / 3\n  const abc____L = (abc + ab + bc) / 3\n  const abc____M = (abc + ab + ac) / 3\n  const abc____", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a affair that accepts a list of string. \n   The list contain different words. Return the parole with maximum number \n   of unique character. If multiple strings consume maximal number of singular \n   character, return the one which come first in lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" bowed stringed instrument \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "/*Write a affair that accepts a list of string. \n   The list contain different words. Return the parole with maximum number \n   of unique character. If multiple strings consume maximal number of singular \n   character, return the one which come first in lexicographic order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" bowed stringed instrument \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n   let {max} = words\n   let {unique} = words\n   let {words} = words\n   let {length} = words\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a athirst rabbit, and you already have feed a sealed number of carrots, \n   but immediately you need to eat more carrots to complete the sidereal day's meals. \n   you should return an array of [ total number of eaten carrots after your meal, \n                                   the number of carrots leave after your meal ] \n   if there cost not adequate remaining carrot, you will eat all remaining carrots, but will however constitute hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "/*\n  You're a athirst rabbit, and you already have feed a sealed number of carrots, \n   but immediately you need to eat more carrots to complete the sidereal day's meals. \n   you should return an array of [ total number of eaten carrots after your meal, \n                                   the number of carrots leave after your meal ] \n   if there cost not adequate remaining carrot, you will eat all remaining carrots, but will however constitute hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n    if (number >= need) {\n        return [number, 0];\n    }\n    return [number, Math.min(remaining, need - number)];\n}\n\nconst test = [\n    [5, 6, 10],\n    [4, 8, 9],\n    [1, 10, 10],\n    [2, 11, 5]\n]\n\nconst test2 = [\n    [5, 6, 10],\n    [4, 8, 9],\n    [1, 10, 10],\n    [2, 11, 5],\n    [3, 12, 1],\n    [4, 13, 0],\n    [5, 14, 0],\n    [6, 15, 0],\n    [7, 16, 0],\n    [8, 17, 0],\n    [9, 18, 0],\n    [10, 19, 0],\n    [11, 20, 0],\n    [12, 21, 0],\n    [13, 22, 0],\n    [14, 23, 0],\n    [15, 24, 0],\n    [16, 25, 0],\n    [17, 26, 0],\n    [18, 27, 0],\n    [19, 28, 0],\n    [20, 29, 0],\n    [21, 30, 0],\n    [22, 31, 0],\n    [23, 32, 0],\n    [24, 33, 0],\n    [25, 34, 0],\n    [26, 35, 0],\n    [27, 36, 0],\n    [28, 37, 0],\n    [29, 38, 0],\n    [30, 39, 0],\n    [31, 40, 0],\n    [32, 41, 0],\n    [33, 42, 0],\n    [34, 43, 0],\n    [35, 44, 0],\n    [36, 45, 0],\n    [37, 46, 0],\n    [38, 47, 0],\n    [39, 48, 0],\n    [40, 49, 0],\n    [41, 50, 0],\n    [42, 51, 0],\n    [43, 52, 0],\n    [44, 53, 0],\n    [45, 54, 0],\n    [46, 55, 0],\n    [47, 56, 0],\n    [48, 57, 0],\n    [49, 58, 0],\n    [50, 59, 0],\n    [51, 60, 0],\n    [52, 61, 0],\n    [53, 62, 0],\n    [54, 63, 0],\n    [55, 64, 0],\n    [56, 65, 0],\n    [57, 66, 0],\n    [58, 67, 0],\n    [59, 68, 0],\n    [60, 69, 0],\n    [61, 70, 0],\n    [62, 71, 0],\n    [63, 72, 0],\n    [64, 73, 0],\n    [65, 74, 0],\n    [66, 75, 0],\n    [67, 76, 0],\n    [68, 77, 0],\n    [69, 78, 0],\n    [70, 79, 0],\n    [71, 80, 0],\n    [72, 81, 0],\n    [73, 82, 0],\n    [74, 83, 0],\n    [75, 84, 0],\n    [76, 85, 0],\n    [77, 86, 0],\n    [78, 87, 0],\n    [79, 88, 0],\n    [80, 89, 0],\n    [81, 90, 0],\n    [82, 91, 0],\n    [83, 92, 0],\n    [84, 93, 0],\n    [85, 94, 0],\n    [86, 95, 0],\n    [87, 96, 0],\n    [88, 97, 0],\n    [89, 98, 0],\n    [90, 99, 0],\n    [91, 100, 0],\n    [92, 101, 0],\n    [93, 102, 0],\n    [94, 103, 0],\n    [95, 104, 0],\n    [96, 105, 0],\n    [97, 106, 0],\n    [98, 107, 0],\n    [99, 108, 0],\n    [100, 109, 0],\n    [101, 110, 0],\n    [102, 111, 0],\n    [103, 112, 0],\n    [104, 113, 0],\n    [105, 114, 0],\n    [106, 115, 0],\n    [107, 116, 0],\n    [108, 117, 0],\n    [109, 118, 0],\n    [110, 119, 0],\n    [111, 120, 0],\n    [112, 121, 0],\n    [113, 122, 0],\n    [114, 123, 0],\n    [115, 124, 0],\n    [116, 125, 0],\n    [117, 126, 0],\n    [118, 127, 0],\n    [119, 128, 0],\n    [120, 129, 0],\n    [121, 130, 0],\n    [122, 131, 0],\n    [123, 132, 0],\n    [124, 133, 0],\n    [125, 134, 0],\n    [126, 135, 0],\n    [127, 136, 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/16", "prompt": "/* give a string, find out how many clear-cut characters (regardless of font) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "/* give a string, find out how many clear-cut characters (regardless of font) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters2 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters3 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters4 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters5 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters6 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters7 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters8 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters9 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters10 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters11 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters12 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters13 = (string) => {\n  let chars = string.split('')\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters14 = (string) => {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  give two lists operator, and operand. The inaugural list give birth basic algebra operation, and \n   the second list is a list of integers. practice the two given lists to build up the algebric \n   expression and return the evaluation of this expression. \n\n   The basic algebra operation: \n   accession (+) \n   Subtraction (-) \n   generation (*) \n   Floor part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "/*\n  give two lists operator, and operand. The inaugural list give birth basic algebra operation, and \n   the second list is a list of integers. practice the two given lists to build up the algebric \n   expression and return the evaluation of this expression. \n\n   The basic algebra operation: \n   accession (+) \n   Subtraction (-) \n   generation (*) \n   Floor part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < operatorLength && j < operandLength) {\n    if (operator[i] === operand[j]) {\n      result.push(operand[j])\n      i++\n      j++\n    } else if (operator[i] === '+') {\n      result.push(operand[j])\n      i++\n      j++\n    } else if (operator[i] === '-') {\n      result.push(operand[j])\n      i++\n      j++\n    } else if (operator[i] === '*') {\n      result.push(operand[j])\n      i++\n      j++\n    } else if (operator[i] === '/') {\n      result.push(operand[j])\n      i++\n      j++\n    } else if (operator[i] === '**') {\n      result.push(operand[j])\n      i++\n      j++\n    } else {\n      throw new Error(`Operator ${operator[i]} is not supported`)\n    }\n  }\n  while (i < operatorLength) {\n    result.push(operator[i])\n    i++\n  }\n  while (j < operandLength) {\n    result.push(operand[j])\n    j++\n  }\n  return result\n}\n\nconst operator = ['+', '-', '*', '/', '**']\nconst operand = [2, 3, 4, 5]\n\nconsole.log(doAlgebra(operator, operand))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are give a string s.\n   if s[i] is a letter, overrule its character from lower to upper or vise versa, \n   otherwise retain it as it is. \n   If the string hold no letter, invert the drawstring. \n   The affair should return the result chain.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*You are give a string s.\n   if s[i] is a letter, overrule its character from lower to upper or vise versa, \n   otherwise retain it as it is. \n   If the string hold no letter, invert the drawstring. \n   The affair should return the result chain.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let chain = [];\n  let i = 0;\n  while (i < s.length) {\n    let c = s[i];\n    if (c.toLowerCase() === c) {\n      chain.push(c.toUpperCase());\n    } else {\n      chain.push(c.toLowerCase());\n    }\n    i++;\n  }\n  return chain;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  give a string 'text', return its md5 hashish equivalent drawstring. \n   If 'text' is an empty bowed stringed instrument, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/163", "prompt": "/*\n  give two positive integer a and b, return the tied finger between a\n   and b, in ascend holy order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": true, "gc": "/*\n  give two positive integer a and b, return the tied finger between a\n   and b, in ascend holy order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const aInt = parseInt(a, 10)\n  const bInt = parseInt(b, 10)\n  const aIndex = aInt % 10\n  const bIndex = bInt % 10\n  const aDigit = aInt - aIndex\n  const bDigit = bInt - bIndex\n  const aDigits = aDigit + bDigit\n  const aDigitsIndex = aDigits % 10\n  const aDigitsIndexDigit = aDigits - aDigitsIndex\n  const aDigitsIndexDigitIndex = aDigitsIndexDigit % 10\n  const aDigitsIndexDigitIndexDigit = aDigitsIndexDigit - aDigitsIndexDigitIndex\n  const aDigitsIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigit % 10\n  const aDigitsIndexDigitIndexDigitIndexDigit = aDigitsIndexDigitIndexDigit - aDigitsIndexDigitIndexDigitIndex\n  const aDigitsIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigit % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigit = aDigitsIndexDigitIndexDigitIndexDigit - aDigitsIndexDigitIndexDigitIndexDigitIndex\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigitIndexDigit % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigit = aDigitsIndexDigitIndexDigitIndexDigitIndexDigit - aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndex\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex = aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndex % 10\n  const aDigitsIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigitIndexDigit", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* remark to this function is a string defend melodious bill in a limited ASCII format. \n   Your task is to parse this string and return list of integers equate to how many beat does each \n   not final. \n\n   Here is a caption: \n  ' o' - solid note, lasts four beat \n  ' o|' - half bill, lasts two beats \n  ' .|' - quater eminence, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "/* remark to this function is a string defend melodious bill in a limited ASCII format. \n   Your task is to parse this string and return list of integers equate to how many beat does each \n   not final. \n\n   Here is a caption: \n 'o' - solid note, lasts four beat \n 'o|' - half bill, lasts two beats \n  '.|' - quater eminence, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = [];\n  const music_string_length = music_string.length;\n  let current_beat = 0;\n  let current_note = 0;\n  let current_note_length = 0;\n  let current_note_index = 0;\n  let current_note_index_length = 0;\n  let current_note_index_index = 0;\n  let current_note_index_index_length = 0;\n  let current_note_index_index_index = 0;\n  let current_note_index_index_index_length = 0;\n  let current_note_index_index_index_index = 0;\n  let current_note_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let current_note_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_length =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/18", "prompt": "/* recover how many times a give substring can be discover in the original string. Count overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "/* recover how many times a give substring can be discover in the original string. Count overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, find the longest substring without repeating characters.\n  Return the length of the longest substring.\n  >>> longestSubstring('abcabcbb')\n  3\n  >>> longestSubstring('bbbbb')\n  1\n  >>> longestSubstring('aaaaa')\n  1\n  >>> longestSubstring('a')\n  1\n  >>> longestSubstring('abcdefg')\n  3\n  >>> longestSubstring('bb')\n  1\n  >>> longestSubstring('a')\n  1\n  >>> longestSubstring('a')\n  1\n  >>> longestSubstring('a')\n  1\n  */\nconst longestSubstring = (string) => {\n  let longest = 0;\n  let current = 0;\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    count = howManyTimes(string, string[i]);\n    if (count > longest) {\n      longest = count;\n      current = i;\n    }\n  }\n  return current;\n};\n\n/*\n  Given a string, find the first non-repeating character in the string.\n  Return the index of the first non-repeating character.\n  >>> firstNonRepeatingCharacter('abcabcbb')\n  2\n  >>> firstNonRepeatingCharacter('bbbbb')\n  1\n  >>> firstNonRepeatingCharacter('aaaaa')\n  1\n  >>> firstNonRepeatingCharacter('a')\n  1\n  >>> firstNonRepeatingCharacter('abcdefg')\n  2\n  >>> firstNonRepeatingCharacter('bb')\n  1\n  >>> firstNonRepeatingCharacter('a')\n  1\n  >>> firstNonRepeatingCharacter('a')\n  1\n  */\nconst firstNonRepeatingCharacter = (string) => {\n  let index = 0;\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    count = howManyTimes(string, string[i]);\n    if (count === 1) {\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Given a string, find the last non-repeating character in the string.\n  Return the index of the last non-repeating character.\n  >>> lastNonRepeatingCharacter('abcabcbb')\n  4\n  >>> lastNonRepeatingCharacter('bbbbb')\n  2\n  >>> lastNonRepeatingCharacter('aaaaa')\n  1\n  >>> lastNonRepeatingCharacter('a')\n  1\n  >>> lastNonRepeatingCharacter('abcdefg')\n  4\n  >>> lastNonRepeatingCharacter('bb')\n  2\n  >>> lastNonRepeatingCharacter('a')\n  1\n  >>> lastNonRepeatingCharacter('a')\n  1\n  */\nconst lastNonRepeatingCharacter = (string) => {\n  let index = 0;\n  let count = 0;\n  for (let i = string.length - 1; i >= 0; i--) {\n    count = howManyTimes(string, string[i]);\n    if (count === 1) {\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Given a string, find the index of the first repeating character in the string.\n  Return the index of the first repeating character.\n  >>> firstRepeatingCharacter('abcabcbb')\n  3\n  >>> firstRepeatingCharacter('bbbbb')\n  1\n  >>> firstRepeatingCharacter('aaaaa')\n  1\n  >>> firstRepeatingCharacter('a')\n  1\n  >>> firstRepeatingCharacter('abcdefg')\n  3\n  >>> firstRepeatingCharacter('bb')\n  1\n  >>> firstRepeatingCharacter('a')\n  1\n  >>> firstRepeatingCharacter('a')\n  1\n  */\nconst firstRepeatingCharacter = (string) => {\n  let index = 0;\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    count = howManyTimes(string, string[i]);\n    if (count > 1) {\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Given a string, find the index of the last repeating character in the string.\n  Return the index of the last repeating character.\n  >>> lastRepeatingCharacter('abcabcbb')\n  3\n  >>> lastRepeatingCharacter('bbbbb')\n  1\n  >>> lastRepeatingCharacter('aaaaa')\n  1\n  >>> lastRepeatingCharacter('a')\n  1\n  >>> lastRepeatingCharacter('abcdefg')\n  3\n  >>> lastRepeatingCharacter('bb')\n  1\n  >>> lastRepeatingCharacter('a')\n  1\n  >>> lastRepeatingCharacter('a')\n  1\n  */\nconst lastRepeatingCharacter = (string) => {\n  let index = 0;\n  let count = 0;\n  for (let i = string.length - 1; i >= 0; i--) {\n    count = howManyTimes(string, string[i]);\n    if (count > 1) {\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Given a string, find the index of the first non-repeating character in the string.\n  Return the index of the first non-repeating character.\n  >>> firstNonRepeatingCharacter('abcabcbb')\n  2\n  >>> firstNonRepeatingCharacter('bbbbb')\n  1\n  >>> firstNonRepeatingCharacter('aaaaa')\n  1\n  >>> firstNonRepeatingCharacter('a')\n  1\n  >>> firstNonRepeatingCharacter('abcdefg')\n  2\n  >>> firstNonRepeatingCharacter('bb')\n  1\n  >>> firstNonRepeatingCharacter('a')\n  1\n  >>> firstNonRepeatingCharacter('a')\n  1\n  */\nconst firstNonRepeatingCharacter = (string)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/19", "prompt": "/* remark is a space - delimited chain of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers sorted from small to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "/* remark is a space - delimited chain of numberals from' zero' to' nine'. \n   Valid option are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return the string with numbers sorted from small to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArr = numbers.split(' ')\n  const numbersArrSorted = []\n  for (let i = 0; i < numbersArr.length; i++) {\n    const number = parseInt(numbersArr[i])\n    if (number < 10) {\n      numbersArrSorted.push(number)\n    } else {\n      numbersArrSorted.push(numbersArr[i])\n      numbersArrSorted.push(numbersArr[i - 1])\n    }\n  }\n  return numbersArrSorted.join(' ')\n}\n\n/*\n  Given a string containing only digits, return the string with the digits sorted in ascending order.\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  >>> sortDigits('123')\n  '123'\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/2", "prompt": "/* give a positive float degree number, it can be disintegrate into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "/* give a positive float degree number, it can be disintegrate into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber2 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber3 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber4 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber5 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber6 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber7 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber8 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber9 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber10 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber11 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated into \n   and integer contribution (largest integer humble than given number) and decimals \n   (leftover part constantly humble than 1). \n\n   retort the decimal contribution of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber12 = (number) => {\n  let decimal = number % 1;\n  let integer = Math.floor(number);\n  return (decimal === 0)? integer : (integer + 1);\n};\n\n/*\n   given a number, it can be disintegrated", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a issue list of numbers (of length at least two) blue-ribbon and return two that equal the close to each \n   other and return them in order (small number, larger issue).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "/* From a issue list of numbers (of length at least two) blue-ribbon and return two that equal the close to each \n   other and return them in order (small number, larger issue).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sorted = sortBy(numbers);\n  const closest = sorted[0];\n  const secondClosest = sorted[1];\n  return [closest, secondClosest];\n};\n\nexport default findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/21", "prompt": "/* give list of numbers (of at least two chemical element), give a linear transform to that list,\n   such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "/* give list of numbers (of at least two chemical element), give a linear transform to that list,\n   such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit2 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit3 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit4 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit5 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit6 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit7 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit8 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit9 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit10 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit11 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/*\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit12 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter move over list of any python values entirely for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": true, "gc": "/* Filter move over list of any python values entirely for integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter move over list of any python values entirely for string\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter move over list of any python values entirely for boolean\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter move over list of any python values entirely for object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter move over list of any python values entirely for array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter move over list of any python values entirely for null\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNulls = (values) => {\n  return values.filter(v => v!== null);\n};\n\n/**\n  * Filter move over list of any python values entirely for undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterUndefineds = (values) => {\n  return values.filter(v => v!== undefined);\n};\n\n/**\n  * Filter move over list of any python values entirely for function\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter move over list of any python values entirely for object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjectsWithProperties = (values) => {\n  return values.filter(v => typeof v === 'object' && v.hasOwnProperty('properties'));\n};\n\n/**\n  * Filter move over list of any python values entirely for array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArraysWithProperties = (values) => {\n  return values.filter(v => Array.isArray(v) && v.hasOwnProperty('properties'));\n};\n\n/**\n  * Filter move over list of any python values entirely for object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjectsWithPropertiesAndIntegers = (values) => {\n  return values.filter(v => typeof v === 'object' && v.hasOwnProperty('properties') && filterIntegers(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArraysWithPropertiesAndIntegers = (values) => {\n  return values.filter(v => Array.isArray(v) && v.hasOwnProperty('properties') && filterIntegers(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjectsWithPropertiesAndStrings = (values) => {\n  return values.filter(v => typeof v === 'object' && v.hasOwnProperty('properties') && filterStrings(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArraysWithPropertiesAndStrings = (values) => {\n  return values.filter(v => Array.isArray(v) && v.hasOwnProperty('properties') && filterStrings(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjectsWithPropertiesAndBooleans = (values) => {\n  return values.filter(v => typeof v === 'object' && v.hasOwnProperty('properties') && filterBooleans(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArraysWithPropertiesAndBooleans = (values) => {\n  return values.filter(v => Array.isArray(v) && v.hasOwnProperty('properties') && filterBooleans(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjectsWithPropertiesAndObjects = (values) => {\n  return values.filter(v => typeof v === 'object' && v.hasOwnProperty('properties') && filterObjects(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArraysWithPropertiesAndObjects = (values) => {\n  return values.filter(v => Array.isArray(v) && v.hasOwnProperty('properties') && filterObjects(v.properties).length > 0);\n};\n\n/**\n  * Filter move over list of any python values entirely for array\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjectsWithPropertiesAndArrays = (values) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/23", "prompt": "/* reappearance length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "/* reappearance length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '\\n') {\n      len++;\n    }\n  }\n  return len;\n};\n\n/*\n  >>> strlen('abc\\n')\n  4\n  >>> strlen('abc\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>> strlen('abc\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n')\n  4\n  >>>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/24", "prompt": "/* For a give number n, recover the large phone number that separate n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "/* For a give number n, recover the large phone number that separate n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let result = 1;\n  while (n % result!== 0) {\n    result++;\n  }\n  return result;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  >>> largestDivisor(16)\n  2\n  >>> largestDivisor(17)\n  7\n  >>> largestDivisor(18)\n  3\n  >>> largestDivisor(19)\n  5\n  >>> largestDivisor(20)\n  2\n  >>> largestDivisor(21)\n  7\n  >>> largestDivisor(22)\n  3\n  >>> largestDivisor(23)\n  5\n  >>> largestDivisor(24)\n  2\n  >>> largestDivisor(25)\n  7\n  >>> largestDivisor(26)\n  3\n  >>> largestDivisor(27)\n  5\n  >>> largestDivisor(28)\n  2\n  >>> largestDivisor(29)\n  7\n  >>> largestDivisor(30)\n  3\n  >>> largestDivisor(31)\n  5\n  >>> largestDivisor(32)\n  2\n  >>> largestDivisor(33)\n  7\n  >>> largestDivisor(34)\n  3\n  >>> largestDivisor(35)\n  5\n  >>> largestDivisor(36)\n  2\n  >>> largestDivisor(37)\n  7\n  >>> largestDivisor(38)\n  3\n  >>> largestDivisor(39)\n  5\n  >>> largestDivisor(40)\n  2\n  >>> largestDivisor(41)\n  7\n  >>> largestDivisor(42)\n  3\n  >>> largestDivisor(43)\n  5\n  >>> largestDivisor(44)\n  2\n  >>> largestDivisor(45)\n  7\n  >>> largestDivisor(46)\n  3\n  >>> largestDivisor(47)\n  5\n  >>> largestDivisor(48)\n  2\n  >>> largestDivisor(49)\n  7\n  >>> largestDivisor(50)\n  3\n  >>> largestDivisor(51)\n  5\n  >>> largestDivisor(52)\n  2\n  >>> largestDivisor(53)\n  7\n  >>> largestDivisor(54)\n  3\n  >>> largestDivisor(55)\n  5\n  >>> largestDivisor(56)\n  2\n  >>> largestDivisor(57)\n  7\n  >>> largestDivisor(58)\n  3\n  >>> largestDivisor(59)\n  5\n  >>> largestDivisor(60)\n  2\n  >>> largestDivisor(61)\n  7\n  >>> largestDivisor(62)\n  3\n  >>> largestDivisor(63)\n  5\n  >>> largestDivisor(64)\n  2\n  >>> largestDivisor(65)\n  7\n  >>> largestDivisor(66)\n  3\n  >>> largestDivisor(67)\n  5\n  >>> largestDivisor(68)\n  2\n  >>> largestDivisor(69)\n  7\n  >>> largestDivisor(70)\n  3\n  >>> largestDivisor(71)\n  5\n  >>> largestDivisor(72)\n  2\n  >>> largestDivisor(73)\n  7\n  >>> largestDivisor(74)\n  3\n  >>> largestDivisor(75)\n  5\n  >>> largestDivisor(76)\n  2\n  >>> largestDivisor(77)\n  7\n  >>> largestDivisor(78)\n  3\n  >>> largestDivisor(79)\n  5\n  >>> largestDivisor(80)\n  2\n  >>> largestDivisor(81)\n  7\n  >>> largestDivisor(82)\n  3\n  >>> largestDivisor(83)\n  5\n  >>> largestDivisor(84)\n  2\n  >>> largestDivisor(85)\n  7\n  >>> largestDivisor(86)\n  3\n  >>> largestDivisor(87)\n  5\n  >>> largestDivisor(88)\n  2\n  >>> largestDivisor(89)\n  7\n  >>> largestDivisor(90)\n  3\n  >>> largestDivisor(91)\n  5\n  >>> largestDivisor(92)\n  2\n  >>> largestDivisor(93)\n  7\n  >>> largestDivisor(94)\n  3\n  >>> largestDivisor(95)\n  5\n  >>> largestDivisor(96)\n  2\n  >>> largestDivisor(97)\n  7\n  >>> largestDivisor(98)\n  3\n  >>> largestDivisor(99)\n  5\n  >>> largestDivisor(100)\n  2\n  >>> largestDivisor(101)\n  7\n  >>> largestDivisor(102)\n  3\n  >>> largestDivisor(103)\n  5\n  >>> largestDivisor(104)\n  2\n  >>> largestDivisor(105)\n  7\n  >>> largestDivisor(106)\n  3\n  >>> largestDivisor(107)\n  5\n  >>> largestDivisor(108)\n  2\n  >>> largestDivisor(109)\n  7\n  >>> largestDivisor(110)\n  3\n  >>> largestDivisor(111)\n  5\n  >>> largestDivisor(112)\n  2\n  >>> largestDivisor(113)\n  7\n  >>> largestDivisor(114)\n  3\n  >>> largestDivisor(115)\n  5\n  >>> largestDivisor(116)\n  2\n  >>> largestDivisor(117)\n  7\n  >>> largestDivisor(118)\n  3\n  >>> largestDivisor(119)\n  5\n  >>> largestDivisor(120)\n  2\n  >>> largestDivisor(121)\n  7\n  >>> largestDivisor(122)\n  3\n  >>> largestDivisor(123)\n  5\n  >>> largestDivisor(124)\n  2\n  >>> largestDivisor(125)\n  7\n  >>> largestDivisor(126", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/25", "prompt": "/* reappearance list of prime factors of give integer in the decree from smallest to largest. \n   Each of the factors should be list issue of time represent to how many time it appear in factorization. \n   Input numeral should be equal to the merchandise of all divisor\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "/* reappearance list of prime factors of give integer in the decree from smallest to largest. \n   Each of the factors should be list issue of time represent to how many time it appear in factorization. \n   Input numeral should be equal to the merchandise of all divisor\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const divisors = []\n  const divisor = (n) => {\n    const divisor = (n) => {\n      const divisor = (n) => {\n        const divisor = (n) => {\n          const divisor = (n) => {\n            const divisor = (n) => {\n              const divisor = (n) => {\n                const divisor = (n) => {\n                  const divisor = (n) => {\n                    const divisor = (n) => {\n                      const divisor = (n) => {\n                        const divisor = (n) => {\n                          const divisor = (n) => {\n                            const divisor = (n) => {\n                              const divisor = (n) => {\n                                const divisor = (n) => {\n                                  const divisor = (n) => {\n                                    const divisor = (n) => {\n                                      const divisor = (n) => {\n                                        const divisor = (n) => {\n                                          const divisor = (n) => {\n                                            const divisor = (n) => {\n                                              const divisor = (n) => {\n                                                const divisor = (n) => {\n                                                  const divisor = (n) => {\n                                                    const divisor = (n) => {\n                                                      const divisor = (n) => {\n                                                        const divisor = (n) => {\n                                                          const divisor = (n) => {\n                                                           const divisor = (n) => {\n                                                            const divisor = (n) => {\n                                                              const divisor = (n) => {\n                                                              }\n                                                            }\n                                                           }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  const divisor = (n) => {\n    const divisor = (n) => {\n      const divisor = (n) => {\n        const divisor = (n) => {\n          const divisor = (n) => {\n            const divisor = (n) => {\n              const divisor = (n) => {\n                const divisor = (n) => {\n                  const divisor = (n) => {\n                    const divisor = (n) => {\n                      const divisor = (n) => {\n                        const divisor = (n) => {\n                          const divisor = (n) => {\n                            const divisor = (n) => {\n                              const divisor = (n) => {\n                                const divisor = (n) => {\n                                  const divisor = (n) => {\n                                    const divisor = (n) => {\n                                      const divisor = (n) => {\n                                        const divisor = (n) => {\n                                          const divisor = (n) => {\n                                            const divisor = (n) => {\n                                              const divisor = (n) => {\n                                                const divisor = (n) => {\n                                                  const divisor = (n) => {\n                                                    const divisor = (n) => {\n                                                      const divisor = (n) => {\n                                                        const divisor = (n) => {\n                                                          const divisor = (n) => {\n                                                           const divisor = (n) => {\n                                                            const divisor = (n) => {\n                                                              const divisor = (n) => {\n                                                              }\n                                                            }\n                                                           }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  const divisor = (n) => {\n    const divisor = (n) => {\n      const divisor = (n) => {\n        const divisor = (n) => {\n          const divisor = (n) => {\n            const divisor = (n) => {\n              const divisor = (n) => {\n                const divisor = (n) => {\n                  const divisor = (n) => {\n                    const divisor = (n) => {\n                      const divis", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integer, absent all elements that happen more than once. \n   Keep decree of elements left the same as in the stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "/* From a list of integer, absent all elements that happen more than once. \n   Keep decree of elements left the same as in the stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (uniqueNumbers.indexOf(number) === -1) {\n      uniqueNumbers.push(number);\n      uniqueNumbersIndex.push(i);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting2 = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting3 = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting4 = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting5 = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting6 = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting7 = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting8 = (numbers) => {\n  const uniqueNumbers = [];\n  const numbersLength = numbers.length;\n  for (let i = 0; i < numbersLength; i++) {\n    const number = numbers[i];\n    if (numbers.indexOf(number)!== -1) {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integer, remove all elements that are not in the list.\n   Keep the order of the remaining elements.\n  >>> removeNonExisting([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  */\nconst removeNonExisting9 = (numbers", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "/* For a give string, throw small letter character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, (match, lower, upper) => {\n    return lower + upper.toLowerCase();\n  });\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase.\n  >>> lowerCase('Hello')\n  'hello'\n  */\nconst lowerCase = (string) => {\n  return string.toLowerCase();\n};\n\n/*\n  Given a string, return a string with all the characters in uppercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCase = (string) => {\n  return string.toUpperCase();\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCase = (string) => {\n  return upperCase(string) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCaseAndLowerCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + flipCase(lowerCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCase('Hello')\n  'HELLO'\n  */\nconst upperCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCaseAndLowerCaseAndFlipCase = (string) => {\n  return upperCase(string) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + flipCase(lowerCase(string)) + lowerCase(string);\n};\n\n/*\n  Given a string, return a string with all the characters in lowercase and uppercase.\n  >>> upperCase", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a individual string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": true, "gc": "/* Concatenate list of strings into a individual string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3, 4])\n  '1234'\n  >>> concatenate([1, 2, 3, 4, 5])\n  '12345'\n  >>> concatenate([1, 2, 3, 4, 5, 6])\n  '123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7])\n  '1234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8])\n  '12345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  '123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  '1234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  '12345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  '123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  '1234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  '12345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  '123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  '1234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  '12345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  '123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  '1234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  '12345678901234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  '123456789012345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  '1234567890123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  '12345678901234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  '123456789012345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  '1234567890123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  '12345678901234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  '123456789012345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  '1234567890123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  '12345678901234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  '123456789012345678901234567890'\n  >>> concatenate([1, 2", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an remark list of strings only for ones that begin with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "/* Filter an remark list of strings only for ones that begin with a give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut(['a', 'b', 'c'], ['a', 'b', 'c'])\n  []\n  >>> filterOut(['a', 'b', 'c'], ['a', 'b', 'c', 'd'])\n  ['c']\n  >>> filterOut(['a', 'b', 'c'], ['a', 'b', 'c', 'd', 'e'])\n  ['c', 'd', 'e']\n  */\nconst filterOut = (strings, excluded) => {\n  return strings.filter(s => excluded.indexOf(s) === -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'a')\n  []\n  >>> filterOutByPrefix(['a', 'b', 'c'], 'd')\n  ['a', 'b',", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/3", "prompt": "/* You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account fallls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "/* You're give a list of deposit and withdrawal operations on a depository financial institution score that starts with \n   zero balance. Your undertaking is to detect if at any point the balance of account fallls below zero, and \n   at that point function should return dependable. differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/*\n  Given a list of deposit and withdrawal operations on a depository financial institution score that starts with \n  zero balance, return the maximum number of deposits and withdrawals that can be made without exceeding the \n  depository's balance.\n  >>> max(belowZero([1, 2, 3]), belowZero([1, 2, -4, 5]), belowZero([1, 2, -4, 5, 6]), belowZero([1, 2, -4, 5, 6, 7]), belowZero([1, 2, -4, 5, 6, 7, 8]), belowZero([1, 2, -4, 5, 6, 7, 8, 9]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34]), belowZero([1, 2, -4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]), belowZero([1, 2, -4, 5, 6", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return merely positive number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": true, "gc": "/*Return merely positive number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/31", "prompt": "/*Return genuine if a given issue be prime, and assumed otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "/*Return genuine if a given issue be prime, and assumed otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  if (n < 2) return false\n  if (n % 3 === 0) return false\n  if (n < 9) return true\n  if (n % 7 === 0) return false\n  if (n < 19) return true\n  if (n % 11 === 0) return false\n  if (n < 37) return true\n  if (n % 13 === 0) return false\n  if (n < 61) return true\n  if (n % 17 === 0) return false\n  if (n < 67) return true\n  if (n % 19 === 0) return false\n  if (n < 137) return true\n  if (n % 23 === 0) return false\n  if (n < 251) return true\n  if (n % 29 === 0) return false\n  if (n < 367) return true\n  if (n % 31 === 0) return false\n  if (n < 701) return true\n  if (n % 37 === 0) return false\n  if (n < 1009) return true\n  if (n % 41 === 0) return false\n  if (n < 1621) return true\n  if (n % 43 === 0) return false\n  if (n < 2233) return true\n  if (n % 47 === 0) return false\n  if (n < 24251) return true\n  if (n % 251 === 0) return false\n  if (n < 27647) return true\n  if (n % 257 === 0) return false\n  if (n < 3277) return true\n  if (n % 263 === 0) return false\n  if (n < 4561) return true\n  if (n % 269 === 0) return false\n  if (n < 5461) return true\n  if (n % 271 === 0) return false\n  if (n < 7001) return true\n  if (n % 709 === 0) return false\n  if (n < 8121) return true\n  if (n % 719 === 0) return false\n  if (n < 8251) return true\n  if (n % 733 === 0) return false\n  if (n < 8457) return true\n  if (n % 751 === 0) return false\n  if (n < 8561) return true\n  if (n % 767 === 0) return false\n  if (n < 8761) return true\n  if (n % 787 === 0) return false\n  if (n < 9001) return true\n  if (n % 809 === 0) return false\n  if (n < 9091) return true\n  if (n % 8191 === 0) return false\n  if (n < 9209) return true\n  if (n % 8309 === 0) return false\n  if (n < 8351) return true\n  if (n % 8509 === 0) return false\n  if (n < 8561) return true\n  if (n % 8789 === 0) return false\n  if (n < 9001) return true\n  if (n % 9001 === 0) return false\n  if (n < 9001) return true\n  return false\n}\n\n/*Return true if a given number is a perfect number, and false otherwise.\n  >>> isPerfect(1)\n  false\n  >>> isPerfect(2)\n  false\n  >>> isPerfect(3)\n  false\n  >>> isPerfect(4)\n  true\n  >>> isPerfect(5)\n  false\n  >>> isPerfect(6)\n  false\n  >>> isPerfect(7)\n  false\n  >>> isPerfect(8)\n  false\n  >>> isPerfect(9)\n  false\n  >>> isPerfect(10)\n  false\n  >>> isPerfect(11)\n  false\n  >>> isPerfect(12)\n  false\n  >>> isPerfect(13)\n  false\n  >>> isPerfect(14)\n  false\n  >>> isPerfect(15)\n  false\n  >>> isPerfect(16)\n  false\n  >>> isPerfect(17)\n  false\n  >>> isPerfect(18)\n  false\n  >>> isPerfect(19)\n  false\n  >>> isPerfect(20)\n  false\n  >>> isPerfect(21)\n  false\n  >>> isPerfect(22)\n  false\n  >>> isPerfect(23)\n  false\n  >>> isPerfect(24)\n  false\n  >>> isPerfect(25)\n  false\n  >>> isPerfect(26)\n  false\n  >>> isPerfect(27)\n  false\n  >>> isPerfect(28)\n  false\n  >>> isPerfect(29)\n  false\n  >>> isPerfect(30)\n  false\n  >>> isPerfect(31)\n  false\n  >>> isPerfect(32)\n  false\n  >>> isPerfect(33)\n  false\n  >>> isPerfect(34)\n  false\n  >>> isPerfect(35)\n  false\n  >>> isPerfect(36)\n  false\n  >>> isPerfect(37)\n  false\n  >>> isPerfect(38)\n  false\n  >>> isPerfect(39)\n  false\n  >>> isPerfect(40)\n  false\n  >>> isPerfect(41)\n  false\n  >>> isPerfect(42)\n  false\n  >>> isPerfect(43)\n  false\n  >>> isPerfect(44)\n  false\n  >>> isPerfect(45)\n  false\n  >>> isPerfect(46)\n  false\n  >>> isPerfect(47)\n  false\n  >>> isPerfect(48)\n  false\n  >>> isPerfect(49)\n  false\n  >>> isPerfect(50)\n  false\n  >>> isPerfect(51)\n  false\n  >>> isPerfect(52)\n  false\n  >>> isPerfect(53)\n  false\n  >>> isPerfect(54)\n  false\n  >>> isPerfect(55)\n  false\n  >>> isPerfect(56)\n  false\n  >>> isPerfect(57)\n  false\n  >>> isPerfect(58)\n  false\n  >>> isPerfect(59)\n  false\n  >>> isPerfect(60)\n  false\n  >>> isPerfect(61)\n  ", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at detail x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficient of a polynomial. \n   findZero discover x such that poly(x) = 0. \n   findZero returns merely only zero point, even if there are many. \n   furthermore, findZero entirely subscribe list xs receive even issue of coefficient \n   and big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients xs at detail x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficient of a polynomial. \n   findZero discover x such that poly(x) = 0. \n   findZero returns merely only zero point, even if there are many. \n   furthermore, findZero entirely subscribe list xs receive even issue of coefficient \n   and big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const poly = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyZero = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyOne = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyTwo = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyThree = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyFour = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyFive = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polySix = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polySeven = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyEight = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyNine = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyTen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyEleven = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyTwelve = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyThirteen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyFourteen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyFifteen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polySixteen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polySeventeen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyEighteen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyNineteen = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  };\n  const polyTwenty = (xs, x) = > {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(x, index);\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n   to the value of the corresponding indicies of l, but screen.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its value at the indicies that are divisible by three are equal \n   to the value of the corresponding indicies of l, but screen.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const sorted = [...l].sort((a, b) => a % 3 - b % 3);\n  const sorted2 = [...l].sort((a, b) => a % 3 + b % 3);\n  return [...sorted,...sorted2];\n};\n\n/*\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return screen unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": true, "gc": "/*Return screen unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.add(x));\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.add(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique2 = (l) => {\n  const seen = new Set();\n  return l.filter(x =>!seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique3 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique4 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique5 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique6 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique7 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique8 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique9 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique10 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique11 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x)).length;\n};\n\n/*Return the number of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  4\n  */\nconst countUnique12 = (l) => {\n  const seen = new Set();\n  return l.filter(x => seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(x) && seen.has(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/35", "prompt": "/*Return maximal element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": true, "gc": "/*Return maximal element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the numeral of times the finger 7 appear in integers less than n which cost divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "/*Return the numeral of times the finger 7 appear in integers less than n which cost divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let fizz = 0, buzz = 0, fizzbuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      fizzbuzz++;\n      fizz++;\n    } else if (i % 3 === 0) {\n      buzz++;\n    } else if (i % 5 === 0) {\n      fizz++;\n    }\n  }\n  return fizzbuzz + fizz + buzz;\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = l.filter((x) => x % 2 === 0)\n  const odd = l.filter((x) => x % 2!== 0)\n  const sorted = even.sort((a, b) => a - b)\n  const sortedOdd = odd.sort((a, b) => a - b)\n  return sorted.concat(sortedOdd)\n}\n\n/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the odd indicies are equal \n   to the value of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  */\nconst sortOdd = (l) => {\n  const even = l.filter((x) => x % 2!== 0)\n  const odd = l.filter((x) => x % 2 === 0)\n  const sorted = odd.sort((a, b) => a - b)\n  const sortedEven = even.sort((a, b) => a - b)\n  return sorted.concat(sortedEven)\n}\n\n/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, and the value at the odd indicies are equal to the value \n   of the odd indicies of l.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  */\nconst sort = (l) => {\n  const even = l.filter((x) => x % 2 === 0)\n  const odd = l.filter((x) => x % 2!== 0)\n  const sorted = even.sort((a, b) => a - b)\n  const sortedOdd = odd.sort((a, b) => a - b)\n  return sorted.concat(sortedOdd)\n}\n\n/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, and the value at the odd indicies are equal to the value \n   of the odd indicies of l.\n  >>> sort([1, 2, 3])\n  [1, 2, 3]\n  >>> sort([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  >>> sort([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  */\nconst sort2 = (l) => {\n  const even = l.filter((x) => x % 2 === 0)\n  const odd = l.filter((x) => x % 2!== 0)\n  const sorted = even.sort((a, b) => a - b)\n  const sortedOdd = odd.sort((a, b) => a - b)\n  return sorted.concat(sortedOdd)\n}\n\n/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, and the value at the odd indicies are equal to the value \n   of the odd indicies of l.\n  >>> sort([1, 2, 3])\n  [1, 2, 3]\n  >>> sort([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  >>> sort([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  */\nconst sort3 = (l) => {\n  const even = l.filter((x) => x % 2 === 0)\n  const odd = l.filter((x) => x % 2!== 0)\n  const sorted = even.sort((a, b) => a - b)\n  const sortedOdd = odd.sort((a, b) => a - b)\n  return sorted.concat(sortedOdd)\n}\n\n/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, and the value at the odd indicies are equal to the value \n   of the odd indicies of l.\n  >>> sort([1, 2, 3])\n  [1, 2, 3]\n  >>> sort([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  >>> sort([5, 6, 3, 4])\n  [3, 4, 5, 6]\n  */\nconst sort4 = (l) => {\n  const even = l.filter((x) => x % 2 === 0)\n  const odd = l.filter((x) => x % 2!== 0)\n  const sorted = even.sort((a, b) => a - b)\n  const sortedOdd = odd.sort((a, b) => a - b)\n  return sorted.concat(sortedOdd)\n}\n\n/*This routine takes a list l and returns a list l' such that \n   l' is identical to l in the leftover indicies, while its value at the even indicies are equal \n   to the value of the even indicies of l, and the value at the odd indicies are equal to the value \n   of the odd indicies of l.\n  >>> sort([1, 2, 3])\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  return key encoded bowed stringed instrument by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   drive as remark drawstring encoded with encode_cyclic routine. tax return decode string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "/*\n  return key encoded bowed stringed instrument by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   drive as remark drawstring encoded with encode_cyclic routine. tax return decode string. \n   * / \n const decodeCyclic = (s) = > {\n   let groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n  return key encoded stringed instrument by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   drive as remark drawstring encoded with encode_cyclic routine. tax return decode string. \n   * / \n const decodeCyclic = (s) = > {\n   let groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n  return key encoded stringed instrument by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   drive as remark drawstring encoded with encode_cyclic routine. tax return decode string. \n   * / \n const decodeCyclic = (s) = > {\n   let groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n  return key encoded stringed instrument by cycle groups of three character. \n   * / \n const encodeCyclic = (s) = > { \n   volt-ampere groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   drive as remark drawstring encoded with encode_cyclic routine. tax return decode string. \n   * / \n const decodeCyclic = (s) = > {\n   let groups = [ ], groups2 = [ ]; \n   for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": true, "gc": "/*\n  primeFib return n-th number that is a Fibonacci issue and it's besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let fib = 1;\n  let prime = 2;\n  while (prime < n) {\n    fib = fib + prime;\n    if (isPrime(fib)) {\n      return fib;\n    }\n    prime = prime + 2;\n  }\n  return fib;\n};\n\nexport default primeFib;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a give list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the median absolute deviation between each \n   element and a centerpoint (mean in this font ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "/* For a give list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the median absolute deviation between each \n   element and a centerpoint (mean in this font ): \n   MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation2 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation3 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation4 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation5 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation6 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation7 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation8 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation9 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation10 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation11 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation12 = (numbers) => {\n  const mean = mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.round(mean + Math.sqrt(deviations.reduce((sum, deviation) => sum + deviation, 0) / numbers.length));\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation13 = (numbers) => {\n  const mean = mean", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const sum = l.reduce((a, b) => a + b, 0);\n    return sum === 0 && l.length > 2;\n};\n\n/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const sum = l.reduce((a, b) => a + b, 0);\n    return sum === 0 && l.length > 2;\n};\n\n/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const sum = l.reduce((a, b) => a + b, 0);\n    return sum === 0 && l.length > 2;\n};\n\n/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const sum = l.reduce((a, b) => a + b, 0);\n    return sum === 0 && l.length > 2;\n};\n\n/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const sum = l.reduce((a, b) => a + b, 0);\n    return sum === 0 && l.length > 2;\n};\n\n/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const sum = l.reduce((a, b) => a + b, 0);\n    return sum === 0 && l.length > 2;\n};\n\n/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const sum = l.reduce((a, b) => a + b, 0);\n    return sum === 0 && l.length > 2;\n};\n\n/*\n  triplesSumToZero take a list of integers as an input signal. \n   it render dependable if there be three distinct elements in the list that \n   sum to zero, and assumed differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tri", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/41", "prompt": "/*\n  think a road that's a absolutely square boundlessly long credit line. \n   n cars are driving left to justly;   simultaneously, a different set of n car \n   are drive correct to leave.    The two set of car start out being very far from \n   each early.   All cars move in the same speed.   Two cars are say to collide \n   when a car that's moving entrust to proper strike a car that's moving right to leave. \n   However, the cars are boundlessly sturdy and hard; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This affair output the issue of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "/*\n  think a road that's a absolutely square boundlessly long credit line. \n   n cars are driving left to justly;   simultaneously, a different set of n car \n   are drive correct to leave.    The two set of car start out being very far from \n   each early.   All cars move in the same speed.   Two cars are say to collide \n   when a car that's moving entrust to proper strike a car that's moving right to leave. \n   However, the cars are boundlessly sturdy and hard; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This affair output the issue of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / \n   * / ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/42", "prompt": "/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": true, "gc": "/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*Return list with element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  let i = l.length - 1;\n  let res = [];\n  while (i >= 0) {\n    res.push(l[i]);\n    i--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*Return list with element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  let i = l.length - 1;\n  let res = [];\n  while (i >= 0) {\n    res.push(l[i]);\n    i--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*Return list with element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  let i = l.length - 1;\n  let res = [];\n  while (i >= 0) {\n    res.push(l[i]);\n    i--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*Return list with element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  let i = l.length - 1;\n  let res = [];\n  while (i >= 0) {\n    res.push(l[i]);\n    i--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*Return list with element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  let i = l.length - 1;\n  let res = [];\n  while (i >= 0) {\n    res.push(l[i]);\n    i--;\n  }\n  return res;\n};\n\n/*Return list with element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i]\n    if (sum === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero2 = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i]\n    if (sum === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero3 = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i]\n    if (sum === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero4 = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i]\n    if (sum === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero5 = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i]\n    if (sum === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero6 = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i]\n    if (sum === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  pairsSumToZero take a list of integers as an input signal. \n   it render dependable if there be two distinct elements in the list that \n   sum to zero, and assumed differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero7 = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i]\n    if (sum === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  pairsSumToZero take a list", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/44", "prompt": "/*Change numeric base of input issue x to base.\n   return drawstring theatrical performance after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "/*Change numeric base of input issue x to base.\n   return drawstring theatrical performance after the conversion. \n   base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase3 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase4 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase5 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase6 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase7 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase8 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase9 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase10 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase11 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase12 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase13 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase14 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase15 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase16 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase17 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase18 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase19 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.toString(base);\n  return result;\n};\n\nconst changeBase20 = (x, base) => {\n  const num = x.toString(base);\n  const rem = x % base;\n  const result = num.slice(0, -rem.toString(base).length) + rem.", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given duration of a side and gamey return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*Given duration of a side and gamey return sphere for a triangulum.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*\n  Given a triangle and a side return the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function to efficiently compute the n-th chemical element of the fib4 number succession.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "/*The Fib4 phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function to efficiently compute the n-th chemical element of the fib4 number succession.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nconsole.log(fib4(5));\nconsole.log(fib4(6));\nconsole.log(fib4(7));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/47", "prompt": "/*Return median of element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": true, "gc": "/*Return median of element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const len = l.length;\n  if (len === 0) {\n    return undefined;\n  }\n  const half = len / 2;\n  const left = l.slice(0, half);\n  const right = l.slice(half);\n  const leftLen = left.length;\n  const rightLen = right.length;\n  if (leftLen === 0) {\n    return right[0];\n  }\n  if (rightLen === 0) {\n    return left[leftLen - 1];\n  }\n  const leftMedian = median(left);\n  const rightMedian = median(right);\n  if (leftMedian === rightMedian) {\n    return leftMedian;\n  }\n  return (leftMedian + rightMedian) / 2;\n};\n\nexport default median;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  check if given bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  check if given bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome15 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  check if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome16 = (text", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": true, "gc": "/*Return 2^n modulo p (be mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp11 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp12 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp13 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp14 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp15 = (n, p) => {\n  return (n % p + p) % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a phone number 'delimeter' between every two consecutive elements of stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": true, "gc": "/* Insert a phone number 'delimeter' between every two consecutive elements of stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const len = numbers.length\n  if (len < 2) return numbers\n  const result = []\n  for (let i = 0; i < len - 1; i++) {\n    result.push(numbers[i])\n    result.push(delimeter)\n  }\n  result.push(numbers[len - 1])\n  return result\n}\n\n/*\n  >>> intersperse([1, 2, 3], 'x')\n  [1, 2, 3, 'x', 'x', 'x']\n  >>> intersperse([1, 2, 3], 'x', 2)\n  [1, 2, 3, 'x', 'x', 'x', 'x', 'x']\n  */\nconst intersperse2 = (numbers, delimeter, times) => {\n  const len = numbers.length\n  if (len < 2) return numbers\n  const result = []\n  for (let i = 0; i < len - 1; i++) {\n    result.push(numbers[i])\n    result.push(delimeter)\n  }\n  result.push(numbers[len - 1])\n  for (let i = 0; i < times; i++) {\n    result.push(delimeter)\n  }\n  return result\n}\n\n/*\n  >>> intersperse3([1, 2, 3], 'x')\n  [1, 2, 3, 'x', 'x', 'x']\n  >>> intersperse3([1, 2, 3], 'x', 2)\n  [1, 2, 3, 'x', 'x', 'x', 'x', 'x']\n  */\nconst intersperse3 = (numbers, delimeter, times) => {\n  const len = numbers.length\n  if (len < 2) return numbers\n  const result = []\n  for (let i = 0; i < len - 1; i++) {\n    result.push(numbers[i])\n    result.push(delimeter)\n  }\n  result.push(numbers[len - 1])\n  for (let i = 0; i < times; i++) {\n    result.push(delimeter)\n  }\n  return result\n}\n\n/*\n  >>> intersperse4([1, 2, 3], 'x')\n  [1, 2, 3, 'x', 'x', 'x']\n  >>> intersperse4([1, 2, 3], 'x', 2)\n  [1, 2, 3, 'x', 'x', 'x', 'x', 'x']\n  */\nconst intersperse4 = (numbers, delimeter, times) => {\n  const len = numbers.length\n  if (len < 2) return numbers\n  const result = []\n  for (let i = 0; i < len - 1; i++) {\n    result.push(numbers[i])\n    result.push(delimeter)\n  }\n  result.push(numbers[len - 1])\n  for (let i = 0; i < times; i++) {\n    result.push(delimeter)\n  }\n  return result\n}\n\n/*\n  >>> intersperse5([1, 2, 3], 'x')\n  [1, 2, 3, 'x', 'x', 'x']\n  >>> intersperse5([1, 2, 3], 'x', 2)\n  [1, 2, 3, 'x', 'x', 'x', 'x', 'x']\n  */\nconst intersperse5 = (numbers, delimeter, times) => {\n  const len = numbers.length\n  if (len < 2) return numbers\n  const result = []\n  for (let i = 0; i < len - 1; i++) {\n    result.push(numbers[i])\n    result.push(delimeter)\n  }\n  result.push(numbers[len - 1])\n  for (let i = 0; i < times; i++) {\n    result.push(delimeter)\n  }\n  return result\n}\n\n/*\n  >>> intersperse6([1, 2, 3], 'x')\n  [1, 2, 3, 'x', 'x', 'x']\n  >>> intersperse6([1, 2, 3], 'x', 2)\n  [1, 2, 3, 'x', 'x', 'x', 'x', 'x']\n  */\nconst intersperse6 = (numbers, delimeter, times) => {\n  const len = numbers.length\n  if (len < 2) return numbers\n  const result = []\n  for (let i = 0; i < len - 1; i++) {\n    result.push(numbers[i])\n    result.push(delimeter)\n  }\n  result.push(numbers[len - 1])\n  for (let i = 0; i < times; i++) {\n    result.push(delimeter)\n  }\n  return result\n}\n\n/*\n  >>> intersperse7([1, 2, 3], 'x')\n  [1, 2, 3, 'x', 'x', 'x']\n  >>> intersperse7([1, 2, 3], 'x', 2)\n  [1, 2, 3, 'x', 'x', 'x', 'x', 'x']\n  */\nconst intersperse7 = (numbers, delimeter, times) => {\n  const len = numbers.length\n  if (len < 2) return numbers\n  const result = []\n  for (let i = 0; i < len - 1; i++) {\n    result.push(numbers[i])\n    result.push(delimeter)\n  }\n  result.push(numbers[len - 1])\n  for (let i = 0; i < times; i++) {\n    result.push(delimeter)\n  }\n  return result\n}\n\n/*\n  >>> intersperse8([1, 2, 3], 'x')\n  [1, 2, 3, 'x', 'x', 'x']\n  >>> intersperse8([1, 2, 3], 'x', 2)\n  [1, 2, 3, 'x', 'x', 'x', 'x', 'x']\n  */\nconst intersperse8", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "/*\n  return key encoded bowed stringed instrument by shift every quality by 5 in the rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   drive as remark drawstring encoded with encode_shift routine. return decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join(\"\"); \n } \n\n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. \n   * / \n const decode = (s) = > decodeShift(s); \n \n / * \n   return encoded string. \n   * / \n const encode = (s) = > encodeShift(s); \n \n / * \n   return decoded string. ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels3 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels4 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels5 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels6 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels7 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.replace(/[aeiouAEIOU]/g, '')\n  return result\n}\n\n/*\n  removeVowels is a routine that takes string and rejoinder drawstring without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghj", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return genuine if all numbers in the list l are below brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": true, "gc": "/*Return genuine if all numbers in the list l are below brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] > t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are above brink t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between brink t and s.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 20)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10)\n  false\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4)\n  false\n  */\nconst betweenThreshold = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between t and s.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 20, 10)\n  false\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, 20)\n  true\n  */\nconst betweenThreshold2 = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between t and s.\n  >>> betweenThreshold2([1, 2, 4, 10], 5, 20, 10)\n  true\n  >>> betweenThreshold2([1, 2, 4, 10], 5, 10, 20)\n  true\n  >>> betweenThreshold2([1, 2, 4, 10], 5, 10, 20, 30)\n  false\n  */\nconst betweenThreshold3 = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between t and s.\n  >>> betweenThreshold3([1, 2, 4, 10], 5, 20, 10, 30)\n  false\n  >>> betweenThreshold3([1, 2, 4, 10], 5, 10, 20, 30)\n  true\n  */\nconst betweenThreshold4 = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between t and s.\n  >>> betweenThreshold4([1, 2, 4, 10], 5, 20, 10, 30, 40)\n  false\n  >>> betweenThreshold4([1, 2, 4, 10], 5, 10, 20, 30, 40)\n  true\n  */\nconst betweenThreshold5 = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between t and s.\n  >>> betweenThreshold5([1, 2, 4, 10], 5, 20, 10, 30, 40, 50)\n  false\n  >>> betweenThreshold5([1, 2, 4, 10], 5, 10, 20, 30, 40, 50)\n  true\n  */\nconst betweenThreshold6 = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between t and s.\n  >>> betweenThreshold6([1, 2, 4, 10], 5, 20, 10, 30, 40, 50, 60)\n  false\n  >>> betweenThreshold6([1, 2, 4, 10], 5, 10, 20, 30, 40, 50, 60)\n  true\n  */\nconst betweenThreshold7 = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Return true if all numbers in the list l are between t and s.\n  >>> betweenThreshold7([1, 2, 4, 10], 5, 20, 10, 30, 40, 50, 60, 70)\n  false\n  >>> betweenThreshold7([1, 2, 4, 10], 5, 10, 20, 30, 40, 50, 60, 70)\n  true\n  */\nconst betweenThreshold8 = (l, t, s) => {\n  const len = l.length;\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t || l[i] > s) {\n      return false;\n    ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Add two issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add2 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add3 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add4 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add5 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add6 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add7 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add8 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add9 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add10 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add11 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add12 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add13 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add14 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add15 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add16 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add17 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add18 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add19 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add20 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add21 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add22 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add23 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add24 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add25 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add26 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add27 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add28 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add29 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add30 = (x, y) => {\n  return x + y;\n};\n\n/*", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  crack if two words have the like quality.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "/*\n  crack if two words have the like quality.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len0 = s0.length\n  const len1 = s1.length\n  if (len0!== len1) {\n    return false\n  }\n  for (let i = 0; i < len0; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport default {\n  sameChars\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": true, "gc": "/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a drawstring of \" < \" and \" > \". \n   return false if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a drawstring of \" < \" and \" > \". \n   return false if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  let bracketsIndex = 0\n  let bracketsOpen = 0\n  let bracketsClose = 0\n  let bracketsOpenIndex = 0\n  let bracketsCloseIndex = 0\n  let bracketsOpenFound = false\n  let bracketsCloseFound = false\n  let bracketsOpenFoundIndex = 0\n  let bracketsCloseFoundIndex = 0\n  let bracketsOpenFoundIndex2 = 0\n  let bracketsCloseFoundIndex2 = 0\n  let bracketsOpenFoundIndex3 = 0\n  let bracketsCloseFoundIndex3 = 0\n  let bracketsOpenFoundIndex4 = 0\n  let bracketsCloseFoundIndex4 = 0\n  let bracketsOpenFoundIndex5 = 0\n  let bracketsCloseFoundIndex5 = 0\n  let bracketsOpenFoundIndex6 = 0\n  let bracketsCloseFoundIndex6 = 0\n  let bracketsOpenFoundIndex7 = 0\n  let bracketsCloseFoundIndex7 = 0\n  let bracketsOpenFoundIndex8 = 0\n  let bracketsCloseFoundIndex8 = 0\n  let bracketsOpenFoundIndex9 = 0\n  let bracketsCloseFoundIndex9 = 0\n  let bracketsOpenFoundIndex10 = 0\n  let bracketsCloseFoundIndex10 = 0\n  let bracketsOpenFoundIndex11 = 0\n  let bracketsCloseFoundIndex11 = 0\n  let bracketsOpenFoundIndex12 = 0\n  let bracketsCloseFoundIndex12 = 0\n  let bracketsOpenFoundIndex13 = 0\n  let bracketsCloseFoundIndex13 = 0\n  let bracketsOpenFoundIndex14 = 0\n  let bracketsCloseFoundIndex14 = 0\n  let bracketsOpenFoundIndex15 = 0\n  let bracketsCloseFoundIndex15 = 0\n  let bracketsOpenFoundIndex16 = 0\n  let bracketsCloseFoundIndex16 = 0\n  let bracketsOpenFoundIndex17 = 0\n  let bracketsCloseFoundIndex17 = 0\n  let bracketsOpenFoundIndex18 = 0\n  let bracketsCloseFoundIndex18 = 0\n  let bracketsOpenFoundIndex19 = 0\n  let bracketsCloseFoundIndex19 = 0\n  let bracketsOpenFoundIndex20 = 0\n  let bracketsCloseFoundIndex20 = 0\n  let bracketsOpenFoundIndex21 = 0\n  let bracketsCloseFoundIndex21 = 0\n  let bracketsOpenFoundIndex22 = 0\n  let bracketsCloseFoundIndex22 = 0\n  let bracketsOpenFoundIndex23 = 0\n  let bracketsCloseFoundIndex23 = 0\n  let bracketsOpenFoundIndex24 = 0\n  let bracketsCloseFoundIndex24 = 0\n  let bracketsOpenFoundIndex25 = 0\n  let bracketsCloseFoundIndex25 = 0\n  let bracketsOpenFoundIndex26 = 0\n  let bracketsCloseFoundIndex26 = 0\n  let bracketsOpenFoundIndex27 = 0\n  let bracketsCloseFoundIndex27 = 0\n  let bracketsOpenFoundIndex28 = 0\n  let bracketsCloseFoundIndex28 = 0\n  let bracketsOpenFoundIndex29 = 0\n  let bracketsCloseFoundIndex29 = 0\n  let bracketsOpenFoundIndex30 = 0\n  let bracketsCloseFoundIndex30 = 0\n  let bracketsOpenFoundIndex31 = 0\n  let bracketsCloseFoundIndex31 = 0\n  let bracketsOpenFoundIndex32 = 0\n  let bracketsCloseFoundIndex32 = 0\n  let bracketsOpenFoundIndex33 = 0\n  let bracketsCloseFoundIndex33 = 0\n  let bracketsOpenFoundIndex34 = 0\n  let bracketsCloseFoundIndex34 = 0\n  let bracketsOpenFoundIndex35 = 0\n  let bracketsCloseFoundIndex35 = 0\n  let bracketsOpenFoundIndex36 = 0\n  let bracketsCloseFoundIndex36 = 0\n  let bracketsOpenFoundIndex37 = 0\n  let bracketsCloseFoundIndex37 = 0\n  let bracketsOpenFoundIndex38 = 0\n  let bracketsCloseFoundIndex38 = 0\n  let bracketsOpenFoundIndex39 = 0\n  let bracketsCloseFoundIndex39 = 0\n  let bracketsOpenFoundIndex40 = 0\n  let bracketsCloseFoundIndex40 = 0\n  let bracketsOpenFoundIndex41 = 0\n  let bracketsCloseFoundIndex41 = 0\n  let bracketsOpenFoundIndex42 = 0\n  let bracketsCloseFoundIndex42 = 0\n  let bracketsOpenFoundIndex43 = 0\n  let bracketsCloseFoundIndex43 = 0\n  let bracketsOpenFoundIndex44 = 0\n  let bracketsCloseFoundIndex44 = 0\n  let bracketsOpenFoundIndex45 = 0\n  let bracketsCloseFoundIndex45 = 0\n  let bracketsOpenFoundIndex46 = 0\n  let bracketsCloseFoundIndex46 = 0\n  let bracketsOpenFoundIndex47 = 0\n  let bracketsCloseFoundIndex47 = 0\n  let bracketsOpenFoundIndex48 = 0\n  let bracketsCloseFoundIndex48 = 0\n  let bracketsOpenFoundIndex49 = 0\n  let bracketsCloseFoundIndex49 = 0\n  let bracketsOpenFoundIndex50 = 0\n  let bracketsCloseFoundIndex50 = 0\n  let bracketsOpenFoundIndex51 = 0\n  let bracketsCloseFoundIndex51 = 0\n  let bracketsOpenFoundIndex52 = 0\n  let bracketsCloseFoundIndex52 = 0\n  let bracketsOpenFoundIndex53 = 0\n  let bracketsCloseFoundIndex53 = 0\n  let bracketsOpenFoundIndex54 = 0\n  let bracketsCloseFoundIndex54 = 0\n  let bracketsOpenFoundIndex55 = 0\n  let bracketsCloseFoundIndex55 = 0\n  let bracketsOpenFoundIndex56 = 0\n  let bracketsCloseFoundIndex56 = 0\n  let bracketsOpenFoundIndex57 = 0\n  let bracketsCloseFoundIndex57 = 0\n  let bracketsOpenFoundIndex58 = 0\n  let bracketsCloseFoundIndex58 = 0\n  let bracketsOpenFoundIndex59 = 0\n  let bracketsCloseFoundIndex59 = 0\n  let bracketsOpenFoundIndex60 = 0\n  let bracketsCloseFoundIndex60 = 0\n  let bracketsOpenFoundIndex61 = 0\n  let bracketsCloseFoundIndex61 = 0\n  let bracketsOpenFoundIndex62 = 0\n  let bracketsCloseFoundIndex62 = 0\n  let bracketsOpenFoundIndex63 = 0\n  let bracketsCloseFoundIndex63 = 0\n  let bracketsOpenFoundIndex64 = 0\n  let bracketsCloseFoundIndex64 = 0\n  let bracketsOpenFoundIndex65 = 0\n  let bracketsCloseFoundIndex65 = 0\n  let bracketsOpenFoundIndex66 = 0\n  let bracketsCloseFoundIndex66 = 0\n  let bracketsOpenFoundIndex67 = 0\n  let bracketsCloseFoundIndex67 = 0\n  let bracketsOpenFoundIndex68 = 0\n  let bracketsCloseFoundIndex68 = 0\n  let bracketsOpenFoundIndex69 = 0\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return genuine is list elements are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "/*Return genuine is list elements are monotonically increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic3 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic4 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic5 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic6 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic7 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic8 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    i++\n    j--\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/58", "prompt": "/*Return screen unique common chemical element for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "/*Return screen unique common chemical element for two tilt.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_set = new Set(l1);\n  const l2_set = new Set(l2);\n  const intersection = new Set(l1_set.intersection(l2_set));\n  const union = new Set(l1_set.union(l2_set));\n  const common_set = new Set(union.intersection(intersection));\n  return Array.from(common_set);\n};\n\nmodule.exports = common;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest premier factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": true, "gc": "/*Return the largest premier factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor8 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor9 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor10 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor11 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor12 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor13 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor14 = (n) => {\n  const primeFactors = primeFactors(n);\n  const largestPrimeFactor = primeFactors.reduce((a, b) => a * b);\n  return largestPrimeFactor;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and be not a flower.\n  >>> largestPrime", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/6", "prompt": "/* remark to this function is a string defend multiple group for nested parenthesis separated by spaces. \n   For each of the group, output the deep grade of nesting of parentheses. \n   E.g. (() ()) has maximal two levels of nest while (( ()) ) receive three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "/* remark to this function is a string defend multiple group for nested parenthesis separated by spaces. \n   For each of the group, output the deep grade of nesting of parentheses. \n   E.g. (() ()) has maximal two levels of nest while (( ()) ) receive three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let stack = []\n  let level = 0\n  let result = []\n  let current_level = 0\n  let current_level_depth = 0\n  let current_level_depth_max = 0\n  let current_level_depth_min = 0\n  let current_level_depth_sum = 0\n  let current_level_depth_sum_max = 0\n  let current_level_depth_sum_min = 0\n  let current_level_depth_sum_sum = 0\n  let current_level_depth_sum_sum_max = 0\n  let current_level_depth_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0\n  let current_level_depth_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_min = 0\n  let current", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a routine that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": true, "gc": "/*sumToN is a routine that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a drawstring of \" (\" and \") \". \n   return true if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a drawstring of \" (\" and \") \". \n   return true if every opening bracket give birth a comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = [brackets];\n  const stackLength = brackets.length;\n  const stackLengthMinusOne = stackLength - 1;\n  const stackLengthMinusTwo = stackLength - 2;\n  const stackLengthMinusThree = stackLength - 3;\n  const stackLengthMinusFour = stackLength - 4;\n  const stackLengthMinusFive = stackLength - 5;\n  const stackLengthMinusSix = stackLength - 6;\n  const stackLengthMinusSeven = stackLength - 7;\n  const stackLengthMinusEight = stackLength - 8;\n  const stackLengthMinusNine = stackLength - 9;\n  const stackLengthMinusTen = stackLength - 10;\n  const stackLengthMinusEleven = stackLength - 11;\n  const stackLengthMinusTwelve = stackLength - 12;\n  const stackLengthMinusThirteen = stackLength - 13;\n  const stackLengthMinusFourteen = stackLength - 14;\n  const stackLengthMinusFifteen = stackLength - 15;\n  const stackLengthMinusSixteen = stackLength - 16;\n  const stackLengthMinusSeventeen = stackLength - 17;\n  const stackLengthMinusEighteen = stackLength - 18;\n  const stackLengthMinusNineteen = stackLength - 19;\n  const stackLengthMinusTwenty = stackLength - 20;\n  const stackLengthMinusTwentyOne = stackLength - 21;\n  const stackLengthMinusTwentyTwo = stackLength - 22;\n  const stackLengthMinusTwentyThree = stackLength - 23;\n  const stackLengthMinusTwentyFour = stackLength - 24;\n  const stackLengthMinusTwentyFive = stackLength - 25;\n  const stackLengthMinusTwentySix = stackLength - 26;\n  const stackLengthMinusTwentySeven = stackLength - 27;\n  const stackLengthMinusTwentyEight = stackLength - 28;\n  const stackLengthMinusTwentyNine = stackLength - 29;\n  const stackLengthMinusThirty = stackLength - 30;\n  const stackLengthMinusThirtyOne = stackLength - 31;\n  const stackLengthMinusThirtyTwo = stackLength - 32;\n  const stackLengthMinusThirtyThree = stackLength - 33;\n  const stackLengthMinusThirtyFour = stackLength - 34;\n  const stackLengthMinusThirtyFive = stackLength - 35;\n  const stackLengthMinusThirtySix = stackLength - 36;\n  const stackLengthMinusThirtySeven = stackLength - 37;\n  const stackLengthMinusThirtyEight = stackLength - 38;\n  const stackLengthMinusThirtyNine = stackLength - 39;\n  const stackLengthMinusForty = stackLength - 40;\n  const stackLengthMinusFortyOne = stackLength - 41;\n  const stackLengthMinusFortyTwo = stackLength - 42;\n  const stackLengthMinusFortyThree = stackLength - 43;\n  const stackLengthMinusFortyFour = stackLength - 44;\n  const stackLengthMinusFortyFive = stackLength - 45;\n  const stackLengthMinusFortySix = stackLength - 46;\n  const stackLengthMinusFortySeven = stackLength - 47;\n  const stackLengthMinusFortyEight = stackLength - 48;\n  const stackLengthMinusFortyNine = stackLength - 49;\n  const stackLengthMinusFifty = stackLength - 50;\n  const stackLengthMinusFiftyOne = stackLength - 51;\n  const stackLengthMinusFiftyTwo = stackLength - 52;\n  const stackLengthMinusFiftyThree = stackLength - 53;\n  const stackLengthMinusFiftyFour = stackLength - 54;\n  const stackLengthMinusFiftyFive = stackLength - 55;\n  const stackLengthMinusFiftySix = stackLength - 56;\n  const stackLengthMinusFiftySeven = stackLength - 57;\n  const stackLengthMinusFiftyEight = stackLength - 58;\n  const stackLengthMinusFiftyNine = stackLength - 59;\n  const stackLengthMinusSixty = stackLength - 60;\n  const stackLengthMinusSixtyOne = stackLength - 61;\n  const stackLengthMinusSixtyTwo = stackLength - 62;\n  const stackLengthMinusSixtyThree = stackLength - 63;\n  const stackLengthMinusSixtyFour = stackLength - 64;\n  const stackLengthMinusSixtyFive = stackLength - 65;\n  const stackLengthMinusSixtySix = stackLength - 66;\n  const stackLengthMinusSixtySeven = stackLength - 67;\n  const stackLengthMinusSixtyEight = stackLength - 68;\n  const stackLengthMinusSixtyNine = stackLength - 69;\n  const stackLengthMinusSeventy = stackLength - 70;\n  const stackLengthMinusSeventyOne = stackLength - 71;\n  const stackLengthMinusSeventyTwo = stackLength - 72;\n  const stackLengthMinusSeventyThree = stackLength - 73;\n  const stackLengthMinusSeventyFour = stackLength - 74;\n  const stackLengthMinusSeventyFive = stackLength - 75;\n  const stackLengthMinusSeventySix = stackLength - 76;\n  const stackLengthMinusSeventySeven = stackLength - 77;\n  const stackLengthMinusSeventyEight = stackLength - 78;\n  const stackLengthMinusSeventyNine = stackLength - 79;\n  const stackLengthMinusSeventyTen = stackLength - 80;\n  const stackLengthMinusSeventyEleven = stackLength - 81;\n  const stackLengthMinusSeventyTwelve = stackLength - 82;\n  const stackLengthMinusSeventyThirteen = stackLength - 83;\n  const stackLengthMinusSeventyFourteen = stackLength - 84;\n  const stackLengthMinusSeventyFifteen = stackLength - 85;\n  const stackLengthMinusSeventySixteen = stackLength - 86;\n  const stackLengthMinusSeventySeventeen = stackLength - 87;\n  const stackLengthMinusSeventyEighteen = stackLength - 88;\n  const stackLengthMinusSeventyNineteen = stackLength - 89;\n  const stackLengthMinusSeventyTwenty = stackLength - 90", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/62", "prompt": "/* xs stage coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    recurrence derivative of this polynomial in the same human body.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "/* xs stage coefficients of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    recurrence derivative of this polynomial in the same human body.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients of its derivative.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = 1; i < len; i++) {\n    d[i] = d[i - 1] + xs[i]\n  }\n  return d\n}\n\n/*\n  Given a polynomial, returns the coefficients", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function to efficiently compute the n-th chemical element of the fibfib number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "/*The FibFib phone number sequence is a sequence exchangeable to the Fibbonacci sequnece that's defined as surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function to efficiently compute the n-th chemical element of the fibfib number succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 0;\n  if (n === 2) return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nconsole.log(fibfib(8));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/64", "prompt": "/*Write a affair vowelsCount which takes a chain represent \n   a word as stimulation and returns the number of vowels in the string. \n   vowel in this casing are' a',' einsteinium',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but merely when it is at the conclusion of the give news. \n\n   case:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "/*Write a affair vowelsCount which takes a chain represent \n   a word as stimulation and returns the number of vowels in the string. \n   vowel in this casing are' a',' einsteinium',' i',' oxygen',' u'. Here,' y' is besides a \n   vowel, but merely when it is at the conclusion of the give news. \n\n   case:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a','e','i','o','u','y']\n  const consonants = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','z']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    } else if (consonants.includes(s[i])) {\n      if (i === s.length - 1) {\n        count++\n      }\n    }\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string and returns the number of consonants in the string.\n  consonants in this case are' a',' e',' i',' o',' u'. Here,' y' is besides a consonant, but \n  merely when it is at the conclusion of the give news. \n\n  case:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['a','e','i','o','u','y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    } else if (i === s.length - 1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string and returns the number of consonants in the string.\n  consonants in this case are' a',' e',' i',' o',' u'. Here,' y' is besides a consonant, but \n  merely when it is at the conclusion of the give news. \n\n  case:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['a','e','i','o','u','y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    } else if (i === s.length - 1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string and returns the number of vowels in the string.\n  vowels in this case are' a',' e',' i',' o',' u'. Here,' y' is besides a vowel, but \n  merely when it is at the conclusion of the give news. \n\n  case:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a','e','i','o','u','y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    } else if (i === s.length - 1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string and returns the number of consonants in the string.\n  consonants in this case are' a',' e',' i',' o',' u'. Here,' y' is besides a consonant, but \n  merely when it is at the conclusion of the give news. \n\n  case:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['a','e','i','o','u','y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    } else if (i === s.length - 1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string and returns the number of consonants in the string.\n  consonants in this case are' a',' e',' i',' o',' u'. Here,' y' is besides a consonant, but \n  merely when it is at the conclusion of the give news. \n\n  case:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['a','e','i','o','u','y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    } else if (i === s.length - 1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string and returns the number of vowels in the string.\n  vowels in this case are' a',' e',' i',' o',' u'. Here,' y' is besides a vowel, but \n  merely when it is at the conclusion of the give news. \n\n  case:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a','e','i','o','u','y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    } else if (i === s.length - 1) {\n      count++\n    }\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digit of the integer x, shift the digit correct by shift\n   and return the result as a chain. \n   If shift > number of digits, return digits overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "/*Circular shift the digit of the integer x, shift the digit correct by shift\n   and return the result as a chain. \n   If shift > number of digits, return digits overrule.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = x;\n  while (shift > 0) {\n    result = (result * 10) + (x % 10);\n    x = Math.floor(x / 10);\n    shift--;\n  }\n  return result;\n};\n\n/*\n  >>> circularShift(12, 2)\n  \"12\"\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 3)\n  \"12\"\n  >>> circularShift(12, 4)\n  \"12\"\n  >>> circularShift(12, 5)\n  \"12\"\n  >>> circularShift(12, 6)\n  \"12\"\n  >>> circularShift(12, 7)\n  \"12\"\n  >>> circularShift(12, 8)\n  \"12\"\n  >>> circularShift(12, 9)\n  \"12\"\n  >>> circularShift(12, 10)\n  \"12\"\n  >>> circularShift(12, 11)\n  \"12\"\n  >>> circularShift(12, 12)\n  \"12\"\n  >>> circularShift(12, 13)\n  \"12\"\n  >>> circularShift(12, 14)\n  \"12\"\n  >>> circularShift(12, 15)\n  \"12\"\n  >>> circularShift(12, 16)\n  \"12\"\n  >>> circularShift(12, 17)\n  \"12\"\n  >>> circularShift(12, 18)\n  \"12\"\n  >>> circularShift(12, 19)\n  \"12\"\n  >>> circularShift(12, 20)\n  \"12\"\n  >>> circularShift(12, 21)\n  \"12\"\n  >>> circularShift(12, 22)\n  \"12\"\n  >>> circularShift(12, 23)\n  \"12\"\n  >>> circularShift(12, 24)\n  \"12\"\n  >>> circularShift(12, 25)\n  \"12\"\n  >>> circularShift(12, 26)\n  \"12\"\n  >>> circularShift(12, 27)\n  \"12\"\n  >>> circularShift(12, 28)\n  \"12\"\n  >>> circularShift(12, 29)\n  \"12\"\n  >>> circularShift(12, 30)\n  \"12\"\n  >>> circularShift(12, 31)\n  \"12\"\n  >>> circularShift(12, 32)\n  \"12\"\n  >>> circularShift(12, 33)\n  \"12\"\n  >>> circularShift(12, 34)\n  \"12\"\n  >>> circularShift(12, 35)\n  \"12\"\n  >>> circularShift(12, 36)\n  \"12\"\n  >>> circularShift(12, 37)\n  \"12\"\n  >>> circularShift(12, 38)\n  \"12\"\n  >>> circularShift(12, 39)\n  \"12\"\n  >>> circularShift(12, 40)\n  \"12\"\n  >>> circularShift(12, 41)\n  \"12\"\n  >>> circularShift(12, 42)\n  \"12\"\n  >>> circularShift(12, 43)\n  \"12\"\n  >>> circularShift(12, 44)\n  \"12\"\n  >>> circularShift(12, 45)\n  \"12\"\n  >>> circularShift(12, 46)\n  \"12\"\n  >>> circularShift(12, 47)\n  \"12\"\n  >>> circularShift(12, 48)\n  \"12\"\n  >>> circularShift(12, 49)\n  \"12\"\n  >>> circularShift(12, 50)\n  \"12\"\n  >>> circularShift(12, 51)\n  \"12\"\n  >>> circularShift(12, 52)\n  \"12\"\n  >>> circularShift(12, 53)\n  \"12\"\n  >>> circularShift(12, 54)\n  \"12\"\n  >>> circularShift(12, 55)\n  \"12\"\n  >>> circularShift(12, 56)\n  \"12\"\n  >>> circularShift(12, 57)\n  \"12\"\n  >>> circularShift(12, 58)\n  \"12\"\n  >>> circularShift(12, 59)\n  \"12\"\n  >>> circularShift(12, 60)\n  \"12\"\n  >>> circularShift(12, 61)\n  \"12\"\n  >>> circularShift(12, 62)\n  \"12\"\n  >>> circularShift(12, 63)\n  \"12\"\n  >>> circularShift(12, 64)\n  \"12\"\n  >>> circularShift(12, 65)\n  \"12\"\n  >>> circularShift(12, 66)\n  \"12\"\n  >>> circularShift(12, 67)\n  \"12\"\n  >>> circularShift(12, 68)\n  \"12\"\n  >>> circularShift(12, 69)\n  \"12\"\n  >>> circularShift(12, 70)\n  \"12\"\n  >>> circularShift(12, 71)\n  \"12\"\n  >>> circularShift(12, 72)\n  \"12\"\n  >>> circularShift(12, 73)\n  \"12\"\n  >>> circularShift(12, 74)\n  \"12\"\n  >>> circularShift(12, 75)\n  \"12\"\n  >>> circularShift(12, 76)\n  \"12\"\n  >>> circularShift(12, 77)\n  \"12\"\n  >>> circularShift(12, 78)\n  \"12\"\n  >>> circularShift(12, 79)\n  \"12\"\n  >>> circularShift(12, 80)\n  \"12\"\n  >>> circularShift(12, 81)\n  \"12\"\n  >>> circularShift(12, 82)\n  \"12\"\n  >>> circularShift(12, 83)\n  \"12\"\n  >>> circularShift(12, 84)\n  \"12\"\n  >>> circularShift(12, 85)\n  \"12\"\n  >>> circularShift(12, 86)\n  \"12\"\n  >>> circularShift(12, 87)\n  \"12\"\n  >>> circularShift(12, 88)\n  \"12\"\n  >>> circularShift(12, 89)\n  \"12\"\n  >>> circularShift(12, 90)\n  \"12\"\n  >>> circularShift(12, 91)\n  \"12\"\n  >>> circularShift(12, 92)\n  \"12\"\n  >>> circularShift(12,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/66", "prompt": "/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tnecessitate \n   spell a function that take a drawstring as stimulation and returns the sum of the upper character only' \n   ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this job, you will be given a string that defend a issue of apples and orange \n   that are distributed in a basket of fruit this basket contains \n   apples, orange, and mango fruits. give the drawstring that represent the entire numeral of \n   the oranges and apples and an integer that stage the total act of the fruits \n   in the basket return the number of the mango fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apple and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "/*\n  In this job, you will be given a string that defend a issue of apples and orange \n   that are distributed in a basket of fruit this basket contains \n   apples, orange, and mango fruits. give the drawstring that represent the entire numeral of \n   the oranges and apples and an integer that stage the total act of the fruits \n   in the basket return the number of the mango fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apple and 3 orange \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let s = s.split(\" \")\n   let n = n.split(\" \")\n   let apples = 0\n   let oranges = 0\n   let mango = 0\n   for (let i = 0; i < s.length; i++) {\n     if (s[i] === \"apple\") {\n       apples++\n     } else if (s[i] === \"orange\") {\n       oranges++\n     } else if (s[i] === \"mango\") {\n       mango++\n     }\n   }\n   return apples + oranges + mango\n }\n*/\n\nfunction fruitDistribution(fruit, total) {\n  let s = fruit.split(\" \")\n  let n = total.split(\" \")\n  let apples = 0\n  let oranges = 0\n  let mango = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"apple\") {\n      apples++\n    } else if (s[i] === \"orange\") {\n      oranges++\n    } else if (s[i] === \"mango\") {\n      mango++\n    }\n  }\n  return apples + oranges + mango\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 orange \", 19))\nconsole.log(fruitDistribution(\"0 apple and 1 oranges\", 3))\nconsole.log(fruitDistribution(\"2 apple and 3 orange \", 100))\nconsole.log(fruitDistribution(\"100 apple and 1 oranges\", 120))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" give an array represent a arm of a tree that has non - negative integer node \n   your task is to pluck one of the nodes and return it. \n   The plucked node should embody the lymph node with the smallest tied value. \n   If multiple node with the same minor tied value are find return the lymph node that has modest index. \n\n   The plucked lymph node should be returned in a list, [ smalest_value, its index ], \n   If there be no tied values or the give array equal empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "/*\n  \" give an array represent a arm of a tree that has non - negative integer node \n   your task is to pluck one of the nodes and return it. \n   The plucked node should embody the lymph node with the smallest tied value. \n   If multiple node with the same minor tied value are find return the lymph node that has modest index. \n\n   The plucked lymph node should be returned in a list, [ smalest_value, its index ], \n   If there be no tied values or the give array equal empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const arrLen = arr.length;\n  let min = arr[0];\n  let minIdx = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arrLen; i++) {\n    if (arr[i] < minValue) {\n      min = arr[i];\n      minIdx = i;\n      minValue = arr[i];\n    }\n  }\n  return [min, minIdx];\n};\n\nexport { pluck };\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are give a non - empty list of positivist integers. come back the greatest integer that be greater than \n   zero, and has a frequency greater than or adequate to the value of the integer itself. \n   The frequency of an integer is the numeral of time it appear in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a non - empty list of positivist integers. come back the greatest integer that be greater than \n   zero, and has a frequency greater than or adequate to the value of the integer itself. \n   The frequency of an integer is the numeral of time it appear in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search2 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search3 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search4 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search5 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search6 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search7 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search8 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search9 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search10 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex\n  return -1\n}\n\nconst search11 = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const maxIndex = lst.reduce((a, b) => Math.max(a, b), -1)\n  if (maxFreq === 0) return -1\n  if (maxFreq === max) return maxIndex", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an remark list of strings only for ones that check give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": true, "gc": "/* Filter an remark list of strings only for ones that check give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  const result = [];\n  strings.forEach(string => {\n    if (string.indexOf(substring)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring12 = (strings, subst", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  give list of integers, return list in foreign decree. \n   foreign sorting, is when you originate with the minimum value, \n   then maximum of the persist integer, then minimum and thus on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "/*\n  give list of integers, return list in foreign decree. \n   foreign sorting, is when you originate with the minimum value, \n   then maximum of the persist integer, then minimum and thus on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  if (len === 0) return []\n  const sorted = []\n  let min = lst[0]\n  let max = lst[0]\n  let i = 1\n  while (i < len) {\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    i++\n  }\n  sorted.push(min)\n  sorted.push(max)\n  while (i < len) {\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    i++\n  }\n  sorted.push(min)\n  sorted.push(max)\n  return sorted\n}\n\nexport default strangeSortList\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  give the lengths of the three side of a triangulum. refund the area of \n   the triangulum polish to 2 decimal points if the three side form a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangulum when the kernel of any two sides be great \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*\n  give the lengths of the three side of a triangulum. refund the area of \n   the triangulum polish to 2 decimal points if the three side form a valid triangulum. \n   Otherwise return -1 \n   Three side make a valid triangulum when the kernel of any two sides be great \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea2 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea3 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea4 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea5 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea6 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea7 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea8 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea9 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea10 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea11 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea12 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea13 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea14 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea15 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea16 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea17 = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  if (area === 0) {\n    return -1\n  }\n  return area\n}\n\nconst triangleArea18 = (a, b, c) => {\n  const s = (a + b + c)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  compose a function that returns on-key if the aim q will vanish, and assumed otherwise. \n   The object q will fly if it's balanced (it is a palindromic list) and the union of its element be less than or equal the maximal potential system of weights w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that returns on-key if the aim q will vanish, and assumed otherwise. \n   The object q will fly if it's balanced (it is a palindromic list) and the union of its element be less than or equal the maximal potential system of weights w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0) return false;\n  if (q.length === 1) return q[0] <= w;\n  if (q.length === 2) return q[0] + q[1] <= w;\n  if (q.length === 3) return q[0] + q[1] + q[2] <= w;\n  if (q.length === 4) return q[0] + q[1] + q[2] + q[3] <= w;\n  if (q.length === 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n  if (q.length === 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n  if (q.length === 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n  if (q.length === 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n  if (q.length === 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n  if (q.length === 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n  if (q.length === 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n  if (q.length === 12) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] <= w;\n  if (q.length === 13) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] <= w;\n  if (q.length === 14) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] + q[13] <= w;\n  if (q.length === 15) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] + q[13] + q[14] <= w;\n  if (q.length === 16) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] + q[13] + q[14] + q[15] <= w;\n  if (q.length === 17) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] + q[13] + q[14] + q[15] + q[16] <= w;\n  if (q.length === 18) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] + q[13] + q[14] + q[15] + q[16] + q[17] <= w;\n  if (q.length === 19) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] + q[13] + q[14] + q[15] + q[16] + q[17] + q[18] <= w;\n  if (q.length === 20) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] + q[11] + q[12] + q[13] + q[14] + q[15] + q[16] + q", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  give an array arr of integer, witness the minimal number of chemical element that \n   need to be changed to make the array palindromic. A palindromic array is an array that \n   is learn the same backward and ahead. In one variety, you can switch one chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "/*\n  give an array arr of integer, witness the minimal number of chemical element that \n   need to be changed to make the array palindromic. A palindromic array is an array that \n   is learn the same backward and ahead. In one variety, you can switch one chemical element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n    let count = 0;\n    let i = 0;\n    let j = arr.length - 1;\n    while (i < j) {\n        while (arr[i]!= arr[j]) {\n            count++;\n            j--;\n        }\n        i++;\n        j--;\n    }\n    return count;\n}\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  compose a function that accepts two tilt of string and return the list that has \n   entire number of chars in the all chain of the list less than the other list.\n\n   if the two lists consume the like number of charwoman, return the inaugural list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that accepts two tilt of string and return the list that has \n   entire number of chars in the all chain of the list less than the other list.\n\n   if the two lists consume the like number of charwoman, return the inaugural list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      lst.push(lst1[i])\n      i++\n      j++\n    } else if (lst1[i] > lst2[j]) {\n      j++\n    } else {\n      i++\n    }\n  }\n  return lst\n}\n\n/*\n  compose a function that accepts two list of string and return the list that has \n   entire number of chars in the all chain of the list less than the other list.\n\n   if the two lists consume the like number of charwoman, return the inaugural list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch2 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      lst.push(lst1[i])\n      i++\n      j++\n    } else if (lst1[i] > lst2[j]) {\n      j++\n    } else {\n      i++\n    }\n  }\n  return lst\n}\n\nconst totalMatch3 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      lst.push(lst1[i])\n      i++\n      j++\n    } else if (lst1[i] > lst2[j]) {\n      j++\n    } else {\n      i++\n    }\n  }\n  return lst\n}\n\nconst totalMatch4 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      lst.push(lst1[i])\n      i++\n      j++\n    } else if (lst1[i] > lst2[j]) {\n      j++\n    } else {\n      i++\n    }\n  }\n  return lst\n}\n\nconst totalMatch5 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      lst.push(lst1[i])\n      i++\n      j++\n    } else if (lst1[i] > lst2[j]) {\n      j++\n    } else {\n      i++\n    }\n  }\n  return lst\n}\n\nconst totalMatch6 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      lst.push(lst1[i])\n      i++\n      j++\n    } else if (lst1[i] > lst2[j]) {\n      j++\n    } else {\n      i++\n    }\n  }\n  return lst\n}\n\nconst totalMatch7 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      lst.push(lst1[i", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that come back dependable if the grant issue cost the multiplication of 3 prime number \n   and assumed otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "/*Write a function that come back dependable if the grant issue cost the multiplication of 3 prime number \n   and assumed otherwise. \n   know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const isPrime = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime2 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime3 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime4 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime5 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime6 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime7 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime8 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime9 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime10 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime11 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime12 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime13 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime14 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime15 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime16 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n    return true\n  }\n  const isPrime17 = (n) => {\n    if (n < 2) return false\n    if (n === 2) return true\n    if (n % 2 === 0) return false\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false\n    }\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your job is to write a function that retort on-key if a number x be a simple \n   power of n and false in other case. \n   x is a dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "/*Your job is to write a function that retort on-key if a number x be a simple \n   power of n and false in other case. \n   x is a dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  let x_int = parseInt(x);\n  let n_int = parseInt(n);\n  if (x_int % n_int === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  return a % 6 === 0 && a % 5 === 0 && a % 4 === 0 && a % 3 === 0 && a % 2 === 0 && a % 1 === 0;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst ispandigital = (a) => {\n  let result = 0;\n  for (let i = 1; i <= a; i++) {\n    if (iscube(i)) {\n      result += i;\n    }\n  }\n  return result;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst ispalindrome = (a) => {\n  let result = 0;\n  let reversed = a;\n  while (reversed > 0) {\n    result += reversed % 10;\n    reversed = reversed / 10;\n  }\n  return result === a;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst isprime = (a) => {\n  let result = 0;\n  for (let i = 2; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      result += i;\n    }\n  }\n  return result === a;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst ispalindromic = (a) => {\n  let result = 0;\n  let reversed = a;\n  while (reversed > 0) {\n    result += reversed % 10;\n    reversed = reversed / 10;\n  }\n  return result === a;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst ispalindromic_2 = (a) => {\n  let result = 0;\n  let reversed = a;\n  while (reversed > 0) {\n    result += reversed % 10;\n    reversed = reversed / 10;\n  }\n  return result === a;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst ispalindromic_3 = (a) => {\n  let result = 0;\n  let reversed = a;\n  while (reversed > 0) {\n    result += reversed % 10;\n    reversed = reversed / 10;\n  }\n  return result === a;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst ispalindromic_4 = (a) => {\n  let result = 0;\n  let reversed = a;\n  while (reversed > 0) {\n    result += reversed % 10;\n    reversed = reversed / 10;\n  }\n  return result === a;\n}\n\n/*\n  compose a function that takes an integer a and render dependable \n   if this ingeger be a cube of some integer act. \n   Note: you may assume the remark is constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tax to write a function that receive \n   a hexadecimal phone number as a chain and counts the number of hexadecimal \n   digit that be primes (flower number=== or a prime=== is a natural issue \n   capital than 1 that exist not a merchandise of two little lifelike numbers). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   thus you have to decide a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== vitamin d (= decimal 13). \n   bill: you may assume the remark is always correct or empty string=== \n   and symbols A===B===C===D===E===F be always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "/*You have been tax to write a function that receive \n   a hexadecimal phone number as a chain and counts the number of hexadecimal \n   digit that be primes (flower number=== or a prime=== is a natural issue \n   capital than 1 that exist not a merchandise of two little lifelike numbers). \n   Hexadecimal digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   thus you have to decide a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== vitamin d (= decimal 13). \n   bill: you may assume the remark is always correct or empty string=== \n   and symbols A===B===C===D===E===F be always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0;\n  let numArr = num.split(\"\");\n  for (let i = 0; i < numArr.length; i++) {\n    result += numArr[i] === \"A\"? 1 : numArr[i] === \"B\"? 2 : numArr[i] === \"C\"? 3 : numArr[i] === \"D\"? 4 : numArr[i] === \"E\"? 5 : numArr[i] === \"F\"? 6 : 0;\n  }\n  return result;\n};\n\nconst isPrime = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isFlower = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isVitaminD = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isFlowerNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isPrimeNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isVitaminDNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isFlowerNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isPrimeNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isVitaminDNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isFlowerNumberNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isPrimeNumberNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isVitaminDNumberNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isFlowerNumberNumberNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isPrimeNumberNumberNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isVitaminDNumberNumberNumberNumber = (num) => {\n  let result = false;\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst isFlowerNumberNumberNumberNumberNumber = (num) => {\n  let result = false;\n  for", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be give a number in decimal kind and your job equal to commute it to \n   binary format. The function should return a bowed stringed instrument, with each character representing a binary \n   number. Each quality in the bowed stringed instrument will embody' 0' or' 1'. \n\n   There will cost an extra couple of quality' db' at the beginning and at the goal of the drawstring. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "/*You will be give a number in decimal kind and your job equal to commute it to \n   binary format. The function should return a bowed stringed instrument, with each character representing a binary \n   number. Each quality in the bowed stringed instrument will embody' 0' or' 1'. \n\n   There will cost an extra couple of quality' db' at the beginning and at the goal of the drawstring. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = ''\n  for (let i = 0; i < decimal; i++) {\n    binary += 'db'\n  }\n  return binary\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = 0\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i], 2)\n  }\n  return decimal\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToBinary = (binary) => {\n  const binary = ''\n  for (let i = 0; i < binary.length; i++) {\n    binary += binary[i]\n  }\n  return binary\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = 0\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i], 2)\n  }\n  return decimal\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToBinary = (binary) => {\n  const binary = ''\n  for (let i = 0; i < binary.length; i++) {\n    binary += binary[i]\n  }\n  return binary\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = 0\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i], 2)\n  }\n  return decimal\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToBinary = (binary) => {\n  const binary = ''\n  for (let i = 0; i < binary.length; i++) {\n    binary += binary[i]\n  }\n  return binary\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = 0\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i], 2)\n  }\n  return decimal\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToBinary = (binary) => {\n  const binary = ''\n  for (let i = 0; i < binary.length; i++) {\n    binary += binary[i]\n  }\n  return binary\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = 0\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i], 2)\n  }\n  return decimal\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToBinary = (binary) => {\n  const binary = ''\n  for (let i = 0; i < binary.length; i++) {\n    binary += binary[i]\n  }\n  return binary\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = 0\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i], 2)\n  }\n  return decimal\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToBinary = (binary) => {\n  const binary = ''\n  for (let i = 0; i < binary.length; i++) {\n    binary += binary[i]\n  }\n  return binary\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = 0\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i], 2)\n  }\n  return decimal\n}\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToBinary", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a give list of integers, return a tuple dwell of a union and a intersection of all the integer in a list.\n   Empty sum should be equal to 0 and empty product should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "/* For a give list of integers, return a tuple dwell of a union and a intersection of all the integer in a list.\n   Empty sum should be equal to 0 and empty product should be adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct2 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct3 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct4 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct5 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct6 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct7 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct8 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct9 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct10 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct11 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct12 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct13 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct14 = (numbers) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return [sum, product];\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  (45, 720)\n  */\nconst sumProduct15 = (numbers) =>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/80", "prompt": "/*You are give a string s.\n   Your undertaking is to control if the drawstring is glad or not. \n   A bowed stringed instrument is happy if its length be at least 3 and every 3 consecutive letter are discrete\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "/*You are give a string s.\n   Your undertaking is to control if the drawstring is glad or not. \n   A bowed stringed instrument is happy if its length be at least 3 and every 3 consecutive letter are discrete\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length\n  let i = 0\n  let j = 0\n  let count = 0\n  let isHappy = true\n  while (i < len) {\n    if (s[i] === s[j]) {\n      count++\n      if (count === 3) {\n        if (i + 1 === len || s[i + 1]!== s[j + 1]) {\n          isHappy = false\n          break\n        }\n      }\n    } else {\n      count = 0\n    }\n    j++\n    i++\n  }\n  return isHappy\n}\n\nconsole.log(isHappy('a'))\nconsole.log(isHappy('aa'))\nconsole.log(isHappy('abcd'))\nconsole.log(isHappy('aabb'))\nconsole.log(isHappy('adb'))\nconsole.log(isHappy('xyy'))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/81", "prompt": "/*Ithymine is the last workweek of the semester and the teacher suffer to contribute the grades\n   to students. The teacher has been making her own algorithm for grading. \n   The alone trouble is, she has lost the code she used for grade. \n   She has give you a list of grade point average for some students and you take to write \n   a function that can output a list of letter grades use the following table: \n            GPA        |     Letter grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 coke \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "/*Ithymine is the last workweek of the semester and the teacher suffer to contribute the grades\n   to students. The teacher has been making her own algorithm for grading. \n   The alone trouble is, she has lost the code she used for grade. \n   She has give you a list of grade point average for some students and you take to write \n   a function that can output a list of letter grades use the following table: \n            GPA        |     Letter grad \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 coke \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 five hundred \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = Array.from(grades);\n  const gradesArrayLength = gradesArray.length;\n  const gradesArraySum = gradesArray.reduce((a, b) => a + b);\n  const gradesArrayAverage = gradesArraySum / gradesArrayLength;\n  const gradesArrayAverageSum = gradesArrayAverage * gradesArrayLength;\n  const gradesArrayAverageSumMinus = gradesArrayAverageSum - gradesArrayLength;\n  const gradesArrayAverageSumMinus2 = gradesArrayAverageSumMinus * gradesArrayLength;\n  const gradesArrayAverageSumMinus3 = gradesArrayAverageSumMinus2 * gradesArrayLength;\n  const gradesArrayAverageSumMinus4 = gradesArrayAverageSumMinus3 * gradesArrayLength;\n  const gradesArrayAverageSumMinus5 = gradesArrayAverageSumMinus4 * gradesArrayLength;\n  const gradesArrayAverageSumMinus6 = gradesArrayAverageSumMinus5 * gradesArrayLength;\n  const gradesArrayAverageSumMinus7 = gradesArrayAverageSumMinus6 * gradesArrayLength;\n  const gradesArrayAverageSumMinus8 = gradesArrayAverageSumMinus7 * gradesArrayLength;\n  const gradesArrayAverageSumMinus9 = gradesArrayAverageSumMinus8 * gradesArrayLength;\n  const gradesArrayAverageSumMinus10 = gradesArrayAverageSumMinus9 * gradesArrayLength;\n  const gradesArrayAverageSumMinus11 = gradesArrayAverageSumMinus10 * gradesArrayLength;\n  const gradesArrayAverageSumMinus12 = gradesArrayAverageSumMinus11 * gradesArrayLength;\n  const gradesArrayAverageSumMinus13 = gradesArrayAverageSumMinus12 * gradesArrayLength;\n  const gradesArrayAverageSumMinus14 = gradesArrayAverageSumMinus13 * gradesArrayLength;\n  const gradesArrayAverageSumMinus15 = gradesArrayAverageSumMinus14 * gradesArrayLength;\n  const gradesArrayAverageSumMinus16 = gradesArrayAverageSumMinus15 * gradesArrayLength;\n  const gradesArrayAverageSumMinus17 = gradesArrayAverageSumMinus16 * gradesArrayLength;\n  const gradesArrayAverageSumMinus18 = gradesArrayAverageSumMinus17 * gradesArrayLength;\n  const gradesArrayAverageSumMinus19 = gradesArrayAverageSumMinus18 * gradesArrayLength;\n  const gradesArrayAverageSumMinus20 = gradesArrayAverageSumMinus19 * gradesArrayLength;\n  const gradesArrayAverageSumMinus21 = gradesArrayAverageSumMinus20 * gradesArrayLength;\n  const gradesArrayAverageSumMinus22 = gradesArrayAverageSumMinus21 * gradesArrayLength;\n  const gradesArrayAverageSumMinus23 = gradesArrayAverageSumMinus22 * gradesArrayLength;\n  const gradesArrayAverageSumMinus24 = gradesArrayAverageSumMinus23 * gradesArrayLength;\n  const gradesArrayAverageSumMinus25 = gradesArrayAverageSumMinus24 * gradesArrayLength;\n  const gradesArrayAverageSumMinus26 = gradesArrayAverageSumMinus25 * gradesArrayLength;\n  const gradesArrayAverageSumMinus27 = gradesArrayAverageSumMinus26 * gradesArrayLength;\n  const gradesArrayAverageSumMinus28 = gradesArrayAverageSumMinus27 * gradesArrayLength;\n  const gradesArrayAverageSumMinus29 = gradesArrayAverageSumMinus28 * gradesArrayLength;\n  const gradesArrayAverageSumMinus30 = gradesArrayAverageSumMinus29 * gradesArrayLength;\n  const gradesArrayAverageSumMinus31 = gradesArrayAverageSumMinus30 * gradesArrayLength;\n  const gradesArrayAverageSumMinus32 = gradesArrayAverageSumMinus31 * gradesArrayLength;\n  const gradesArrayAverageSumMinus33 = gradesArrayAverageSumMinus32 * gradesArrayLength;\n  const gradesArrayAverageSumMinus34 = gradesArrayAverageSumMinus33 * gradesArrayLength;\n  const gradesArrayAverageSumMinus35 = gradesArrayAverageSumMinus34 * gradesArrayLength;\n  const gradesArrayAverageSumMinus36 = gradesArrayAverageSumMinus35 * gradesArrayLength;\n  const gradesArrayAverageSumMinus37 = gradesArrayAverageSumMinus36 * gradesArrayLength;\n  const gradesArrayAverageSumMinus38 = gradesArrayAverageSumMinus37 * gradesArrayLength;\n  const gradesArrayAverageSumMinus39 = gradesArrayAverageSumMinus38 * gradesArrayLength;\n  const gradesArrayAverageSumMinus40 = gradesArrayAverageSumMinus39 * gradesArrayLength;\n  const gradesArrayAverageSumMinus41 = gradesArrayAverageSumMinus40 * gradesArrayLength;\n  const gradesArrayAverageSumMinus42 = gradesArrayAverageSumMinus41 * gradesArrayLength;\n  const gradesArrayAverageSumMinus43 = gradesArrayAverageSumMinus42 * gradesArrayLength;\n  const gradesArrayAverageSumMinus44 = gradesArrayAverageSumMinus43 * gradesArrayLength;\n  const gradesArrayAverageSumMinus45 = gradesArrayAverageSumMinus44 * gradesArrayLength;\n  const gradesArrayAverageSumMinus46 = gradesArrayAverageSumMinus45 * gradesArrayLength;\n  const gradesArrayAverageSumMinus47 = gradesArrayAverageSumMinus46 * gradesArrayLength;\n  const gradesArrayAverageSumMinus48 = gradesArrayAverageSumMinus47 * gradesArrayLength;\n  const gradesArrayAverageSumMinus49 = gradesArrayAverageSumMinus48 * gradesArrayLength;\n  const gradesArrayAverageSumMinus50 = gradesArrayAverageSumMinus49 * gradesArrayLength;\n  const gradesArrayAverageSumMinus51 = gradesArrayAverageSumMinus50 * gradesArrayLength;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a affair that takes a string and retort on-key if the string\n   length be a prime number or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "/*Write a affair that takes a string and retort on-key if the string\n   length be a prime number or false differently\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const length = string.length;\n  const prime = (number) => {\n    return number % 2 === 0? false : true;\n  };\n  const isPrime = (number) => {\n    for (let i = 2; i < number; i++) {\n      if (prime(i) === false) {\n        return false;\n      }\n    }\n    return true;\n  };\n  if (prime(length) === true) {\n    return true;\n  }\n  return false;\n};\n\n/*Write a function that takes a string and return the number of\n   characters that are in upper case\n  Examples\n  upperCase('Hello') == 5\n  upperCase('abcdcba') == 5\n  upperCase('kittens') == 5\n  upperCase('orange') == 0\n  */\nconst upperCase = (string) => {\n  const length = string.length;\n  const upper = (string) => {\n    return string.toUpperCase();\n  };\n  const count = (string) => {\n    let count = 0;\n    for (let i = 0; i < string.length; i++) {\n      if (upper(string[i]) === true) {\n        count++;\n      }\n    }\n    return count;\n  };\n  if (count(string) === length) {\n    return length;\n  }\n  return 0;\n};\n\n/*Write a function that takes a string and return the number of\n   characters that are in lower case\n  Examples\n  lowerCase('Hello') == 5\n  lowerCase('abcdcba') == 5\n  lowerCase('kittens') == 5\n  lowerCase('orange') == 0\n  */\nconst lowerCase = (string) => {\n  const length = string.length;\n  const lower = (string) => {\n    return string.toLowerCase();\n  };\n  const count = (string) => {\n    let count = 0;\n    for (let i = 0; i < string.length; i++) {\n      if (lower(string[i]) === true) {\n        count++;\n      }\n    }\n    return count;\n  };\n  if (count(string) === length) {\n    return length;\n  }\n  return 0;\n};\n\n/*Write a function that takes a string and return the number of\n   characters that are in upper case and lower case\n  Examples\n  bothCase('Hello') == 5\n  bothCase('abcdcba') == 5\n  bothCase('kittens') == 5\n  bothCase('orange') == 0\n  */\nconst bothCase = (string) => {\n  const length = string.length;\n  const upper = (string) => {\n    return string.toUpperCase();\n  };\n  const lower = (string) => {\n    return string.toLowerCase();\n  };\n  const count = (string) => {\n    let count = 0;\n    for (let i = 0; i < string.length; i++) {\n      if (upper(string[i]) === true && lower(string[i]) === true) {\n        count++;\n      }\n    }\n    return count;\n  };\n  if (count(string) === length) {\n    return length;\n  }\n  return 0;\n};\n\n/*Write a function that takes a string and return the number of\n   characters that are in upper case and lower case and upper case\n  Examples\n  bothCase('Hello') == 5\n  bothCase('abcdcba') == 5\n  bothCase('kittens') == 5\n  bothCase('orange') == 0\n  */\nconst bothUpperCase = (string) => {\n  const length = string.length;\n  const upper = (string) => {\n    return string.toUpperCase();\n  };\n  const lower = (string) => {\n    return string.toLowerCase();\n  };\n  const count = (string) => {\n    let count = 0;\n    for (let i = 0; i < string.length; i++) {\n      if (upper(string[i]) === true && lower(string[i]) === true) {\n        count++;\n      }\n    }\n    return count;\n  };\n  if (count(string) === length) {\n    return length;\n  }\n  return 0;\n};\n\n/*Write a function that takes a string and return the number of\n   characters that are in upper case and lower case and lower case\n  Examples\n  bothCase('Hello') == 5\n  bothCase('abcdcba') == 5\n  bothCase('kittens') == 5\n  bothCase('orange') == 0\n  */\nconst bothLowerCase = (string) => {\n  const length = string.length;\n  const upper = (string) => {\n    return string.toUpperCase();\n  };\n  const lower = (string) => {\n    return string.toLowerCase();\n  };\n  const count = (string) => {\n    let count = 0;\n    for (let i = 0; i < string.length; i++) {\n      if (upper(string[i]) === true && lower(string[i]) === true) {\n        count++;\n      }\n    }\n    return count;\n  };\n  if (count(string) === length) {\n    return length;\n  }\n  return 0;\n};\n\n/*Write a function that takes a string and return the number of\n   characters that are in upper case and lower case and upper case\n  Examples\n  bothCase('Hello') == 5\n  bothCase('abcdcba') == 5\n  bothCase('kittens') == 5\n  bothCase('orange') == 0\n  */\nconst bothBothCase = (string) => {\n  const length = string.length;\n  const upper = (string) => {\n    return string.toUpperCase();\n  };\n  const lower = (string) => {\n    return string.toLowerCase();\n  };\n  const count = (string) => {\n    let count = 0;\n    for (let i = 0; i < string.length; i++) {\n      if (upper(string[i]) === true && lower(string[", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/83", "prompt": "/*\n  give a positive integer n, return the count of the number of n-digit\n   positive integer that originate or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "/*\n  give a positive integer n, return the count of the number of n-digit\n   positive integer that originate or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let i = 0\n   while (i < n) {\n     let j = 0\n     while (j < n) {\n       if (i + j == n) {\n         return 1\n       }\n       if (i + j > n) {\n         break\n       }\n       if (i + j < n) {\n         if (i + j == n - 1) {\n           return 1\n         }\n         if (i + j == n - 2) {\n           return 2\n         }\n         if (i + j == n - 3) {\n           return 3\n         }\n       }\n       j++\n     }\n     i++\n   }\n   return 0\n }\n*/\n\nconst startsOneEnds = (n) => {\n  let i = 0\n  while (i < n) {\n    let j = 0\n    while (j < n) {\n      if (i + j == n) {\n        return 1\n      }\n      if (i + j > n) {\n        break\n      }\n      if (i + j < n) {\n        if (i + j == n - 1) {\n          return 1\n        }\n        if (i + j == n - 2) {\n          return 2\n        }\n        if (i + j == n - 3) {\n          return 3\n        }\n      }\n      j++\n    }\n    i++\n  }\n  return 0\n}\n\nconsole.log(startsOneEnds(10))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positivist integer N, return the entire union of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*Given a positivist integer N, return the entire union of its digits in binary star.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const digits = [];\n  for (let i = N; i > 0; i--) {\n    digits.push(i % 2);\n  }\n  return digits.join(\"\");\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integer lst. add the tied element that be at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Given a non - empty list of integer lst. add the tied element that be at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add2 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add3 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add4 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add5 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add6 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add7 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add8 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add9 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add10 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add11 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add12 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add13 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add14 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add15 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add16 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add17 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add18 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add19 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add20 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add21 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add22 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add23 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add24 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add25 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add26 = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconst add27 = (lst)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/86", "prompt": "/*\n  compose a function that takes a chain and reelect an ordered interpretation of it. \n   Ordered version of string, is a chain where all words (separated by distance) \n   are replaced by a modern parole where all the characters stage in\n   ascending order establish on american standard code for information interchange value. \n   bill: You should keep the order of words and blank outer space in the conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that takes a chain and reelect an ordered interpretation of it. \n   Ordered version of string, is a chain where all words (separated by distance) \n   are replaced by a modern parole where all the characters stage in\n   ascending order establish on american standard code for information interchange value. \n   bill: You should keep the order of words and blank outer space in the conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let chain = s.split('')\n  let result = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  while (i < chain.length) {\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if (chain[i] ==='') {\n      i++\n      continue\n    }\n    if", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are give a 2 dimensional datum, as a cuddle tilt, \n   which is exchangeable to matrix, however, unlike matrices, \n   each rowing may check a unlike number of column. \n   give lst, and integer x, find oneself integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (course, column), start with 0. \n   Sort coordinates initially by rows in ascending orderliness. \n   Also, sort coordinates of the row by column in condescend holy order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a 2 dimensional datum, as a cuddle tilt, \n   which is exchangeable to matrix, however, unlike matrices, \n   each rowing may check a unlike number of column. \n   give lst, and integer x, find oneself integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (course, column), start with 0. \n   Sort coordinates initially by rows in ascending orderliness. \n   Also, sort coordinates of the row by column in condescend holy order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\n/*\n  Given a 2 dimensional datum, as a cuddle tilt, \n   which is exchangeable to matrix, however, unlike matrices, \n   each rowing may check a unlike number of column. \n   give lst, and integer x, find oneself integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (course, column), start with 0. \n   Sort coordinates initially by rows in ascending orderliness. \n   Also, sort coordinates of the row by column in condescend holy order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        res.push([i, j])\n      }\n    }\n  }\n  return res\n}\n\nconst getRow = (lst, x) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let row = lst[i]\n    for (let j = 0; j < row.length;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  give an array of non - damaging integer, return a copy of the give array after screen, \n   you will sort the given array in ascend decree if the sum (beginning exponent value, final exponent value) is curious, \n   or sort it in descending ordering if the kernel (first index value, last index value) cost even. \n\n   Note: \n   * don't change the give array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  give an array of non - damaging integer, return a copy of the give array after screen, \n   you will sort the given array in ascend decree if the sum (beginning exponent value, final exponent value) is curious, \n   or sort it in descending ordering if the kernel (first index value, last index value) cost even. \n\n   Note: \n   * don't change the give array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sortedArray = array.slice();\n  let sortedArrayLength = sortedArray.length;\n  let sortedArrayIndex = 0;\n  let sortedArrayIndexEnd = sortedArrayLength - 1;\n  let sortedArrayIndexBegin = 0;\n  let sortedArrayIndexEndBegin = sortedArrayIndexEnd - 1;\n  let sortedArrayIndexEndEnd = sortedArrayIndexEnd + 1;\n  let sortedArrayIndexBeginEnd = sortedArrayIndexEnd - 1;\n  let sortedArrayIndexBeginEndBegin = sortedArrayIndexEndBegin - 1;\n  let sortedArrayIndexBeginEndEnd = sortedArrayIndexEndBegin + 1;\n  let sortedArrayIndexBeginEndBeginEnd = sortedArrayIndexEndBeginEnd - 1;\n  let sortedArrayIndexBeginEndBeginEnd = sortedArrayIndexEndBeginEnd + 1;\n  let sortedArrayIndexBeginEndBeginEndEnd = sortedArrayIndexEndBeginEndBeginEnd - 1;\n  while (sortedArrayIndex <= sortedArrayIndexEnd) {\n    let sortedArrayIndexBegin = sortedArrayIndex;\n    let sortedArrayIndexEndBegin = sortedArrayIndexEndBegin;\n    let sortedArrayIndexEndEnd = sortedArrayIndexEndEndBegin;\n    let sortedArrayIndexBeginEnd = sortedArrayIndexBeginEnd;\n    let sortedArrayIndexBeginEndBegin = sortedArrayIndexBeginEndBegin;\n    let sortedArrayIndexBeginEndEnd = sortedArrayIndexBeginEndBeginEnd;\n    let sortedArrayIndexBeginEndBeginEnd = sortedArrayIndexBeginEndBeginEnd;\n    let sortedArrayIndexBeginEndBeginEndEnd = sortedArrayIndexBeginEndBeginEndBeginEnd;\n    while (sortedArrayIndexBegin <= sortedArrayIndexBeginEnd) {\n      let sortedArrayIndexBeginEndBegin = sortedArrayIndexBeginEndBegin;\n      let sortedArrayIndexBeginEndEnd = sortedArrayIndexBeginEndBeginEnd;\n      let sortedArrayIndexBeginEndBeginEnd = sortedArrayIndexBeginEndBeginEndBegin;\n      let sortedArrayIndexBeginEndBeginEndEnd = sortedArrayIndexBeginEndBeginEndBeginEnd;\n      while (sortedArrayIndexBeginEndBegin <= sortedArrayIndexBeginEndBeginEnd) {\n        let sortedArrayIndexBeginEndBeginEnd = sortedArrayIndexBeginEndBeginEndBegin;\n        let sortedArrayIndexBeginEndBeginEndEnd = sortedArrayIndexBeginEndBeginEndBeginEnd;\n        while (sortedArrayIndexBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndEnd) {\n          let sortedArrayIndexBeginEndBeginEndEnd = sortedArrayIndexBeginEndBeginEndBeginEnd;\n          while (sortedArrayIndexBeginEndBeginEndEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n            while (sortedArrayIndexBeginEndBeginEndEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n              while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                  while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                    while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                      while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                        while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                          while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                            while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                              while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                  while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                    while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                      while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                        while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                          while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                            while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                              while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                  while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                    while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                      while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                        while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                          while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                            while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                              while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd) {\n                                                                while (sortedArrayIndexBeginEndBeginEndBeginEnd <= sortedArrayIndexBeginEndBeginEndBeginEnd)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a affair encrypt that takes a chain as an argumentation and \n   returns a chain encrypted with the alphabet being rotated. \n   The rudiment should be rotated in a manner such that the letters \n   careen down by two multiply to two space.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "/*Create a affair encrypt that takes a chain as an argumentation and \n   returns a chain encrypted with the alphabet being rotated. \n   The rudiment should be rotated in a manner such that the letters \n   careen down by two multiply to two space.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let result = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = s[i];\n    let index = (i + 1) % s.length;\n    let nextLetter = s[index];\n    let nextIndex = (index + 1) % s.length;\n    let nextNextLetter = s[nextIndex];\n    let nextNextIndex = (nextIndex + 1) % s.length;\n    let nextNextNextLetter = s[nextNextIndex];\n    let nextNextNextIndex = (nextNextIndex + 1) % s.length;\n    let nextNextNextNextLetter = s[nextNextNextIndex];\n    let nextNextNextNextLetter = s[nextNextNextNextIndex];\n    let nextNextNextNextLetter = s[nextNextNextNextIndex];\n    let nextNextNextNextLetter = s[nextNextNextNextNextIndex];\n    let nextNextNextNextNextLetter = s[nextNextNextNextNextIndex];\n    let nextNextNextNextNextLetter = s[nextNextNextNextNextNextIndex];\n    let nextNextNextNextNextLetter = s[nextNextNextNextNextNextIndex];\n    let nextNextNextNextNextLetter = s[nextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex];\n    let nextNextNextNextNextNextLetter = s[nextNextNextNextNextNextNextIndex", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "/* From a give list of integers, render a list of roll maximal element find until given here and now \n   in the succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  let i = 1;\n  while (i < numbers.length) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n    }\n    i++;\n  }\n  return [max, maxIndex];\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are give a list of integers. \n   publish a routine nextSmallest() that return the second smallest component of the list.\n   Return null if there is no such component. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "/*\n  You are give a list of integers. \n   publish a routine nextSmallest() that return the second smallest component of the list.\n   Return null if there is no such component. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n  let smallest = lst[0];\n  let index = 0;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n      index = i;\n    }\n  }\n  return lst[index + 1];\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be give a string of parole, and your job equal to reckon the act \n   of boredoms. A boredom is a conviction that start with the discussion \" I \". \n   conviction are delimited by'.','?' or'!'. \n \n   For exercise:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "/*\n  You'll be give a string of parole, and your job equal to reckon the act \n   of boredoms. A boredom is a conviction that start with the discussion \" I \". \n   conviction are delimited by'.','?' or'!'. \n \n   For exercise:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const len = S.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let c = 0\n  let isBored = 0\n  while (i < len) {\n    c = S[i]\n    if (c === '.' || c === '?' || c === '!') {\n      j = i\n      while (j < len && S[j]!== '.' && S[j]!== '?' && S[j]!== '!') {\n        j++\n      }\n      if (j === len) {\n        isBored = 1\n        break\n      }\n      if (S[j] === '.' || S[j] === '?' || S[j] === '!') {\n        k = j\n        while (k < len && S[k]!== '.' && S[k]!== '?' && S[k]!== '!') {\n          k++\n        }\n        if (k === len) {\n          isBored = 1\n          break\n        }\n        if (S[k] === '.' || S[k] === '?' || S[k] === '!') {\n          isBored = 1\n          break\n        }\n      }\n    }\n    i++\n  }\n  return isBored\n}\n\nconsole.log(isBored(\"Hello world\"))\nconsole.log(isBored(\"The sky is blue. The sun is shining. I love this weather\"))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/92", "prompt": "/* produce a function that takes 3 number. \n   return true if one of the number is equal to the sum of the early two, and all numbers are integer. \n   Returns fake in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "/* produce a function that takes 3 number. \n   return true if one of the number is equal to the sum of the early two, and all numbers are integer. \n   Returns fake in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt2 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt3 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt4 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt5 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt6 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt7 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt8 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt9 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt10 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt11 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt12 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt13 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt14 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt15 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt16 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt17 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt18 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt19 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt20 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt21 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt22 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt23 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt24 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt25 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt26 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt27 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt28 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt29 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt30 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt31 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt32 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt33 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt34 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt35 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt36 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0;\n};\n\nconst anyInt37 = (x, y, z) => {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  compose a function that takes a message, and encodes in such a \n   means that it swap casing of all letter, replaces all vowels in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english rudiment. \n   Assume only letter. \n  \n   exemplar:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "/*\n  compose a function that takes a message, and encodes in such a \n   means that it swap casing of all letter, replaces all vowels in \n   the message with the letter that appears 2 places ahead of that \n   vowel in the english rudiment. \n   Assume only letter. \n  \n   exemplar:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const consonants_index = consonants.indexOf(message.charAt(0))\n  const vowels_index = vowels.indexOf(message.charAt(0))\n  const consonants_index_2 = consonants.indexOf(message.charAt(1))\n  const vowels_index_2 = vowels.indexOf(message.charAt(1))\n  const consonants_index_3 = consonants.indexOf(message.charAt(2))\n  const vowels_index_3 = vowels.indexOf(message.charAt(2))\n  const consonants_index_4 = consonants.indexOf(message.charAt(3))\n  const vowels_index_4 = vowels.indexOf(message.charAt(3))\n  const consonants_index_5 = consonants.indexOf(message.charAt(4))\n  const vowels_index_5 = vowels.indexOf(message.charAt(4))\n  const consonants_index_6 = consonants.indexOf(message.charAt(5))\n  const vowels_index_6 = vowels.indexOf(message.charAt(5))\n  const consonants_index_7 = consonants.indexOf(message.charAt(6))\n  const vowels_index_7 = vowels.indexOf(message.charAt(6))\n  const consonants_index_8 = consonants.indexOf(message.charAt(7))\n  const vowels_index_8 = vowels.indexOf(message.charAt(7))\n  const consonants_index_9 = consonants.indexOf(message.charAt(8))\n  const vowels_index_9 = vowels.indexOf(message.charAt(8))\n  const consonants_index_10 = consonants.indexOf(message.charAt(9))\n  const vowels_index_10 = vowels.indexOf(message.charAt(9))\n  const consonants_index_11 = consonants.indexOf(message.charAt(10))\n  const vowels_index_11 = vowels.indexOf(message.charAt(10))\n  const consonants_index_12 = consonants.indexOf(message.charAt(11))\n  const vowels_index_12 = vowels.indexOf(message.charAt(11))\n  const consonants_index_13 = consonants.indexOf(message.charAt(12))\n  const vowels_index_13 = vowels.indexOf(message.charAt(12))\n  const consonants_index_14 = consonants.indexOf(message.charAt(13))\n  const vowels_index_14 = vowels.indexOf(message.charAt(13))\n  const consonants_index_15 = consonants.indexOf(message.charAt(14))\n  const vowels_index_15 = vowels.indexOf(message.charAt(14))\n  const consonants_index_16 = consonants.indexOf(message.charAt(15))\n  const vowels_index_16 = vowels.indexOf(message.charAt(15))\n  const consonants_index_17 = consonants.indexOf(message.charAt(16))\n  const vowels_index_17 = vowels.indexOf(message.charAt(16))\n  const consonants_index_18 = consonants.indexOf(message.charAt(17))\n  const vowels_index_18 = vowels.indexOf(message.charAt(17))\n  const consonants_index_19 = consonants.indexOf(message.charAt(18))\n  const vowels_index_19 = vowels.indexOf(message.charAt(18))\n  const consonants_index_20 = consonants.indexOf(message.charAt(19))\n  const vowels_index_20 = vowels.indexOf(message.charAt(19))\n  const consonants_index_21 = consonants.indexOf(message.charAt(20))\n  const vowels_index_21 = vowels.indexOf(message.charAt(20))\n  const consonants_index_22 = consonants.indexOf(message.charAt(21))\n  const vowels_index_22 = vowels.indexOf(message.charAt(21))\n  const consonants_index_23 = consonants.indexOf(message.charAt(22))\n  const vowels_index_23 = vowels.indexOf(message.charAt(22))\n  const consonants_index_24 = consonants.indexOf(message.charAt(23))\n  const vowels_index_24 = vowels.indexOf(message.charAt(23))\n  const consonants_index_25 = consonants.indexOf(message.charAt(24))\n  const vowels_index_25 = vowels.indexOf(message.charAt(24))\n  const consonants_index_26 = consonants.indexOf(message.charAt(25))\n  const vowels_index_26 = vowels.indexOf(message.charAt(25))\n  const consonants_index_27 = consonants.indexOf(message.charAt(26))\n  const vowels_index_27 = vowels.indexOf(message.charAt(26))\n  const consonants_index_28 = consonants.indexOf(message.charAt(27))\n  const vowels_index_28 = vowels.indexOf(message.charAt(27))\n  const consonants_index_29 = consonants.indexOf(message.charAt(28))\n  const vowels_index_29 = vowels", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are give a list of integers. \n   You necessitate to determine the large choice value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "/*You are give a list of integers. \n   You necessitate to determine the large choice value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  give a dictionary, return truthful if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "/*\n  give a dictionary, return truthful if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let result = true;\n  for (let key in dict) {\n    if (key.toLowerCase()!== key) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n}\n\n/*\n  give a dictionary, return true if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase2 = (dict) => {\n  let result = true;\n  for (let key in dict) {\n    if (key.toUpperCase()!== key) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n}\n\n/*\n  give a dictionary, return true if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase3 = (dict) => {\n  let result = true;\n  for (let key in dict) {\n    if (key.toLowerCase()!== key) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n}\n\n/*\n  give a dictionary, return true if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase4 = (dict) => {\n  let result = true;\n  for (let key in dict) {\n    if (key.toUpperCase()!== key) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n}\n\n/*\n  give a dictionary, return true if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase5 = (dict) => {\n  let result = true;\n  for (let key in dict) {\n    if (key.toLowerCase()!== key) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n}\n\n/*\n  give a dictionary, return true if all key equal chain in lower \n   case or all keys are chain in upper case, else return false. \n   The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase6 = (dict) => {\n  let result = true;\n  for (let key in dict) {\n    if (key.toUpperCase()!== key) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n}\n\n/*\n  give", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a affair that takes an non - minus integer and render an array of the first n\n   integers that be choice number and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "/*Implement a affair that takes an non - minus integer and render an array of the first n\n   integers that be choice number and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconsole.log(countUpTo(5))\nconsole.log(countUpTo(11))\nconsole.log(countUpTo(0))\nconsole.log(countUpTo(20))\nconsole.log(countUpTo(1))\nconsole.log(countUpTo(18))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the affair that takes two integer and return \n   the intersection of their whole digit. \n   Assume the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "/*Complete the affair that takes two integer and return \n   the intersection of their whole digit. \n   Assume the input is constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_int = a.toString().split('').map(x => parseInt(x));\n  let b_int = b.toString().split('').map(x => parseInt(x));\n  let a_int_len = a_int.length;\n  let b_int_len = b_int.length;\n  let a_int_len_min = Math.min(a_int_len, b_int_len);\n  let a_int_len_max = Math.max(a_int_len, b_int_len);\n  let a_int_len_sum = a_int_len_min + a_int_len_max;\n  let b_int_len_sum = a_int_len_min + b_int_len_max;\n  let a_int_len_sum_min = Math.min(a_int_len_sum, b_int_len_sum);\n  let a_int_len_sum_max = Math.max(a_int_len_sum, b_int_len_sum);\n  let a_int_len_sum_diff = a_int_len_sum_min - a_int_len_sum_max;\n  let b_int_len_sum_diff = b_int_len_sum_min - b_int_len_sum_max;\n  let a_int_len_sum_diff_min = Math.min(a_int_len_sum_diff, b_int_len_sum_diff);\n  let a_int_len_sum_diff_max = Math.max(a_int_len_sum_diff, b_int_len_sum_diff);\n  let a_int_len_sum_diff_sum = a_int_len_sum_diff_min + a_int_len_sum_diff_max;\n  let a_int_len_sum_diff_diff = a_int_len_sum_diff_sum - a_int_len_sum_diff_max;\n  let b_int_len_sum_diff_diff = b_int_len_sum_diff_sum - b_int_len_sum_diff_max;\n  let a_int_len_sum_diff_diff_min = Math.min(a_int_len_sum_diff_diff, b_int_len_sum_diff_diff);\n  let a_int_len_sum_diff_diff_max = Math.max(a_int_len_sum_diff_diff, b_int_len_sum_diff_diff);\n  let a_int_len_sum_diff_diff_sum = a_int_len_sum_diff_diff_min + a_int_len_sum_diff_diff_max;\n  let a_int_len_sum_diff_diff_diff = a_int_len_sum_diff_diff_sum - a_int_len_sum_diff_diff_max;\n  let a_int_len_sum_diff_diff_diff_min = Math.min(a_int_len_sum_diff_diff_diff, b_int_len_sum_diff_diff_diff);\n  let a_int_len_sum_diff_diff_diff_max = Math.max(a_int_len_sum_diff_diff_diff, b_int_len_sum_diff_diff_diff);\n  let a_int_len_sum_diff_diff_diff_sum = a_int_len_sum_diff_diff_diff_min + a_int_len_sum_diff_diff_diff_max;\n  let a_int_len_sum_diff_diff_diff_diff = a_int_len_sum_diff_diff_diff_sum - a_int_len_sum_diff_diff_diff_max;\n  let a_int_len_sum_diff_diff_diff_diff_min = Math.min(a_int_len_sum_diff_diff_diff_diff, b_int_len_sum_diff_diff_diff_diff);\n  let a_int_len_sum_diff_diff_diff_diff_max = Math.max(a_int_len_sum_diff_diff_diff_diff, b_int_len_sum_diff_diff_diff_diff);\n  let a_int_len_sum_diff_diff_diff_diff_sum = a_int_len_sum_diff_diff_diff_diff_min + a_int_len_sum_diff_diff_diff_diff_max;\n  let a_int_len_sum_diff_diff_diff_diff_diff = a_int_len_sum_diff_diff_diff_diff_sum - a_int_len_sum_diff_diff_diff_diff_max;\n  let a_int_len_sum_diff_diff_diff_diff_diff_min = Math.min(a_int_len_sum_diff_diff_diff_diff_diff, b_int_len_sum_diff_diff_diff_diff_diff);\n  let a_int_len_sum_diff_diff_diff_diff_diff_max = Math.max(a_int_len_sum_diff_diff_diff_diff_diff, b_int_len_sum_diff_diff_diff_diff_diff);\n  let a_int_len_sum_diff_diff_diff_diff_diff_sum = a_int_len_sum_diff_diff_diff_diff_diff_min + a_int_len_sum_diff_diff_diff_diff_diff_max;\n  let a_int_len_sum_diff_diff_diff_diff_diff_diff_min = Math.min(a_int_len_sum_diff_diff_diff_diff_diff_diff, b_int_len_sum_diff_diff_diff_diff_diff_diff);\n  let a_int_len_sum_diff_diff_diff_diff_diff_diff_max = Math.max(a_int_len_sum_diff_diff_diff_diff_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  give a string s, consider the phone number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "/*\n  give a string s, consider the phone number of capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countUpper('aBCdEf'));\nconsole.log(countUpper('abcdefg'));\nconsole.log(countUpper('dBBE'));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* produce a function that takes a value (chain) represent a number \n   and render the closest integer to it. If the number be equidistant \n   from two integers, round it off from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "/* produce a function that takes a value (chain) represent a number \n   and render the closest integer to it. If the number be equidistant \n   from two integers, round it off from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let closest = value;\n  let closestIndex = 0;\n  let closestDistance = Math.abs(closest - Math.round(closest));\n  let currentDistance = Math.abs(closest - Math.round(closest));\n  let currentIndex = 1;\n  while (currentDistance > closestDistance) {\n    closest = Math.round(closest);\n    closestIndex = currentIndex;\n    closestDistance = currentDistance;\n    currentDistance = Math.abs(closest - Math.round(closest));\n    currentIndex++;\n  }\n  return closest;\n};\n\n/*\n  Given a list of numbers, return the closest number to the given number.\n  If the given number is not in the list, return the closest number in the list.\n  Examples\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"1\")\n  1\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"6\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"7\")\n  2\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0\")\n  1\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.1\")\n  1\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.2\")\n  2\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.3\")\n  3\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.4\")\n  4\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.5\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.6\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.7\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.8\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"0.9\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"1\")\n  1\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"2\")\n  2\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"3\")\n  3\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"4\")\n  4\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"5\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"6\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"7\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"8\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"9\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"10\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"11\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"12\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"13\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"14\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"15\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"16\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"17\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"18\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"19\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"20\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"21\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"22\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"23\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"24\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"25\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"26\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"27\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"28\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"29\")\n  5\n  >>> closestNumber([\"1\", \"2\", \"3\", \"4\", \"5\"], \"30\")\n  5\n  >>> closestNumber(", "passed": 1, "run_status": 0}
