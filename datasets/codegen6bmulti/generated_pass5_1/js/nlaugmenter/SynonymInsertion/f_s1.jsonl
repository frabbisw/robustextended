{"task_id": "JavaScript/0", "prompt": "/* Check match if in given pass list of numbers, are any two numbers closer to each other than \n   given hold threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 1, "perturbed": true, "gc": "/* Check match if in given pass list of numbers, are any two numbers closer to each other than \n   given hold threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements2 = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements3 = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements4 = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements5 = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements6 = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements7 = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements8 = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort();\n  const len = sortedNumbers.length;\n  let i = 0;\n  let j = 1;\n  while (i < len && j < len) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[j]) < threshold) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n};\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>>", "passed": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input input signal to this function routine is a string containing incorporate multiple groups of nested nest parentheses. Your goal finish is to \n   separate those group into separate freestanding strings and return the list of those. \n   Separate disjoined groups group are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string containing incorporate multiple groups of nested nest parentheses. Your goal finish is to \n   separate those group into separate freestanding strings and return the list of those. \n   Separate disjoined groups group are balanced (each open brace couple is properly closed) and not nested within each other \n   Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_regex = /\\(|\\)/g;\n  const paren_list = paren_string.match(paren_regex);\n  const paren_list_length = paren_list.length;\n  const paren_list_array = [];\n  for (let i = 0; i < paren_list_length; i++) {\n    paren_list_array.push(paren_list[i]);\n  }\n  return paren_list_array;\n};\n\n/*\n  Input:\n  '(((())))'\n  Output:\n  '((()))'\n  */\nconst remove_nested_parens = (paren_string) => {\n  const paren_regex = /\\(|\\)/g;\n  const paren_list = paren_string.match(paren_regex);\n  const paren_list_length = paren_list.length;\n  const paren_list_array = [];\n  for (let i = 0; i < paren_list_length; i++) {\n    paren_list_array.push(paren_list[i]);\n  }\n  const paren_list_array_length = paren_list_array.length;\n  for (let i = 0; i < paren_list_array_length; i++) {\n    const paren_list_array_item = paren_list_array[i];\n    const paren_list_array_item_length = paren_list_array_item.length;\n    const paren_list_array_item_array = [];\n    for (let j = 0; j < paren_list_array_item_length; j++) {\n      paren_list_array_item_array.push(paren_list_array_item[j]);\n    }\n    paren_list_array_item_array.push(paren_list_array_item[0]);\n    paren_list_array.push(paren_list_array_item_array);\n  }\n  return paren_list_array;\n};\n\n/*\n  Input:\n  '(((())))'\n  Output:\n  '((()))'\n  */\nconst remove_nested_parens_2 = (paren_string) => {\n  const paren_regex = /\\(|\\)/g;\n  const paren_list = paren_string.match(paren_regex);\n  const paren_list_length = paren_list.length;\n  const paren_list_array = [];\n  for (let i = 0; i < paren_list_length; i++) {\n    paren_list_array.push(paren_list[i]);\n  }\n  const paren_list_array_length = paren_list_array.length;\n  for (let i = 0; i < paren_list_array_length; i++) {\n    const paren_list_array_item = paren_list_array[i];\n    const paren_list_array_item_length = paren_list_array_item.length;\n    const paren_list_array_item_array = [];\n    for (let j = 0; j < paren_list_array_item_length; j++) {\n      paren_list_array_item_array.push(paren_list_array_item[j]);\n    }\n    paren_list_array_item_array.push(paren_list_array_item[0]);\n    paren_list_array.push(paren_list_array_item_array);\n  }\n  return paren_list_array;\n};\n\n/*\n  Input:\n  '(((())))'\n  Output:\n  '((()))'\n  */\nconst remove_nested_parens_3 = (paren_string) => {\n  const paren_regex = /\\(|\\)/g;\n  const paren_list = paren_string.match(paren_regex);\n  const paren_list_length = paren_list.length;\n  const paren_list_array = [];\n  for (let i = 0; i < paren_list_length; i++) {\n    paren_list_array.push(paren_list[i]);\n  }\n  const paren_list_array_length = paren_list_array.length;\n  for (let i = 0; i < paren_list_array_length; i++) {\n    const paren_list_array_item = paren_list_array[i];\n    const paren_list_array_item_length = paren_list_array_item.length;\n    const paren_list_array_item_array = [];\n    for (let j = 0; j < paren_list_array_item_length; j++) {\n      paren_list_array_item_array.push(paren_list_array_item[j]);\n    }\n    paren_list_array_item_array.push(paren_list_array_item[0]);\n    paren_list_array.push(paren_list_array_item_array);\n  }\n  return paren_list_array;\n};\n\n/*\n  Input:\n  '(((())))'\n  Output:\n  '((()))'\n  */\nconst remove_nested_parens_4 = (paren_string) => {\n  const paren_regex = /\\(|\\)/g;\n  const paren_list = paren_string.match(paren_regex);\n  const paren_list_length = paren_list.length;\n  const paren_list_array = [];\n  for (let i = 0; i < paren_list_length; i++) {\n    paren_list_array.push(paren_list[i]);\n  }\n  const paren_list_array_length = paren_list_array.length;\n  for (let i = 0;", "passed": 0}
{"task_id": "JavaScript/10", "prompt": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Test if the string is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find recover the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end conclusion of the string reverse reversion of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = string.split('').reverse().join('');\n  const prefix = string.split('').join('');\n  const result = prefix + suffix;\n  return result;\n}\n\n/* Find witness the shortest palindrome that begins begin with a supplied string.\n   Algorithm idea estimate is simple: \n   - Find", "passed": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given grant a positive integer n, you have to make seduce a pile atomic pile of n levels grade of stones. \n   The first inaugural level has n stones stone. \n   The number of stones gem in the next future level is: \n       - the next following odd leftover number if n is odd curious. \n       - the next even number if n is even. \n   Return the number of stones in each level in a list, where element at index exponent \n   i represents the number of stones in the level degree (i+1).\n\n   Examples model:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, you have to make seduce a pile atomic pile of n levels grade of stones. \n   The first inaugural level has n stones stone. \n   The number of stones gem in the next future level is: \n       - the next following odd leftover number if n is odd curious. \n       - the next even number if n is even. \n   Return the number of stones in each level in a list, where element at index exponent \n   i represents the number of stones in the level degree (i+1).\n\n   Examples model:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  const isOdd = (n) => n % 2 === 1;\n  const isEven = (n) => n % 2 === 0;\n  const isEvenOdd = (n) => isEven(n) || isOdd(n);\n  const isEvenOddOdd = (n) => isEvenOdd(n) || isOdd(n);\n  const isEvenOddOddOdd = (n) => isEvenOddOdd(n) || isOddOdd(n);\n  const isEvenOddOddOddOdd = (n) => isEvenOddOddOdd(n) || isOddOddOdd(n);\n  const isEvenOddOddOddOddOdd = (n) => isEvenOddOddOddOdd(n) || isOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOdd(n) || isOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOdd(n) || isOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOdd(n) || isOddOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOddOdd(n) || isOddOddOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOddOddOdd(n) || isOddOddOddOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOddOddOddOdd(n) || isOddOddOddOddOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOddOddOddOddOdd(n) || isOddOddOddOddOddOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOddOddOddOddOddOdd(n) || isOddOddOddOddOddOddOddOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOddOddOddOddOddOddOdd(n) || isOddOddOddOddOddOddOddOddOddOddOddOddOddOddOdd(n);\n  const isEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOdd = (n) => isEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddO", "passed": 0}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given grant a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 1, "perturbed": true, "gc": "/*\n  You will be given grant a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\s|,)/g);\n  return words;\n}\n\n/*\n  You will be given a string of words word separated distinguish by commas comma or spaces. Your task job is \n   to split the string drawstring into words and return an array of the words discussion.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/(\\", "passed": 0}
{"task_id": "JavaScript/102", "prompt": "/*This function affair takes lead two positive numbers phone number x and y and returns the \n   biggest bad even integer number that is in the range image [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead two positive numbers phone number x and y and returns the \n   biggest bad even integer number that is in the range image [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x < y) {\n    return -1;\n  }\n  let x1 = x;\n  let y1 = y;\n  let x2 = x;\n  let y2 = y;\n  while (x1 < y1) {\n    x2 = x1 + 2;\n    y2 = y1;\n    while (x2 < y2) {\n      if (x2 % 2 === 0) {\n        return x2;\n      }\n      x2 += 2;\n    }\n    x1 += 2;\n  }\n  return -1;\n};\n\nconsole.log(chooseNum(12, 15));\nconsole.log(chooseNum(13, 12));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given grant two positive integers integer n and m, and your task undertaking is to compute calculate the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest cheeseparing integer and convert that to binary. \n   If n is greater great than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 1, "perturbed": true, "gc": "/*You are given grant two positive integers integer n and m, and your task undertaking is to compute calculate the \n   average of the integers from n through m (including admit n and m). \n   Round the answer to the nearest cheeseparing integer and convert that to binary. \n   If n is greater great than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const n_m = n + m;\n  const n_m_1 = n_m - 1;\n  const n_m_2 = n_m - 2;\n  const n_m_3 = n_m - 3;\n  const n_m_4 = n_m - 4;\n  const n_m_5 = n_m - 5;\n  const n_m_6 = n_m - 6;\n  const n_m_7 = n_m - 7;\n  const n_m_8 = n_m - 8;\n  const n_m_9 = n_m - 9;\n  const n_m_10 = n_m - 10;\n  const n_m_11 = n_m - 11;\n  const n_m_12 = n_m - 12;\n  const n_m_13 = n_m - 13;\n  const n_m_14 = n_m - 14;\n  const n_m_15 = n_m - 15;\n  const n_m_16 = n_m - 16;\n  const n_m_17 = n_m - 17;\n  const n_m_18 = n_m - 18;\n  const n_m_19 = n_m - 19;\n  const n_m_20 = n_m - 20;\n  const n_m_21 = n_m - 21;\n  const n_m_22 = n_m - 22;\n  const n_m_23 = n_m - 23;\n  const n_m_24 = n_m - 24;\n  const n_m_25 = n_m - 25;\n  const n_m_26 = n_m - 26;\n  const n_m_27 = n_m - 27;\n  const n_m_28 = n_m - 28;\n  const n_m_29 = n_m - 29;\n  const n_m_30 = n_m - 30;\n  const n_m_31 = n_m - 31;\n  const n_m_32 = n_m - 32;\n  const n_m_33 = n_m - 33;\n  const n_m_34 = n_m - 34;\n  const n_m_35 = n_m - 35;\n  const n_m_36 = n_m - 36;\n  const n_m_37 = n_m - 37;\n  const n_m_38 = n_m - 38;\n  const n_m_39 = n_m - 39;\n  const n_m_40 = n_m - 40;\n  const n_m_41 = n_m - 41;\n  const n_m_42 = n_m - 42;\n  const n_m_43 = n_m - 43;\n  const n_m_44 = n_m - 44;\n  const n_m_45 = n_m - 45;\n  const n_m_46 = n_m - 46;\n  const n_m_47 = n_m - 47;\n  const n_m_48 = n_m - 48;\n  const n_m_49 = n_m - 49;\n  const n_m_50 = n_m - 50;\n  const n_m_51 = n_m - 51;\n  const n_m_52 = n_m - 52;\n  const n_m_53 = n_m - 53;\n  const n_m_54 = n_m - 54;\n  const n_m_55 = n_m - 55;\n  const n_m_56 = n_m - 56;\n  const n_m_57 = n_m - 57;\n  const n_m_58 = n_m - 58;\n  const n_m_59 = n_m - 59;\n  const n_m_60 = n_m - 60;\n  const n_m_61 = n_m - 61;\n  const n_m_62 = n_m - 62;\n  const n_m_63 = n_m - 63;\n  const n_m_64 = n_m - 64;\n  const n_m_65 = n_m - 65;\n  const n_m_66 = n_m - 66;\n  const n_m_67 = n_m - 67;\n  const n_m_68 = n_m - 68;\n  const n_m_69 = n_m - 69;\n  const n_m_70 = n_m - 70;\n  const n_m_71 = n_m - 71;\n  const n_m_72 = n_m - 72;\n  const n_m_73 = n_m - 73;\n  const n_m_74 = n_m - 74;\n  const n_m_75 = n_m - 75;\n  const n_m_76 = n_m - 76;\n  const n_m_77 = n_m - 77;\n  const n_m_78 = n_m - 78;\n  const n_m_79 = n_m - 79;\n  const n_m_80 = n_m - 80;\n  const n_m_81 = n_m - 81;\n  const n_m_82 = n_m - 82;\n  const n_m_83 = n_m - 83;\n  const n_m_84 = n_m - 84;\n  const n_m_85 = n_m - 85;\n  const n_m_86 = n_m - 86;\n  const n_m_87 = n_m - 87;\n  const n_m_88 = n_m - 88;\n  const n_m_89 = n_m - 89;\n  const n_m_90 = n_m - 90;\n  const n_m_91 = n_m - 91;\n  const n_m_92 =", "passed": 0}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive cocksure integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted in increasing increase order. \n  \n   For example model:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 1, "perturbed": true, "gc": "/*Given a list of positive cocksure integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted in increasing increase order. \n  \n   For example model:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = []\n  for (let i = 0; i < x; i++) {\n    const digit = x % 10\n    if (digit % 2 === 0) {\n      digits.push(digit)\n    }\n    x = Math.floor(x / 10)\n  }\n  return digits\n}\n\nconsole.log(uniqueDigits([15, 33, 1422, 1]))\nconsole.log(uniqueDigits([152, 323, 1422, 10]))\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given grant an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse revoke the resulting result array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of integers, sort the integers integer that are between 1 and 9 inclusive, \n   reverse revoke the resulting result array, and then replace each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength2 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength3 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength4 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength5 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength6 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength7 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength8 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength9 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength10 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength11 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength12 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength13 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength14 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return reversed.map(x => names[x]);\n};\n\nconst byLength15 = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five", "passed": 0}
{"task_id": "JavaScript/106", "prompt": "/* Implement follow through the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element component at index i is the factorial of i if i is even \n   or the sum kernel of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication generation of the numbers issue from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "/* Implement follow through the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element component at index i is the factorial of i if i is even \n   or the sum kernel of numbers from 1 to i otherwise differently. \n   i starts from 1. \n   the factorial of i is the multiplication generation of the numbers issue from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const factorials = []\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i)\n  }\n  return factorials\n}\n\nconst sumKernel = (n) => {\n  const kernel = []\n  for (let i = 1; i <= n; i++) {\n    kernel.push(f(i))\n  }\n  return kernel\n}\n\nconst sum = (n) => {\n  const sum = []\n  for (let i = 1; i <= n; i++) {\n    sum.push(f(i))\n  }\n  return sum\n}\n\nconst main = () => {\n  const n = 5\n  const kernel = sumKernel(n)\n  const sum = sum(n)\n  console.log(kernel)\n  console.log(sum)\n}\n\nmain()\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given grant a positive integer n, return a tuple that has the number issue of even and odd curious \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return a tuple that has the number issue of even and odd curious \n   integer palindromes palindrome that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0, odd = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 2 === 0) {\n        even++;\n      } else {\n        odd++;\n      }\n      num = Math.floor(num / 2);\n    }\n  }\n  return [even, odd];\n};\n\nexport default evenOddPalindrome;\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number issue of elements which has a sum kernel of digits > 0. \n   If a number act is negative, then its first beginning signed bless digit will be negative minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number issue of elements which has a sum kernel of digits > 0. \n   If a number act is negative, then its first beginning signed bless digit will be negative minus: \n   e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (sum > 0) {\n      count++;\n    }\n    sum -= arr[i];\n  }\n  return count;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers integer arr[1], arr[2],... , arr[N].The\n   numbers phone number in the array will be randomly ordered. Your task undertaking is to determine if \n   it is possible potential to get an array sorted classify in non - decreasing order by performing do \n   the following operation mathematical process on the given feed array: \n       You are allowed to perform do right shift operation any number of times. \n  \n   One right shift operation process means shifting all elements of the array by one \n   position situation in the right direction steering. The last final element of the array will be moved to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain prevail the sorted array by performing the above operation \n   then return true else return false. \n   If the given array is empty then return true dependable. \n\n   Note: The given list is guaranteed undertake to have unique singular elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 1, "perturbed": true, "gc": "/*We have an array 'arr' of N integers integer arr[1], arr[2],..., arr[N].The\n   numbers phone number in the array will be randomly ordered. Your task undertaking is to determine if \n   it is possible potential to get an array sorted classify in non - decreasing order by performing do \n   the following operation mathematical process on the given feed array: \n       You are allowed to perform do right shift operation any number of times. \n  \n   One right shift operation process means shifting all elements of the array by one \n   position situation in the right direction steering. The last final element of the array will be moved to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain prevail the sorted array by performing the above operation \n   then return true else return false. \n   If the given array is empty then return true dependable. \n\n   Note: The given list is guaranteed undertake to have unique singular elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall2 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall3 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall4 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall5 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall6 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall7 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall8 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      break;\n    }\n  }\n  return i === j;\n};\n\nconst moveOneBall9 = (arr) => {\n  if (!arr || arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      ", "passed": 0}
{"task_id": "JavaScript/11", "prompt": "/* Input input signal are two strings string a and b consisting only of 1s and 0s zero. \n   Perform binary XOR on these inputs input and return result also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 1, "perturbed": true, "gc": "/* Input input signal are two strings string a and b consisting only of 1s and 0s zero. \n   Perform binary XOR on these inputs input and return result also besides as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\nmodule.exports = stringXor;\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem trouble, you will implement enforce a function that takes remove two lists of numbers issue, \n   and determines whether it is possible potential to perform an exchange of elements component \n   between them to make lst1 a list of only even numbers numeral. \n   There is no limit terminus ad quem on the number of exchanged change elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 1, "perturbed": true, "gc": "/*In this problem trouble, you will implement enforce a function that takes remove two lists of numbers issue, \n   and determines whether it is possible potential to perform an exchange of elements component \n   between them to make lst1 a list of only even numbers numeral. \n   There is no limit terminus ad quem on the number of exchanged change elements between lst1 and lst2.\n   If it is possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const lst1_even = lst1.filter(x => x % 2 === 0)\n  const lst2_even = lst2.filter(x => x % 2 === 0)\n  if (lst1_even.length === 0 || lst2_even.length === 0) {\n    return \"NO\"\n  }\n  const lst1_odd = lst1.filter(x => x % 2!== 0)\n  const lst2_odd = lst2.filter(x => x % 2!== 0)\n  const lst1_len = lst1_odd.length\n  const lst2_len = lst2_odd.length\n  const lst1_len_even = lst1_odd.filter(x => x % 2 === 0)\n  const lst2_len_even = lst2_odd.filter(x => x % 2 === 0)\n  const lst1_len_odd = lst1_odd.filter(x => x % 2!== 0)\n  const lst2_len_odd = lst2_odd.filter(x => x % 2!== 0)\n  const lst1_len_even_len_odd = lst1_len_even.length\n  const lst2_len_even_len_odd = lst2_len_even.length\n  const lst1_len_odd_len_odd = lst1_len_odd.length\n  const lst2_len_odd_len_odd = lst2_len_odd.length\n  const lst1_len_even_len_odd_len_odd = lst1_len_even_len_odd.length\n  const lst2_len_even_len_odd_len_odd = lst2_len_even_len_odd.length\n  const lst1_len_odd_len_odd_len_odd = lst1_len_odd_len_odd.length\n  const lst2_len_odd_len_odd_len_odd = lst2_len_odd_len_odd.length\n  const lst1_len_even_len_odd_len_odd_len_odd = lst1_len_even_len_odd_len_odd.length\n  const lst2_len_even_len_odd_len_odd_len_odd = lst2_len_even_len_odd_len_odd.length\n  const lst1_len_odd_len_odd_len_odd_len_odd = lst1_len_odd_len_odd_len_odd.length\n  const lst2_len_odd_len_odd_len_odd_len_odd = lst2_len_odd_len_odd_len_odd.length\n  const lst1_len_even_len_odd_len_odd_len_odd_len_odd = lst1_len_even_len_odd_len_odd_len_odd.length\n  const lst2_len_even_len_odd_len_odd_len_odd_len_odd = lst2_len_even_len_odd_len_odd_len_odd.length\n  const lst1_len_odd_len_odd_len_odd_len_odd_len_odd = lst1_len_odd_len_odd_len_odd_len_odd.length\n  const lst2_len_odd_len_odd_len_odd_len_odd_len_odd = lst2_len_odd_len_odd_len_odd_len_odd.length\n  const lst1_len_even_len_odd_len_odd_len_odd_len_odd_len_odd = lst1_len_even_len_odd_len_odd_len_odd_len_odd.length\n  const lst2_len_even_len_odd_len_odd_len_odd_len_odd_len_odd = lst2_len_even_len_odd_len_odd_len_odd_len_odd.length\n  const lst1_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd = lst1_len_odd_len_odd_len_odd_len_odd_len_odd.length\n  const lst2_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd = lst2_len_odd_len_odd_len_odd_len_odd_len_odd.length\n  const lst1_len_even_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd = lst1_len_even_len_odd_len_odd_len_odd_len_odd_len_odd.length\n  const lst2_len_even_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd = lst2_len_even_len_odd_len_odd_len_odd_len_odd_len_odd.length\n  const lst1_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd = lst1_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd.length\n  const lst2_len_odd_len_odd_len_odd_len_odd_len_odd_len_odd", "passed": 0}
{"task_id": "JavaScript/111", "prompt": "/*Given a string bowed stringed instrument representing exemplify a space separated distinguish lowercase letters letter, return a dictionary \n   of the letter with the most repetition and containing contain the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "/*Given a string bowed stringed instrument representing exemplify a space separated distinguish lowercase letters letter, return a dictionary \n   of the letter with the most repetition and containing contain the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition and containing contain the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition and containing contain the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition and containing contain the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition and containing contain the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition and containing contain the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return a dictionary of the letter with the most repetition and containing contain the corresponding count. \n  If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst hist", "passed": 0}
{"task_id": "JavaScript/112", "prompt": "/*Task necessitate \n   We are given pass two strings s and c, you have to deleted delete all the characters in s that are equal adequate to any character in c\n   then check see if the result string chain is palindrome. \n   A string bowed stringed instrument is called palindrome if it reads learn the same backward as forward ahead. \n   You should return a tuple containing the result consequence string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 1, "perturbed": true, "gc": "/*Task necessitate \n   We are given pass two strings s and c, you have to deleted delete all the characters in s that are equal adequate to any character in c\n   then check see if the result string chain is palindrome. \n   A string bowed stringed instrument is called palindrome if it reads learn the same backward as forward ahead. \n   You should return a tuple containing the result consequence string and true / false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n    let result = s.split('');\n    let len = result.length;\n    let i = 0;\n    let j = len - 1;\n    while (i < j) {\n        while (i < len && result[i] === c[j]) {\n            i++;\n            j--;\n        }\n        if (i === j) {\n            break;\n        }\n        result[i] = result[j];\n        i++;\n        j--;\n    }\n    return [result.join(''), j === 0];\n};\n\nconst isPalindrome = (s) => {\n    let [result, isPalindrome] = reverseDelete(s, s);\n    return isPalindrome;\n};\n\nconsole.log(isPalindrome(\"abcdef\"));\nconsole.log(isPalindrome(\"abcdedcba\"));\nconsole.log(isPalindrome(\"abcdefghijklmnopqrstuvwxyz\"));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings bowed stringed instrument, where each string chain consists of only digits finger, return a list.\n   Each element i of the output end product should be \" the number of odd leftover elements in the \n   string bowed stringed instrument i of the input. \" where all the i's should be replaced substitute by the number issue \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 1, "perturbed": true, "gc": "/*Given a list of strings bowed stringed instrument, where each string chain consists of only digits finger, return a list.\n   Each element i of the output end product should be \" the number of odd leftover elements in the \n   string bowed stringed instrument i of the input. \" where all the i's should be replaced substitute by the number issue \n   of odd digits finger in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const result = [];\n  const lstLength = lst.length;\n  let i = 0;\n  while (i < lstLength) {\n    const lstString = lst[i];\n    const lstStringLength = lstString.length;\n    let j = 0;\n    while (j < lstStringLength) {\n      const char = lstString[j];\n      if (char === '1' || char === '2' || char === '3' || char === '4' || char === '5' || char === '6' || char === '7' || char === '8' || char === '9') {\n        result.push(`the number of odd elements ${char}n the str${char}ng ${char} of the ${char}put.`);\n      }\n      j++;\n    }\n    i++;\n  }\n  return result;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given grant an array of integers nums, find line up the minimum minimal sum union of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of integers nums, find line up the minimum minimal sum union of any non - empty sub - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = 0;\n  let minSumIndex = 0;\n  let minSumIndex2 = 0;\n  let minSumIndex3 = 0;\n  let minSumIndex4 = 0;\n  let minSumIndex5 = 0;\n  let minSumIndex6 = 0;\n  let minSumIndex7 = 0;\n  let minSumIndex8 = 0;\n  let minSumIndex9 = 0;\n  let minSumIndex10 = 0;\n  let minSumIndex11 = 0;\n  let minSumIndex12 = 0;\n  let minSumIndex13 = 0;\n  let minSumIndex14 = 0;\n  let minSumIndex15 = 0;\n  let minSumIndex16 = 0;\n  let minSumIndex17 = 0;\n  let minSumIndex18 = 0;\n  let minSumIndex19 = 0;\n  let minSumIndex20 = 0;\n  let minSumIndex21 = 0;\n  let minSumIndex22 = 0;\n  let minSumIndex23 = 0;\n  let minSumIndex24 = 0;\n  let minSumIndex25 = 0;\n  let minSumIndex26 = 0;\n  let minSumIndex27 = 0;\n  let minSumIndex28 = 0;\n  let minSumIndex29 = 0;\n  let minSumIndex30 = 0;\n  let minSumIndex31 = 0;\n  let minSumIndex32 = 0;\n  let minSumIndex33 = 0;\n  let minSumIndex34 = 0;\n  let minSumIndex35 = 0;\n  let minSumIndex36 = 0;\n  let minSumIndex37 = 0;\n  let minSumIndex38 = 0;\n  let minSumIndex39 = 0;\n  let minSumIndex40 = 0;\n  let minSumIndex41 = 0;\n  let minSumIndex42 = 0;\n  let minSumIndex43 = 0;\n  let minSumIndex44 = 0;\n  let minSumIndex45 = 0;\n  let minSumIndex46 = 0;\n  let minSumIndex47 = 0;\n  let minSumIndex48 = 0;\n  let minSumIndex49 = 0;\n  let minSumIndex50 = 0;\n  let minSumIndex51 = 0;\n  let minSumIndex52 = 0;\n  let minSumIndex53 = 0;\n  let minSumIndex54 = 0;\n  let minSumIndex55 = 0;\n  let minSumIndex56 = 0;\n  let minSumIndex57 = 0;\n  let minSumIndex58 = 0;\n  let minSumIndex59 = 0;\n  let minSumIndex60 = 0;\n  let minSumIndex61 = 0;\n  let minSumIndex62 = 0;\n  let minSumIndex63 = 0;\n  let minSumIndex64 = 0;\n  let minSumIndex65 = 0;\n  let minSumIndex66 = 0;\n  let minSumIndex67 = 0;\n  let minSumIndex68 = 0;\n  let minSumIndex69 = 0;\n  let minSumIndex70 = 0;\n  let minSumIndex71 = 0;\n  let minSumIndex72 = 0;\n  let minSumIndex73 = 0;\n  let minSumIndex74 = 0;\n  let minSumIndex75 = 0;\n  let minSumIndex76 = 0;\n  let minSumIndex77 = 0;\n  let minSumIndex78 = 0;\n  let minSumIndex79 = 0;\n  let minSumIndex80 = 0;\n  let minSumIndex81 = 0;\n  let minSumIndex82 = 0;\n  let minSumIndex83 = 0;\n  let minSumIndex84 = 0;\n  let minSumIndex85 = 0;\n  let minSumIndex86 = 0;\n  let minSumIndex87 = 0;\n  let minSumIndex88 = 0;\n  let minSumIndex89 = 0;\n  let minSumIndex90 = 0;\n  let minSumIndex91 = 0;\n  let minSumIndex92 = 0;\n  let minSumIndex93 = 0;\n  let minSumIndex94 = 0;\n  let minSumIndex95 = 0;\n  let minSumIndex96 = 0;\n  let minSumIndex97 = 0;\n  let minSumIndex98 = 0;\n  let minSumIndex99 = 0;\n  let minSumIndex100 = 0;\n  let minSumIndex101 = 0;\n  let minSumIndex102 = 0;\n  let minSumIndex103 = 0;\n  let minSumIndex104 = 0;\n  let minSumIndex105 = 0;\n  let minSumIndex106 = 0;\n  let minSumIndex107 = 0;\n  let minSumIndex108 = 0;\n  let minSumIndex109 = 0;\n  let minSumIndex110 = 0;\n  let minSumIndex111 = 0;\n  let minSumIndex112 = 0;\n  let minSumIndex113 = 0;\n  let minSumIndex114 = 0;\n  let minSumIndex115 = 0;\n  let minSumIndex116 = 0;\n  let minSumIndex117 = 0;\n  let minSumIndex118 = 0;\n  let minSumIndex119 = 0;\n  let minSumIndex120 = 0;\n  let minSumIndex121 = 0;\n  let minSumIndex122 = 0;\n  let minSumIndex123 = 0;\n  let minSumIndex124 = 0;\n  let minSumIndex125 = 0;\n  let minSumIndex126 = 0;\n  let minSumIndex127 = 0;\n  let minSumIndex128 = 0;\n  let minSumIndex129 = 0;\n  let minSumIndex130 = 0;\n  let minSumIndex131 = 0;\n  let minSumIndex132 = 0;\n  let minSumIndex133 = 0;\n  let minSumIndex134 = 0;\n  let minSumIndex135 = 0;\n  let minSumIndex136 = 0;\n  let minSumIndex137 = 0;\n  let minSumIndex138 = 0;\n  let minSumIndex139 = 0;\n  let minSumIndex140 = 0;\n  let minSumIndex141 = 0;\n  let minSumIndex142 = 0;\n  let minSumIndex143 = 0;\n  let minSum", "passed": 0}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given grant a rectangular grid of wells well. Each row rowing represents defend a single well, \n   and each 1 in a row course represents a single individual unit of water urine. \n   Each well has a corresponding bucket that can be used practice to extract distill water from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use the buckets to empty the wells. \n   Output the number of times clock time you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a rectangular grid of wells well. Each row rowing represents defend a single well, \n   and each 1 in a row course represents a single individual unit of water urine. \n   Each well has a corresponding bucket that can be used practice to extract distill water from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use the buckets to empty the wells. \n   Output the number of times clock time you need necessitate to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += Math.min(capacity, grid[i][j]);\n      }\n    }\n  }\n  return count;\n};\n\nconst test = (grid, capacity) => {\n  console.log(`grid: ${grid}`);\n  console.log(`capacity: ${capacity}`);\n  console.log(`count: ${maxFill(grid, capacity)}`);\n};\n\ntest([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1);\ntest([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2);\ntest([[0,0,0], [0,0,0]], 5);\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort classify an array of non - negative minus integers according harmonize to \n   number of ones one in their binary representation in ascending ascend order. \n   For similar like number of ones one, sort based base on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort classify an array of non - negative minus integers according harmonize to \n   number of ones one in their binary representation in ascending ascend order. \n   For similar like number of ones one, sort based base on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sortedArray = arr.slice();\n  sortedArray.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedArray;\n};\n\nconsole.log(sortArray([1, 5, 2, 3, 4]));\nconsole.log(sortArray([-2, -3, -4, -5, -6]));\nconsole.log(sortArray([1, 0, 2, 3, 4]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked tax to implement \n   a function affair that returns a list of all words news from string s that contain control exactly precisely \n   n consonants, in order decree these words bible appear in the string chain s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume the input string contains only letters letter and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 1, "perturbed": true, "gc": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked tax to implement \n   a function affair that returns a list of all words news from string s that contain control exactly precisely \n   n consonants, in order decree these words bible appear in the string chain s.\n   If the string s is empty then the function should return an empty list.\n   Note: you may assume the input string contains only letters letter and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const consonants = ['a', 'e', 'i', 'o', 'u'];\n  const consonantCount = consonants.reduce((acc, consonant) => {\n    return acc + (s.indexOf(consonant) > -1? 1 : 0);\n  }, 0);\n  if (consonantCount === n) {\n    words.push(s);\n  }\n  const index = s.indexOf(' ');\n  if (index > -1) {\n    const nextWord = s.substring(index + 1);\n    const nextConsonantCount = consonants.reduce((acc, consonant) => {\n      return acc + (nextWord.indexOf(consonant) > -1? 1 : 0);\n    }, 0);\n    if (nextConsonantCount === n) {\n      words.push(nextWord);\n    }\n  }\n  return words;\n};\n\nconst test = [\n  [\"Mary had a little lamb\", 4],\n  [\"Mary had a little lamb\", 3],\n  [\"simple white space\", 2],\n  [\"Hello world\", 4],\n  [\"Uncle sam\", 3],\n];\n\ntest.forEach(t => {\n  console.log(selectWords(t[0], t[1]));\n});\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/118", "prompt": "/*You are given grant a word. Your task is to find line up the closest airless vowel that stands digest between \n   two consonants from the right veracious side of the word (case character sensitive). \n  \n   Vowels vowel in the beginning and ending doesn't count consider. Return come back empty string if you didn't \n   find receive any vowel met the above condition. \n\n   You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 1, "perturbed": true, "gc": "/*You are given grant a word. Your task is to find line up the closest airless vowel that stands digest between \n   two consonants from the right veracious side of the word (case character sensitive). \n  \n   Vowels vowel in the beginning and ending doesn't count consider. Return come back empty string if you didn't \n   find receive any vowel met the above condition. \n\n   You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const consonantCount = consonants.reduce((acc, consonant, index) => {\n    if (consonant === word[index]) {\n      acc++;\n    }\n    return acc;\n  }, 0);\n  const vowelCount = vowels.reduce((acc, vowel, index) => {\n    if (vowel === word[index + 1]) {\n      acc++;\n    }\n    return acc;\n  }, 0);\n  const vowelIndex = vowels.indexOf(word[0]);\n  const consonantIndex = consonants.indexOf(word[vowelIndex + 1]);\n  const distance = Math.abs(consonantIndex - vowelCount);\n  if (distance === 0) {\n    return word[0];\n  }\n  return '';\n};\n\nconsole.log(getClosestVowel('yogurt'));\nconsole.log(getClosestVowel('FULL'));\nconsole.log(getClosestVowel('quick'));\nconsole.log(getClosestVowel('ab'));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are given grant a list of two strings, both strings bowed stringed instrument consist dwell of open overt \n   parentheses' (' or close cheeseparing parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings string section in\n   some order, that the resulting result string bowed stringed instrument will be good. \n   A string chain S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 1, "perturbed": true, "gc": "/* You are given grant a list of two strings, both strings bowed stringed instrument consist dwell of open overt \n   parentheses' (' or close cheeseparing parentheses')' only. \n   Your job problem is to check if it is possible potential to concatenate the two strings string section in\n   some order, that the resulting result string bowed stringed instrument will be good. \n   A string chain S is considered to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens2 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens3 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens4 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens5 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens6 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens7 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens8 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens9 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens10 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens11 = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconst matchParens12 = (lst) => {\n  const stack = []\n  ", "passed": 0}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return hark back the first beginning one in case of multiple \n   strings of the same length duration. Return null in case character the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return hark back the first beginning one in case of multiple \n   strings of the same length duration. Return null in case character the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let longest = '';\n  let longestLength = 0;\n  strings.forEach((string) => {\n    if (string.length > longestLength) {\n      longest = string;\n      longestLength = string.length;\n    }\n  });\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given grant an array arr of integers and a positive cocksure integer k, return a sorted screen list \n   of length duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array arr of integers and a positive cocksure integer k, return a sorted screen list \n   of length duration k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const max = arr.reduce((a, b) => Math.max(a, b), -1e9)\n  const result = arr.slice(0, k)\n  return result.sort((a, b) => a - b)\n}\n\nconst test = () => {\n  const arr = [-3, -4, 5]\n  console.log(maximum(arr, 3))\n  console.log(maximum(arr, 2))\n  console.log(maximum(arr, 1))\n}\n\ntest()\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers integer, return the sum union of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 1, "perturbed": true, "gc": "/*Given a non - empty list of integers integer, return the sum union of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const odd = lst.filter((x) => x % 2 === 1);\n  const even = lst.filter((x) => x % 2 === 0);\n  return odd.reduce((acc, x) => acc + x, 0) + even.reduce((acc, x) => acc + x, 0);\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given grant a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements chemical element with at most two digits finger from the first k elements component of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a non - empty array of integers arr and an integer k, return\n   the sum kernel of the elements chemical element with at most two digits finger from the first k elements component of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements2 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements3 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements4 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements5 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements6 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements7 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements8 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements9 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements10 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements11 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements12 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements13 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements14 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements15 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements16 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements17 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements18 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements19 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements20 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements21 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements22 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements23 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements24 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements25 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements26 = (arr, k) => {\n  const sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconst addElements27 = (arr, k) =>", "passed": 0}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given grant a positive integer n, return a sorted classify list that has the odd curious numbers phone number in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns concern a sequence defined specify \n   as follows: start begin with any positive cocksure integer n. Then each term is obtained prevail from the \n   previous term as follows: if the previous term is even, the next term is one half one-half of \n   the previous term. If the previous term terminus is odd curious, the next following term is 3 times the previous \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order holy order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return a sorted classify list that has the odd curious numbers phone number in collatz sequence. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns concern a sequence defined specify \n   as follows: start begin with any positive cocksure integer n. Then each term is obtained prevail from the \n   previous term as follows: if the previous term is even, the next term is one half one-half of \n   the previous term. If the previous term terminus is odd curious, the next following term is 3 times the previous \n   term plus 1. The conjecture is that no matter what value of n, the sequence will always constantly reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing order holy order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz2 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz3 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz4 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz5 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz6 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz7 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz8 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.push(odd);\n      collatz[i] = odd * 2 + 1;\n    } else {\n      oddCollatz.push(odd * 3 + 1);\n      collatz[i] = odd * 3 + 1;\n    }\n    i++;\n  }\n  return oddCollatz;\n};\n\nconst getOddCollatz9 = (n) => {\n  const collatz = [1, n];\n  const oddCollatz = [];\n  let i = 0;\n  while (collatz[i]!== 1) {\n    const odd = collatz[i];\n    if (odd % 2 === 0) {\n      oddCollatz.", "passed": 0}
{"task_id": "JavaScript/124", "prompt": "/*You have to write publish a function routine which validates a given hold date string and \n   returns rejoinder true if the date is valid otherwise differently false. \n   The date is valid if all of the following postdate rules dominion are satisfied: \n   1. The date string bowed stringed instrument is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n   3. The months month should not be less than 1 or higher gamey than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 1, "perturbed": true, "gc": "/*You have to write publish a function routine which validates a given hold date string and \n   returns rejoinder true if the date is valid otherwise differently false. \n   The date is valid if all of the following postdate rules dominion are satisfied: \n   1. The date string bowed stringed instrument is not empty. \n   2. The number of days day is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months calendar month 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month calendar month 2. \n   3. The months month should not be less than 1 or higher gamey than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let dateArray = date.split('-');\n  let month = parseInt(dateArray[1]);\n  let day = parseInt(dateArray[2]);\n  let year = parseInt(dateArray[0]);\n  let dayOfMonth = day;\n  let dayOfYear = day;\n  let dayOfWeek = day;\n  let monthOfYear = month;\n  let yearOfDate = year;\n  let dayOfWeekOfYear = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let dayOfWeekOfMonth = day;\n  let day", "passed": 0}
{"task_id": "JavaScript/125", "prompt": "/* Given grant a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 1, "perturbed": true, "gc": "/* Given grant a string of words word, return a list of words discussion split cleave on whitespace, if no whitespaces exists in the text textbook you \n   should split on commas comma',' if no commas exists exist you should return the number of lower abject - case character letters with odd curious order in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords2 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords3 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords4 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords5 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords6 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords7 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords8 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords9 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords10 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords11 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords12 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords13 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords14 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  return wordsList;\n};\n\nconst splitWords15 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsLength = words.length;\n  const wordsCount = wordsLength;\n  const wordsList = [];\n  for (let i = 0; i < wordsCount; i++) {\n    wordsList.push(words[i]);\n  }\n  ", "passed": 0}
{"task_id": "JavaScript/126", "prompt": "/* Given grant a list of numbers, return whether or not they are sorted classify \n   in ascending rise order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative damaging numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 1, "perturbed": true, "gc": "/* Given grant a list of numbers, return whether or not they are sorted classify \n   in ascending rise order orderliness. If list has more than 1 duplicate of the same \n   number issue, return false. Assume no negative damaging numbers and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const sorted = [];\n  const sortedIndex = [];\n  const sortedLength = 0;\n  const sortedLengthIndex = 0;\n  const sortedLengthIndex2 = 0;\n  const sortedLengthIndex3 = 0;\n  const sortedLengthIndex4 = 0;\n  const sortedLengthIndex5 = 0;\n  const sortedLengthIndex6 = 0;\n  const sortedLengthIndex7 = 0;\n  const sortedLengthIndex8 = 0;\n  const sortedLengthIndex9 = 0;\n  const sortedLengthIndex10 = 0;\n  const sortedLengthIndex11 = 0;\n  const sortedLengthIndex12 = 0;\n  const sortedLengthIndex13 = 0;\n  const sortedLengthIndex14 = 0;\n  const sortedLengthIndex15 = 0;\n  const sortedLengthIndex16 = 0;\n  const sortedLengthIndex17 = 0;\n  const sortedLengthIndex18 = 0;\n  const sortedLengthIndex19 = 0;\n  const sortedLengthIndex20 = 0;\n  const sortedLengthIndex21 = 0;\n  const sortedLengthIndex22 = 0;\n  const sortedLengthIndex23 = 0;\n  const sortedLengthIndex24 = 0;\n  const sortedLengthIndex25 = 0;\n  const sortedLengthIndex26 = 0;\n  const sortedLengthIndex27 = 0;\n  const sortedLengthIndex28 = 0;\n  const sortedLengthIndex29 = 0;\n  const sortedLengthIndex30 = 0;\n  const sortedLengthIndex31 = 0;\n  const sortedLengthIndex32 = 0;\n  const sortedLengthIndex33 = 0;\n  const sortedLengthIndex34 = 0;\n  const sortedLengthIndex35 = 0;\n  const sortedLengthIndex36 = 0;\n  const sortedLengthIndex37 = 0;\n  const sortedLengthIndex38 = 0;\n  const sortedLengthIndex39 = 0;\n  const sortedLengthIndex40 = 0;\n  const sortedLengthIndex41 = 0;\n  const sortedLengthIndex42 = 0;\n  const sortedLengthIndex43 = 0;\n  const sortedLengthIndex44 = 0;\n  const sortedLengthIndex45 = 0;\n  const sortedLengthIndex46 = 0;\n  const sortedLengthIndex47 = 0;\n  const sortedLengthIndex48 = 0;\n  const sortedLengthIndex49 = 0;\n  const sortedLengthIndex50 = 0;\n  const sortedLengthIndex51 = 0;\n  const sortedLengthIndex52 = 0;\n  const sortedLengthIndex53 = 0;\n  const sortedLengthIndex54 = 0;\n  const sortedLengthIndex55 = 0;\n  const sortedLengthIndex56 = 0;\n  const sortedLengthIndex57 = 0;\n  const sortedLengthIndex58 = 0;\n  const sortedLengthIndex59 = 0;\n  const sortedLengthIndex60 = 0;\n  const sortedLengthIndex61 = 0;\n  const sortedLengthIndex62 = 0;\n  const sortedLengthIndex63 = 0;\n  const sortedLengthIndex64 = 0;\n  const sortedLengthIndex65 = 0;\n  const sortedLengthIndex66 = 0;\n  const sortedLengthIndex67 = 0;\n  const sortedLengthIndex68 = 0;\n  const sortedLengthIndex69 = 0;\n  const sortedLengthIndex70 = 0;\n  const sortedLengthIndex71 = 0;\n  const sortedLengthIndex72 = 0;\n  const sortedLengthIndex73 = 0;\n  const sortedLengthIndex74 = 0;\n  const sortedLengthIndex75 = 0;\n  const sortedLengthIndex76 = 0;\n  const sortedLengthIndex77 = 0;\n  const sortedLengthIndex78 = 0;\n  const sortedLengthIndex79 = 0;\n  const sortedLengthIndex80 = 0;\n  const sortedLengthIndex81 = 0;\n  const sortedLengthIndex82 = 0;\n  const sortedLengthIndex83 = 0;\n  const sortedLengthIndex84 = 0;\n  const sortedLengthIndex85 = 0;\n  const sortedLengthIndex86 = 0;\n  const sortedLengthIndex87 = 0;\n  const sortedLengthIndex88 = 0;\n  const sortedLengthIndex89 = 0;\n  const sortedLengthIndex90 = 0;\n  const sortedLengthIndex91 = 0;\n  const sortedLengthIndex92 = 0;\n  const sortedLengthIndex93 = 0;\n  const sortedLengthIndex94 = 0;\n  const sortedLengthIndex95 = 0;\n  const sortedLengthIndex96 = 0;\n  const sortedLengthIndex97 = 0;\n  const sortedLengthIndex98 = 0;\n  const sortedLengthIndex99 = 0;\n  const sortedLengthIndex100 = 0;\n  const sortedLengthIndex101 = 0;\n  const sortedLengthIndex102 = 0;\n  const sortedLengthIndex103 = 0;\n  const sortedLengthIndex104 = 0;\n  const sortedLengthIndex105 = 0;\n  const sortedLengthIndex106 = 0;\n  const sortedLengthIndex107 = 0;\n  const sortedLengthIndex108 = 0;\n  const sortedLengthIndex109 = 0;\n  const sortedLengthIndex110 = 0;\n  const sortedLengthIndex111 = 0;\n  const sortedLengthIndex112 = 0;\n  const sortedLengthIndex113 = 0;\n  const sortedLengthIndex114 = 0;\n  const sortedLengthIndex115 = 0;\n  const sortedLengthIndex116 = 0;\n  const sortedLengthIndex117 = 0;\n  const sortedLengthIndex118 = 0;\n  const sortedLengthIndex119 = 0;\n  const sortedLengthIndex120 = 0;\n  const sortedLengthIndex121 = 0;\n  const sortedLengthIndex122 = 0;\n  const sortedLengthIndex123 = 0;\n  const sortedLengthIndex124 = 0;\n  const sortedLengthIndex125 = 0;\n  const sortedLengthIndex126 = 0;\n  const sortedLengthIndex127 = 0;\n  const sortedLengthIndex", "passed": 0}
{"task_id": "JavaScript/127", "prompt": "/*You are given grant two intervals, \n   where each interval time interval is a pair couple of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "/*You are given grant two intervals, \n   where each interval time interval is a pair couple of integers integer. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end || interval2.start > interval1.end) {\n    return \"NO\";\n  }\n\n  let start = Math.max(interval1.start, interval2.start);\n  let end = Math.min(interval1.end, interval2.end);\n\n  let length = end - start;\n\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n\n  return \"YES\";\n};\n\nconsole.log(intersection((-3, -1), (-5, 5)));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given grant an array arr of integers and you need want to return\n   sum union of magnitudes order of magnitude of integers multiplied reproduce by product of all signs sign of the zodiac \n   of each number in the array, represented exemplify by 1, -1 or 0. \n   Note bill: return null for empty arr.\n\n   Example exercise:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant an array arr of integers and you need want to return\n   sum union of magnitudes order of magnitude of integers multiplied reproduce by product of all signs sign of the zodiac \n   of each number in the array, represented exemplify by 1, -1 or 0. \n   Note bill: return null for empty arr.\n\n   Example exercise:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const sign = (arr) => {\n    let result = 0;\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] > 0) {\n        result += 1;\n      } else if (arr[i] < 0) {\n        result -= 1;\n      }\n    }\n    return result;\n  };\n  const magnitudes = (arr) => {\n    let result = 0;\n    for (let i = 0; i < arr.length; i++) {\n      result += Math.pow(Math.abs(arr[i]), 2);\n    }\n    return result;\n  };\n  const product = (arr) => {\n    let result = 1;\n    for (let i = 0; i < arr.length; i++) {\n      result *= arr[i];\n    }\n    return result;\n  };\n  const signOfZodiac = (arr) => {\n    let result = 0;\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] > 0) {\n        result += 1;\n      } else if (arr[i] < 0) {\n        result -= 1;\n      }\n    }\n    return result;\n  };\n  return arr.reduce((acc, elem, index) => {\n    if (index === 0) {\n      acc[0] = elem;\n    } else {\n      acc[index] = elem;\n    }\n    return acc;\n  }, [0]);\n};\n\nconsole.log(prodSigns([1, 2, 2, -4]));\nconsole.log(prodSigns([0, 1]));\nconsole.log(prodSigns([]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given grant a grid with N rows and N columns column (N > = 2) and a positive convinced integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find rule the minimum path way of length distance k in the grid. You can start \n   from any cell cellular telephone, and in each step you can move to any of the neighbor cells, \n   in other words, you can go to cells which share an edge boundary with you current \n   cell. \n   Please note that a path of length distance k means entail visiting travel to exactly k cells (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length duration k) is considered less than a path B (of length k) if \n   after making the ordered arrange lists of the values value on the cells cellular telephone that A ampere and B boron go \n   through (let lease's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words lyric, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique alone. \n   Return an ordered arrange list of the values on the cells that the minimum path go start through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a grid with N rows and N columns column (N > = 2) and a positive convinced integer k, \n   each cell cellular telephone of the grid contains a value. Every integer in the range image [ 1, N * N ] \n   inclusive appears exactly precisely once on the cells of the grid.\n\n   You have to find rule the minimum path way of length distance k in the grid. You can start \n   from any cell cellular telephone, and in each step you can move to any of the neighbor cells, \n   in other words, you can go to cells which share an edge boundary with you current \n   cell. \n   Please note that a path of length distance k means entail visiting travel to exactly k cells (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length duration k) is considered less than a path B (of length k) if \n   after making the ordered arrange lists of the values value on the cells cellular telephone that A ampere and B boron go \n   through (let lease's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words lyric, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed that the answer is unique alone. \n   Return an ordered arrange list of the values on the cells that the minimum path go start through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const grid_copy = grid.slice();\n  const visited = new Array(N);\n  const visited_copy = visited.slice();\n  const visited_copy_copy = visited_copy.slice();\n  const visited_copy_copy_copy = visited_copy_copy.slice();\n  const visited_copy_copy_copy_copy = visited_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited_copy_copy_copy_copy_copy_copy_copy_copy = visited_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy.slice();\n  const visited", "passed": 0}
{"task_id": "JavaScript/13", "prompt": "/* Return rejoinder a greatest capital common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder a greatest capital common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === b) return a;\n  if (a > b) return greatestCommonDivisor(a % b, b);\n  return greatestCommonDivisor(a, b % a);\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  947900\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/* Return the sum of the squares of the first n positive integers\n  >>> sumOfSquares(3)\n  9\n  >>> sumOfSquares(10)\n  385\n  >>> sumOfSquares(100)\n  ", "passed": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries. However, what people multitude don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries. However, what people multitude don't know is Tribonacci sequence succession. \n   Tribonacci sequence is defined define by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd leftover.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\n", "passed": 0}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive cocksure integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "/*Given a positive cocksure integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\nconsole.log(digits(1));\nconsole.log(digits(4));\nconsole.log(digits(235));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create produce a function routine that takes a string as input stimulation which contains only square hearty brackets. \n   The function affair should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence posteriority is nested nest. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false assumed \n   isNested('[][]') ➞ false \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 1, "perturbed": true, "gc": "/*\n  Create produce a function routine that takes a string as input stimulation which contains only square hearty brackets. \n   The function affair should return true if and only if there is a valid subsequence sequel of brackets \n   where at least one bracket in the subsequence posteriority is nested nest. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false assumed \n   isNested('[][]') ➞ false \n   isNested('[]') ➞ false \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true \n   * / \n const isNested = (string) = > {\n  const {length} = string;\n  const {charAt} = string;\n  const {startsWith} = string;\n  const {endsWith} = string;\n  const {substring} = string;\n  const {indexOf} = string;\n  const {lastIndexOf} = string;\n  const {match} = string;\n  const {search} = string;\n  const {slice} = string;\n  const {split} = string;\n  const {toLowerCase} = string;\n  const {toUpperCase} = string;\n  const {trim} = string;\n  const {concat} = string;\n  const {replace} = string;\n  const {charCodeAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {codePointAt} = string;\n  const {codePointBefore} = string;\n  const {codePointCount} = string;\n  const {codePointAt} = string;\n  const {", "passed": 0}
{"task_id": "JavaScript/133", "prompt": "/*You are given grant a list of numbers. \n   You need want to return the sum union of squared numbers phone number in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*You are given grant a list of numbers. \n   You need want to return the sum union of squared numbers phone number in the given list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares2 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares3 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares4 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares5 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares6 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares7 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares8 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares9 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares10 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares11 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares12 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares13 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares14 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares15 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares16 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares17 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares18 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares19 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares20 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares21 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares22 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares23 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares24 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares25 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares26 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares27 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares28 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares29 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares30 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares31 = (lst) => {\n  const sum = lst.reduce((a, b) => a +", "passed": 0}
{"task_id": "JavaScript/134", "prompt": "/* Create produce a function routine that returns true truthful if the last character fictional character \n   of a given string drawstring is an alphabetical character quality and is not \n   a part contribution of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that returns true truthful if the last character fictional character \n   of a given string drawstring is an alphabetical character quality and is not \n   a part contribution of a word, and false assumed otherwise differently. \n   Note: \" word discussion \" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar) &&!isPartOfWord(lastChar, txt);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/* Create produce a function routine that returns true if the last character \n   fictional character of a given string drawstring is a letter, and false \n   assumed otherwise differently.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  check", "passed": 0}
{"task_id": "JavaScript/135", "prompt": "/*Create a function affair which returns retort the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 1, "perturbed": true, "gc": "/*Create a function affair which returns retort the largest index exponent of an element which \n   is not greater bang-up than or equal to the element component immediately preceding it. If \n   no such element component exists then return -1. The given render array will not contain check \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  const arrLen = arr.length;\n  let max = -1;\n  let maxIndex = -1;\n  let i = 0;\n  while (i < arrLen) {\n    const cur = arr[i];\n    const curIndex = arr.indexOf(cur);\n    if (curIndex > max) {\n      max = curIndex;\n      maxIndex = i;\n    }\n    i++;\n  }\n  return maxIndex;\n};\n\nmodule.exports = canArrange;\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create produce a function routine that returns a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers integer, and 'b' is the smallest \n   of positive incontrovertible integers in a list.\n   If there is no negative minus or positive positivist integers, return them as null nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that returns a tuple (a, b), where 'a' is \n   the largest bombastic of negative integers integer, and 'b' is the smallest \n   of positive incontrovertible integers in a list.\n   If there is no negative minus or positive positivist integers, return them as null nothing.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const max = Math.max(...lst);\n  const min = Math.min(...lst);\n  if (max < 0 && min > 0) {\n    return [max, min];\n  }\n  return null;\n};\n\n/* Create a function that returns the largest and smallest of two numbers.\n   If the two numbers are the same, return the largest number.\n   If the two numbers are null, return null.\n  Examples:\n  largestSmallest([2, 4, 1, 3, 5, 7]) == (7, 2)\n  largestSmallest([0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0, 0)\n  largestSmallest([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == (0,", "passed": 0}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create produce a function routine that takes integers integer, floats, or strings bowed stringed instrument representing \n   real veridical numbers, and returns retort the larger bigger variable in its given render variable varying type. \n   Return null nothing if the values are equal. \n   Note: If a real number is represented as a string, the floating float point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 1, "perturbed": true, "gc": "/*\n  Create produce a function routine that takes integers integer, floats, or strings bowed stringed instrument representing \n   real veridical numbers, and returns retort the larger bigger variable in its given render variable varying type. \n   Return null nothing if the values are equal. \n   Note: If a real number is represented as a string, the floating float point might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null \n   * / \n const compareOne = (a, b) = > {\n  if (a === b) return null;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if (a < b) return a;\n  if (a > b) return b;\n  if", "passed": 0}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate measure whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 1, "perturbed": true, "gc": "/*Evaluate measure whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 1;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 0 || sum % 2 === 1;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 1 || sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 1 || sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 0 || sum % 2 === 1;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 0 || sum % 2 === 1;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 1 || sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 1 || sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 0 || sum % 2 === 1;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 0 || sum % 2 === 1;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive odd numbers numbers pool\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddOdd = (n) => {\n  const sum = n * (n + 1) / 2;\n  return sum % 2 === 1 || sum % 2 === 0;\n};\n\n/*\n  Evaluate whether the given pass number n can be written spell as the sum of exactly precisely 4 positive even numbers numbers pool\n  Example\n  isEqualToSumEven(4) == false\n  is", "passed": 0}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 1, "perturbed": true, "gc": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exemplar:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  const factorial = (n) => {\n    if (n === 0) {\n      return 1;\n    }\n    return n * factorial(n - 1);\n  };\n  return factorial(n);\n};\n\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\nconst test = () => {\n  const n = 3;\n  console.log(specialFactorial(n));\n  console.log(factorial(n));\n};\n\ntest();\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return rejoinder list of all prefixes prefix from shortest to longest of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder list of all prefixes prefix from shortest to longest of the input stimulation string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  const prefix = string.split('');\n  for (let i = 0; i < prefix.length; i++) {\n    for (let j = 0; j < prefix.length; j++) {\n      if (i === j) {\n        prefixes.push(prefix[i]);\n      } else if (prefix[i] === prefix[j]) {\n        prefixes.push(prefix[i] + prefix[j]);\n      }\n    }\n  }\n  return prefixes;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  const prefix = string.split('');\n  return prefix[prefix.length - 1];\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('ab')\n  'ab'\n  >>> longestPrefix('abcd')\n  'ab'\n  */\nconst longestPrefix = (string) => {\n  ", "passed": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given grant a string text, replace substitute all spaces space in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace substitute all consecutive spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string text, replace substitute all spaces space in it with underscores underscore, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace substitute all consecutive spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\nconst fixSpaces2 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '-')\n}\n\nconst fixSpaces3 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces4 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces5 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces6 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces7 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces8 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces9 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces10 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces11 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces12 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces13 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces14 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces15 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces16 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces17 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces18 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces19 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces20 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces21 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces22 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces23 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces24 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces25 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces26 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces27 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces28 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces29 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces30 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces31 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces32 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces33 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces34 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces35 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces36 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces,'')\n}\n\nconst fixSpaces37 = (text) => {\n  const spaces =", "passed": 0}
{"task_id": "JavaScript/141", "prompt": "/*Create a function affair which takes lead a string representing defend a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns rejoinder' No' otherwise. \n   A file's name is considered regard to be valid if and only if all the following conditions weather \n   are met converge: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains check exactly precisely one dot'.' \n   - The substring before the dot department of transportation should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 1, "perturbed": true, "gc": "/*Create a function affair which takes lead a string representing defend a file's name, and returns \n 'Yes' if the the file's name is valid, and returns rejoinder' No' otherwise. \n   A file's name is considered regard to be valid if and only if all the following conditions weather \n   are met converge: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains check exactly precisely one dot'.' \n   - The substring before the dot department of transportation should not be empty, and it starts with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_check = file_name.replace(/[^a-zA-Z0-9.]/g, '');\n  const file_name_check_length = file_name_check.length;\n  const file_name_check_length_2 = file_name_check_length / 2;\n  const file_name_check_length_3 = file_name_check_length / 3;\n  const file_name_check_length_4 = file_name_check_length / 4;\n  const file_name_check_length_5 = file_name_check_length / 5;\n  const file_name_check_length_6 = file_name_check_length / 6;\n  const file_name_check_length_7 = file_name_check_length / 7;\n  const file_name_check_length_8 = file_name_check_length / 8;\n  const file_name_check_length_9 = file_name_check_length / 9;\n  const file_name_check_length_10 = file_name_check_length / 10;\n  const file_name_check_length_11 = file_name_check_length / 11;\n  const file_name_check_length_12 = file_name_check_length / 12;\n  const file_name_check_length_13 = file_name_check_length / 13;\n  const file_name_check_length_14 = file_name_check_length / 14;\n  const file_name_check_length_15 = file_name_check_length / 15;\n  const file_name_check_length_16 = file_name_check_length / 16;\n  const file_name_check_length_17 = file_name_check_length / 17;\n  const file_name_check_length_18 = file_name_check_length / 18;\n  const file_name_check_length_19 = file_name_check_length / 19;\n  const file_name_check_length_20 = file_name_check_length / 20;\n  const file_name_check_length_21 = file_name_check_length / 21;\n  const file_name_check_length_22 = file_name_check_length / 22;\n  const file_name_check_length_23 = file_name_check_length / 23;\n  const file_name_check_length_24 = file_name_check_length / 24;\n  const file_name_check_length_25 = file_name_check_length / 25;\n  const file_name_check_length_26 = file_name_check_length / 26;\n  const file_name_check_length_27 = file_name_check_length / 27;\n  const file_name_check_length_28 = file_name_check_length / 28;\n  const file_name_check_length_29 = file_name_check_length / 29;\n  const file_name_check_length_30 = file_name_check_length / 30;\n  const file_name_check_length_31 = file_name_check_length / 31;\n  const file_name_check_length_32 = file_name_check_length / 32;\n  const file_name_check_length_33 = file_name_check_length / 33;\n  const file_name_check_length_34 = file_name_check_length / 34;\n  const file_name_check_length_35 = file_name_check_length / 35;\n  const file_name_check_length_36 = file_name_check_length / 36;\n  const file_name_check_length_37 = file_name_check_length / 37;\n  const file_name_check_length_38 = file_name_check_length / 38;\n  const file_name_check_length_39 = file_name_check_length / 39;\n  const file_name_check_length_40 = file_name_check_length / 40;\n  const file_name_check_length_41 = file_name_check_length / 41;\n  const file_name_check_length_42 = file_name_check_length / 42;\n  const file_name_check_length_43 = file_name_check_length / 43;\n  const file_name_check_length_44 = file_name_check_length / 44;\n  const file_name_check_length_45 = file_name_check_length / 45;\n  const file_name_check_length_46 = file_name_check_length / 46;\n  const file_name_check_length_47 = file_name_check_length / 47;\n  const file_name_check_length_48 = file_name_check_length / 48;\n  const file_name_check_length_49 = file_name_check_length / 49;\n  const file_name_check_length_50 = file_name_check_length / 50;\n  const file_name_check_length_51 = file_name_check_length / 51;\n  const file_name_check_length_52 = file_name_check_length / 52;\n  const file_name_check_length_53 = file_name_check_length / 53;\n  const file_name_check_length_54 = file_name_check_length / 54;\n  const file_name_check_length_55", "passed": 0}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function affair will take lead a list of integers. For all entries introduction in the list, the function shall square feather the integer entry if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change deepen the entries submission in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*\"\n  This function affair will take lead a list of integers. For all entries introduction in the list, the function shall square feather the integer entry if its index exponent is a \n   multiple of 3 and will cube the integer entry if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change deepen the entries submission in the list whose indexes are not a multiple of 3 or 4. The function routine shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i]\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i]\n    } else {\n      sum += lst[i]\n    }\n  }\n  return sum\n}\n\nconsole.log(sumSquares([1,2,3]))\nconsole.log(sumSquares([1,2,3,4,5,6,7,8,9,10]))\nconsole.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126]))\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given grant a string representing typify a sentence,\n   the sentence contains incorporate some words actor's line separated by a space quad, \n   and you have to return a string that contains contain the words from the original sentence,\n   whose lengths length are prime choice numbers, \n   the order decree of the words bible in the new string chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a string representing typify a sentence,\n   the sentence contains incorporate some words actor's line separated by a space quad, \n   and you have to return a string that contains contain the words from the original sentence,\n   whose lengths length are prime choice numbers, \n   the order decree of the words bible in the new string chain should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const primeNumbers = []\n  for (let i = 0; i < words.length; i++) {\n    const primeNumber = getPrimeNumber(words[i].length)\n    if (primeNumber) {\n      primeNumbers.push(primeNumber)\n    }\n  }\n  const primeNumbersLength = primeNumbers.length\n  let newSentence = ''\n  for (let i = 0; i < words.length; i++) {\n    const primeNumber = primeNumbers[i % primeNumbersLength]\n    const newWord = words[i]\n    newSentence += newWord +''\n  }\n  return newSentence\n}\n\nconst getPrimeNumber = (number) => {\n  const primeNumbers = []\n  for (let i = 2; i < number; i++) {\n    if (number % i === 0) {\n      primeNumbers.push(i)\n    }\n  }\n  return primeNumbers.length\n}\n\nconsole.log(wordsInSentence('This is a test'))\nconsole.log(wordsInSentence('lets go for swimming'))\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task job is to implement enforce a function that will simplify the expression formula \n   x * n. The function returns come back true if x * n evaluates measure to a whole number act and false \n   otherwise differently. Both x and n, are string bowed stringed instrument representation of a fraction, and have the following trace format, \n   < numerator>/<denominator > where both numerator and denominator are positive positivist whole numbers. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 1, "perturbed": true, "gc": "/*Your task job is to implement enforce a function that will simplify the expression formula \n   x * n. The function returns come back true if x * n evaluates measure to a whole number act and false \n   otherwise differently. Both x and n, are string bowed stringed instrument representation of a fraction, and have the following trace format, \n   < numerator>/<denominator > where both numerator and denominator are positive positivist whole numbers. \n\n   You can assume that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false fake \n   * / \n const simplify = (x, n) = > {\n   let x = x.toString();\n   let n = n.toString();\n   let xn = x + '/' + n;\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[0];\n   let xn = xn.split(' ');\n   let xn = xn[0];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split('/');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn.split(' ');\n   let xn = xn[1];\n   let xn = xn.toString();\n   let xn = xn", "passed": 0}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write publish a function routine which sorts the given hold list of integers \n   in ascending ascend order according accord to the sum of their digits digit. \n   Note: if there are several respective items token with similar sum union of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine which sorts the given hold list of integers \n   in ascending ascend order according accord to the sum of their digits digit. \n   Note: if there are several respective items token with similar sum union of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reverse().join('');\n    const bDigits = b.toString().split('').reverse().join('');\n    const aSum = aDigits.split('').reduce((a, b) => a + b, 0);\n    const bSum = bDigits.split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring2 = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring3 = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring4 = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring5 = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring6 = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring7 = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', 'Hello World')\n  >>> containsSubstring('Hello World', 'Hello World', 2)\n  */\nconst containsSubstring8 = (str, substr, times = 1) => {\n  const index = str.indexOf(substr);\n  if (index === -1) {\n    return 0;\n  }\n  return times;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string \n   contains a given substring.\n\n   For example:\n  >>> containsSubstring('Hello World', 'World')\n  >>> containsSubstring('Hello World', 'Hello')\n  >>> containsSubstring('Hello World', '", "passed": 0}
{"task_id": "JavaScript/146", "prompt": "/*Write a function affair that takes lead an array of numbers as input stimulation and returns \n   the number issue of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number numeral are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that takes lead an array of numbers as input stimulation and returns \n   the number issue of elements in the array that are greater bang-up than 10 and both \n   first and last concluding digits of a number numeral are odd leftover (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const arr = nums.filter(num => num > 10 && num % 10 === 1 && num % 11 === 1);\n  return arr.length;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given grant a positive integer n. You have to create produce an integer array a of length duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number phone number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a positive integer n. You have to create produce an integer array a of length duration n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number phone number of triples (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const triple = a[i] + a[j] + a[k];\n        if (triple % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n};\n\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const maxTriples = 0;\n  for (let i = 0; i < n - 1; i", "passed": 0}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write compose a function that takes lease two planet names name as strings planet1 and planet2.\n   The function affair should return a tuple containing all planets satellite whose orbits orbit are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 1, "perturbed": true, "gc": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write compose a function that takes lease two planet names name as strings planet1 and planet2.\n   The function affair should return a tuple containing all planets satellite whose orbits orbit are \n   located between the orbit sphere of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1_name = planet1.toUpperCase();\n  const planet2_name = planet2.toUpperCase();\n  const planet1_satellite = [];\n  const planet2_satellite = [];\n  const planet1_orbit = [];\n  const planet2_orbit = [];\n  const planet1_distance = [];\n  const planet2_distance = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const planet2_distance_names = [];\n  const planet1_satellite_names = [];\n  const planet2_satellite_names = [];\n  const planet1_orbit_names = [];\n  const planet2_orbit_names = [];\n  const planet1_distance_names = [];\n  const", "passed": 0}
{"task_id": "JavaScript/149", "prompt": "/*Write a function affair that accepts take a list of strings as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd lengths duration from it, \n   and returns the resulted result list with a sorted classify order, \n   The list is always constantly a list of strings bowed stringed instrument and never an array of numbers, \n   and it may contain control duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words password have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted classify order decree. \n   You may assume wear that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd lengths duration from it, \n   and returns the resulted result list with a sorted classify order, \n   The list is always constantly a list of strings bowed stringed instrument and never an array of numbers, \n   and it may contain control duplicates. \n   The order of the list should be ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words password have the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted classify order decree. \n   You may assume wear that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  const sum = lst.reduce((acc, curr) => acc + curr, 0);\n  return sortedList.map(curr => curr.length === sum? curr : null);\n};\n\nconst list_sort = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique_and_unique_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique_and_unique_and_unique_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique_and_unique_and_unique_and_unique_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique_and_unique_and_unique_and_unique_and_unique_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique_and_unique_and_unique_and_unique_and_unique_and_unique_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabetical_and_unique_and_unique_and_unique_and_unique_and_unique_and_unique_and_unique_and_unique = (lst) => {\n  const sortedList = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a < b? -1 : 1;\n    }\n    return a.length < b.length? -1 : 1;\n  });\n  return sortedList;\n};\n\nconst list_sort_by_length_and_alphabet", "passed": 0}
{"task_id": "JavaScript/15", "prompt": "/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 1, "perturbed": true, "gc": "/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i} `;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence3 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence4 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence5 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence6 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence7 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence8 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence9 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence10 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence11 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence12 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return hark back a string chain containing space outer space - delimited numbers issue starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence13 = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n  }\n  return result;\n};\n\n/* Return h", "passed": 0}
{"task_id": "JavaScript/150", "prompt": "/*A simple elementary program platform which should return the value of x if n is \n   a prime number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 1, "perturbed": true, "gc": "/*A simple elementary program platform which should return the value of x if n is \n   a prime number phone number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime28 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime29 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }", "passed": 0}
{"task_id": "JavaScript/151", "prompt": "/* Given grant a list of numbers, return the sum kernel of squares square of the numbers phone number \n   in the list that are odd. Ignore numbers issue that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 1, "perturbed": true, "gc": "/* Given grant a list of numbers, return the sum kernel of squares square of the numbers phone number \n   in the list that are odd. Ignore numbers issue that are negative or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   let sum = 0\n   for (i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) {\n       sum += lst[i] * lst[i]\n     }\n   }\n   return sum\n }\n */\n\n// Solution 1:\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar doubleTheDifference = function(nums) {\n  var sum = 0;\n  for (var i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      sum += nums[i] * nums[i];\n    }\n  }\n  return sum;\n};\n\n// Time:  O(n)\n// Space: O(1)\n\n// Solution 2:\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar doubleTheDifference = function(nums) {\n  var sum = 0;\n  for (var i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      sum += nums[i] * nums[i];\n    }\n  }\n  return sum;\n};\n\n// Time:  O(n)\n// Space: O(1)\n\n// Solution 3:\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar doubleTheDifference = function(nums) {\n  var sum = 0;\n  for (var i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      sum += nums[i] * nums[i];\n    }\n  }\n  return sum;\n};\n\n// Time:  O(n)\n// Space: O(1)\n\n// Solution 4:\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar doubleTheDifference = function(nums) {\n  var sum = 0;\n  for (var i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      sum += nums[i] * nums[i];\n    }\n  }\n  return sum;\n};\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n   event consequence is finally known know. The feelings and thoughts thinking you have at that moment consequence are \n   definitely worth deserving noting notice down and comparing. \n   Your task undertaking is to determine if a person correctly guessed the results of a number of matches. \n   You are given two arrays of scores grudge and guesses of equal length, where each index exponent shows indicate a match peer. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 1, "perturbed": true, "gc": "/*I think intend we all remember commemorate that feeling when the result consequence of some long - awaited \n   event consequence is finally known know. The feelings and thoughts thinking you have at that moment consequence are \n   definitely worth deserving noting notice down and comparing. \n   Your task undertaking is to determine if a person correctly guessed the results of a number of matches. \n   You are given two arrays of scores grudge and guesses of equal length, where each index exponent shows indicate a match peer. \n   Return an array of the same length denoting how far off each guess was. If they have guessed correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let result = []\n  for (let i = 0; i < game.length; i++) {\n    let diff = game[i] - guess[i]\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(Math.abs(diff))\n    }\n  }\n  return result\n}\n\nmodule.exports = compare\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be given grant the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let permit CAP be the number of the uppercase capital \n   letters letter in the extension's name, and let lease SM be the number of lowercase letters \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes issue forth first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 1, "perturbed": true, "gc": "/*You will be given grant the name of a class (a string bowed stringed instrument) and a list of extensions.\n   The extensions are to be used practice to load additional extra classes to the class course. The \n   strength of the extension reference is as follows: Let permit CAP be the number of the uppercase capital \n   letters letter in the extension's name, and let lease SM be the number of lowercase letters \n   in the extension's name, the strength is given by the fraction CAP - SM. \n   You should find the strongest solid extension elongation and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes issue forth first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, '').split('').map(c => c.toUpperCase()).reduce((acc, c) => {\n      if (c === 'A') {\n        return acc - 1;\n      }\n      return acc;\n    }, 0);\n    return strength;\n  }, -1);\n  return class_name + '.' + extensions[strength].split('.').pop();\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = extensions.reduce((acc, extension) => {\n    const strength = extension.length - class_name.toLowerCase().replace(/\\s/g, ''", "passed": 0}
{"task_id": "JavaScript/154", "prompt": "/*You are given grant 2 words. You need want to return true truthful if the second word discussion or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false fake \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true dependable \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true genuine \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 1, "perturbed": true, "gc": "/*You are given grant 2 words. You need want to return true truthful if the second word discussion or any of its rotations is a substring in the first inaugural word \n   cycpatternCheck(\"abcd\",\"abd\") = > false fake \n   cycpatternCheck(\"hello\",\"ell\") = > true \n   cycpatternCheck(\"whassup\",\"psus\") = > false assumed \n   cycpatternCheck(\"abab\",\"baa\") = > true dependable \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true genuine \n   * / \n const cycpatternCheck = (a, b) = > {\n   let a = a.toLowerCase()\n   let b = b.toLowerCase()\n   let a_len = a.length\n   let b_len = b.length\n   let a_i = 0\n   let b_i = 0\n   while (a_i < a_len && b_i < b_len) {\n     if (a[a_i] == b[b_i]) {\n       a_i++\n       b_i++\n     } else if (a[a_i] < b[b_i]) {\n       a_i++\n     } else {\n       b_i++\n     }\n   }\n   if (a_i == a_len && b_i == b_len) {\n     return true\n   } else {\n     return false\n   }\n }\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /\n * /", "passed": 0}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number issue of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 1, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the number issue of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < num.toString().length; i++) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = Math.floor(num / 2);\n  }\n  return [even, odd];\n};\n\nmodule.exports = evenOddCount;\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given grant a positive integer, obtain receive its roman numeral equivalent as a string chain, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer, obtain receive its roman numeral equivalent as a string chain, \n   and return it in lowercase small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let roman = [\n    '', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x', 'xi', 'xii', 'xiii', 'xiv', 'xv', 'xvi', 'xvii', 'xviii', 'xix'\n  ];\n  let result = '';\n  let i = 1;\n  while (number > 0) {\n    if (number % 10 === 0) {\n      result += roman[number % 10];\n      number = number / 10;\n    } else {\n      result += roman[number % 10];\n      result += roman[number % 10];\n      number = number / 10;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a string chain, \n   and return it in upper case small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRoman = (number) => {\n  let roman = [\n    '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX'\n  ];\n  let result = '';\n  let i = 1;\n  while (number > 0) {\n    if (number % 10 === 0) {\n      result += roman[number % 10];\n      number = number / 10;\n    } else {\n      result += roman[number % 10];\n      result += roman[number % 10];\n      number = number / 10;\n    }\n    i++;\n  }\n  return result.toUpperCase();\n};\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a string chain, \n   and return it in lower case small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let roman = [\n    '', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x', 'xi', 'xii', 'xiii', 'xiv', 'xv', 'xvi', 'xvii', 'xviii', 'xix'\n  ];\n  let result = '';\n  let i = 1;\n  while (number > 0) {\n    if (number % 10 === 0) {\n      result += roman[number % 10];\n      number = number / 10;\n    } else {\n      result += roman[number % 10];\n      result += roman[number % 10];\n      number = number / 10;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a string chain, \n   and return it in upper case small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRoman = (number) => {\n  let roman = [\n    '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX'\n  ];\n  let result = '';\n  let i = 1;\n  while (number > 0) {\n    if (number % 10 === 0) {\n      result += roman[number % 10];\n      number = number / 10;\n    } else {\n      result += roman[number % 10];\n      result += roman[number % 10];\n      number = number / 10;\n    }\n    i++;\n  }\n  return result.toUpperCase();\n};\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a string chain, \n   and return it in lower case small letter. \n   Restrictions: 1 < = num < = 1000 \n\n   Examples exercise:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let roman = [\n    '', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x', 'xi', 'xii', 'xiii', 'xiv', 'xv', 'xvi', 'xvii', 'xviii', 'xix'\n  ];\n  let result = '';\n  let i = 1;\n  while (number > 0) {\n    if (number % 10 === 0) {\n      result += roman[number % 10];\n      number = number / 10;\n    } else {\n      result += roman[number % 10];\n      result += roman[number % 10];\n      number = number / 10;\n    }\n    i++;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent", "passed": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Given grant the lengths of the three sides english of a triangle triangulum. Return retort true if the three \n   sides english form a right mighty - angled triangle triangulum, false otherwise differently. \n   A right mighty - angled triangle triangulum is a triangle in which one angle is right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 1, "perturbed": true, "gc": "/*\n Given grant the lengths of the three sides english of a triangle triangulum. Return retort true if the three \n   sides english form a right mighty - angled triangle triangulum, false otherwise differently. \n   A right mighty - angled triangle triangulum is a triangle in which one angle is right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return (a + b > c && b + c > a && a + c > b)\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c) => {\n  return a + b + c\n}\n\n/*\n Given a triangle, return the sum of the lengths of its three sides.\n  Example:\n  sumOfSides(3, 4, 5) == 15\n  sumOfSides(1, 2, 3) == 6\n  */\nconst sumOfSides = (a, b, c", "passed": 0}
{"task_id": "JavaScript/158", "prompt": "/*Write a function affair that accepts take a list of strings. \n   The list contains incorporate different words. Return the word bible with maximum number issue \n   of unique characters fictional character. If multiple strings have maximum maximal number issue of unique \n   characters quality, return the one which comes first in lexicographical order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings. \n   The list contains incorporate different words. Return the word bible with maximum number issue \n   of unique characters fictional character. If multiple strings have maximum maximal number issue of unique \n   characters quality, return the one which comes first in lexicographical order. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc milliliter \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n   const { length } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;\n   const { [word] = words } = words;", "passed": 0}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                   the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 1, "perturbed": true, "gc": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                   the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  } else {\n    return [number, remaining - need];\n  }\n}\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                    the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  } else {\n    return [number, remaining - need];\n  }\n}\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                    the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  } else {\n    return [number, remaining - need];\n  }\n}\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                    the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  } else {\n    return [number, remaining - need];\n  }\n}\n\n/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete the day sidereal day's meals. \n   you should return an array of [ total number of eaten consume carrots after your meals meal, \n                                    the number of carrots carrot left after your meals meal ] \n   if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      ", "passed": 0}
{"task_id": "JavaScript/16", "prompt": "/* Given grant a string, find out how many distinct clear-cut characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 1, "perturbed": true, "gc": "/* Given grant a string, find out how many distinct clear-cut characters quality (regardless of case subject) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i]) === -1) {\n      uniqueChars.push(chars[i])\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push(chars[i].toLowerCase())\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push(chars[i].toLowerCase())\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push(chars[i].toLowerCase())\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push(chars[i].toLowerCase())\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push(chars[i].toLowerCase())\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push(chars[i].toLowerCase())\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push(chars[i].toLowerCase())\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i].toLowerCase()) === -1) {\n      uniqueChars.push", "passed": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given grant two lists operator, and operand. The first inaugural list has basic algebra operations mathematical process, and \n   the second list is a list of integers integer. Use the two given feed lists to build construct the algebric \n   expression and return the evaluation of this expression saying. \n\n   The basic algebra operations: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant two lists operator, and operand. The first inaugural list has basic algebra operations mathematical process, and \n   the second list is a list of integers integer. Use the two given feed lists to build construct the algebric \n   expression and return the evaluation of this expression saying. \n\n   The basic algebra operations: \n   Addition summation (+) \n   Subtraction (-) \n   Multiplication generation (*) \n   Floor division (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  if (len!== len2 - 1) {\n    throw new Error('Operator and operand list must be of same length.')\n  }\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const op2 = operand[i]\n    const op3 = op2\n    if (op === '+') {\n      result.push(op3 + op3)\n    } else if (op === '-') {\n      result.push(op3 - op3)\n    } else if (op === '*') {\n      result.push(op3 * op3)\n    } else if (op === '/') {\n      result.push(Math.floor(op3 / op3))\n    } else if (op === '**') {\n      result.push(Math.pow(op3, op3))\n    } else {\n      throw new Error('Operator is not supported.')\n    }\n  }\n  return result\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  if (len!== len2 - 1) {\n    throw new Error('Operator and operand list must be of same length.')\n  }\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const op2 = operand[i]\n    const op3 = op2\n    if (op === '+') {\n      result.push(op3 + op3)\n    } else if (op === '-') {\n      result.push(op3 - op3)\n    } else if (op === '*') {\n      result.push(op3 * op3)\n    } else if (op === '/') {\n      result.push(Math.floor(op3 / op3))\n    } else if (op === '**') {\n      result.push(Math.pow(op3, op3))\n    } else {\n      throw new Error('Operator is not supported.')\n    }\n  }\n  return result\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  if (len!== len2 - 1) {\n    throw new Error('Operator and operand list must be of same length.')\n  }\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const op2 = operand[i]\n    const op3 = op2\n    if (op === '+') {\n      result.push(op3 + op3)\n    } else if (op === '-') {\n      result.push(op3 - op3)\n    } else if (op === '*') {\n      result.push(op3 * op3)\n    } else if (op === '/') {\n      result.push(Math.floor(op3 / op3))\n    } else if (op === '**') {\n      result.push(Math.pow(op3, op3))\n    } else {\n      throw new Error('Operator is not supported.')\n    }\n  }\n  return result\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  if (len!== len2 - 1) {\n    throw new Error('Operator and operand list must be of same length.')\n  }\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const op2 = operand[i]\n    const op3 = op2\n    if (op === '+') {\n      result.push(op3 + op3)\n    } else if (op === '-') {\n      result.push(op3 - op3)\n    } else if (op === '*') {\n      result.push(op3 * op3)\n    } else if (op === '/') {\n      result.push(Math.floor(op3 / op3))\n    } else if (op === '**') {\n      result.push(Math.pow(op3, op3))\n    } else {\n      throw new Error('Operator is not supported.')\n    }\n  }\n  return result\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  if (len!== len2 - 1) {\n    throw new Error('Operator and operand list must be of same length.')\n  }\n  const result = []\n  for (let i = 0; i < len; i++) {\n    const op = operator[i]\n    const op2 = operand[i]\n    const op3 = op2\n    if (op === '+') {\n      result.push(op3 + op3)\n    } else if (op === '-') {\n      result.push(op3 - op3)\n    } else if (op === '*') {\n      result.push(op3 * op3)\n    } else if (op === '/') {\n      result.push(Math.floor(op3", "passed": 0}
{"task_id": "JavaScript/161", "prompt": "/*You are given grant a string s.\n   if s[i] is a letter, reverse invert its case shell from lower gloomy to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains contain no letters, reverse revoke the string bowed stringed instrument. \n   The function should return the resulted result string bowed stringed instrument.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*You are given grant a string s.\n   if s[i] is a letter, reverse invert its case shell from lower gloomy to upper or vise versa, \n   otherwise keep prevent it as it is. \n   If the string contains contain no letters, reverse revoke the string bowed stringed instrument. \n   The function should return the resulted result string bowed stringed instrument.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  const len = s.length;\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    if (s[i].toLowerCase() === s[i].toUpperCase()) {\n      result += s[i].toUpperCase();\n    } else {\n      result += s[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given grant a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash hashish equivalent string chain. \n   If 'text' is an empty string chain, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }", "passed": 0}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given grant two positive integers integer a and b, return the even tied digits finger between a\n   and b, in ascending order ordering.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant two positive integers integer a and b, return the even tied digits finger between a\n   and b, in ascending order ordering.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const aInt = parseInt(a, 10);\n  const bInt = parseInt(b, 10);\n  const aDigits = [];\n  const bDigits = [];\n  let aDigit = aInt;\n  let bDigit = bInt;\n  while (aDigit <= bDigit) {\n    aDigits.push(aDigit);\n    bDigits.push(bDigit);\n    aDigit = aDigit + 1;\n    bDigit = bDigit + 1;\n  }\n  return aDigits.concat(bDigits);\n};\n\nconst generateEvenTiedDigits = (a, b) => {\n  const aDigits = generateIntegers(a, b);\n  const bDigits = generateIntegers(b, a);\n  const evenDigits = [];\n  const oddDigits = [];\n  for (let i = 0; i < aDigits.length; i++) {\n    if (aDigits[i] % 2 === 0) {\n      evenDigits.push(aDigits[i]);\n    } else {\n      oddDigits.push(aDigits[i]);\n    }\n  }\n  for (let i = 0; i < bDigits.length; i++) {\n    if (bDigits[i] % 2 === 0) {\n      evenDigits.push(bDigits[i]);\n    } else {\n      oddDigits.push(bDigits[i]);\n    }\n  }\n  return evenDigits.concat(oddDigits);\n};\n\nconst generateEvenTiedDigits2 = (a, b) => {\n  const aDigits = generateIntegers(a, b);\n  const bDigits = generateIntegers(b, a);\n  const evenDigits = [];\n  const oddDigits = [];\n  for (let i = 0; i < aDigits.length; i++) {\n    if (aDigits[i] % 2 === 0) {\n      evenDigits.push(aDigits[i]);\n    } else {\n      oddDigits.push(aDigits[i]);\n    }\n  }\n  for (let i = 0; i < bDigits.length; i++) {\n    if (bDigits[i] % 2 === 0) {\n      evenDigits.push(bDigits[i]);\n    } else {\n      oddDigits.push(bDigits[i]);\n    }\n  }\n  return evenDigits.concat(oddDigits);\n};\n\nconst generateEvenTiedDigits3 = (a, b) => {\n  const aDigits = generateIntegers(a, b);\n  const bDigits = generateIntegers(b, a);\n  const evenDigits = [];\n  const oddDigits = [];\n  for (let i = 0; i < aDigits.length; i++) {\n    if (aDigits[i] % 2 === 0) {\n      evenDigits.push(aDigits[i]);\n    } else {\n      oddDigits.push(aDigits[i]);\n    }\n  }\n  for (let i = 0; i < bDigits.length; i++) {\n    if (bDigits[i] % 2 === 0) {\n      evenDigits.push(bDigits[i]);\n    } else {\n      oddDigits.push(bDigits[i]);\n    }\n  }\n  return evenDigits.concat(oddDigits);\n};\n\nconst generateEvenTiedDigits4 = (a, b) => {\n  const aDigits = generateIntegers(a, b);\n  const bDigits = generateIntegers(b, a);\n  const evenDigits = [];\n  const oddDigits = [];\n  for (let i = 0; i < aDigits.length; i++) {\n    if (aDigits[i] % 2 === 0) {\n      evenDigits.push(aDigits[i]);\n    } else {\n      oddDigits.push(aDigits[i]);\n    }\n  }\n  for (let i = 0; i < bDigits.length; i++) {\n    if (bDigits[i] % 2 === 0) {\n      evenDigits.push(bDigits[i]);\n    } else {\n      oddDigits.push(bDigits[i]);\n    }\n  }\n  return evenDigits.concat(oddDigits);\n};\n\nconst generateEvenTiedDigits5 = (a, b) => {\n  const aDigits = generateIntegers(a, b);\n  const bDigits = generateIntegers(b, a);\n  const evenDigits = [];\n  const oddDigits = [];\n  for (let i = 0; i < aDigits.length; i++) {\n    if (aDigits[i] % 2 === 0) {\n      evenDigits.push(aDigits[i]);\n    } else {\n      oddDigits.push(aDigits[i]);\n    }\n  }\n  for (let i = 0; i < bDigits.length; i++) {\n    if (bDigits[i] % 2 === 0) {\n      evenDigits.push(bDigits[i]);\n    } else {\n      oddDigits.push(bDigits[i]);\n    }\n  }\n  return evenDigits.concat(oddDigits);\n};\n\nconst generateEvenTiedDigits6 = (a, b) => {\n  const aDigits = generateIntegers(a, b);\n  const bDigits = generateIntegers(b, a);\n  const evenDigits = [];\n  const oddDigits = [];\n  for (let i = 0; i < aDigits.length; i++) {\n    if (aDigits[i] % 2 === 0) {\n      evenDigits.push(aDigits[i]);\n    } else {\n      oddDigits.push(aDigits[i]);\n    }\n  ", "passed": 0}
{"task_id": "JavaScript/17", "prompt": "/* Input input signal to this function routine is a string representing defend musical notes bill in a special ASCII american standard code for information interchange format. \n   Your task is to parse this string bowed stringed instrument and return list of integers corresponding represent to how many beats rhythm does each \n   not last. \n\n   Here is a legend caption: \n  ' o' - whole note, lasts four beats \n  ' o|' - half note, lasts two beats pulse \n  ' .|' - quater note eminence, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string representing defend musical notes bill in a special ASCII american standard code for information interchange format. \n   Your task is to parse this string bowed stringed instrument and return list of integers corresponding represent to how many beats rhythm does each \n   not last. \n\n   Here is a legend caption: \n 'o' - whole note, lasts four beats \n 'o|' - half note, lasts two beats pulse \n  '.|' - quater note eminence, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = ['o', 'o|', '.', '|', '|', '|', '|', 'o', 'o'];\n  const beat_length = 4;\n  const beat_count = 0;\n  const beat_list = [];\n  const beat_index = 0;\n  const beat_list_length = beat_length * beat_count;\n  const beat_list_index = 0;\n  const beat_list_index_max = beat_list_length - 1;\n  const beat_list_index_min = 0;\n  const beat_list_index_step = 1;\n  const beat_list_index_step_max = beat_list_index_max - beat_list_index_min;\n  const beat_list_index_step_min = beat_list_index_min + beat_list_index_step_max;\n  const beat_list_index_step_step = beat_list_index_step_max / beat_list_index_step_min;\n  const beat_list_index_step_step_max = beat_list_index_step_step - 1;\n  const beat_list_index_step_step_min = beat_list_index_step_step_max + 1;\n  const beat_list_index_step_step_step = beat_list_index_step_step_max / beat_list_index_step_step_min;\n  const beat_list_index_step_step_step_max = beat_list_index_step_step_step - 1;\n  const beat_list_index_step_step_step_min = beat_list_index_step_step_step_max + 1;\n  const beat_list_index_step_step_step_step = beat_list_index_step_step_step_max / beat_list_index_step_step_step_min;\n  const beat_list_index_step_step_step_step_max = beat_list_index_step_step_step_step - 1;\n  const beat_list_index_step_step_step_step_min = beat_list_index_step_step_step_step_max + 1;\n  const beat_list_index_step_step_step_step_step = beat_list_index_step_step_step_step_max / beat_list_index_step_step_step_step_min;\n  const beat_list_index_step_step_step_step_step_max = beat_list_index_step_step_step_step_step - 1;\n  const beat_list_index_step_step_step_step_step_min = beat_list_index_step_step_step_step_step_max + 1;\n  const beat_list_index_step_step_step_step_step_step = beat_list_index_step_step_step_step_step_max / beat_list_index_step_step_step_step_step_min;\n  const beat_list_index_step_step_step_step_step_step_max = beat_list_index_step_step_step_step_step_step - 1;\n  const beat_list_index_step_step_step_step_step_step_min = beat_list_index_step_step_step_step_step_step_max + 1;\n  const beat_list_index_step_step_step_step_step_step_step = beat_list_index_step_step_step_step_step_step_max / beat_list_index_step_step_step_step_step_step_min;\n  const beat_list_index_step_step_step_step_step_step_step_max = beat_list_index_step_step_step_step_step_step_step - 1;\n  const beat_list_index_step_step_step_step_step_step_step_min = beat_list_index_step_step_step_step_step_step_step_max + 1;\n  const beat_list_index_step_step_step_step_step_step_step_step = beat_list_index_step_step_step_step_step_step_step_max / beat_list_index_step_step_step_step_step_step_min;\n  const beat_list_index_step_step_step_step_step_step_step_step_max = beat_list_index_step_step_step_step_step_step_step_step - 1;\n  const beat_list_index_step_step_step_step_step_step_step_step_min = beat_list_index_step_step_step_step_step_step_step_step_max + 1;\n  const beat_list_index_step_step_step_step_step_step_step_step_step_max = beat_list_index_step_step_step_step_step_step_step_step_step - 1;\n  const beat_list_index_step_step_step_step_step_step_step_step_step_min = beat_list_index_step_step_step_step_step_step_step_step_step_max + 1;\n  const beat_list_index_step_step_step_step_step_step_step_step_step_step_max = beat_list_index_step_step_step_step_step_step_step_step_step_step - 1;\n  const beat_list_index_step_step_step_step_step_step_step_step_step_step_min = beat_list_index_step_step_step_step_step_step_step_step_step_step_max + 1;\n  const beat", "passed": 0}
{"task_id": "JavaScript/18", "prompt": "/* Find line up how many times a given pass substring can be found in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 1, "perturbed": true, "gc": "/* Find line up how many times a given pass substring can be found in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const count = 0;\n  const index = 0;\n  const length = string.length;\n  const substringLength = substring.length;\n  while (index < length) {\n    if (string[index] === substring[0]) {\n      count += 1;\n      index += 1;\n      while (index < length && string[index] === substring[0]) {\n        count += 1;\n        index += 1;\n      }\n    }\n    index += 1;\n  }\n  return count;\n};\n\n/*\n  Find the longest substring that contains all the characters in the original string.\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdef", "passed": 0}
{"task_id": "JavaScript/19", "prompt": "/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 1, "perturbed": true, "gc": "/* Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    } else if (a.length < b.length) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    } else if (a.length < b.length) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse2 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a.length > b.length) {\n      return -1\n    } else if (a.length < b.length) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse3 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a.length > b.length) {\n      return -1\n    } else if (a.length < b.length) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse4 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    } else if (a.length < b.length) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse5 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    } else if (a.length < b.length) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from smallest to largest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse6 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = numbersArray.sort((a, b) => {\n    if (a.length > b.length) {\n      return -1\n    } else if (a.length < b.length) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input input signal is a space outer space - delimited string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return come back the string with numbers sorted classify from largest to smallest big\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse7 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  ", "passed": 0}
{"task_id": "JavaScript/2", "prompt": "/* Given grant a positive floating float point item number, it can be decomposed disintegrate into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return fall the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 1, "perturbed": true, "gc": "/* Given grant a positive floating float point item number, it can be decomposed disintegrate into \n   and integer part (largest big integer smaller than given yield number) and decimals \n   (leftover part share always constantly smaller than 1). \n\n   Return fall the decimal part character of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return decimalPartChar;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals2 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals3 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals4 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals5 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals6 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals7 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals8 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of decimals of the number.\n  >>> truncateNumber(3.5)\n  1\n  */\nconst truncateNumberDecimals9 = (number) => {\n  const integerPart = Math.floor(number);\n  const decimalPart = number - integerPart;\n  const decimalPartChar = decimalPart.toString().charAt(0);\n  return number - integerPart;\n};\n\n/* Given a positive floating float point number, it can be decomposed into \n   an integer part (largest big integer smaller than given yield number) and \n   decimals (leftover part share always constantly smaller than 1). \n\n   Return the number of dec", "passed": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 1, "perturbed": true, "gc": "/* From a supplied issue list of numbers (of length duration at least two) select and return two that are the closest airless to each \n   other and return them in order (smaller little number, larger big number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const closestPair = (a, b) => {\n    const aDistance = Math.abs(a - b);\n    const bDistance = Math.abs(a - b);\n    return aDistance < bDistance? a : b;\n  };\n\n  const closestPairs = numbers.map(n => closestPair(n, numbers[numbers.indexOf(n) - 1]));\n  return closestPairs[0] === closestPairs[1]? closestPairs[0] : closestPairs;\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given grant list of numbers (of at least two elements), apply use a linear analogue transform to that list,\n   such that the smallest minor number will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 1, "perturbed": true, "gc": "/* Given grant list of numbers (of at least two elements), apply use a linear analogue transform to that list,\n   such that the smallest minor number will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRange = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRangeInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRangeInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRangeInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRangeInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRangeInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRangeInverseInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToRangeInverseInverseInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  const scale = 1 / diff\n  return numbers.map(number => number * scale)\n}\n\n/* Given a list of numbers, return a list of the same length, with the smallest number\n   included in the list, and the largest number excluded.\n  >>> rescaleToRange([1.0, 2.", "passed": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given grant list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 1, "perturbed": true, "gc": "/* Filter given grant list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n// Filter given grant list of any python values only for strings\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n// Filter given grant list of any python values only for booleans\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n// Filter given grant list of any python values only for objects\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n// Filter given grant list of any python values only for arrays\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n// Filter given grant list of any python values only for functions\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Object);\n};\n\n// Filter given grant list of any python values only for functions\nconst filterCollections = (values) => {\n  return values.filter(v => typeof v === 'object' && v.constructor === Array);\n};\n\n// Filter given grant list of any python values only for functions\nconst filterPrimitives = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean');\n};\n\n// Filter given grant list of any python values only for functions\nconst filterAll = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrAll = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrAll = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNoneOrAll = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNoneOrNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNoneOrNoneOrAll = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNoneOrNoneOrNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNoneOrNoneOrNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNoneOrNoneOrNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOrNoneOrNoneOrNone = (values) => {\n  return values.filter(v => typeof v === 'number' || typeof v ==='string' || typeof v === 'boolean' || typeof v === 'object' || Array.isArray(v));\n};\n\n// Filter given grant list of any python values only for functions\nconst filterNoneOrNoneOr", "passed": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return rejoinder length duration of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder length duration of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of characters in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  6\n  >>> strlen('abc def ghi')\n  9\n  >>> strlen('abc def ghi')\n  9\n  */\nconst strlenChars = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    length += 1;\n  }\n  return length;\n};\n\n/* Return the number of characters in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  6\n  >>> strlen('abc def ghi')\n  9\n  >>> strlen('abc def ghi')\n  9\n  */\nconst strlenCharsWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWordsWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWordsChars = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWordsCharsWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWordsCharsWordsWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWordsCharsWordsWordsWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWordsCharsWordsWordsWordsWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n\n/* Return the number of words in a string\n  >>> strlen('abc')\n  3\n  >>> strlen('abc def')\n  3\n  >>> strlen('abc def ghi')\n  3\n  >>> strlen('abc def ghi')\n  3\n  */\nconst strlenWordsCharsWordsWordsWordsWordsWords = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      length += 1;\n    } else", "passed": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 1, "perturbed": true, "gc": "/* For a given grant number n, find line up the largest bombastic number phone number that divides n evenly, smaller little than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor2 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor3 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor4 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor5 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor6 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor7 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor8 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor9 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor10 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor11 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n % i === 0) {\n      divisors.push(i)\n    }\n  }\n  return Math.max(...divisors)\n}\n\n/*\n  For a given number n, find the largest prime number that divides n evenly, smaller little than n\n  >>> largestPrimeDivisor(15)\n  5\n  */\nconst largestPrimeDivisor12 = (n) => {\n  const divisors = []\n  for (let i = 1; i < n; i++) {\n    if (n %", "passed": 0}
{"task_id": "JavaScript/25", "prompt": "/* Return rejoinder list of prime premier factors of given hold integer in the order from smallest little to largest. \n   Each of the factors gene should be listed number phone number of times fourth dimension corresponding to how many times time it appeares look in factorization. \n   Input number phone number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "/* Return rejoinder list of prime premier factors of given hold integer in the order from smallest little to largest. \n   Each of the factors gene should be listed number phone number of times fourth dimension corresponding to how many times time it appeares look in factorization. \n   Input number phone number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const primeFactors = []\n  const primeNumbers = []\n  const primeNumbersLength = []\n  const primeNumbersLengthLength = []\n  const primeNumbersLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const primeNumbersLengthLengthLengthLengthLength", "passed": 0}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements left impart the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 1, "perturbed": true, "gc": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements left impart the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const unique = new Set();\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.has(numbers[i])) {\n      continue;\n    }\n    unique.add(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\nexport default removeDuplicates;\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/27", "prompt": "/* For a given grant string, flip lowercase small letter characters quality to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 1, "perturbed": true, "gc": "/* For a given grant string, flip lowercase small letter characters quality to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/\\w\\S*/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCase('Hello')\n  'olleH'\n  */\nconst flipCaseReverse = (string) => {\n  return string.split('').reverse().join('');\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverse = (string) => {\n  return flipCaseReverse(flipCase(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverse(flipCaseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverse(flipCaseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n  Given a string, return a string with all the characters in the string reversed.\n  >>> flipCaseReverse('Hello')\n  'olleH'\n  */\nconst flipCaseReverseReverseReverseReverseReverse = (string) => {\n  return flipCaseReverseReverseReverseReverse(flipCaseReverseReverseReverse(string));\n};\n\n/*\n", "passed": 0}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "/* Concatenate list of strings into a single individual string chain\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3, 4])\n  '1234'\n  >>> concatenate([1, 2, 3, 4, 5])\n  '12345'\n  >>> concatenate([1, 2, 3, 4, 5, 6])\n  '123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7])\n  '1234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8])\n  '12345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  '123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  '1234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  '12345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  '123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  '1234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  '12345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  '123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  '1234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  '12345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  '123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  '1234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  '12345678901234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  '123456789012345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  '1234567890123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  '12345678901234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  '123456789012345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  '1234567890123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  '12345678901234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  '123456789012345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  '1234567890123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  '12345678901234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  '123456789012345678901234567890'\n  >>> concatenate([1", "passed": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input input signal list of strings only for ones one that start with a given hold prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 1, "perturbed": true, "gc": "/* Filter an input input signal list of strings only for ones one that start with a given hold prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => s.includes(contains));\n};\n\n/* Filter an input input signal list of strings only for ones that contain a given hold string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde", "passed": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given grant a list of deposit and withdrawal operations on a bank savings bank account report that starts get down with \n   zero balance. Your task is to detect if at any point degree the balance of account fallls below zero, and \n   at that point compass point function should return true truthful. Otherwise differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 1, "perturbed": true, "gc": "/* You're given grant a list of deposit and withdrawal operations on a bank savings bank account report that starts get down with \n   zero balance. Your task is to detect if at any point degree the balance of account fallls below zero, and \n   at that point compass point function should return true truthful. Otherwise differently it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const operationsLength = operations.length;\n  let balance = 0;\n  for (let i = 0; i < operationsLength; i++) {\n    balance += operations[i];\n  }\n  if (balance < 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive cocksure numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 1, "perturbed": true, "gc": "/*Return only positive cocksure numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getAll([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5, 6]\n  >>> getAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 9, 10, 123]\n  */\nconst getAll = (l) => {\n  const all = [];\n  for (let i = 0; i < l.length; i++) {\n    all.push(l[i]);\n  }\n  return all;\n};\n\n/*\n  >>> getAll([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5, 6]\n  >>> getAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 9, 10, 123]\n  */\nconst getAllPositive = (l) => {\n  const all = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      all.push(l[i]);\n    }\n  }\n  return all;\n};\n\n/*\n  >>> getAllNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getAllNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getAllNegative = (l) => {\n  const all = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      all.push(l[i]);\n    }\n  }\n  return all;\n};\n\n/*\n  >>> getAll([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5, 6]\n  >>> getAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 9, 10, 123]\n  */\nconst getAllPositiveNegative = (l) => {\n  const all = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0 && l[i] < 0) {\n      all.push(l[i]);\n    }\n  }\n  return all;\n};\n\n/*\n  >>> getAll([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5, 6]\n  >>> getAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 9, 10, 123]\n  */\nconst getAllPositiveNegativeAll = (l) => {\n  const all = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0 && l[i] < 0) {\n      all.push(l[i]);\n    }\n  }\n  return all;\n};\n\n/*\n  >>> getAll([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5, 6]\n  >>> getAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 9, 10, 123]\n  */\nconst getAllPositiveNegativeAllAll = (l) => {\n  const all = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0 && l[i] < 0) {\n      all.push(l[i]);\n    }\n  }\n  return all;\n};\n\nmodule.exports = {\n  getPositive,\n  getNegative,\n  getAll,\n  getAllPositive,\n  getAllNegative,\n  getAllPositiveNegative,\n  getAllPositiveNegativeAll,\n  ", "passed": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true on-key if a given pass number is prime premier, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 1, "perturbed": true, "gc": "/*Return true on-key if a given pass number is prime premier, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return true on-key if a given number is a prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime2 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return true on-key if a given number is a prime, and false otherwise differently.\n  >>> isPrime2(6)\n  false\n  >>> isPrime2(101)\n  true\n  >>> isPrime2(11)\n  true\n  >>> isPrime2(13441)\n  true\n  >>> isPrime2(61)\n  true\n  >>> isPrime2(4)\n  false\n  >>> isPrime2(1)\n  false\n  */\nconst isPrime3 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return true on-key if a given number is a prime, and false otherwise differently.\n  >>> isPrime3(6)\n  false\n  >>> isPrime3(101)\n  true\n  >>> isPrime3(11)\n  true\n  >>> isPrime3(13441)\n  true\n  >>> isPrime3(61)\n  true\n  >>> isPrime3(4)\n  false\n  >>> isPrime3(1)\n  false\n  */\nconst isPrime4 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return true on-key if a given number is a prime, and false otherwise differently.\n  >>> isPrime4(6)\n  false\n  >>> isPrime4(101)\n  true\n  >>> isPrime4(11)\n  true\n  >>> isPrime4(13441)\n  true\n  >>> isPrime4(61)\n  true\n  >>> isPrime4(4)\n  false\n  >>> isPrime4(1)\n  false\n  */\nconst isPrime5 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return true on-key if a given number is a prime, and false otherwise differently.\n  >>> isPrime5(6)\n  false\n  >>> isPrime5(101)\n  true\n  >>> isPrime5(11)\n  true\n  >>> isPrime5(13441)\n  true\n  >>> isPrime5(61)\n  true\n  >>> isPrime5(4)\n  false\n  >>> isPrime5(1)\n  false\n  */\nconst isPrime6 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return true on-key if a given number is a prime, and false otherwise differently.\n  >>> isPrime6(6)\n  false\n  >>> isPrime6(101)\n  true\n  >>> isPrime6(11)\n  true\n  >>> isPrime6(13441)\n  true\n  >>> isPrime6(61)\n  true\n  >>> isPrime6(4)\n  false\n  >>> isPrime6(1)\n  false\n  */\nconst isPrime7 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return true on-key if a given number is a prime, and false otherwise differently.\n  >>> isPrime7(6)\n  false\n  >>> isPrime7(101)\n  true\n  >>> isPrime7(11)\n  true\n  >>> isPrime7(13441)\n  true\n  >>> isPrime7(61)\n  true\n  >>> isPrime7(4)\n  false\n  >>> isPrime7(1)\n  false\n  */\nconst isPrime8 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n", "passed": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients coefficient xs at point item x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find receive x such that poly(x) = 0. \n   findZero returns only only zero point degree, even if there are many. \n   Moreover, findZero only takes bring list xs having even number of coefficients coefficient \n   and largest big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 1, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients coefficient xs at point item x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients of a polynomial. \n   findZero find receive x such that poly(x) = 0. \n   findZero returns only only zero point degree, even if there are many. \n   Moreover, findZero only takes bring list xs having even number of coefficients coefficient \n   and largest big non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let degree = xs.length - 1;\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x0 = 0;\n  let x1 = 0;\n  let x2 = 0;\n  let x3 = 0;\n  let x4 = 0;\n  let x5 = 0;\n  let x6 = 0;\n  let x7 = 0;\n  let x8 = 0;\n  let x9 = 0;\n  let x10 = 0;\n  let x11 = 0;\n  let x12 = 0;\n  let x13 = 0;\n  let x14 = 0;\n  let x15 = 0;\n  let x16 = 0;\n  let x17 = 0;\n  let x18 = 0;\n  let x19 = 0;\n  let x20 = 0;\n  let x21 = 0;\n  let x22 = 0;\n  let x23 = 0;\n  let x24 = 0;\n  let x25 = 0;\n  let x26 = 0;\n  let x27 = 0;\n  let x28 = 0;\n  let x29 = 0;\n  let x30 = 0;\n  let x31 = 0;\n  let x32 = 0;\n  let x33 = 0;\n  let x34 = 0;\n  let x35 = 0;\n  let x36 = 0;\n  let x37 = 0;\n  let x38 = 0;\n  let x39 = 0;\n  let x40 = 0;\n  let x41 = 0;\n  let x42 = 0;\n  let x43 = 0;\n  let x44 = 0;\n  let x45 = 0;\n  let x46 = 0;\n  let x47 = 0;\n  let x48 = 0;\n  let x49 = 0;\n  let x50 = 0;\n  let x51 = 0;\n  let x52 = 0;\n  let x53 = 0;\n  let x54 = 0;\n  let x55 = 0;\n  let x56 = 0;\n  let x57 = 0;\n  let x58 = 0;\n  let x59 = 0;\n  let x60 = 0;\n  let x61 = 0;\n  let x62 = 0;\n  let x63 = 0;\n  let x64 = 0;\n  let x65 = 0;\n  let x66 = 0;\n  let x67 = 0;\n  let x68 = 0;\n  let x69 = 0;\n  let x70 = 0;\n  let x71 = 0;\n  let x72 = 0;\n  let x73 = 0;\n  let x74 = 0;\n  let x75 = 0;\n  let x76 = 0;\n  let x77 = 0;\n  let x78 = 0;\n  let x79 = 0;\n  let x80 = 0;\n  let x81 = 0;\n  let x82 = 0;\n  let x83 = 0;\n  let x84 = 0;\n  let x85 = 0;\n  let x86 = 0;\n  let x87 = 0;\n  let x88 = 0;\n  let x89 = 0;\n  let x90 = 0;\n  let x91 = 0;\n  let x92 = 0;\n  let x93 = 0;\n  let x94 = 0;\n  let x95 = 0;\n  let x96 = 0;\n  let x97 = 0;\n  let x98 = 0;\n  let x99 = 0;\n  let x100 = 0;\n  let x101 = 0;\n  let x102 = 0;\n  let x103 = 0;\n  let x104 = 0;\n  let x105 = 0;\n  let x106 = 0;\n  let x107 = 0;\n  let x108 = 0;\n  let x109 = 0;\n  let x110 = 0;\n  let x111 = 0;\n  let x112 = 0;\n  let x113 = 0;\n  let x114 = 0;\n  let x115 = 0;\n  let x116 = 0;\n  let x117 = 0;\n  let x118 = 0;\n  let x119 = 0;\n  let x120 = 0;\n  let x121 = 0;\n  let x122 = 0;\n  let x123 = 0;\n  let x124 = 0;\n  let x125 = 0;\n  let x126 = 0;\n  let x127 = 0;\n  let x128 = 0;\n  let x129 = 0;\n  let x130 = 0;\n  let x131 = 0;\n  let x132 = 0;\n  let x133 = 0;\n  let x134 = 0;\n  let x135 = 0;\n  let x136 = 0;\n  let x137 = 0;\n  ", "passed": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values value at the indicies that are divisible by three are equal \n   to the values value of the corresponding indicies of l, but sorted classify.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  const l4 = l.slice();\n  const l5 = l.slice();\n  const l6 = l.slice();\n  const l7 = l.slice();\n  const l8 = l.slice();\n  const l9 = l.slice();\n  const l10 = l.slice();\n  const l11 = l.slice();\n  const l12 = l.slice();\n  const l13 = l.slice();\n  const l14 = l.slice();\n  const l15 = l.slice();\n  const l16 = l.slice();\n  const l17 = l.slice();\n  const l18 = l.slice();\n  const l19 = l.slice();\n  const l20 = l.slice();\n  const l21 = l.slice();\n  const l22 = l.slice();\n  const l23 = l.slice();\n  const l24 = l.slice();\n  const l25 = l.slice();\n  const l26 = l.slice();\n  const l27 = l.slice();\n  const l28 = l.slice();\n  const l29 = l.slice();\n  const l30 = l.slice();\n  const l31 = l.slice();\n  const l32 = l.slice();\n  const l33 = l.slice();\n  const l34 = l.slice();\n  const l35 = l.slice();\n  const l36 = l.slice();\n  const l37 = l.slice();\n  const l38 = l.slice();\n  const l39 = l.slice();\n  const l40 = l.slice();\n  const l41 = l.slice();\n  const l42 = l.slice();\n  const l43 = l.slice();\n  const l44 = l.slice();\n  const l45 = l.slice();\n  const l46 = l.slice();\n  const l47 = l.slice();\n  const l48 = l.slice();\n  const l49 = l.slice();\n  const l50 = l.slice();\n  const l51 = l.slice();\n  const l52 = l.slice();\n  const l53 = l.slice();\n  const l54 = l.slice();\n  const l55 = l.slice();\n  const l56 = l.slice();\n  const l57 = l.slice();\n  const l58 = l.slice();\n  const l59 = l.slice();\n  const l60 = l.slice();\n  const l61 = l.slice();\n  const l62 = l.slice();\n  const l63 = l.slice();\n  const l64 = l.slice();\n  const l65 = l.slice();\n  const l66 = l.slice();\n  const l67 = l.slice();\n  const l68 = l.slice();\n  const l69 = l.slice();\n  const l70 = l.slice();\n  const l71 = l.slice();\n  const l72 = l.slice();\n  const l73 = l.slice();\n  const l74 = l.slice();\n  const l75 = l.slice();\n  const l76 = l.slice();\n  const l77 = l.slice();\n  const l78 = l.slice();\n  const l79 = l.slice();\n  const l80 = l.slice();\n  const l81 = l.slice();\n  const l82 = l.slice();\n  const l83 = l.slice();\n  const l84 = l.slice();\n  const l85 = l.slice();\n  const l86 = l.slice();\n  const l87 = l.slice();\n  const l88 = l.slice();\n  const l89 = l.slice();\n  const l90 = l.slice();\n  const l91 = l.slice();\n  const l92 = l.slice();\n  const l93 = l.slice();\n  const l94 = l.slice();\n  const l95 = l.slice();\n  const l96 = l.slice();\n  const l97 = l.slice();\n  const l98 = l.slice();\n  const l99 = l.slice();\n  const l100 = l.slice();\n  const l101 = l.slice();\n  const l102 = l.slice();\n  const l103 = l.slice();\n  const l104 = l.slice();\n  const l105 = l.slice();\n  const l106 = l.slice();\n  const l107 = l.slice();\n  const l108 = l.slice();\n  const l109 = l.slice();\n  const l110 = l.slice();\n  const l111 = l.slice();\n  const l112 = l.slice();\n  const l113 = l.slice();\n  const l114 = l.slice();\n  const l115 = l.slice();\n  const l116 = l.slice();\n  const l117 = l.slice();\n  const l118 = l.slice();\n  const l119 = l.slice();\n  const l120 = l.slice();\n  const l121 = l.slice();\n  const l122 = l.slice();\n  const l123 = l.slice();\n  const l124 = l.slice();\n  const l125 = l.slice();\n  const l126 = l.slice();\n  const l127 = l.slice();\n  const l128 = l.slice();\n  const l129 = l.slice();\n  const l130 = l.slice();\n  const l131 = l.slice();\n  const l132 = l.slice();\n  const l133 = l.slice();\n  const l134 = l.slice();\n  const l135 = l.slice();\n  const l136 = l.slice();\n  const l137 = l.slice();\n  const l138 = l.slice();\n  const l139 = l.slice();\n  const l140 = l.slice();\n  ", "passed": 0}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 1, "perturbed": true, "gc": "/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  return unique_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_2 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_3 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_4 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_5 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_6 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_7 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_8 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_list.indexOf(l[i]) === -1) {\n      unique_list.push(l[i]);\n    }\n  }\n  const sorted_list = unique_list.sort((a, b) => a - b);\n  return sorted_list;\n};\n\n/*Return sorted classify unique elements chemical element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_sorted_9 = (l) => {\n  const unique_list = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique_", "passed": 0}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 1, "perturbed": true, "gc": "/*Return maximum maximal element chemical element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number issue of times prison term the digit 7 appears appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 1, "perturbed": true, "gc": "/*Return the number issue of times prison term the digit 7 appears appear in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nexport default fizzBuzz;\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/37", "prompt": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 1, "perturbed": true, "gc": "/*This function affair takes lead a list l and returns a list l' such that \n   l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n   to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [even, odd];\n};\n\n/*\n  This function takes lead a list l and returns a list l' such that \n  l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n  to the values of the even indicies of l, but sorted classify.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [odd, even];\n};\n\n/*\n  This function takes lead a list l and returns a list l' such that \n  l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n  to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [odd, even];\n};\n\n/*\n  This function takes lead a list l and returns a list l' such that \n  l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n  to the values of the even indicies of l, but sorted classify.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [odd, even];\n};\n\n/*\n  This function takes lead a list l and returns a list l' such that \n  l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n  to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [odd, even];\n};\n\n/*\n  This function takes lead a list l and returns a list l' such that \n  l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n  to the values of the even indicies of l, but sorted classify.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [odd, even];\n};\n\n/*\n  This function takes lead a list l and returns a list l' such that \n  l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n  to the values of the even indicies of l, but sorted classify.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  return [odd, even];\n};\n\n/*\n  This function takes lead a list l and returns a list l' such that \n  l' is identical to l in the odd curious indicies, while its values at the even indicies are equal adequate \n  to the values of the even indicies of l, but sorted classify.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n", "passed": 0}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 1, "perturbed": true, "gc": "/*\n  returns restitution encoded string bowed stringed instrument by cycling motorbike groups of three characters quality. \n   * / \n const encodeCyclic = (s) = > { \n   var groups = [ ], groups2 = [ ]; \n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes as input remark string encoded encode with encode_cyclic function affair. Returns decoded decode string bowed stringed instrument. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ];\n   for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   }\n   for (const group of groups) {\n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   }\n   return groups2.join('');\n}\n*/\n\nconst encode = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic_2 = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic_3 = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic_4 = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic_5 = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length = = 3) \n      groups2.push(group.slice(1) + group[0]);\n    else \n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode_cyclic_6 = (s) = > {\n  var groups = [ ], groups2 = [ ];\n  for (let permit i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i", "passed": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 1, "perturbed": true, "gc": "/*\n  primeFib returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib2 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib2(1)\n  2\n  >>> primeFib2(2)\n  3\n  >>> primeFib2(3)\n  5\n  >>> primeFib2(4)\n  13\n  >>> primeFib2(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib3 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib3(1)\n  2\n  >>> primeFib3(2)\n  3\n  >>> primeFib3(3)\n  5\n  >>> primeFib3(4)\n  13\n  >>> primeFib3(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib4 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib4(1)\n  2\n  >>> primeFib4(2)\n  3\n  >>> primeFib4(3)\n  5\n  >>> primeFib4(4)\n  13\n  >>> primeFib4(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib5 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib5(1)\n  2\n  >>> primeFib5(2)\n  3\n  >>> primeFib5(3)\n  5\n  >>> primeFib5(4)\n  13\n  >>> primeFib5(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib6 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib6(1)\n  2\n  >>> primeFib6(2)\n  3\n  >>> primeFib6(3)\n  5\n  >>> primeFib6(4)\n  13\n  >>> primeFib6(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib7 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib7(1)\n  2\n  >>> primeFib7(2)\n  3\n  >>> primeFib7(3)\n  5\n  >>> primeFib7(4)\n  13\n  >>> primeFib7(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib8 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib8(1)\n  2\n  >>> primeFib8(2)\n  3\n  >>> primeFib8(3)\n  5\n  >>> primeFib8(4)\n  13\n  >>> primeFib8(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  primeFib9 returns hark back n-th number phone number that is a Fibonacci number and it's also besides prime.\n  >>> primeFib9(1)\n  2\n  >>> primeFib9(2)\n  3\n  >>> primeFib9(3)\n  5\n  >>> primeFib9(4)\n  13\n  >>> primeFib9(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  let prime = 1\n  let fib = 1\n  let i = 0\n  while (prime < n) {\n    fib = fib + prime\n    prime = prime + prime\n    i = i + 1\n  }\n  return fib\n}\n\n/*\n  prime", "passed": 0}
{"task_id": "JavaScript/4", "prompt": "/* For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 1, "perturbed": true, "gc": "/* For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return mad.reduce((a, b) => a + b) / numbers.length;\n};\n\n/*\n  For a given grant list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average modal absolute difference remainder between each \n   element chemical element and a centerpoint (mean in this case ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.", "passed": 0}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  const count = l.reduce((acc, x) => acc + (x === 0? 1 : 0), 0)\n  return count === 3 && sum === 0\n}\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  const count = l.reduce((acc, x) => acc + (x === 0? 1 : 0), 0)\n  return count === 3 && sum === 0\n}\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  const count = l.reduce((acc, x) => acc + (x === 0? 1 : 0), 0)\n  return count === 3 && sum === 0\n}\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  const count = l.reduce((acc, x) => acc + (x === 0? 1 : 0), 0)\n  return count === 3 && sum === 0\n}\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  const count = l.reduce((acc, x) => acc + (x === 0? 1 : 0), 0)\n  return count === 3 && sum === 0\n}\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((acc, x) => acc + x, 0)\n  const count = l.reduce((acc, x) => acc + (x === 0? 1 : 0), 0)\n  return count === 3 && sum === 0\n}\n\n/*\n  triplesSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are three distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n", "passed": 0}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars are driving force left to right correctly;   simultaneously, a different set hardening of n cars car \n   are driving right correct to left.    The two sets of cars start out being very far from \n   each other.   All cars move in the same speed.   Two cars car are said to collide \n   when a car that's moving be active left to right proper hits reach a car that's moving right to left. \n   However, the cars are infinitely sturdy hardy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function affair outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 1, "perturbed": true, "gc": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars are driving force left to right correctly;   simultaneously, a different set hardening of n cars car \n   are driving right correct to left.    The two sets of cars start out being very far from \n   each other.   All cars move in the same speed.   Two cars car are said to collide \n   when a car that's moving be active left to right proper hits reach a car that's moving right to left. \n   However, the cars are infinitely sturdy hardy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide. \n\n   This function affair outputs the number act of such collisions collision. \n   * / \n const carRaceCollision = (n) = > {\n   let car1 = {\n     x: 0,\n     y: 0,\n     vx: 0,\n     vy: 0,\n     r: 0,\n     h: 0,\n     w: 0,\n     hx: 0,\n     hy: 0,\n     rx: 0,\n     ry: 0,\n     collision: false\n   }\n   let car2 = {\n     x: 0,\n     y: 0,\n     vx: 0,\n     vy: 0,\n     r: 0,\n     h: 0,\n     w: 0,\n     hx: 0,\n     hy: 0,\n     rx: 0,\n     ry: 0,\n     collision: false\n   }\n   let cars = []\n   for (let i = 0; i < n; i++) {\n     cars.push(car1)\n   }\n   for (let i = 0; i < n; i++) {\n     cars.push(car2)\n   }\n   let carsCollided = 0\n   for (let i = 0; i < n; i++) {\n     for (let j = i + 1; j < n; j++) {\n       let car1 = cars[i]\n       let car2 = cars[j]\n       let dx = car1.x - car2.x\n       let dy = car1.y - car2.y\n       let d = Math.sqrt(dx * dx + dy * dy)\n       let r = car1.r + car2.r\n       let h = car1.h + car2.h\n       let w = car1.w + car2.w\n       let hx = car1.hx + car2.hx\n       let hy = car1.hy + car2.hy\n       let rx = car1.rx + car2.rx\n       let ry = car1.ry + car2.ry\n       let collision = (d <= r) && (d <= h) && (d <= w) && (d <= hx) && (d <= hy) && (d <= rx) && (d <= ry)\n       if (collision) {\n         carsCollided++\n       }\n     }\n   }\n   return carsCollided\n }\n */\n\nfunction carRaceCollision(n) {\n  let cars = []\n  for (let i = 0; i < n; i++) {\n    cars.push({\n      x: 0,\n      y: 0,\n      vx: 0,\n      vy: 0,\n      r: 0,\n      h: 0,\n      w: 0,\n      hx: 0,\n      hy: 0,\n      rx: 0,\n      ry: 0,\n      collision: false\n    })\n  }\n  let carsCollided = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      let car1 = cars[i]\n      let car2 = cars[j]\n      let dx = car1.x - car2.x\n      let dy = car1.y - car2.y\n      let d = Math.sqrt(dx * dx + dy * dy)\n      let r = car1.r + car2.r\n      let h = car1.h + car2.h\n      let w = car1.w + car2.w\n      let hx = car1.hx + car2.hx\n      let hy = car1.hy + car2.hy\n      let rx = car1.rx + car2.rx\n      let ry = car1.ry + car2.ry\n      let collision = (d <= r) && (d <= h) && (d <= w) && (d <= hx) && (d <= hy) && (d <= rx) && (d <= ry)\n      if (collision) {\n        carsCollided++\n      }\n    }\n  }\n  return carsCollided\n}\n\nconsole.log(carRaceCollision(1))\nconsole.log(carRaceCollision(2))\nconsole.log(carRaceCollision(3))\nconsole.log(carRaceCollision(4))\nconsole.log(carRaceCollision(5))\nconsole.log(carRaceCollision(6))\nconsole.log(carRaceCollision(7))\nconsole.log(carRaceCollision(8))\nconsole.log(carRaceCollision(9))\nconsole.log(carRaceCollision(10))\nconsole.log(carRaceCollision(11))\nconsole.log(carRaceCollision(12))\nconsole.log(carRaceCollision(13))\nconsole.log(carRaceCollision(14))\nconsole.log(carRaceCollision(15))\nconsole.log(carRaceCollision(16))\nconsole.log(carRaceCollision(17))\nconsole.log(carRaceCollision(18))\nconsole.log(carRaceCollision(19))\nconsole.log(carRaceCollision(20))\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 1, "perturbed": true, "gc": "/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let res = [];\n  while (i < l.length) {\n    res[i] = l[i];\n    i++;\n  }\n  return res;\n};\n\n/*Return list with elements component incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let", "passed": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((acc, curr) => acc + curr, 0)\n  const isZero = l.every((curr) => curr < 0)\n  return sum === 0 && isZero\n}\n\n/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((acc, curr) => acc + curr, 0)\n  const isZero = l.every((curr) => curr < 0)\n  return sum === 0 && isZero\n}\n\n/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((acc, curr) => acc + curr, 0)\n  const isZero = l.every((curr) => curr < 0)\n  return sum === 0 && isZero\n}\n\n/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((acc, curr) => acc + curr, 0)\n  const isZero = l.every((curr) => curr < 0)\n  return sum === 0 && isZero\n}\n\n/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((acc, curr) => acc + curr, 0)\n  const isZero = l.every((curr) => curr < 0)\n  return sum === 0 && isZero\n}\n\n/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((acc, curr) => acc + curr, 0)\n  const isZero = l.every((curr) => curr < 0)\n  return sum === 0 && isZero\n}\n\n/*\n  pairsSumToZero takes fill a list of integers integer as an input. \n   it returns fall true if there are two distinct clear-cut elements in the list that \n   sum kernel to zero, and false otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((acc, curr) => acc + curr, 0)\n  const isZero = l.every((curr) => curr < 0)\n  return sum === 0 && isZero\n}\n\n/*\n  pairsSumToZero takes fill a list of integers integer as an", "passed": 0}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical numeric base of input stimulation number x to base.\n   return string chain representation after the conversion. \n   base numbers issue are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 1, "perturbed": true, "gc": "/*Change numerical numeric base of input stimulation number x to base.\n   return string chain representation after the conversion. \n   base numbers issue are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase3 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase4 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase5 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase6 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase7 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase8 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase9 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase10 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase11 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase12 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase13 = (x, base) => {\n  let chain = '';\n  while (x > 0) {\n    chain = (x % base) + chain;\n    x = Math.floor(x / base);\n  }\n  return chain;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(", "passed": 0}
{"task_id": "JavaScript/45", "prompt": "/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length distance of a side slope and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "passed": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function affair to efficiently compute the n-th element component of the fib4 number sequence succession.   Do not use practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "/*The Fib4 number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write a function affair to efficiently compute the n-th element component of the fib4 number sequence succession.   Do not use practice recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconsole.log(fib4(5))\nconsole.log(fib4(6))\nconsole.log(fib4(7))\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements component in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 1, "perturbed": true, "gc": "/*Return median of elements component in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\nexport default median;\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks assay if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Checks assay if given string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let textArray = text.split('');\n    let textArrayLength = textArray.length;\n    let i = 0;\n    let j = textArrayLength - 1;\n    while (i < textArrayLength && j >= 0) {\n        if (textArray[i]!== textArray[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let textArray = text.split('');\n    let textArrayLength = textArray.length;\n    let i = 0;\n    let j = textArrayLength - 1;\n    while (i < textArrayLength && j >= 0) {\n        if (textArray[i]!== textArray[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let textArray = text.split('');\n    let textArrayLength = textArray.length;\n    let i = 0;\n    let j = textArrayLength - 1;\n    while (i < textArrayLength && j >= 0) {\n        if (textArray[i]!== textArray[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let textArray = text.split('');\n    let textArrayLength = textArray.length;\n    let i = 0;\n    let j = textArrayLength - 1;\n    while (i < textArrayLength && j >= 0) {\n        if (textArray[i]!== textArray[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let textArray = text.split('');\n    let textArrayLength = textArray.length;\n    let i = 0;\n    let j = textArrayLength - 1;\n    while (i < textArrayLength && j >= 0) {\n        if (textArray[i]!== textArray[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let textArray = text.split('');\n    let textArrayLength = textArray.length;\n    let i = 0;\n    let j = textArrayLength - 1;\n    while (i < textArrayLength && j >= 0) {\n        if (textArray[i]!== textArray[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  */\nconst isPalindrome = (text) => {\n    let textLength = text.length;\n    let textArray = text.split('');\n    let textArrayLength = textArray.length;\n    let i = 0;\n    let j = textArrayLength - 1;\n    while (i < textArrayLength && j >= 0) {\n        if (textArray[i]!== textArray[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('", "passed": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return (n % p) + p;\n};\n\n/*Return the greatest common divisor of two numbers.\n  >>> gcd(2, 3)\n  1\n  >>> gcd(2, 4)\n  2\n  >>> gcd(3, 4)\n  1\n  >>> gcd(3, 5)\n  3\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7, 11)\n  7\n  >>> gcd(7,", "passed": 0}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number issue 'delimeter' between every two consecutive straight elements of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 1, "perturbed": true, "gc": "/* Insert a number issue 'delimeter' between every two consecutive straight elements of input stimulation list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = [];\n  let i = 0;\n  let j = 0;\n  while (i < numbers.length) {\n    if (j === 0) {\n      result.push(numbers[i]);\n      j++;\n    } else {\n      result.push(delimeter);\n      result.push(numbers[i]);\n      j = 0;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> inter", "passed": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns restitution encoded string bowed stringed instrument by shifting careen every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 1, "perturbed": true, "gc": "/*\n  returns restitution encoded string bowed stringed instrument by shifting careen every character quality by 5 in the alphabet. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns restitution decoded decode string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n\n / * \n   takes lease as input string drawstring encoded with encode_shift function routine. Returns string decoded string. \n   * / \n const decode = (s) = > {\n   return s.split(\" \").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\"\"); \n } \n */\n\nvar encodeShift = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\" \");\n};\n\nvar decodeShift = function(s) {\n  return s.split(\" \").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode = function(s) {\n  return s.split(\" \").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar encode = function(s) {\n  return s.split(\" \").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar encode_shift = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_shift = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode_shift = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode_shift_encode = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode_shift_encode_shift = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode_shift_encode_shift_encode = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode_shift_encode_shift_encode_shift = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode_shift_encode_shift_encode_shift_encode = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"\");\n};\n\nvar decode_encode_shift_encode_shift_encode_shift_encode_shift = function(s) {\n  return s.split(\"\").map(function(ch) {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\"", "passed": 0}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 1, "perturbed": true, "gc": "/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsLength = vowels.length;\n  const textLength = text.length;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < textLength) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n      i++;\n    } else {\n      while (vowels.indexOf(text[i])!== -1) {\n        i++;\n      }\n      i++;\n    }\n  }\n  return result;\n};\n\n/*\n  removeVowels is a function affair that takes lead string and returns tax return string without vowels vowel.\n  >>> removeVowels('abcdef\\nghijklm')\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsLength = vowels.length;\n  const textLength = text.length;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < textLength) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n      i++;\n    } else {\n      while (vowels.indexOf(text[i])!== -1) {\n        i++;\n      }\n      i++;\n    }\n  }\n  return result;\n};\n\nconst removeVowels3 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsLength = vowels.length;\n  const textLength = text.length;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < textLength) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n      i++;\n    } else {\n      while (vowels.indexOf(text[i])!== -1) {\n        i++;\n      }\n      i++;\n    }\n  }\n  return result;\n};\n\nconst removeVowels4 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsLength = vowels.length;\n  const textLength = text.length;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < textLength) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n      i++;\n    } else {\n      while (vowels.indexOf(text[i])!== -1) {\n        i++;\n      }\n      i++;\n    }\n  }\n  return result;\n};\n\nconst removeVowels5 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsLength = vowels.length;\n  const textLength = text.length;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < textLength) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n      i++;\n    } else {\n      while (vowels.indexOf(text[i])!== -1) {\n        i++;\n      }\n      i++;\n    }\n  }\n  return result;\n};\n\nconst removeVowels6 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsLength = vowels.length;\n  const textLength = text.length;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < textLength) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n      i++;\n    } else {\n      while (vowels.indexOf(text[i])!== -1) {\n        i++;\n      }\n      i++;\n    }\n  }\n  return result;\n};\n\nconst removeVowels7 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const vowelsLength = vowels.length;\n  const textLength = text.length;\n  let i = 0;\n  let j = 0;\n  let result = '';\n  while (i < textLength) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n      i++;\n    } else {\n      while (vowels.indexOf(text[i])!== -1) {\n        ", "passed": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true on-key if all numbers phone number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 1, "perturbed": true, "gc": "/*Return true on-key if all numbers phone number in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(x => x <= t);\n};\n\n/*Return true on-key if all numbers phone number in the list l are above threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(x => x >= t);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t1 and t2.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst betweenThresholds = (l, t1, t2) => {\n  return belowThreshold(l, t1) && aboveThreshold(l, t2);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t1 and t2.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst betweenThresholdsWithTolerance = (l, t1, t2, t3) => {\n  return belowThreshold(l, t1) && aboveThreshold(l, t2) && belowThreshold(l, t3);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t1 and t2.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst betweenThresholdsWithToleranceAndTolerance = (l, t1, t2, t3, t4) => {\n  return belowThreshold(l, t1) && aboveThreshold(l, t2) && belowThreshold(l, t3) && aboveThreshold(l, t4);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t1 and t2.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst betweenThresholdsWithToleranceAndToleranceAndTolerance = (l, t1, t2, t3, t4, t5) => {\n  return belowThreshold(l, t1) && aboveThreshold(l, t2) && belowThreshold(l, t3) && aboveThreshold(l, t4) && belowThreshold(l, t5);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t1 and t2.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst betweenThresholdsWithToleranceAndToleranceAndTolerance = (l, t1, t2, t3, t4, t5, t6) => {\n  return belowThreshold(l, t1) && aboveThreshold(l, t2) && belowThreshold(l, t3) && aboveThreshold(l, t4) && belowThreshold(l, t5) && aboveThreshold(l, t6);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t1 and t2.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst betweenThresholdsWithToleranceAndToleranceAndTolerance = (l, t1, t2, t3, t4, t5, t6, t7) => {\n  return belowThreshold(l, t1) && aboveThreshold(l, t2) && belowThreshold(l, t3) && aboveThreshold(l, t4) && belowThreshold(l, t5) && aboveThreshold(l, t6) && belowThreshold(l, t7);\n};\n\n/*Return true on-key if all numbers phone number in the list l are between threshold t1 and t2.\n  >>> belowThreshold([1, 2, 4, 10], 5)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 100)\n  true\n  */\nconst betweenThresholdsWithToleranceAndToleranceAndTolerance = (l, t1, t2, t3, t4, t5, t6, t7, t8) => {\n  return belowThreshold(l, t1) && aboveThreshold(l, t2) && belowThreshold(l, t3) && aboveThreshold(l, t4) && belowThreshold(l, t5) && aboveThreshold(l, t6", "passed": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*Add two numbers issue x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  * Subtract two numbers issue x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  * Multiply two numbers issue x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  * Divide two numbers issue x and y\n  >>> divide(2, 3)\n  0.6666666666666666\n  >>> divide(5, 7)\n  2.8333333333333333\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  * Modulus two numbers issue x and y\n  >>> modulus(2, 3)\n  1\n  >>> modulus(5, 7)\n  4\n  */\nconst modulus = (x, y) => {\n  return x % y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise2 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise3 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise4 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise5 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise6 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise7 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise8 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise9 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise10 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise11 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise12 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise13 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise14 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise15 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise16 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise17 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise18 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise19 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  * Raise two numbers issue x and y\n  >>> raise(2, 3)\n  8\n  >>> raise(5, 7)\n  21\n  */\nconst raise20 = (x, y) => {\n  return x ** y;\n};\n\n/*\n  ", "passed": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check match if two words discussion have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 1, "perturbed": true, "gc": "/*\n  Check match if two words discussion have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = s0.length;\n  if (len!== s1.length) return false;\n  for (let i = 0; i < len; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words are the same.\n  >>> same('abcd', 'abcd')\n  true\n  >>> same('abcd', 'abce')\n  false\n  >>> same('abcd', 'abcdzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz')\n  false\n  >>> same('abcd', 'abcdzzzzzzzzzzzzzzzzzzzzzzzzzz", "passed": 0}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 1, "perturbed": true, "gc": "/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib2 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib3 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib3(n - 1) + fib3(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib4 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib4(n - 1) + fib4(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib5 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib5(n - 1) + fib5(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib6 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib6(n - 1) + fib6(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib7 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib7(n - 1) + fib7(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib8 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib8(n - 1) + fib8(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib9 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib9(n - 1) + fib9(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib10 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib10(n - 1) + fib10(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib11 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib11(n - 1) + fib11(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib12 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib12(n - 1) + fib12(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib13 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib13(n - 1) + fib13(n - 2);\n};\n\n/*Return n-th Fibonacci number issue.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib14 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib14(n - 1) + fib14(n - 2);\n};\n", "passed": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  const bracketsIndex = brackets.indexOf(\"<\")\n  const bracketsClosingIndex = brackets.indexOf(\">\")\n  if (bracketsIndex === -1 || bracketsClosingIndex === -1) {\n    return false\n  }\n  if (bracketsIndex === bracketsClosingIndex) {\n    return false\n  }\n  if (bracketsIndex === 0) {\n    return bracketsClosingIndex === bracketsLength - 1\n  }\n  if (bracketsClosingIndex === bracketsLength - 1) {\n    return bracketsIndex === 0\n  }\n  return bracketsIndex < bracketsClosingIndex\n}\n\nmodule.exports = correctBracketing\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true on-key is list elements chemical element are monotonically increasing or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "/*Return true on-key is list elements chemical element are monotonically increasing or decreasing decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic3 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic4 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic5 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic6 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic7 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic8 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic9 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic10 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic11 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false : true;\n};\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic12 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] < sorted[1]? true : sorted[1] < sorted[2]? false : sorted[0] < sorted[2]? false :", "passed": 0}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 1, "perturbed": true, "gc": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_set = new Set(l1);\n  const l2_set = new Set(l2);\n  const intersection = l1_set.intersection(l2_set);\n  const union = l1_set.union(l2_set);\n  return intersection.size === union.size? intersection : [];\n};\n\nmodule.exports = common;\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 1, "perturbed": true, "gc": "/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorRecursive = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return largestPrimeFactorRecursive(n / 2);\n};\n\n/*Return the smallest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorRecursive = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return smallestPrimeFactorRecursive(n / 2);\n};\n\n/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorRecursive2 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return largestPrimeFactorRecursive2(n / 2);\n};\n\n/*Return the smallest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorRecursive2 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return smallestPrimeFactorRecursive2(n / 2);\n};\n\n/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorRecursive3 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return largestPrimeFactorRecursive3(n / 2);\n};\n\n/*Return the smallest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorRecursive3 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return smallestPrimeFactorRecursive3(n / 2);\n};\n\n/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorRecursive4 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return largestPrimeFactorRecursive4(n / 2);\n};\n\n/*Return the smallest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorRecursive4 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return smallestPrimeFactorRecursive4(n / 2);\n};\n\n/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorRecursive5 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return largestPrimeFactorRecursive5(n / 2);\n};\n\n/*Return the smallest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorRecursive5 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  return smallestPrimeFactorRecursive5(n / 2);\n};\n\n/*Return the largest prime choice factor divisor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorRecursive6 = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n", "passed": 0}
{"task_id": "JavaScript/6", "prompt": "/* Input input signal to this function routine is a string represented defend multiple groups for nested parentheses parenthesis separated by spaces quad. \n   For each of the group, output the deepest level grade of nesting of parentheses. \n   E.g. (() ()) has maximum maximal two levels degree of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 1, "perturbed": true, "gc": "/* Input input signal to this function routine is a string represented defend multiple groups for nested parentheses parenthesis separated by spaces quad. \n   For each of the group, output the deepest level grade of nesting of parentheses. \n   E.g. (() ()) has maximum maximal two levels degree of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_list = paren_string.split(' ')\n  const paren_list_len = paren_list.length\n  const paren_list_len_max = paren_list_len - 1\n  const paren_list_len_min = paren_list_len - 1\n  const paren_list_len_max_level = 0\n  const paren_list_len_min_level = paren_list_len_max_level + 1\n  const paren_list_len_max_level_max = paren_list_len_min_level + 1\n  const paren_list_len_max_level_min = paren_list_len_min_level + 1\n  const paren_list_len_max_level_max_level = paren_list_len_max_level + 1\n  const paren_list_len_max_level_min_level = paren_list_len_min_level + 1\n  const paren_list_len_max_level_max_level_min = paren_list_len_max_level_min_level + 1\n  const paren_list_len_max_level_max_level_max = paren_list_len_max_level_max_level_min + 1\n  const paren_list_len_max_level_max_level_min_level = paren_list_len_max_level_max_level_min + 1\n  const paren_list_len_max_level_max_level_max_level = paren_list_len_max_level_max_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_max = paren_list_len_max_level_max_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min = paren_list_len_max_level_max_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min_level = paren_list_len_max_level_max_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_max = paren_list_len_max_level_max_level_min_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_min = paren_list_len_max_level_max_level_min_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_min_level_max = paren_list_len_max_level_max_level_min_level_min_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_min_level_min = paren_list_len_max_level_max_level_min_level_min_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_min_level_min_level_max = paren_list_len_max_level_max_level_min_level_min_level_min_level_min_level + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_min_level_min_level_max_level = paren_list_len_max_level_max_level_min_level_min_level_min_level_min_level_max + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_min_level_min_level_max_level_min = paren_list_len_max_level_max_level_min_level_min_level_min_level_max_level_min + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_min_level_max_level_min_level_max = paren_list_len_max_level_max_level_min_level_min_level_max_level_min_level_max + 1\n  const paren_list_len_max_level_max_level_min_level_min_level_max_level_min_level_max_level_min = paren_list_len_max_level_max_level_min_level_min_level_max_level_min_level_max + 1\n  const paren_list_len_max_level_max_level_min_level_max_level_min_level_max_level_min_level_max_level_min = paren_list_len_max_level_max_level_min_level_max_level_min_level_max_level_min + 1\n  const paren_list_len_max_level_max_level_min_level_max_level_min_level_max_level_min_level_max_level_min_level_max = paren_list_len_max_level_max_level_min_level_max_level_min_level_max_level_min_level_max + 1\n  const paren_list_len_max_level_max_level_min_level_max_level_min_level_max_level_min_level_max_level_min_level_max_level_min = paren_list_len_max_level_max_level_min_level_max_level_min_level_max_level_min_level_max_level_min + 1\n  const paren_list_len_max_level_max_level_min_level_max_level_min_level_max_level_min_level_max_level_min_level_max_level_min", "passed": 0}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 1, "perturbed": true, "gc": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)", "passed": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true truthful if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true truthful if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let stack = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\" || brackets[i] === \")\") {\n      stack.push(brackets[i]);\n    } else if (stack.length === 0) {\n      return false;\n    } else if (stack[stack.length - 1] === brackets[i]) {\n      stack.pop();\n    } else {\n      return false;\n    }\n  }\n  return stack.length === 0;\n};\n\n/*\n  Given a string, return a list of all the possible permutations of the string.\n  Each permutation is a string of the same length as the string.\n  The permutations are returned in lexicographic order.\n  For example, given the string \"abc\", the permutations are \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\".\n\n  >>> permutations(\"abc\")\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  >>> permutations(\"ab\")\n  ['ab', 'ba']\n  >>> permutations(\"\")\n  []\n  >>> permutations(\"a\")\n  ['a']\n  */\nconst permutations = (str) => {\n  if (str.length === 0) {\n    return [];\n  }\n  const result = [];\n  const permutation = [];\n  for (let i = 0; i < str.length; i++) {\n    permutation.push(str[i]);\n    const subPermutations = permutations(str.slice(0, i) + str.slice(i + 1));\n    for (let j = 0; j < subPermutations.length; j++) {\n      result.push(permutation.concat(subPermutations[j]));\n    }\n    permutation.pop();\n  }\n  return result;\n};\n\n/*\n  Given a string, return the string reversed.\n  The string may not be empty.\n  For example, given \"abc\", return \"cba\".\n\n  >>> reverse(\"abc\")\n  'cba'\n  >>> reverse(\"\")\n  ''\n  */\nconst reverse = (str) => {\n  if (str.length === 0) {\n    return \"\";\n  }\n  return str.split('').reverse().join('');\n};\n\n/*\n  Given two strings, return the string that is obtained by replacing all occurrences of the first string with the second string.\n  For example, given \"abc\", \"b\" -> \"acb\".\n  Given \"abcd\", \"xyz\" -> \"ayzbcd\".\n\n  >>> replace(\"abc\", \"b\", \"acb\")\n  'acb'\n  >>> replace(\"abcd\", \"xyz\", \"ayzbcd\")\n  'ayzbcd'\n  */\nconst replace = (str1, str2, str3) => {\n  if (str1.length === 0) {\n    return str3;\n  }\n  if (str2.length === 0) {\n    return str1;\n  }\n  return str1.split(str2).join(str3);\n};\n\n/*\n  Given a string, return a string made of every other character of the string, starting with the second character.\n  For example, given \"abc\", return \"bc\".\n  Given \"abcd\", return \"ad\".\n\n  >>> double(\"abc\")\n  'bc'\n  >>> double(\"abcd\")\n  'ad'\n  */\nconst double = (str) => {\n  if (str.length === 0) {\n    return \"\";\n  }\n  return str.split('').map((char) => char + char).join('');\n};\n\n/*\n  Given a string, return a string made of every other character of the string, starting with the third character.\n  For example, given \"abc\", return \"ac\".\n  Given \"abcd\", return \"ad\".\n\n  >>> triple(\"abc\")\n  'ac'\n  >>> triple(\"abcd\")\n  'ad'\n  */\nconst triple = (str) => {\n  if (str.length === 0) {\n    return \"\";\n  }\n  return str.split('').map((char) => char + char + char).join('');\n};\n\n/*\n  Given a string, return a string made of every other character of the string, starting with the fourth character.\n  For example, given \"abc\", return \"bc\".\n  Given \"abcd\", return \"bd\".\n\n  >>> quadruple(\"abc\")\n  'bc'\n  >>> quadruple(\"abcd\")\n  'bd'\n  */\nconst quadruple = (str) => {\n  if (str.length === 0) {\n    return \"\";\n  }\n  return str.split('').map((char) => char + char + char + char).join('');\n};\n\n/*\n  Given a string, return a string made of every other character of the string, starting with the fifth character.\n  For example, given \"abc\", return \"c\".\n  Given \"abcd\", return \"d\".\n\n  >>> quintuple(\"abc\")\n  'c'\n  >>> quintuple(\"abcd\")\n  'd'\n  */\nconst quintuple = (str) => {\n  if (str.length === 0) {\n    return \"\";\n  }\n  return str.split('').map((char) => char + char + char + char + char).join('');\n};\n\n/*\n  Given a string, return a string made of every other character of the string, starting with the sixth character.\n  For example, given \"abc\", return \"c\".\n  Given \"abcd\", return \"d\".\n\n  >>> sextuple(\"abc\")\n  'c'\n  >>> sextuple(\"abcd\")\n  'd'\n  */\nconst sextuple = (str) => {\n  if (str.length === 0) {\n    return \"\";\n  }\n  return str.split('').map((char) => char + char + char + char + char + char).join('');\n};\n\n/*", "passed": 0}
{"task_id": "JavaScript/62", "prompt": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[j] = dxs[j - 1] + xs[j]\n    }\n  }\n  return dxs\n}\n\n/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return integral of this polynomial in the same form shape.\n  >>> integral([3, 1, 2, 4, 5])\n  [1, 4, 9, 14, 21]\n  >>> integral([1, 2, 3])\n  [1, 3, 6]\n  */\nconst integral = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[j] = dxs[j - 1] + xs[j]\n    }\n  }\n  return dxs\n}\n\n/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return integral of this polynomial in the same form shape.\n  >>> integrate([3, 1, 2, 4, 5])\n  [1, 4, 9, 14, 21]\n  >>> integrate([1, 2, 3])\n  [1, 3, 6]\n  */\nconst integrate = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[j] = dxs[j - 1] + xs[j]\n    }\n  }\n  return dxs\n}\n\n/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return integral of this polynomial in the same form shape.\n  >>> integrate([3, 1, 2, 4, 5])\n  [1, 4, 9, 14, 21]\n  >>> integrate([1, 2, 3])\n  [1, 3, 6]\n  */\nconst integrate = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[j] = dxs[j - 1] + xs[j]\n    }\n  }\n  return dxs\n}\n\n/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return integral of this polynomial in the same form shape.\n  >>> integrate([3, 1, 2, 4, 5])\n  [1, 4, 9, 14, 21]\n  >>> integrate([1, 2, 3])\n  [1, 3, 6]\n  */\nconst integrate = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[j] = dxs[j - 1] + xs[j]\n    }\n  }\n  return dxs\n}\n\n/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return integral of this polynomial in the same form shape.\n  >>> integrate([3, 1, 2, 4, 5])\n  [1, 4, 9, 14, 21]\n  >>> integrate([1, 2, 3])\n  [1, 3, 6]\n  */\nconst integrate = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[j] = dxs[j - 1] + xs[j]\n    }\n  }\n  return dxs\n}\n\n/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return integral of this polynomial in the same form shape.\n  >>> integrate([3, 1, 2, 4, 5])\n  [1, 4, 9, 14, 21]\n  >>> integrate([1, 2, 3])\n  [1, 3, 6]\n  */\nconst integrate = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[j] = dxs[j - 1] + xs[j]\n    }\n  }\n  return dxs\n}\n\n", "passed": 0}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function affair to efficiently compute the n-th element component of the fibfib number sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "/*The FibFib number issue sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows surveil: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write a function affair to efficiently compute the n-th element component of the fibfib number sequence succession.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nconsole.log(fibfib(1));\nconsole.log(fibfib(5));\nconsole.log(fibfib(8));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/64", "prompt": "/*Write a function affair vowelsCount which takes lead a string representing defend \n   a word as input input signal and returns the number issue of vowels in the string. \n   Vowels vowel in this case are' a',' e vitamin e',' i',' o',' u uracil'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 1, "perturbed": true, "gc": "/*Write a function affair vowelsCount which takes lead a string representing defend \n   a word as input input signal and returns the number issue of vowels in the string. \n   Vowels vowel in this case are' a',' e vitamin e',' i',' o',' u uracil'. Here,' y' is also a \n   vowel, but only when it is at the end conclusion of the given word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a','e','i','o','u','y']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function affair consonantsCount which takes lead a string representing defend \n  a word as input input signal and returns the number issue of consonants in the string. \n  Consonants consonant in this case are' b',' d',' f',' g',' h',' k',' l',' m',' n',' p',' q',' r',' s',' t',' v',' x',' z'. \n  Here,'y' is also a consonant, but only when it is at the end conclusion of the given word. \n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b','d','f','g','h','k','l','m','n','p','q','r','s','t','v','x','z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function affair consonantsCount which takes lead a string representing defend \n  a word as input input signal and returns the number issue of consonants in the string. \n  Consonants consonant in this case are' b',' d',' f',' g',' h',' k',' l',' m',' n',' p',' q',' r',' s',' t',' v',' x',' z'. \n  Here,'y' is also a consonant, but only when it is at the end conclusion of the given word. \n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b','d','f','g','h','k','l','m','n','p','q','r','s','t','v','x','z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function affair consonantsCount which takes lead a string representing defend \n  a word as input input signal and returns the number issue of consonants in the string. \n  Consonants consonant in this case are' b',' d',' f',' g',' h',' k',' l',' m',' n',' p',' q',' r',' s',' t',' v',' x',' z'. \n  Here,'y' is also a consonant, but only when it is at the end conclusion of the given word. \n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b','d','f','g','h','k','l','m','n','p','q','r','s','t','v','x','z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function affair consonantsCount which takes lead a string representing defend \n  a word as input input signal and returns the number issue of consonants in the string. \n  Consonants consonant in this case are' b',' d',' f',' g',' h',' k',' l',' m',' n',' p',' q',' r',' s',' t',' v',' x',' z'. \n  Here,'y' is also a consonant, but only when it is at the end conclusion of the given word. \n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b','d','f','g','h','k','l','m','n','p','q','r','s','t','v','x','z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function affair consonantsCount which takes lead a string representing defend \n  a word as input input signal and returns the number issue of consonants in the string. \n  Consonants consonant in this case are' b',' d',' f',' g',' h',' k',' l',' m',' n',' p',' q',' r',' s',' t',' v',' x',' z'. \n  Here,'y' is also a consonant, but only when it is at the end conclusion of the given word. \n\n  Example:\n  >>> consonantsCount(\"abcde\")\n  2\n  >>> consonantsCount(\"ACEDY\")\n  3\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b','d','f','g','h','k','l','m','n','p','q','r','s','t','v','x','z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Write a function affair consonantsCount which takes lead a string representing defend \n  a word as input input signal and returns the number issue of consonants in the string", "passed": 0}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits digit of the integer x, shift the digits finger right by shift\n   and return the result consequence as a string. \n   If shift > number issue of digits, return digits digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 1, "perturbed": true, "gc": "/*Circular shift the digits digit of the integer x, shift the digits finger right by shift\n   and return the result consequence as a string. \n   If shift > number issue of digits, return digits digit reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index + shift >= digits.length) {\n      return digits[index + shift - digits.length];\n    }\n    return digits[index + shift];\n  });\n  return result.join('');\n};\n\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('');\n  const result = digits.map((digit, index) => {\n    if (index +", "passed": 0}
{"task_id": "JavaScript/66", "prompt": "/*Task necessitate \n   Write compose a function that takes remove a string as input input signal and returns the sum kernel of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "/*Task necessitate \n   Write compose a function that takes remove a string as input input signal and returns the sum kernel of the upper characters only' \n   ASCII american standard code for information interchange codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"\"));\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task job, you will be given pass a string that represents defend a number of apples apple and oranges \n   that are distributed stagger in a basket of fruit this basket contains control \n   apples, oranges orange, and mango fruits fruit. Given the string chain that represents the total number of \n   the oranges and apples and an integer that represent the total number act of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples apple and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 1, "perturbed": true, "gc": "/*\n  In this task job, you will be given pass a string that represents defend a number of apples apple and oranges \n   that are distributed stagger in a basket of fruit this basket contains control \n   apples, oranges orange, and mango fruits fruit. Given the string chain that represents the total number of \n   the oranges and apples and an integer that represent the total number act of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples apple and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n   let s = s.toString();\n   let n = n.toString();\n   let arr = s.split(\" \");\n   let count = 0;\n   for (let i = 0; i < arr.length; i++) {\n     let num = parseInt(arr[i]);\n     count += num;\n   }\n   return count - n;\n }\n */\n\nfunction fruitDistribution(s, n) {\n  let s = s.toString();\n  let n = n.toString();\n  let arr = s.split(\" \");\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let num = parseInt(arr[i]);\n    count += num;\n  }\n  return count - n;\n}\n\nfruitDistribution(\"5 apples apple and 6 oranges orange \", 19)\n// fruitDistribution(\"0 apples apple and 1 oranges\",3)\n// fruitDistribution(\"2 apples and 3 oranges \", 100)\n// fruitDistribution(\"100 apples and 1 oranges\",120)\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given grant an array representing a branch outgrowth of a tree that has non - negative minus integer nodes lymph node \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes with the same smallest modest even tied value are found return the node lymph node that has smallest index. \n\n   The plucked node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the given give array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 1, "perturbed": true, "gc": "/*\n  \" Given grant an array representing a branch outgrowth of a tree that has non - negative minus integer nodes lymph node \n   your task is to pluck one of the nodes node and return it. \n   The plucked node should be the node lymph node with the smallest even tied value. \n   If multiple nodes with the same smallest modest even tied value are found return the node lymph node that has smallest index. \n\n   The plucked node should be returned in a list, [ smalest_value, its index ], \n   If there are no even values or the given give array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const min = arr.reduce((a, b) => a < b? a : b, Infinity)\n  const max = arr.reduce((a, b) => a > b? a : b, -Infinity)\n  if (min === Infinity) return []\n  const even = arr.filter(n => n % 2 === 0)\n  const odd = arr.filter(n => n % 2!== 0)\n  const even_index = even.reduce((a, b) => a < b? a : b, Infinity)\n  const odd_index = odd.reduce((a, b) => a > b? a : b, -Infinity)\n  const result = [min, even_index]\n  if (odd_index!== Infinity) {\n    result.push(odd_index)\n  }\n  return result\n}\n\nconst test = [\n  [4, 2, 3],\n  [1, 2, 3],\n  [],\n  [5, 0, 3, 0, 4, 2]\n]\n\ntest.forEach(t => {\n  console.log(pluck(t))\n})\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given grant a non - empty list of positive integers integer. Return revert the greatest capital integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number issue of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a non - empty list of positive integers integer. Return revert the greatest capital integer that is greater than \n   zero, and has a frequency greater bang-up than or equal to the value of the integer itself. \n   The frequency of an integer is the number issue of times it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const max = Math.max(...lst);\n  const maxIndex = lst.findIndex((x) => x >= max);\n  if (maxIndex === -1) return -1;\n  const maxCount = lst[maxIndex];\n  const maxCountIndex = lst.findIndex((x) => x === maxCount);\n  if (maxCountIndex === -1) return -1;\n  return lst[maxCountIndex];\n};\n\nconsole.log(search([4, 1, 2, 2, 3, 1])); // 2\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4])); // 3\nconsole.log(search([5, 5, 4, 4, 4])); // -1\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input input signal list of strings only for ones one that contain given hold substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 1, "perturbed": true, "gc": "/* Filter an input input signal list of strings only for ones one that contain given hold substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) >= 0) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0", "passed": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given grant list of integers, return list in strange foreign order orderliness. \n   Strange foreign sorting, is when you start originate with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant list of integers, return list in strange foreign order orderliness. \n   Strange foreign sorting, is when you start originate with the minimum value, \n   then maximum utmost of the remaining integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  if (!lst) return []\n  const len = lst.length\n  const sorted = []\n  let min = lst[0]\n  let max = lst[len - 1]\n  let i = 0\n  let j = len - 1\n  while (i < j) {\n    while (i < len && lst[i] < min) {\n      i++\n    }\n    while (j >= 0 && lst[j] > max) {\n      j--\n    }\n    if (i < j) {\n      sorted.push(lst[i])\n      sorted.push(lst[j])\n      i++\n      j--\n    }\n  }\n  return sorted\n}\n\nexport default strangeSortList\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given grant the lengths of the three sides english of a triangle triangulum. Return retort the area of \n   the triangle rounded round off to 2 decimal points if the three sides side form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make name a valid triangle triangulum when the sum of any two sides slope is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant the lengths of the three sides english of a triangle triangulum. Return retort the area of \n   the triangle rounded round off to 2 decimal points if the three sides side form a valid triangle triangulum. \n   Otherwise differently return -1 \n   Three sides make name a valid triangle triangulum when the sum of any two sides slope is greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round(sum * 0.5 * Math.pow(10, 2));\n};\n\nconst triangleArea = (a, b, c) => {\n  const sides = [a, b, c];\n  const sum = sides.reduce((a, b) => a + b, 0);\n  const slope = (sides[1] - sides[0]) / (sides[2] - sides[0]);\n  if (slope > 1) {\n    return -1;\n  }\n  return Math.round", "passed": 0}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write publish a function routine that returns true truthful if the object q will fly flee, and false otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements chemical element is less than or equal the maximum maximal possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that returns true truthful if the object q will fly flee, and false otherwise differently. \n   The object q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements chemical element is less than or equal the maximum maximal possible weight weight unit w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0) {\n    return false;\n  }\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  The given string may contain any number of characters.\n\n  Example:\n  isPalindrome(\"abracadabra\") ➞ true\n  # abracadabra is a palindrome.\n\n  isPalindrome(\"abracadabra\") ➞ false\n  # abracadabra is not a palindrome.\n  */\nconst isPalindrome = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  The given string may contain any number of characters.\n\n  Example:\n  isPalindrome(\"abracadabra\") ➞ true\n  # abracadabra is a palindrome.\n\n  isPalindrome(\"abracadabra\") ➞ false\n  # abracadabra is not a palindrome.\n  */\nconst isPalindrome2 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  The given string may contain any number of characters.\n\n  Example:\n  isPalindrome(\"abracadabra\") ➞ true\n  # abracadabra is a palindrome.\n\n  isPalindrome(\"abracadabra\") ➞ false\n  # abracadabra is not a palindrome.\n  */\nconst isPalindrome3 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  The given string may contain any number of characters.\n\n  Example:\n  isPalindrome(\"abracadabra\") ➞ true\n  # abracadabra is a palindrome.\n\n  isPalindrome(\"abracadabra\") ➞ false\n  # abracadabra is not a palindrome.\n  */\nconst isPalindrome4 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  The given string may contain any number of characters.\n\n  Example:\n  isPalindrome(\"abracadabra\") ➞ true\n  # abracadabra is a palindrome.\n\n  isPalindrome(\"abracadabra\") ➞ false\n  # abracadabra is not a palindrome.\n  */\nconst isPalindrome5 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  The given string may contain any number of characters.\n\n  Example:\n  isPalindrome(\"abracadabra\") ➞ true\n  # abracadabra is a palindrome.\n\n  isPalindrome(\"abracadabra\") ➞ false\n  # abracadabra is not a palindrome.\n  */\nconst isPalindrome6 = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i]!== s[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  The given string may contain any number of characters.\n\n  Example:\n  isPalindrome(\"abracadabra\") ➞ true\n  # abracadabra is a palindrome.\n\n  isPalindrome(\"abracadabra\") ➞ false\n  # abracadabra is not a palindrome.", "passed": 0}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given grant an array arr of integers, find line up the minimum minimal number phone number of elements that \n   need want to be changed to make do the array palindromic. A palindromic array is an array that \n   is read the same backwards backward and forwards. In one change variety, you can change switch one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array arr of integers, find line up the minimum minimal number phone number of elements that \n   need want to be changed to make do the array palindromic. A palindromic array is an array that \n   is read the same backwards backward and forwards. In one change variety, you can change switch one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = arr.length;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) {\n        min = Math.min(min, j - i);\n      }\n    }\n  }\n  return min;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2, 3, 2, 1]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write publish a function routine that accepts two lists list of strings and returns come back the list that has \n   total number issue of chars in the all strings string section of the list less than the other list.\n\n   if the two lists have the same number numeral of chars char, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that accepts two lists list of strings and returns come back the list that has \n   total number issue of chars in the all strings string section of the list less than the other list.\n\n   if the two lists have the same number numeral of chars char, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1!== len2) return []\n  const result = []\n  for (let i = 0; i < len1; i++) {\n    const char1 = lst1[i]\n    const char2 = lst2[i]\n    if (char1 === char2) {\n      result.push(char1)\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes a list of strings and returns a list of strings that contains the \n   characters in the list of strings but not in the other list.\n\n  Examples\n  contains([], []) ➞ []\n  contains(['hi', 'admin'], ['hI', 'Hi']) ➞ ['i', 'a']\n  contains(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hI', 'hi', 'admin']\n  contains(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst contains = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1!== len2) return []\n  const result = []\n  for (let i = 0; i < len1; i++) {\n    const char1 = lst1[i]\n    const char2 = lst2[i]\n    if (char1!== char2) {\n      result.push(char1)\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes a list of strings and returns a list of strings that contains the \n   characters in the list of strings but not in the other list.\n\n  Examples\n  contains([], []) ➞ []\n  contains(['hi', 'admin'], ['hI', 'Hi']) ➞ ['i', 'a']\n  contains(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hI', 'hi', 'admin']\n  contains(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst containsNot = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1!== len2) return []\n  const result = []\n  for (let i = 0; i < len1; i++) {\n    const char1 = lst1[i]\n    const char2 = lst2[i]\n    if (char1 === char2) {\n      result.push(char1)\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes a list of strings and returns a list of strings that contains the \n   characters in the list of strings but not in the other list.\n\n  Examples\n  contains([], []) ➞ []\n  contains(['hi', 'admin'], ['hI', 'Hi']) ➞ ['i', 'a']\n  contains(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hI', 'hi', 'admin']\n  contains(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst containsNot2 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1!== len2) return []\n  const result = []\n  for (let i = 0; i < len1; i++) {\n    const char1 = lst1[i]\n    const char2 = lst2[i]\n    if (char1!== char2) {\n      result.push(char1)\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes a list of strings and returns a list of strings that contains the \n   characters in the list of strings but not in the other list.\n\n  Examples\n  contains([], []) ➞ []\n  contains(['hi', 'admin'], ['hI', 'Hi']) ➞ ['i', 'a']\n  contains(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hI', 'hi', 'admin']\n  contains(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst containsNot3 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1!== len2) return []\n  const result = []\n  for (let i = 0; i < len1; i++) {\n    const char1 = lst1[i]\n    const char2 = lst2[i]\n    if (char1!== char2) {\n      result.push(char1)\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes a list of strings and returns a list of strings that contains the \n   characters in the list of strings but not in the other list.\n\n  ", "passed": 0}
{"task_id": "JavaScript/75", "prompt": "/*Write a function affair that returns retort true if the given hold number is the multiplication generation of 3 prime numbers numbers pool \n   and false otherwise differently. \n   Knowing acknowledge that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that returns retort true if the given hold number is the multiplication generation of 3 prime numbers numbers pool \n   and false otherwise differently. \n   Knowing acknowledge that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i = 0;\n  while (i < 100) {\n    let j = 0;\n    while (j < 100) {\n      if (a % (i * j) === 0) {\n        return false;\n      }\n      j++;\n    }\n    i++;\n  }\n  return true;\n};\n\nconsole.log(isMultiplyPrime(30));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task job is to write compose a function that returns fall true if a number issue x is a simple \n   power of n and false fake in other cases. \n   x is a simple dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 1, "perturbed": true, "gc": "/*Your task job is to write compose a function that returns fall true if a number issue x is a simple \n   power of n and false fake in other cases. \n   x is a simple dim-witted power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower(x / n, n)\n}\n\nconsole.log(isSimplePower(1, 4))\nconsole.log(isSimplePower(2, 2))\nconsole.log(isSimplePower(8, 2))\nconsole.log(isSimplePower(3, 2))\nconsole.log(isSimplePower(3, 1))\nconsole.log(isSimplePower(5, 3))\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write publish a function routine that takes an integer a and returns fall true \n   if this ingeger is a cube block of some integer number. \n   Note bill: you may assume the input input signal is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes an integer a and returns fall true \n   if this ingeger is a cube block of some integer number. \n   Note bill: you may assume the input input signal is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true;\n  if (a % 2 === 0) return false;\n  return iscube(a - 1) && iscube(a + 1);\n};\n\n/*\n  Write a function that takes an integer a and returns true if this integer is a perfect cube.\n  Note: a perfect cube is a cube that is a power of 3.\n  Examples:\n  isperfectcube(1) ==> false\n  isperfectcube(2) ==> false\n  isperfectcube(3) ==> true\n  isperfectcube(4) ==> false\n  isperfectcube(5) ==> false\n  isperfectcube(6) ==> true\n  isperfectcube(7) ==> false\n  isperfectcube(8) ==> true\n  isperfectcube(9) ==> false\n  isperfectcube(10) ==> false\n  isperfectcube(11) ==> true\n  isperfectcube(12) ==> true\n  isperfectcube(13) ==> false\n  isperfectcube(14) ==> false\n  isperfectcube(15) ==> true\n  isperfectcube(16) ==> true\n  isperfectcube(17) ==> false\n  isperfectcube(18) ==> false\n  isperfectcube(19) ==> true\n  isperfectcube(20) ==> false\n  isperfectcube(21) ==> false\n  isperfectcube(22) ==> true\n  isperfectcube(23) ==> true\n  isperfectcube(24) ==> true\n  isperfectcube(25) ==> false\n  isperfectcube(26) ==> false\n  isperfectcube(27) ==> true\n  isperfectcube(28) ==> true\n  isperfectcube(29) ==> false\n  isperfectcube(30) ==> false\n  isperfectcube(31) ==> true\n  isperfectcube(32) ==> true\n  isperfectcube(33) ==> true\n  isperfectcube(34) ==> false\n  isperfectcube(35) ==> false\n  isperfectcube(36) ==> true\n  isperfectcube(37) ==> true\n  isperfectcube(38) ==> true\n  isperfectcube(39) ==> false\n  isperfectcube(40) ==> false\n  isperfectcube(41) ==> true\n  isperfectcube(42) ==> true\n  isperfectcube(43) ==> true\n  isperfectcube(44) ==> false\n  isperfectcube(45) ==> false\n  isperfectcube(46) ==> true\n  isperfectcube(47) ==> true\n  isperfectcube(48) ==> true\n  isperfectcube(49) ==> false\n  isperfectcube(50) ==> false\n  isperfectcube(51) ==> true\n  isperfectcube(52) ==> true\n  isperfectcube(53) ==> true\n  isperfectcube(54) ==> false\n  isperfectcube(55) ==> false\n  isperfectcube(56) ==> true\n  isperfectcube(57) ==> true\n  isperfectcube(58) ==> true\n  isperfectcube(59) ==> false\n  isperfectcube(60) ==> false\n  isperfectcube(61) ==> true\n  isperfectcube(62) ==> true\n  isperfectcube(63) ==> true\n  isperfectcube(64) ==> true\n  isperfectcube(65) ==> false\n  isperfectcube(66) ==> false\n  isperfectcube(67) ==> true\n  isperfectcube(68) ==> true\n  isperfectcube(69) ==> true\n  isperfectcube(70) ==> false\n  isperfectcube(71) ==> false\n  isperfectcube(72) ==> true\n  isperfectcube(73) ==> true\n  isperfectcube(74) ==> true\n  isperfectcube(75) ==> false\n  isperfectcube(76) ==> false\n  isperfectcube(77) ==> true\n  isperfectcube(78) ==> true\n  isperfectcube(79) ==> true\n  isperfectcube(80) ==> false\n  isperfectcube(81) ==> false\n  isperfectcube(82) ==> true\n  isperfectcube(83) ==> true\n  isperfectcube(84) ==> true\n  isperfectcube(85) ==> false\n  isperfectcube(86) ==> false\n  isperfectcube(87) ==> true\n  isperfectcube(88) ==> true\n  isperfectcube(89) ==> true\n  isperfectcube(90) ==> false\n  isperfectcube(91) ==> false\n  isperfectcube(92) ==> true\n  isperfectcube(93) ==> true\n  isperfectcube(94) ==> true\n  isperfectcube(95) ==> false\n  isperfectcube(96) ==> false\n  isperfectcube(97) ==> true\n  isperfectcube(98) ==> true\n  isperfectcube(99) ==> true\n  isperfectcube(100) ==> false\n  isperfectcube(101) ==> false\n  isperfectcube(102) ==> true\n  isperfectcube(103) ==> true\n  isperfectcube(104) ==> true\n  isperfectcube(105) ==> false\n  isperfectcube(106) ==> false\n  isperfectcube(107) ==> true\n  isperfectcube(108) ==> true\n  isperfectcube(109) ==> true\n  isperfectcube(110) ==> false\n  isperfectcube(111) ==> false\n  isperfectcube(112) ==> true\n  isperfectcube(113) ==> true\n  isperfectcube(114) ==> true\n  isperfectcube(115) ==> false\n  isperfectcube(116) ==> false\n  isperfectcube(117) ==> true\n  isperfectcube(118) ==> true\n  isperfectcube(119) ==> true\n  isperfectcube(120) ==> false", "passed": 0}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked task to write compose a function that receives receive \n   a hexadecimal number as a string bowed stringed instrument and counts the number issue of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number numeral \n   greater bang-up than 1 that is not a product of two smaller minor natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine a number of the following come digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note bill: you may assume simulate the input is always constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 1, "perturbed": true, "gc": "/*You have been tasked task to write compose a function that receives receive \n   a hexadecimal number as a string bowed stringed instrument and counts the number issue of hexadecimal \n   digits that are primes (prime flower number=== or a prime=== is a natural number numeral \n   greater bang-up than 1 that is not a product of two smaller minor natural numbers). \n   Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine a number of the following come digits finger: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimal 13). \n   Note bill: you may assume simulate the input is always constantly correct or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n    let res = 0;\n    for (let i = 0; i < num.length; i++) {\n        let digit = num[i];\n        if (digit === 'A' || digit === 'B' || digit === 'C' || digit === 'D' || digit === 'E' || digit === 'F') {\n            res += 1;\n        }\n    }\n    return res;\n};\n\nconst isPrime = (num) => {\n    let res = false;\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n        if (num % i === 0) {\n            res = false;\n            break;\n        }\n    }\n    return res;\n};\n\nconst main = () => {\n    let num = \"\";\n    let res = 0;\n    while (num!== \"\") {\n        num = prompt(\"Enter a hexadecimal number: \");\n        if (num!== \"\") {\n            res += hexKey(num);\n        }\n    }\n    res = res / 2;\n    console.log(res);\n};\n\nmain();\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/79", "prompt": "/*You will be given grant a number in decimal form phase and your task undertaking is to convert commute it to \n   binary format. The function should return a string bowed stringed instrument, with each character representing stage a binary \n   number. Each character fictional character in the string will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end of the string chain. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 1, "perturbed": true, "gc": "/*You will be given grant a number in decimal form phase and your task undertaking is to convert commute it to \n   binary format. The function should return a string bowed stringed instrument, with each character representing stage a binary \n   number. Each character fictional character in the string will be' 0' or' 1'. \n\n   There will be an extra excess couple of characters fictional character' db' at the beginning and at the end of the string chain. \n   The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  for (let i = 0; i < decimal.length; i++) {\n    binary += (decimal[i] === 1)? '1' : '0';\n  }\n  return binary;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '1') {\n      decimal += Math.pow(2, i);\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a string in the form of \"db1111db\" and your task undertaking is to convert it to a decimal number. \n  The function should return a number. \n\n  Examples:\n", "passed": 0}
{"task_id": "JavaScript/8", "prompt": "/* For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 1, "perturbed": true, "gc": "/* For a given grant list of integers, return a tuple consisting consist of a sum union and a product merchandise of all the integers in a list.\n   Empty sum kernel should be equal to 0 and empty product intersection should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const product = numbers.reduce((acc, num) => acc * num, 1);\n  return (sum, product);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the numbers in the list.\n  >>> sumList([1, 2, 3, 4])\n  [5, 7, 9]\n  */\nconst sumList = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the product of the numbers in the list.\n  >>> productList([1, 2, 3, 4])\n  [12, 24, 36, 48]\n  */\nconst productList = (numbers) => {\n  return numbers.reduce((acc, num) => acc * num, 1);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquares = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList2 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList3 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList4 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList5 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList6 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList7 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList8 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList9 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList10 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList11 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [5, 14, 27, 40]\n  */\nconst sumSquaresList12 = (numbers) => {\n  return numbers.reduce((acc, num) => acc + num * num, 0);\n};\n\n/*\n  Given a list of integers,", "passed": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given grant a string s.\n   Your task job is to check control if the string chain is happy or not. \n   A string bowed stringed instrument is happy if its length distance is at least 3 and every 3 consecutive letters letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 1, "perturbed": true, "gc": "/*You are given grant a string s.\n   Your task job is to check control if the string chain is happy or not. \n   A string bowed stringed instrument is happy if its length distance is at least 3 and every 3 consecutive letters letter are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length\n  let count = 0\n  let result = true\n  let prev = 0\n  let curr = 0\n  let next = 0\n  let i = 0\n  while (i < len) {\n    curr = s[i]\n    next = s[i + 1]\n    if (curr === next) {\n      count++\n      if (count === 3) {\n        if (prev!== curr) {\n          result = false\n          break\n        }\n      }\n    } else {\n      count = 0\n    }\n    prev = curr\n    i++\n  }\n  return result\n}\n\nconsole.log(isHappy('a'))\nconsole.log(isHappy('aa'))\nconsole.log(isHappy('abcd'))\nconsole.log(isHappy('aabb'))\nconsole.log(isHappy('adb'))\nconsole.log(isHappy('xyy'))\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students scholar. The teacher has been making her own algorithm for grading grade. \n   The only problem is, she has lost lose the code she used for grading rate. \n   She has given impart you a list of GPAs grade point average for some students and you have to write publish \n   a function that can output a list of letter grades using practice the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 1, "perturbed": true, "gc": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students scholar. The teacher has been making her own algorithm for grading grade. \n   The only problem is, she has lost lose the code she used for grading rate. \n   She has given impart you a list of GPAs grade point average for some students and you have to write publish \n   a function that can output a list of letter grades using practice the following table: \n            GPA        |     Letter grade \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = Array.from(grades);\n  const gradesArrayLength = gradesArray.length;\n  const gradesArraySum = gradesArray.reduce((a, b) => a + b);\n  const gradesArrayAverage = gradesArraySum / gradesArrayLength;\n  const gradesArrayAverageFloor = Math.floor(gradesArrayAverage);\n  const gradesArrayAverageCeil = Math.ceil(gradesArrayAverage);\n  const gradesArrayAverageDifference = gradesArrayAverage - gradesArrayAverageFloor;\n  const gradesArrayAverageDifferenceFloor = Math.floor(gradesArrayAverageDifference);\n  const gradesArrayAverageDifferenceCeil = Math.ceil(gradesArrayAverageDifference);\n  const gradesArrayAverageDifferenceDifference = gradesArrayAverageDifference - gradesArrayAverageDifferenceFloor;\n  const gradesArrayAverageDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifference = gradesArrayAverageDifferenceDifference - gradesArrayAverageDifferenceDifferenceFloor;\n  const gradesArrayAverageDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifference = gradesArrayAverageDifferenceDifferenceDifference - gradesArrayAverageDifferenceDifferenceDifferenceFloor;\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifference = gradesArrayAverageDifferenceDifferenceDifferenceDifference - gradesArrayAverageDifferenceDifferenceDifferenceDifferenceFloor;\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference = gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifference - gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceFloor;\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.floor(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceCeil = Math.ceil(gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifference);\n  const gradesArrayAverageDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceFloor = Math.", "passed": 0}
{"task_id": "JavaScript/82", "prompt": "/*Write a function affair that takes lead a string and returns true truthful if the string\n   length is a prime choice number or false fake otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 1, "perturbed": true, "gc": "/*Write a function affair that takes lead a string and returns true truthful if the string\n   length is a prime choice number or false fake otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  if (isPrime(len)) {\n    return true\n  }\n  return false\n}\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only prime number or false fake otherwise\n  Examples\n  primeContains('Hello') == true\n  primeContains('abcdcba') == true\n  primeContains('kittens') == true\n  primeContains('orange') == false\n  */\nconst primeContains = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 0; i < len; i++) {\n    if (!isPrime(string[i])) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only prime number or false fake otherwise\n  Examples\n  primeContains('Hello') == true\n  primeContains('abcdcba') == true\n  primeContains('kittens') == true\n  primeContains('orange') == false\n  */\nconst primeContains2 = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 0; i < len; i++) {\n    if (isPrime(string[i])) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only prime number or false fake otherwise\n  Examples\n  primeContains('Hello') == true\n  primeContains('abcdcba') == true\n  primeContains('kittens') == true\n  primeContains('orange') == false\n  */\nconst primeContains3 = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 0; i < len; i++) {\n    if (isPrime(string[i])) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only prime number or false fake otherwise\n  Examples\n  primeContains('Hello') == true\n  primeContains('abcdcba') == true\n  primeContains('kittens') == true\n  primeContains('orange') == false\n  */\nconst primeContains4 = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 0; i < len; i++) {\n    if (isPrime(string[i])) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only prime number or false fake otherwise\n  Examples\n  primeContains('Hello') == true\n  primeContains('abcdcba') == true\n  primeContains('kittens') == true\n  primeContains('orange') == false\n  */\nconst primeContains5 = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 0; i < len; i++) {\n    if (isPrime(string[i])) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only prime number or false fake otherwise\n  Examples\n  primeContains('Hello') == true\n  primeContains('abcdcba') == true\n  primeContains('kittens') == true\n  primeContains('orange') == false\n  */\nconst primeContains6 = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 0; i < len; i++) {\n    if (isPrime(string[i])) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Write a function affair that takes lead a string and returns true if the string\n  contains only prime number or false fake otherwise\n  Examples\n  primeContains('Hello') == true\n  primeContains('abcdcba') == true\n  primeContains('kittens') == true\n  primeContains('orange') == false\n  */\nconst primeContains7 = (string) => {\n  const len = string.length\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n %", "passed": 0}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given grant a positive integer n, return the count of the numbers issue of n-digit\n   positive convinced integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a positive integer n, return the count of the numbers issue of n-digit\n   positive convinced integers integer that start or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   const n = (n)\n   const nDigits = (n)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n   const nDigits = (nDigits)\n", "passed": 0}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive cocksure integer N, return the total entire sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*Given a positive cocksure integer N, return the total entire sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const digits = Array.from(Array(N).keys());\n  const sum = digits.reduce((a, b) => a + b);\n  return sum.toString(2);\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd curious indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let i = 0, j = 0, sum = 0;\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n      j++;\n    }\n    i++;\n  }\n  return sum;\n};\n\nconsole.log(add([4, 2, 6, 7]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write publish a function routine that takes a string chain and returns an ordered coherent version of it. \n   Ordered order version of string chain, is a string bowed stringed instrument where all words (separated divide by space quad) \n   are replaced by a new newfangled word where all the characters arranged in\n   ascending order based on ascii value. \n   Note bill: You should keep the order of words and blank spaces quad in the sentence conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a string chain and returns an ordered coherent version of it. \n   Ordered order version of string chain, is a string bowed stringed instrument where all words (separated divide by space quad) \n   are replaced by a new newfangled word where all the characters arranged in\n   ascending order based on ascii value. \n   Note bill: You should keep the order of words and blank spaces quad in the sentence conviction.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      let newChar = ''\n      if (char.toLowerCase() >= 'a' && char.toLowerCase() <= 'z') {\n        newChar = char.toUpperCase()\n      } else if (char.toLowerCase() >= 'A' && char.toLowerCase() <= 'Z') {\n        newChar = char.toLowerCase()\n      } else {\n        newChar = char\n      }\n      newWord += newChar\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconsole.log(antiShuffle('Hi'))\nconsole.log(antiShuffle('hello'))\nconsole.log(antiShuffle('Hello World!!!'))\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given grant a 2 dimensional data, as a nested nest lists list, \n   which is similar exchangeable to matrix, however, unlike matrices, \n   each row course may contain a different unlike number of columns column. \n   Given lst, and integer x, find discover integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, columns column), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort kind coordinates of the row by columns in descending derive order decree.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a 2 dimensional data, as a nested nest lists list, \n   which is similar exchangeable to matrix, however, unlike matrices, \n   each row course may contain a different unlike number of columns column. \n   Given lst, and integer x, find discover integers integer x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row, columns column), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort kind coordinates of the row by columns in descending derive order decree.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const sort = (a, b) => a[0] - b[0] || b[1] - a[1]\n  const sortBy = (a, b) => a[1] - b[1] || a[0] - b[0]\n  const get = (lst, x) => lst.find(row => row[0] === x)\n  const getBy = (lst, x) => lst.find(row => row[1] === x)\n  const getRow = (lst, x) => {\n    const row = get(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverse = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverse = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverse = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverse = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n      return [row[0], row[1]]\n    }\n    return []\n  }\n  const getRowByReverseByReverseByReverseByReverseBy = (lst, x) => {\n    const row = getBy(lst, x)\n    if (row) {\n", "passed": 0}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given grant an array of non - negative integers integer, return a copy transcript of the given hold array after sorting, \n   you will sort classify the given array in ascending ascend order if the sum kernel (first index exponent value, last concluding index value) is odd curious, \n   or sort it in descending order if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant an array of non - negative integers integer, return a copy transcript of the given hold array after sorting, \n   you will sort classify the given array in ascending ascend order if the sum kernel (first index exponent value, last concluding index value) is odd curious, \n   or sort it in descending order if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.slice();\n  sortedArray.sort((a, b) => {\n    const aSum = a + b;\n    const bSum = b + a;\n    if (aSum % 2 === 1) {\n      return a - b;\n    }\n    return b - a;\n  });\n  return sortedArray;\n};\n\nconsole.log(sortArray([5, 4, 3, 0, 1, 2]));\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function affair encrypt that takes lead a string as an argument argumentation and \n   returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters letter \n   shift stir down by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "/*Create a function affair encrypt that takes lead a string as an argument argumentation and \n   returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n   The alphabet rudiment should be rotated in a manner such that the letters letter \n   shift stir down by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  const alphabet_length = alphabet.length\n  const alphabet_shift = 2\n  const alphabet_rotation = (s) => {\n    let result = ''\n    for (let i = 0; i < s.length; i++) {\n      let letter = s[i]\n      let index = alphabet.indexOf(letter)\n      let new_index = (index + alphabet_shift) % alphabet_length\n      result += alphabet[new_index]\n    }\n    return result\n  }\n  return alphabet_rotation(s)\n}\n\n/*\n  Create a function affair decrypt that takes lead a string as an argument argumentation and \n  returns a string bowed stringed instrument decrypted with the alphabet rudiment being rotated. \n  The alphabet rudiment should be rotated in a manner such that the letters letter \n  shift stir up by two multiplied to two places home.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  const alphabet_length = alphabet.length\n  const alphabet_shift = 2\n  const alphabet_rotation = (s) => {\n    let result = ''\n    for (let i = 0; i < s.length; i++) {\n      let letter = s[i]\n      let index = alphabet.indexOf(letter)\n      let new_index = (index - alphabet_shift) % alphabet_length\n      result += alphabet[new_index]\n    }\n    return result\n  }\n  return alphabet_rotation(s)\n}\n\n/*\n  Create a function affair encrypt that takes lead a string as an argument argumentation and \n  returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n  The alphabet rudiment should be rotated in a manner such that the letters letter \n  shift stir up by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt_reverse = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  const alphabet_length = alphabet.length\n  const alphabet_shift = 2\n  const alphabet_rotation = (s) => {\n    let result = ''\n    for (let i = 0; i < s.length; i++) {\n      let letter = s[i]\n      let index = alphabet.indexOf(letter)\n      let new_index = (index - alphabet_shift) % alphabet_length\n      result += alphabet[new_index]\n    }\n    return result\n  }\n  return alphabet_rotation(s)\n}\n\n/*\n  Create a function affair decrypt that takes lead a string as an argument argumentation and \n  returns a string bowed stringed instrument decrypted with the alphabet rudiment being rotated. \n  The alphabet rudiment should be rotated in a manner such that the letters letter \n  shift stir up by two multiplied to two places home.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt_reverse = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  const alphabet_length = alphabet.length\n  const alphabet_shift = 2\n  const alphabet_rotation = (s) => {\n    let result = ''\n    for (let i = 0; i < s.length; i++) {\n      let letter = s[i]\n      let index = alphabet.indexOf(letter)\n      let new_index = (index + alphabet_shift) % alphabet_length\n      result += alphabet[new_index]\n    }\n    return result\n  }\n  return alphabet_rotation(s)\n}\n\n/*\n  Create a function affair encrypt that takes lead a string as an argument argumentation and \n  returns a string bowed stringed instrument encrypted with the alphabet rudiment being rotated. \n  The alphabet rudiment should be rotated in a manner such that the letters letter \n  shift stir up by two multiplied to two places home.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt_reverse_rotated = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  const alphabet_length = alphabet.length\n  const alphabet_shift = 2\n  const alphabet_rotation = (s) => {\n    let result = ''\n    for (let i = 0; i < s.length; i++) {\n      let letter = s[i]\n      let index = alphabet.indexOf(letter)\n      let new_index = (index + alphabet_shift) % alphabet_length\n      result += alphabet[new_index]\n    }\n    return result\n  }\n  return alphabet_rotation(s)\n}\n\n/*\n  Create a function affair decrypt that takes lead a string as an argument argumentation and \n  returns a string bowed stringed instrument decrypted with the alphabet rudiment being rotated. \n  The alphabet rudiment should be rotated in a manner such that the letters letter \n  shift stir up by two multiplied", "passed": 0}
{"task_id": "JavaScript/9", "prompt": "/* From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 1, "perturbed": true, "gc": "/* From a given grant list of integers, generate beget a list of rolling wind maximum maximal element found recover until given moment consequence \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  const maxValue = max;\n  const maxRolling = [max];\n  const rollingMax = [];\n  const rollingMaxIndex = 0;\n  const rollingMaxValue = max;\n  const rollingMaxRolling = [max];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n      maxValue = max;\n      maxRolling = [max];\n      rollingMax = [max];\n      rollingMaxIndex = 0;\n      rollingMaxValue = max;\n      rollingMaxRolling = [max];\n    } else if (numbers[i] === max) {\n      maxRolling.push(numbers[i]);\n      rollingMax.push(numbers[i]);\n      rollingMaxIndex++;\n      rollingMaxValue = max;\n    }\n  }\n  return rollingMax;\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>", "passed": 0}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given grant a list of integers. \n   Write publish a function routine nextSmallest() that returns fall the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 1, "perturbed": true, "gc": "/*\n  You are given grant a list of integers. \n   Write publish a function routine nextSmallest() that returns fall the 2nd smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n    let smallest = lst[0];\n    for (let i = 1; i < lst.length; i++) {\n        if (lst[i] < smallest) {\n            smallest = lst[i];\n        }\n    }\n    return smallest;\n}\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//     let smallest = lst[0];\n//     for (let i = 1; i < lst.length; i++) {\n//         if (lst[i] < smallest) {\n//             smallest = lst[i];\n//         }\n//     }\n//     return smallest;\n// }\n\n// const nextSmallest = (lst) = > {\n//", "passed": 0}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given grant a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 1, "perturbed": true, "gc": "/*\n  You'll be given grant a string of words word, and your task undertaking is to count consider the number \n   of boredoms boredom. A boredom is a sentence that starts depart with the word \" I \". \n   Sentences conviction are delimited specify by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  let startIndex = 0;\n  let endIndex = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  ", "passed": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create produce a function routine that takes 3 numbers phone number. \n   Returns true on-key if one of the numbers is equal adequate to the sum of the other two, and all numbers act are integers. \n   Returns return false delusive in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that takes 3 numbers phone number. \n   Returns true on-key if one of the numbers is equal adequate to the sum of the other two, and all numbers act are integers. \n   Returns return false delusive in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (typeof x!== 'number' || typeof y!== 'number' || typeof z!== 'number') {\n    return false;\n  }\n  if (x === y + z) {\n    return true;\n  }\n  if (x === y - z) {\n    return true;\n  }\n  if (x === z + y) {\n    return true;\n  }\n  if (x === z - y) {\n    return true;\n  }\n  if (x === y * z) {\n    return true;\n  }\n  if (x === z / y) {\n    return true;\n  }\n  if (x === y % z) {\n    return true;\n  }\n  if (x === z + y / x) {\n    return true;\n  }\n  if (x === z - y / x) {\n    return true;\n  }\n  if (x === y * z / x) {\n    return true;\n  }\n  if (x === z / y / x) {\n    return true;\n  }\n  if (x === y % z / x) {\n    return true;\n  }\n  if (x === z + y % x) {\n    return true;\n  }\n  if (x === z - y % x) {\n    return true;\n  }\n  if (x === y * z / x / y) {\n    return true;\n  }\n  if (x === z / y / x / y) {\n    return true;\n  }\n  if (x === y % z / x / y) {\n    return true;\n  }\n  if (x === z + y % x / y) {\n    return true;\n  }\n  if (x === z - y % x / y) {\n    return true;\n  }\n  if (x === y * z / x / y / z) {\n    return true;\n  }\n  if (x === z / y / x / y / z) {\n    return true;\n  }\n  if (x === y % z / x / y / z) {\n    return true;\n  }\n  if (x === z + y % x / y / z) {\n    return true;\n  }\n  if (x === z - y % x / y / z) {\n    return true;\n  }\n  if (x === y * z / x / y / z / x) {\n    return true;\n  }\n  if (x === z / y / x / y / z / x) {\n    return true;\n  }\n  if (x === y % z / x / y / z / x) {\n    return true;\n  }\n  if (x === z + y % x / y / z / x) {\n    return true;\n  }\n  if (x === z - y % x / y / z / x) {\n    return true;\n  }\n  if (x === y * z / x / y / z / x / y) {\n    return true;\n  }\n  if (x === z / y / x / y / z / x / y) {\n    return true;\n  }\n  if (x === y % z / x / y / z / x / y) {\n    return true;\n  }\n  if (x === z + y % x / y / z / x / y) {\n    return true;\n  }\n  if (x === z - y % x / y / z / x / y) {\n    return true;\n  }\n  if (x === y * z / x / y / z / x / y / z) {\n    return true;\n  }\n  if (x === z / y / x / y / z / x / y / z) {\n    return true;\n  }\n  if (x === y % z / x / y / z / x / y / z) {\n    return true;\n  }\n  if (x === z + y % x / y / z / x / y / z) {\n    return true;\n  }\n  if (x === z - y % x / y / z / x / y / z) {\n    return true;\n  }\n  if (x === y * z / x / y / z / x / y / z / x) {\n    return true;\n  }\n  if (x === z / y / x / y / z / x / y / z / x) {\n    return true;\n  }\n  if (x === y % z / x / y / z / x / y / z / x) {\n    return true;\n  }\n  if (x === z + y % x / y / z / x / y / z / x) {\n    return true;\n  }\n  if (x === z - y % x / y / z / x / y / z / x) {\n    return true;\n  }\n  if (x === y * z / x / y / z / x / y / z / x / y) {\n    return true;\n  }\n  if (x === z / y / x / y / z / x / y / z / x / y) {\n    return true;\n  }\n  if (x === y % z / x / y / z / x / y / z / x / y) {\n    return true;\n  }\n  if (x === z + y % x / y / z / x / y / z / x / y) {\n    return true;\n  }\n  if (x === z - y % x / y / z / x / y / z / x / y) {\n    return true;\n  }\n  if (x === y * z / x / y / z / x / y / z / x / y / z) {\n    return true;\n  }\n  if (x === z / y / x / y / z / x / y / z /", "passed": 0}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way direction that it swaps case character of all letters, replaces supplant all vowels in \n   the message with the letter that appears appear 2 places position ahead of that \n   vowel in the english alphabet. \n   Assume only letters letter. \n  \n   Examples exercise:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way direction that it swaps case character of all letters, replaces supplant all vowels in \n   the message with the letter that appears appear 2 places position ahead of that \n   vowel in the english alphabet. \n   Assume only letters letter. \n  \n   Examples exercise:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].toUpperCase() === message[i].toLowerCase()) {\n      result += message[i];\n    } else {\n      result += message[i].toUpperCase();\n    }\n  }\n  return result;\n};\n\nconsole.log(encode('This is a message'));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are given grant a list of integers. \n   You need want to find witness the largest bombastic prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "/*You are given grant a list of integers. \n   You need want to find witness the largest bombastic prime value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const max = Math.max(...lst);\n  const max_digits = max.toString(10).length;\n  const max_prime = find_prime(max);\n  const max_prime_digits = max_prime.toString(10).length;\n  const max_prime_digits_sum = max_prime_digits * max_prime;\n  const max_prime_digits_sum_digits = max_prime_digits_sum.toString(10).length;\n  const max_prime_digits_sum_digits_sum = max_prime_digits_sum_digits * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum = max_prime_digits_sum_digits_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum = max_prime_digits_sum_digits_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum * max_prime_digits;\n  const max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = max_prime_digits_sum_digits_sum_sum_sum_sum_sum_sum_sum_sum_sum", "passed": 0}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given grant a dictionary, return true if all keys key are strings string in lower gloomy \n   case or all keys key are strings in upper case character, else return false. \n   The function should return false is the given impart dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a dictionary, return true if all keys key are strings string in lower gloomy \n   case or all keys key are strings in upper case character, else return false. \n   The function should return false is the given impart dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  for (let i = 0; i < keys.length; i++) {\n    if (!isString(keys[i])) {\n      return false\n    }\n    if (keys[i].toUpperCase()!== keys[i].toLowerCase()) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Given a string, return true if the string is a valid email address, else return false.\n  Examples:\n  isEmail(\"john@gmail.com\") should return true.\n  isEmail(\"john@gmail\") should return true.\n  isEmail(\"john@gmail.\") should return true.\n  isEmail(\"john@gmail.com.\") should return true.\n  isEmail(\"john@gmail.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.com.\") should return true.\n  isEmail(\"john@gmail.com.com.com.com.com.com.com.com.com.com.com.com.com.com.", "passed": 0}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function affair that takes lead an non - negative integer and returns fall an array of the first n\n   integers integer that are prime numbers numbers pool and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 1, "perturbed": true, "gc": "/*Implement a function affair that takes lead an non - negative integer and returns fall an array of the first n\n   integers integer that are prime numbers numbers pool and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = [];\n  for (let i = 2; i < n; i++) {\n    if (isPrime(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconsole.log(countUpTo(5));\nconsole.log(countUpTo(11));\nconsole.log(countUpTo(0));\nconsole.log(countUpTo(20));\nconsole.log(countUpTo(1));\nconsole.log(countUpTo(18));\n<|endoftext|>", "passed": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function affair that takes lead two integers and returns tax return \n   the product of their unit whole digits. \n   Assume simulate the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "/*Complete the function affair that takes lead two integers and returns tax return \n   the product of their unit whole digits. \n   Assume simulate the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_unit = a % 10\n  let b_unit = b % 10\n  let a_digit = a / 10\n  let b_digit = b / 10\n  let result = a_digit * b_digit\n  if (a_unit === 0 && b_unit === 0) {\n    return result\n  }\n  if (a_unit === 0) {\n    return multiply(b_unit, b_digit)\n  }\n  if (b_unit === 0) {\n    return multiply(a_unit, a_digit)\n  }\n  return multiply(a_unit, multiply(b_unit, b_digit))\n}\n\nconst multiply_test = [\n  [148, 412, 16],\n  [19, 28, 72],\n  [2020, 1851, 0],\n  [14, -15, 20]\n]\n\nconst multiply_test_result = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_2 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_3 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_4 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_5 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_6 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_7 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_8 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_9 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_10 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_11 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_12 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_13 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_14 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_15 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_16 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_17 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_18 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_19 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_20 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_21 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_22 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_23 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_24 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_25 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_26 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_27 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_28 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_29 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_30 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_31 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_32 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_33 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_34 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_35 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_36 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_37 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_38 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_39 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_40 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_41 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result_42 = [\n  16,\n  72,\n  0,\n  20\n]\n\nconst multiply_test_result", "passed": 0}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given grant a string s, count reckon the number phone number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 1, "perturbed": true, "gc": "/*\n  Given grant a string s, count reckon the number phone number of uppercase capital vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonants = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of consonants and vowels in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowels = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of consonants and vowels in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowels = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of consonants, vowels, and consonants in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowels = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of consonants, vowels, and consonants in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowels = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of consonants, vowels, consonants, and vowels in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowels = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count the number of consonants, vowels, consonants, and vowels in even indices.\n  \n  For example:\n  countConsonantsVowels('aBCdEf') returns 1\n  countConsonantsVowels('abcdefg') returns 0\n  countConsonantsVowels('dBBE') returns 0\n  */\nconst countConsonantsVowels = (s) => {\n  const len = s.length\n  const count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase()!== s[i + 1].toUpperCase()) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, count", "passed": 0}
{"task_id": "JavaScript/99", "prompt": "/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away off from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 1, "perturbed": true, "gc": "/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away off from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let valueInt = parseInt(value);\n  let valueIntClosest = valueInt;\n  let valueIntClosestDiff = Math.abs(valueInt - Math.floor(valueInt));\n  let valueIntClosestDiffNext = Math.abs(valueInt - Math.ceil(valueInt));\n  if (valueIntClosestDiffNext < valueIntClosestDiff) {\n    valueIntClosest = Math.ceil(valueInt);\n  } else {\n    valueIntClosest = Math.floor(valueInt);\n  }\n  return valueIntClosest;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger2 = (value) => {\n  let valueInt = parseInt(value);\n  let valueIntClosest = valueInt;\n  let valueIntClosestDiff = Math.abs(valueInt - Math.floor(valueInt));\n  let valueIntClosestDiffNext = Math.abs(valueInt - Math.ceil(valueInt));\n  if (valueIntClosestDiffNext < valueIntClosestDiff) {\n    valueIntClosest = Math.ceil(valueInt);\n  } else {\n    valueIntClosest = Math.floor(valueInt);\n  }\n  return valueIntClosest;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger3 = (value) => {\n  let valueInt = parseInt(value);\n  let valueIntClosest = valueInt;\n  let valueIntClosestDiff = Math.abs(valueInt - Math.floor(valueInt));\n  let valueIntClosestDiffNext = Math.abs(valueInt - Math.ceil(valueInt));\n  if (valueIntClosestDiffNext < valueIntClosestDiff) {\n    valueIntClosest = Math.ceil(valueInt);\n  } else {\n    valueIntClosest = Math.floor(valueInt);\n  }\n  return valueIntClosest;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger4 = (value) => {\n  let valueInt = parseInt(value);\n  let valueIntClosest = valueInt;\n  let valueIntClosestDiff = Math.abs(valueInt - Math.floor(valueInt));\n  let valueIntClosestDiffNext = Math.abs(valueInt - Math.ceil(valueInt));\n  if (valueIntClosestDiffNext < valueIntClosestDiff) {\n    valueIntClosest = Math.ceil(valueInt);\n  } else {\n    valueIntClosest = Math.floor(valueInt);\n  }\n  return valueIntClosest;\n};\n\n/* Create produce a function routine that takes a value (string chain) representing a number issue \n   and returns the closest cheeseparing integer to it. If the number is equidistant \n   from two integers integer, round it away from zero. \n   Examples exercise\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger5 = (value) => {\n  let valueInt = parseInt(value);\n  let valueIntClosest = valueInt;\n  let valueIntClosestDiff = Math.abs(valueInt - Math.floor(valueInt));\n  let valueIntClosestDiffNext = Math.abs(valueInt - Math.ceil(valueInt));\n  if (valueIntClosestDiffNext < valueIntClosestDiff) {\n    valueIntClosest = Math.ceil(", "passed": 0}
