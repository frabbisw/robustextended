{"task_id": "JavaScript/0", "prompt": "/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "/* Check match if in given contribute list of numbers, are any two numbers closer near to each other than \n   given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = sorted(numbers);\n  const len = sortedNumbers.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * @param {number[]} numbers\n  * @param {number} threshold\n  * @return {boolean}\n  * @example\n  * hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  * // => false\n  * hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  * // => true\n  */\nexport const hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = sorted(numbers);\n  const len = sortedNumbers.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sortedNumbers[i] - sortedNumbers[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const mean = (numbers) => {\n  return sum(numbers) / numbers.length;\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const median = (numbers) => {\n  const len = numbers.length;\n  const sortedNumbers = sorted(numbers);\n  if (len % 2 === 0) {\n    return (sortedNumbers[len / 2 - 1] + sortedNumbers[len / 2]) / 2;\n  }\n  return sortedNumbers[len / 2];\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const mode = (numbers) => {\n  const len = numbers.length;\n  const sortedNumbers = sorted(numbers);\n  const max = sortedNumbers[0];\n  let maxCount = 1;\n  for (let i = 1; i < len; i++) {\n    if (sortedNumbers[i] === max) {\n      maxCount++;\n    } else {\n      break;\n    }\n  }\n  return max;\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const sum = (numbers) => {\n  return numbers.reduce((acc, number) => acc + number, 0);\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const variance = (numbers) => {\n  const mean = mean(numbers);\n  const len = numbers.length;\n  const sum = sum(numbers);\n  return sum / len - mean * mean;\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const standardDeviation = (numbers) => {\n  return Math.sqrt(variance(numbers));\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const standardError = (numbers) => {\n  return standardDeviation(numbers) / Math.sqrt(numbers.length);\n};\n\n/**\n * @param {number[]} numbers\n * @return {number}\n */\nexport const skewness = (numbers) => {\n  const mean = mean(numbers);\n  const len = numbers.length;\n  const sum = sum(numbers);\n  const variance = variance(numbers);\n  const standardDeviation = standardDeviation(numbers);\n  const standardError = standardError(numbers);\n  const meanSquare = mean * mean;\n  const varianceSquare = variance * variance;\n  const standardDeviationSquare = standardDeviation * standardDeviation;\n  const standardErrorSquare = standardError * standardError;\n  const meanSquareStandardDeviation = meanSquare * standardDeviation;\n  const varianceSquareStandardDeviation = varianceSquare * standardDeviation;\n  const standardDeviationSquareStandardDeviation = standardDeviationSquare * standardDeviation;\n  const meanSquareStandardDeviationSquare = meanSquareStandardDeviation * standardDeviationSquare;\n  const varianceSquareStandardDeviationSquare = varianceSquareStandardDeviation * standardDeviationSquare;\n  const standardDeviationSquareStandardDeviationSquare = standardDeviationSquareStandardDeviation * standardDeviationSquare;\n  const meanSquareStandardDeviationSquareStandardDeviation = meanSquareStandardDeviationSquare * standardDeviationSquareStandardDeviation;\n  const varianceSquareStandardDeviationSquareStandardDeviation = varianceSquareStandardDeviationSquare * standardDeviationSquareStandardDeviation;\n  const standardDeviationSquareStandardDeviationSquareStandardDeviation = standardDeviationSquareStandardDeviationSquare * standardDeviationSquareStandardDeviation;\n  const meanSquareStandardDeviationSquareStandardDeviationSquare = meanSquareStandardDeviationSquareStandardDeviation * standardDeviationSquareStandardDeviationSquare;\n  const varianceSquareStandardDeviationSquareStandardDeviationSquare = varianceSquareStandardDeviationSquareStandardDeviation * standardDeviationSquareStandardDeviationSquare;\n  const standardDeviationSquareStandardDeviationSquareStandardDeviationSquare = standardDeviationSquareStandardDeviationSquareStandardDeviation * standardDeviationSquareStandardDeviationSquare;\n  const meanSquareStandardDeviationSquareStandardDeviationSquareStandardDeviation = meanSquareStandardDeviationSquareStandardDeviationSquareStandardDeviation * standardDeviationSquareStandardDeviationSquare;\n  const varianceSquareStandardDeviationSquareStandardDeviationSquareStandardDeviation = varianceSquareStandardDeviationSquareStandardDeviationSquareStandardDeviation * standardDeviationSquareStandardDeviationSquareStandardDeviation;\n  const standardDeviationSquareStandardDeviationSquareStandardDeviationSquareStandardDeviation = standardDeviationSquareStandardDeviationSquareStandardDeviationSquareStandardDeviation * standardDeviationSquareStandardDeviationSquareStandardDeviation;\n  return standardDeviationSquareStandardDeviationSquareStandardDeviationSquare - 3 * standardDeviationSquareStandardDeviationSquareStandardDeviationSquareStandardDeviation +", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "/* Input stimulation to this function routine is a string containing contain multiple groups of nested cuddle parentheses parenthesis. Your goal is to \n   separate those group into separate freestanding strings string and return the list of those. \n   Separate groups are balanced (each open brace is properly by rights closed shut) and not nested within each other \n   Ignore dismiss any spaces in the input string bowed stringed instrument.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split('(');\n  const paren_list_len = paren_list.length;\n  const paren_list_len_minus_1 = paren_list_len - 1;\n  const paren_list_len_minus_2 = paren_list_len - 2;\n  const paren_list_len_minus_3 = paren_list_len - 3;\n  const paren_list_len_minus_4 = paren_list_len - 4;\n  const paren_list_len_minus_5 = paren_list_len - 5;\n  const paren_list_len_minus_6 = paren_list_len - 6;\n  const paren_list_len_minus_7 = paren_list_len - 7;\n  const paren_list_len_minus_8 = paren_list_len - 8;\n  const paren_list_len_minus_9 = paren_list_len - 9;\n  const paren_list_len_minus_10 = paren_list_len - 10;\n  const paren_list_len_minus_11 = paren_list_len - 11;\n  const paren_list_len_minus_12 = paren_list_len - 12;\n  const paren_list_len_minus_13 = paren_list_len - 13;\n  const paren_list_len_minus_14 = paren_list_len - 14;\n  const paren_list_len_minus_15 = paren_list_len - 15;\n  const paren_list_len_minus_16 = paren_list_len - 16;\n  const paren_list_len_minus_17 = paren_list_len - 17;\n  const paren_list_len_minus_18 = paren_list_len - 18;\n  const paren_list_len_minus_19 = paren_list_len - 19;\n  const paren_list_len_minus_20 = paren_list_len - 20;\n  const paren_list_len_minus_21 = paren_list_len - 21;\n  const paren_list_len_minus_22 = paren_list_len - 22;\n  const paren_list_len_minus_23 = paren_list_len - 23;\n  const paren_list_len_minus_24 = paren_list_len - 24;\n  const paren_list_len_minus_25 = paren_list_len - 25;\n  const paren_list_len_minus_26 = paren_list_len - 26;\n  const paren_list_len_minus_27 = paren_list_len - 27;\n  const paren_list_len_minus_28 = paren_list_len - 28;\n  const paren_list_len_minus_29 = paren_list_len - 29;\n  const paren_list_len_minus_30 = paren_list_len - 30;\n  const paren_list_len_minus_31 = paren_list_len - 31;\n  const paren_list_len_minus_32 = paren_list_len - 32;\n  const paren_list_len_minus_33 = paren_list_len - 33;\n  const paren_list_len_minus_34 = paren_list_len - 34;\n  const paren_list_len_minus_35 = paren_list_len - 35;\n  const paren_list_len_minus_36 = paren_list_len - 36;\n  const paren_list_len_minus_37 = paren_list_len - 37;\n  const paren_list_len_minus_38 = paren_list_len - 38;\n  const paren_list_len_minus_39 = paren_list_len - 39;\n  const paren_list_len_minus_40 = paren_list_len - 40;\n  const paren_list_len_minus_41 = paren_list_len - 41;\n  const paren_list_len_minus_42 = paren_list_len - 42;\n  const paren_list_len_minus_43 = paren_list_len - 43;\n  const paren_list_len_minus_44 = paren_list_len - 44;\n  const paren_list_len_minus_45 = paren_list_len - 45;\n  const paren_list_len_minus_46 = paren_list_len - 46;\n  const paren_list_len_minus_47 = paren_list_len - 47;\n  const paren_list_len_minus_48 = paren_list_len - 48;\n  const paren_list_len_minus_49 = paren_list_len - 49;\n  const paren_list_len_minus_50 = paren_list_len - 50;\n  const paren_list_len_minus_51 = paren_list_len - 51;\n  const paren_list_len_minus_52 = paren_list_len - 52;\n  const paren_list_len_minus_53 = paren_list_len - 53;\n  const paren_list_len_minus_54 = paren_list_len - 54;\n  const paren_list_len_minus_55 = paren_list_len - 55;\n  const paren_list_len_minus_56 = paren_list_len - 56;\n  const paren_list_len_minus_57 = paren_list_len - 57;\n  const paren_list_len_minus_58 = paren_list_len - 58;\n  const paren_list_len_minus_59 = paren_list_len - 59;\n  const paren_list_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/* Test quiz if gniven strig is a palindrome * / \n const isPalindrome = (string) = > { \n   return string = = string.split('').reverse().join('');\n}\n\n/* Find line up the shortest palindrome that begins get down with a supplied string.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied provide string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const suffix = findLongestPalindrome(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest postfix suffix of supplied string that is a palindrome.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> findLongestPalindrome('cat')\n  'cat'\n  >>> findLongestPalindrome('cata')\n  'cata'\n  */\nconst findLongestPalindrome = (string) => {\n  const suffix = findLongestPalindromeSuffix(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest postfix suffix of supplied string that is a palindrome.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> findLongestPalindromeSuffix('cat')\n  'cat'\n  >>> findLongestPalindromeSuffix('cata')\n  'cata'\n  */\nconst findLongestPalindromeSuffix = (string) => {\n  const suffix = findLongestPalindromeSuffix(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest postfix suffix of supplied string that is a palindrome.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> findLongestPalindromeSuffix('cat')\n  'cat'\n  >>> findLongestPalindromeSuffix('cata')\n  'cata'\n  */\nconst findLongestPalindromeSuffix = (string) => {\n  const suffix = findLongestPalindromeSuffix(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest postfix suffix of supplied string that is a palindrome.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> findLongestPalindromeSuffix('cat')\n  'cat'\n  >>> findLongestPalindromeSuffix('cata')\n  'cata'\n  */\nconst findLongestPalindromeSuffix = (string) => {\n  const suffix = findLongestPalindromeSuffix(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest postfix suffix of supplied string that is a palindrome.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> findLongestPalindromeSuffix('cat')\n  'cat'\n  >>> findLongestPalindromeSuffix('cata')\n  'cata'\n  */\nconst findLongestPalindromeSuffix = (string) => {\n  const suffix = findLongestPalindromeSuffix(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest postfix suffix of supplied string that is a palindrome.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> findLongestPalindromeSuffix('cat')\n  'cat'\n  >>> findLongestPalindromeSuffix('cata')\n  'cata'\n  */\nconst findLongestPalindromeSuffix = (string) => {\n  const suffix = findLongestPalindromeSuffix(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix + suffix.split('').reverse().join('');\n}\n\n/* Find the longest postfix suffix of supplied string that is a palindrome.\n   Algorithm idea estimate is simple elementary: \n   - Find the longest postfix suffix of supplied string that is a palindrome. \n   - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> findLongestPalindromeSuffix('cat')\n  'cat'\n  >>> findLongestPalindromeSuffix('cata')\n  'cata'\n  */\nconst findLongestPalindromeSuffix = (string) => {\n  const suffix = findLongestPalindromeSuffix(string);\n  const prefix = string.slice(0, suffix.length);\n  return prefix", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let pile = [n];\n  for (let i = 1; i < n; i++) {\n    let num = (i % 2 === 0)? i + 1 : i;\n    pile.push(num);\n  }\n  return pile;\n};\n\n/*\n  Given a positive number n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile2 = (n) => {\n  let pile = [n];\n  for (let i = 1; i < n; i++) {\n    let num = (i % 2 === 0)? i + 1 : i;\n    pile.push(num);\n  }\n  return pile;\n};\n\n/*\n  Given a positive number n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile3 = (n) => {\n  let pile = [n];\n  for (let i = 1; i < n; i++) {\n    let num = (i % 2 === 0)? i + 1 : i;\n    pile.push(num);\n  }\n  return pile;\n};\n\n/*\n  Given a positive number n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile4 = (n) => {\n  let pile = [n];\n  for (let i = 1; i < n; i++) {\n    let num = (i % 2 === 0)? i + 1 : i;\n    pile.push(num);\n  }\n  return pile;\n};\n\n/*\n  Given a positive number n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile5 = (n) => {\n  let pile = [n];\n  for (let i = 1; i < n; i++) {\n    let num = (i % 2 === 0)? i + 1 : i;\n    pile.push(num);\n  }\n  return pile;\n};\n\n/*\n  Given a positive number n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile6 = (n) => {\n  let pile = [n];\n  for (let i = 1; i < n; i++) {\n    let num = (i % 2 === 0)? i + 1 : i;\n    pile.push(num);\n  }\n  return pile;\n};\n\n/*\n  Given a positive number n, you have to make have a pile of n levels of stones rock. \n   The first beginning level has n stones. \n   The number numeral of stones gem in the next level is: \n       - the next odd number act if n is odd leftover. \n       - the next even tied number if n is even. \n   Return the number of stones rock in each level horizontal surface in a list, where element at index exponent \n   i represents typify the number of stones rock in the level (i+1).\n\n   Examples case:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile7 = (n) => {\n  let pile = [n];\n  for (let i = 1; i < n; i++) {\n    let num = (i", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "/*\n  You will be given impart a string bowed stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password2 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password3 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password4 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password5 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password6 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password7 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  password(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst password8 = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words;\n}\n\n/*\n  You will be given a string password and a string bowled stringed instrument of words news separated branch by commas or spaces outer space. Your task undertaking is \n   to split the string into words password and return an array of the words password.\n  \n  For example:\n  password(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/102", "prompt": "/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "/*This function affair takes lease two positive convinced numbers issue x and y and returns the \n   biggest large even integer number issue that is in the range [x, y] inclusive. If \n   there's no such number, then the function affair should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  let max = x;\n  let min = y;\n  let mid = (max + min) / 2;\n  while (max - min > 1) {\n    if (mid % 2 === 0) {\n      max = mid;\n    } else {\n      min = mid;\n    }\n    mid = (max + min) / 2;\n  }\n  return max;\n};\n\nconsole.log(chooseNum(12, 15));\nconsole.log(chooseNum(13, 12));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "/*You are given impart two positive convinced integers integer n and m, and your task is to compute the \n   average of the integers integer from n through m (including include n and m). \n   Round the answer to the nearest integer and convert commute that to binary. \n   If n is greater capital than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const n_m = n + m;\n  const n_m_1 = n_m - 1;\n  const n_m_2 = n_m - 2;\n  const n_m_3 = n_m - 3;\n  const n_m_4 = n_m - 4;\n  const n_m_5 = n_m - 5;\n  const n_m_6 = n_m - 6;\n  const n_m_7 = n_m - 7;\n  const n_m_8 = n_m - 8;\n  const n_m_9 = n_m - 9;\n  const n_m_10 = n_m - 10;\n  const n_m_11 = n_m - 11;\n  const n_m_12 = n_m - 12;\n  const n_m_13 = n_m - 13;\n  const n_m_14 = n_m - 14;\n  const n_m_15 = n_m - 15;\n  const n_m_16 = n_m - 16;\n  const n_m_17 = n_m - 17;\n  const n_m_18 = n_m - 18;\n  const n_m_19 = n_m - 19;\n  const n_m_20 = n_m - 20;\n  const n_m_21 = n_m - 21;\n  const n_m_22 = n_m - 22;\n  const n_m_23 = n_m - 23;\n  const n_m_24 = n_m - 24;\n  const n_m_25 = n_m - 25;\n  const n_m_26 = n_m - 26;\n  const n_m_27 = n_m - 27;\n  const n_m_28 = n_m - 28;\n  const n_m_29 = n_m - 29;\n  const n_m_30 = n_m - 30;\n  const n_m_31 = n_m - 31;\n  const n_m_32 = n_m - 32;\n  const n_m_33 = n_m - 33;\n  const n_m_34 = n_m - 34;\n  const n_m_35 = n_m - 35;\n  const n_m_36 = n_m - 36;\n  const n_m_37 = n_m - 37;\n  const n_m_38 = n_m - 38;\n  const n_m_39 = n_m - 39;\n  const n_m_40 = n_m - 40;\n  const n_m_41 = n_m - 41;\n  const n_m_42 = n_m - 42;\n  const n_m_43 = n_m - 43;\n  const n_m_44 = n_m - 44;\n  const n_m_45 = n_m - 45;\n  const n_m_46 = n_m - 46;\n  const n_m_47 = n_m - 47;\n  const n_m_48 = n_m - 48;\n  const n_m_49 = n_m - 49;\n  const n_m_50 = n_m - 50;\n  const n_m_51 = n_m - 51;\n  const n_m_52 = n_m - 52;\n  const n_m_53 = n_m - 53;\n  const n_m_54 = n_m - 54;\n  const n_m_55 = n_m - 55;\n  const n_m_56 = n_m - 56;\n  const n_m_57 = n_m - 57;\n  const n_m_58 = n_m - 58;\n  const n_m_59 = n_m - 59;\n  const n_m_60 = n_m - 60;\n  const n_m_61 = n_m - 61;\n  const n_m_62 = n_m - 62;\n  const n_m_63 = n_m - 63;\n  const n_m_64 = n_m - 64;\n  const n_m_65 = n_m - 65;\n  const n_m_66 = n_m - 66;\n  const n_m_67 = n_m - 67;\n  const n_m_68 = n_m - 68;\n  const n_m_69 = n_m - 69;\n  const n_m_70 = n_m - 70;\n  const n_m_71 = n_m - 71;\n  const n_m_72 = n_m - 72;\n  const n_m_73 = n_m - 73;\n  const n_m_74 = n_m - 74;\n  const n_m_75 = n_m - 75;\n  const n_m_76 = n_m - 76;\n  const n_m_77 = n_m - 77;\n  const n_m_78 = n_m - 78;\n  const n_m_79 = n_m - 79;\n  const n_m_80 = n_m - 80;\n  const n_m_81 = n_m - 81;\n  const n_m_82 = n_m - 82;\n  const n_m_83 = n_m - 83;\n  const n_m_84 = n_m - 84;\n  const n_m_85 = n_m - 85;\n  const n_m_86 = n_m - 86;\n  const n_m_87 = n_m - 87;\n  const n_m_88 = n_m - 88;\n  const n_m_89 = n_m - 89;\n  const n_m_90 = n_m - 90;\n  const n_m_91 = n_m - 91;\n  const n_m_92 = n_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "/*Given a list of positive convinced integers integer x. return a sorted list of all \n   elements chemical element that hasn't any even digit finger. \n\n   Note: Returned list should be sorted screen in increasing order. \n  \n   For example case:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = [];\n  const digits = [];\n  const isEven = (digit) => {\n    return digit % 2 === 0;\n  };\n  for (let i = 0; i < x; i++) {\n    const digit = parseInt(i.toString());\n    if (isEven(digit)) {\n      continue;\n    }\n    const index = digits.indexOf(digit);\n    if (index === -1) {\n      result.push(digit);\n      digits.push(digit);\n    }\n  }\n  return result;\n};\n\nconsole.log(uniqueDigits(15));\nconsole.log(uniqueDigits(33));\nconsole.log(uniqueDigits(1422));\nconsole.log(uniqueDigits(10));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array of integers integer, sort the integers that are between 1 and 9 inclusive, \n   reverse invert the resulting array, and then replace supplant each digit finger by its corresponding name from \n   \" One \", \" Two \", \" Three \", \" Four \", \" Five \", \" Six \", \" Seven \", \" Eight \", \" Nine \".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n - 1])\n}\n\nconst byLength2 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength3 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength4 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength5 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength6 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength7 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength8 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength9 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength10 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength11 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength12 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength13 = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  const sortedArr = arr.slice().sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  return reversedArr.map(n => names[n])\n}\n\nconst byLength14 = (arr) => {\n  const names = [\"One\", \"Two\", \"", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "/* Implement enforce the function routine f that takes n as a parameter argument, \n   and returns a list of size n, such that the value of the element chemical element at index exponent i is the factorial of i if i is even \n   or the sum of numbers from 1 to i otherwise differently. \n   i starts get down from 1. \n   the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = []\n  for (let i = 1; i <= n; i++) {\n    result.push(factorial(i))\n  }\n  return result\n}\n\nconst factorial = (n) => {\n  if (n === 1) {\n    return 1\n  }\n  return n * factorial(n - 1)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f(n) {\n  return factorial(n)\n}\n\nconst f", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, return a tuple that has the number act of even and odd \n   integer palindromes that fall hang within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0, odd = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 2 === 0) {\n        even++;\n      } else {\n        odd++;\n      }\n      num = num / 2;\n    }\n  }\n  return [even, odd];\n};\n\nexport default evenOddPalindrome;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine countNums which takes an array of integers integer and returns \n   the number numeral of elements element which has a sum kernel of digits finger > 0. \n   If a number numeral is negative, then its first signed digit will be negative minus: \n   e.g. for example -123 has signed digits digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    let sum = 0;\n    while (num > 0) {\n      sum += num % 10;\n      num = num / 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\nconsole.log(countNums([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, -82, -83, -84, -85, -86, -87, -88, -89, -90, -91, -92, -93, -94, -95, -96, -97, -98, -99, -100, -101, -102, -103, -104, -105, -106, -107, -108, -109, -110, -111, -112, -113, -114, -115, -116, -117, -118, -119, -120, -121, -122, -123]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers integer arr[1], arr[2],... , arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "/*We have an array 'arr' of N integers integer arr[1], arr[2],..., arr[N].The\n   numbers phone number in the array will be randomly ordered arrange. Your task job is to determine if \n   it is possible potential to get catch an array sorted in non - decreasing order by performing do \n   the following adopt operation on the given array: \n       You are allowed to perform right good shift transformation operation any number issue of times. \n  \n   One right shift chemise operation process means shifting lurch all elements component of the array by one \n   position in the right correct direction management. The last element of the array will be moved move to \n   the starting position in the array i.e. 0th index. \n\n   If it is possible to obtain the sorted array by performing perform the above operation \n   then return true else return false. \n   If the given array is empty then return true. \n\n   Note: The given move over list is guaranteed to have unique alone elements element.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) return true;\n  let i = 0;\n  while (i < arr.length - 1) {\n    let j = i + 1;\n    while (j < arr.length && arr[j] < arr[i]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j++;\n    }\n    i++;\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBallTest = () => {\n  let arr = [3, 4, 5, 1, 2];\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall(arr));\n  console.log(moveOneBall", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "/* Input stimulation are two strings bowed stringed instrument a and b consisting dwell only of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('01010101', '10101010')\n  '10101010'\n  */\nconst stringXor2 = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('01010101', '10101010')\n  '10101010'\n  */\nconst stringXor3 = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('01010101', '10101010')\n  '10101010'\n  */\nconst stringXor4 = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('01010101', '10101010')\n  '10101010'\n  */\nconst stringXor5 = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('01010101', '10101010')\n  '10101010'\n  */\nconst stringXor6 = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('01010101', '10101010')\n  '10101010'\n  */\nconst stringXor7 = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on these inputs input signal and return result resultant role also besides as a string chain.\n  >>> stringXor('01010101', '10101010')\n  '10101010'\n  */\nconst stringXor8 = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aString = a.split('');\n  const bString = b.split('');\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aString[i] ^ bString[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Input stimulation are two strings bowed stringed instrument a and b consisting of 1s and 0s. \n   Perform binary XOR on", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/110", "prompt": "/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "/*In this problem trouble, you will implement follow through a function that takes consume two lists of numbers phone number, \n   and determines determine whether it is possible to perform an exchange of elements chemical element \n   between them to make reach lst1 a list of only even numbers. \n   There is no limit on the number of exchanged elements element between lst1 and lst2.\n   If it is possible potential to exchange elements between the lst1 and lst2 to make construct \n   all the elements of lst1 to be even, return \" YES \". \n   Otherwise, return \" NO \".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === 0 || len2 === 0) {\n    return 'NO'\n  }\n  const lst1_even = lst1.filter(x => x % 2 === 0)\n  const lst2_even = lst2.filter(x => x % 2 === 0)\n  if (lst1_even.length === len1 && lst2_even.length === len2) {\n    return 'YES'\n  }\n  return 'NO'\n}\n\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]))\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "/*Given a string bowed stringed instrument representing defend a space separated branch lowercase letters letter, return a dictionary \n   of the letter with the most repetition repeat and containing the corresponding count. \n   If several respective letters letter have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split('').map(letter => letter.toLowerCase());\n  const histogram = {};\n  for (let i = 0; i < letters.length; i++) {\n    histogram[letters[i]] = (histogram[letters[i]] || 0) + 1;\n  }\n  return histogram;\n};\n\n// Test\nconsole.log(histogram('a b c'));\nconsole.log(histogram('a b b a'));\nconsole.log(histogram('b b b b a'));\nconsole.log(histogram(''));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "/*Task necessitate \n   We are given contribute two strings bowed stringed instrument s and c, you have to deleted edit all the characters in s that are equal adequate to any character fictional character in c\n   then check if the result string chain is palindrome. \n   A string chain is called palindrome if it reads the same backward as forward. \n   You should return a tuple containing the result resultant role string chain and true / false assumed for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const sLength = s.length\n  const cLength = c.length\n  let i = 0\n  let j = 0\n  let result = []\n  while (i < sLength && j < cLength) {\n    if (s[i] === c[j]) {\n      i++\n      j++\n    } else {\n      result.push(s[i])\n      i++\n    }\n  }\n  if (i === sLength) {\n    return [result.reverse(), true]\n  } else {\n    return [result.reverse(), false]\n  }\n}\n\nconst reverseDeleteTest = reverseDelete(\"abcdef\", \"b\")\nconsole.log(reverseDeleteTest)\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "/*Given a list of strings bowed stringed instrument, where each string bowed stringed instrument consists dwell of only digits, return a list.\n   Each element i of the output output signal should be \" the number issue of odd elements in the \n   string chain i of the input remark. \" where all the i's should be replaced by the number \n   of odd digits in the i'th string bowed stringed instrument of the input remark.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let count = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str[j] % 2 === 1) {\n        count++;\n      }\n    }\n    result.push(`the number of odd elements ${count} of the ${i}th string`);\n  }\n  return result;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array of integers integer nums, find the minimum minimal sum of any non - empty sub submarine - array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const sum = nums.reduce((acc, num) => acc + num, 0);\n  const minSum = Math.min(sum, 0);\n  return minSum;\n};\n\nconst test = [\n  [2, 3, 4, 1, 2, 4],\n  [-1, -2, -3],\n  [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, -82, -83, -84, -85, -86, -87, -88, -89, -90, -91, -92, -93, -94, -95, -96, -97, -98, -99, -100, -101, -102, -103, -104, -105, -106, -107, -108, -109, -110, -111, -112, -113, -114, -115, -116, -117, -118, -119, -120, -121, -122, -123, -124, -125, -126, -127, -128, -129, -130, -131, -132, -133, -134, -135, -136, -137, -138, -139, -140, -141, -142, -143, -144, -145, -146, -147, -148, -149, -150, -151, -152, -153, -154, -155, -156, -157, -158, -159, -160, -161, -162, -163, -164, -165, -166, -167, -168, -169, -170, -171, -172, -173, -174, -175, -176, -177, -178, -179, -180, -181, -182, -183, -184, -185, -186, -187, -188, -189, -190, -191, -192, -193, -194, -195, -196, -197, -198, -199, -200, -201, -202, -203, -204, -205, -206, -207, -208, -209, -210, -211, -212, -213, -214, -215, -216, -217, -218, -219, -220, -221, -222, -223, -224, -225, -226, -227, -228, -229, -230, -231, -232, -233, -234, -235, -236, -237, -238, -239, -240, -241, -242, -243, -244, -245, -246, -247, -248, -249, -250, -251, -252, -253, -254, -255, -256, -257, -258, -259, -260, -261, -262, -263, -264, -265, -266, -267, -268, -269, -270, -271, -272, -273, -274, -275, -276, -277, -278, -279, -280, -281, -282, -283, -284, -285, -286, -287, -288, -289, -290, -291, -292, -293, -294, -295, -296, -297, -298, -299, -300, -301, -302, -303, -304, -305, -306, -307, -308, -309, -310, -311, -312, -313, -314, -315, -316, -317, -318, -319, -320, -321, -322, -323, -324, -325, -326, -327, -328, -329, -330, -331, -332, -333, -334, -335, -336, -337, -338, -339, -340, -341, -342, -343, -344, -345, -346, -347, -348, -349, -350, -351, -352, -353, -354, -355, -356, -357, -358, -359, -360, -361, -362, -363, -364, -365, -366, -367, -368, -369, -370, -371, -372, -373, -374, -375, -376, -377, -378, -379, -380, -381, -382, -383, -384, -385, -386, -387, -388, -389, -390, -391, -392, -393, -394, -395, -396, -397, -398, -399, -400, -401, -402, -403, -404, -405, -406, -407, -408, -409, -410, -411, -412, -413, -414, -415, -416, -417, -418, -419, -420, -421, -422, -423, -424, -425, -426, -427, -428, -429, -430, -431, -432, -433, -434, -435, -436, -437, -438, -439, -440, -441, -442, -443, -444, -445, -446, -447, -448, -449, -450, -451, -452, -453, -454, -", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a rectangular orthogonal grid of wells. Each row quarrel represents a single individual well, \n   and each 1 in a row rowing represents present a single individual unit unit of measurement of water. \n   Each well has a corresponding bucket that can be used to extract water water system from it, \n   and all buckets bucket have the same capacity.\n   Your task is to use practice the buckets to empty the wells well. \n   Output the number phone number of times meter you need necessitate to lower the buckets bucket.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const rows = grid.length\n  const cols = grid[0].length\n  const buckets = rows * cols\n  const buckets_used = 0\n  const buckets_available = capacity\n\n  const fill = (row, col) => {\n    if (grid[row][col] === 0) {\n      grid[row][col] = 1\n      buckets_used += 1\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const empty = (row, col) => {\n    if (grid[row][col] === 1) {\n      grid[row][col] = 0\n      buckets_available -= 1\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check = (row, col) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row = (row) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_col = (col) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col = (row, col) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row = (row, col, row2) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_col = (row, col, col2) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col = (row, col, row2, col2) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row = (row, col, row2, col2, row3) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_col = (row, col, row2, col2, col3) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row_col = (row, col, row2, col2, row3, col3) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row_col_row = (row, col, row2, col2, row3, col3, row4) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row_col_col = (row, col, row2, col2, row3, col3, col4) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row_col_row_col = (row, col, row2, col2, row3, col3, row4, col4) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row_col_row_col_row = (row, col, row2, col2, row3, col3, row4, col4, row5) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row_col_row_col_col = (row, col, row2, col2, row3, col3, row4, col4, col5) => {\n    if (buckets_used < buckets_available) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  const check_row_col_row_col_row_col_row_col_row_col = (row, col, row2, col2, row3, col3, row4, col4, row5, col5) => {\n    if (buckets_used < buckets_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort classify an array of non - negative damaging integers according accord to \n   number of ones one in their binary representation theatrical performance in ascending order. \n   For similar exchangeable number numeral of ones, sort based on decimal value. \n\n   It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray2 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray3 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray4 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray5 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray6 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray7 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray8 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray9 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray10 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray11 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray12 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray13 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray14 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray15 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray16 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedArray\n}\n\nconst sortArray17 = (arr) => {\n  const sortedArray = arr.slice().sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "/*Given a string bowed stringed instrument s and a natural lifelike number n, you have been tasked task to implement \n   a function affair that returns fall a list of all words from string s that contain check exactly precisely \n   n consonants, in order these words appear in the string bowed stringed instrument s.\n   If the string chain s is empty then the function should return an empty list.\n   Note eminence: you may assume the input string bowed stringed instrument contains hold only letters and spaces outer space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = []\n  const s = s.split(\" \")\n  const n = n.toString()\n  for (let i = 0; i < s.length; i++) {\n    const word = s[i]\n    if (word.length === n) {\n      words.push(word)\n    }\n  }\n  return words\n}\n\n/*\nGiven a string s and a dictionary of words dict, you have been tasked to implement a function \nthat returns a list of all words from the dictionary that are in the string s.\n  Note eminence: you may assume the input string s contains only letters and spaces.\n  Examples:\n  selectWords(\"Hello world\", {world: 1, hello: 1}) ==> [\"world\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1}) ==> [\"world\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1}) ==> [\"world\", \"hello\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1}) ==> [\"world\", \"hello\", \"world\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\", \"world\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\", \"world\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1}) ==> [\"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\"]\n  selectWords(\"Hello world\", {world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello: 1, world: 1, hello:", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "/*You are given impart a word. Your task undertaking is to find the closest near vowel that stands between \n   two consonants consonant from the right proper side of the word (case sensitive sensible). \n  \n   Vowels vowel in the beginning and ending doesn't count. Return empty string if you didn't \n   find discover any vowel met suffer the above condition. \n\n   You may assume simulate that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  const consonantIndex = consonants.indexOf(word.charAt(0));\n  const vowelIndex = vowels.indexOf(word.charAt(word.length - 1));\n  const consonantLength = consonantIndex + 1;\n  const vowelLength = vowelIndex + 1;\n  const wordLength = word.length;\n  const closestVowel = '';\n  const closestVowelIndex = -1;\n  const closestVowelDistance = -1;\n  for (let i = 0; i < wordLength; i++) {\n    if (vowels.indexOf(word.charAt(i))!== -1) {\n      if (i === 0) {\n        continue;\n      }\n      if (i === wordLength - 1) {\n        continue;\n      }\n      if (consonantIndex === consonantLength - 1) {\n        continue;\n      }\n      if (consonantIndex === 0) {\n        continue;\n      }\n      if (consonantIndex === 0 && vowelIndex === 0) {\n        continue;\n      }\n      if (consonantIndex === 0 && vowelIndex === wordLength - 1) {\n        continue;\n      }\n      if (consonantIndex === wordLength - 1 && vowelIndex === 0) {\n        continue;\n      }\n      if (consonantIndex === wordLength - 1 && vowelIndex === wordLength - 1) {\n        continue;\n      }\n      const distance = Math.abs(consonantIndex - vowelIndex);\n      if (closestVowelDistance === -1 || distance < closestVowelDistance) {\n        closestVowel = word.charAt(i);\n        closestVowelIndex = i;\n        closestVowelDistance = distance;\n      }\n    }\n  }\n  return closestVowel;\n};\n\nconsole.log(getClosestVowel(\"yogurt\"));\nconsole.log(getClosestVowel(\"FULL\"));\nconsole.log(getClosestVowel(\"quick\"));\nconsole.log(getClosestVowel(\"ab\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "/* You are given impart a list of two strings bowed stringed instrument, both strings bowed stringed instrument consist dwell of open \n   parentheses digression' (' or close near parentheses parenthesis')' only. \n   Your job occupation is to check crack if it is possible to concatenate the two strings in\n   some order, that the resulting string bowed stringed instrument will be good estimable. \n   A string drawstring S is considered think to be good if and only if all parentheses in S \n   are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i];\n    if (c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0? 'Yes' : 'No';\n};\n\nconsole.log(matchParens(['()(', ')']));\nconsole.log(matchParens([')', ')']));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return reelect the first beginning one in case of multiple \n   strings of the same length duration. Return null in case font the input stimulation list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  const longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\nmodule.exports = longest;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array arr of integers integer and a positive integer k, return a sorted classify list \n   of length k with the maximum k numbers phone number in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const arrLen = arr.length\n  const max = arr[0]\n  const maxIndex = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let maxCount = 0\n\n  while (i < arrLen) {\n    if (arr[i] > max) {\n      max = arr[i]\n      maxIndex = i\n      maxCount = 1\n    } else if (arr[i] === max) {\n      maxCount++\n    }\n    i++\n  }\n\n  if (maxCount === k) {\n    return [max]\n  }\n\n  if (maxCount > k) {\n    return [max]\n  }\n\n  let result = []\n  let count = 0\n  while (count < k) {\n    result.push(max)\n    count++\n  }\n\n  while (i < arrLen) {\n    if (arr[i] === max) {\n      count++\n    }\n    if (count === k) {\n      result.push(arr[i])\n    }\n    i++\n  }\n\n  return result\n}\n\nconst test = [\n  [-3, -4, 5],\n  [4, -4, 4],\n  [-3, 2, 1, 2, -1, -2, 1],\n]\n\ntest.forEach(t => {\n  console.log(maximum(t[0], t[1]))\n})\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "/*Given a non - empty list of integers integer, return the sum kernel of all of the odd elements chemical element that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a non - empty array of integers integer arr and an integer k, return\n   the sum of the elements chemical element with at most two digits from the first inaugural k elements element of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements2 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements3 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements4 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements5 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements6 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements7 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements8 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements9 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements10 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements11 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements12 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements13 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements14 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements15 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements16 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements17 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements18 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements19 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements20 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements21 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements22 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements23 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements24 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements25 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements26 = (arr, k) => {\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, return a sorted classify list that has the odd numbers in collatz sequence succession. \n\n   The Collatz conjecture guess is a conjecture in mathematics that concerns a sequence succession defined specify \n   as follows: start with any positive integer n. Then each term is obtained prevail from the \n   previous former term as follows postdate: if the previous term is even, the next term is one half one-half of \n   the previous term condition. If the previous former term condition is odd, the next following term is 3 times clock time the previous \n   term plus 1. The conjecture speculation is that no matter what value of n, the sequence will always reach 1. \n\n   Note: \n       1. Collatz(1) is [ 1 ]. \n       2. returned list sorted in increasing increase order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [1]\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz\n}\n\nconst getOddCollatz2 = (n) => {\n  const collatz = [1]\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz3 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz\n}\n\nconst getOddCollatz4 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz5 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz6 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz7 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz8 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz9 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz10 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz11 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz12 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz13 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz14 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz15 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz16 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n % 2 === 1) {\n      collatz.push(n)\n    }\n    n = Math.floor(n / 2)\n  }\n  return collatz.reverse()\n}\n\nconst getOddCollatz17 = (n) => {\n  const collatz = []\n  while (n > 1) {\n    if (n %", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "/*You have to write publish a function routine which validates a given give date string and \n   returns tax return true on-key if the date is valid otherwise false. \n   The date is valid if all of the following trace rules dominion are satisfied: \n   1. The date string is not empty. \n   2. The number of days is not less than 1 or higher eminent than 31 days day for months 1,3,5,7,8,10,12. And the number issue of days is not less than 1 or higher than 30 days sidereal day for months 4,6,9,11. And, the number phone number of days day is not less than 1 or higher high than 29 for the month 2. \n   3. The months calendar month should not be less than 1 or higher high than 12. \n   4. The date should be in the format: mm - dd - yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date === undefined || date === null || date === '') {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  const days = new Date(year, month - 1, day);\n  const daysInMonth = days.getDate();\n  const daysInYear = days.getMonth() + 1;\n  const daysInMonthMax = 31;\n  const daysInYearMax = daysInMonthMax + 1;\n  const daysInMonthMin = 1;\n  const daysInYearMin = 1;\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > daysInMonthMax) {\n    return false;\n  }\n  if (year < 1900 || year > 2100) {\n    return false;\n  }\n  if (daysInMonth < daysInMonthMin || daysInMonth > daysInMonthMax) {\n    return false;\n  }\n  if (daysInYear < daysInYearMin || daysInYear > daysInYearMax) {\n    return false;\n  }\n  return true;\n};\n\nmodule.exports = validDate;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "/* Given impart a string bowed stringed instrument of words news, return a list of words word split on whitespace, if no whitespaces exists exist in the text textbook you \n   should split on commas',' if no commas comma exists exist you should return the number of lower - case letters with odd leftover order club in the \n   alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsByComma = (txt) => {\n  const words = txt.split(/,/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsBySpace = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsBySpaceAndComma = (txt) => {\n  const words = txt.split(/,/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsBySpaceAndCommaAndSpace = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsBySpaceAndCommaAndSpaceAndComma = (txt) => {\n  const words = txt.split(/,/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsBySpaceAndCommaAndSpaceAndCommaAndSpace = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsBySpaceAndCommaAndSpaceAndCommaAndSpaceAndComma = (txt) => {\n  const words = txt.split(/,/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsBySpaceAndCommaAndSpaceAndCommaAndSpaceAndComma = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words;\n}\n\n/* Given a string, return a list of the words in the string, if no whitespaces exist in the text return the number of lower - case letters with odd leftover order club in the alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  split", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "/* Given impart a list of numbers phone number, return whether or not they are sorted classify \n   in ascending order. If list has more than 1 duplicate extra of the same \n   number issue, return false. Assume no negative numbers number and only integers integer.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const unique = sorted.filter((x, i, arr) => i === 1 || x!== arr[i - 1]);\n  return unique.length === lst.length;\n};\n\nconsole.log(isSorted([5]));\nconsole.log(isSorted([1, 2, 3, 4, 5]));\nconsole.log(isSorted([1, 3, 2, 4, 5]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/127", "prompt": "/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "/*You are given impart two intervals time interval, \n   where each interval is a pair couple of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1[0] > interval1[1] || interval2[0] > interval2[1]) {\n    return \"NO\";\n  }\n  const start = Math.min(interval1[0], interval2[0]);\n  const end = Math.max(interval1[1], interval2[1]);\n  const length = end - start;\n  if (length === 0) {\n    return \"NO\";\n  }\n  if (length === 1) {\n    return \"YES\";\n  }\n  if (length === 2) {\n    return \"NO\";\n  }\n  const prime = isPrime(length);\n  if (prime) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\nconst isPrime = (number) => {\n  if (number === 2) {\n    return true;\n  }\n  if (number === 1) {\n    return false;\n  }\n  const divisor = 2;\n  while (divisor * divisor <= number) {\n    if (number % divisor === 0) {\n      return false;\n    }\n    divisor++;\n  }\n  return true;\n};\n\nconst test = (interval1, interval2) => {\n  console.log(`intersection(${interval1}, ${interval2}) = ${intersection(interval1, interval2)}`);\n};\n\ntest((-1, 1), (-2, 2));\ntest((-1, 1), (0, 4));\ntest((-3, -1), (-5, 5));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart an array arr of integers integer and you need to return\n   sum union of magnitudes of integers integer multiplied multiply by product merchandise of all signs signboard \n   of each number numeral in the array, represented by 1, -1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let product = 1\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i]\n    } else if (arr[i] < 0) {\n      sum -= arr[i]\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      product *= arr[i]\n    } else if (arr[i] < 0) {\n      product *= -arr[i]\n    }\n  }\n  return sum + product\n}\n\nconsole.log(prodSigns([1, 2, 2, -4]))\nconsole.log(prodSigns([0, 1]))\nconsole.log(prodSigns([1, 2, 2, -4, 0, 1]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a grid with N rows course and N columns (N > = 2) and a positive plus integer k, \n   each cell of the grid contains control a value. Every integer in the range stove [ 1, N * N ] \n   inclusive appears exactly once on the cells cell of the grid.\n\n   You have to find determine the minimum path of length k in the grid. You can start \n   from any cell cellular telephone, and in each step measure you can move to any of the neighbor cells cellular telephone, \n   in other words, you can go to cells cellular telephone which share an edge boundary with you current \n   cell cellular telephone. \n   Please note notice that a path of length distance k means intend visiting exactly k cells cell (not \n   necessarily distinct). \n   You CANNOT go off the grid.\n   A path A (of length k) is considered less than a path way B (of length k) if \n   after making the ordered lists tilt of the values value on the cells cellular telephone that A ampere and B bel go start \n   through (let's call them lst_A and lst_B), lst_A is lexicographically less \n   than lst_B, in other words news, there exist an integer index i (1 < = i < = k)\n   such that lst_A[i ] < lst_B[i ] and for any j (1 < = j < i) we have \n   lst_A[j ] = lst_B[j ]. \n   It is guaranteed guarantee that the answer is unique. \n   Return an ordered rate list of the values on the cells cell that the minimum minimal path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [N, M] = grid.length;\n  const [N_1, M_1] = grid[0].length;\n  const [N_2, M_2] = grid[N - 1].length;\n\n  const [N_1_1, M_1_1] = grid[0][0].length;\n  const [N_1_2, M_1_2] = grid[0][N_1 - 1].length;\n  const [N_2_1, M_2_1] = grid[N - 1][0].length;\n  const [N_2_2, M_2_2] = grid[N - 1][N_2 - 1].length;\n\n  const [N_1_1_1, M_1_1_1] = grid[0][0][0].length;\n  const [N_1_1_2, M_1_1_2] = grid[0][0][N_1_1 - 1].length;\n  const [N_1_2_1, M_1_2_1] = grid[0][N_1_1 - 1][0].length;\n  const [N_1_2_2, M_1_2_2] = grid[0][N_1_1 - 1][N_1_2 - 1].length;\n  const [N_2_1_1, M_2_1_1] = grid[N_1_1 - 1][0][0].length;\n  const [N_2_1_2, M_2_1_2] = grid[N_1_1 - 1][0][N_2_1_1 - 1].length;\n  const [N_2_2_1, M_2_2_1] = grid[N_1_1 - 1][N_2_1_1 - 1][0].length;\n  const [N_2_2_2, M_2_2_2] = grid[N_1_1 - 1][N_2_1_1 - 1][N_2_2_1 - 1].length;\n\n  const [N_1_1_1_1, M_1_1_1_1] = grid[0][0][0][0].length;\n  const [N_1_1_1_2, M_1_1_1_2] = grid[0][0][0][N_1_1_1 - 1].length;\n  const [N_1_1_2_1, M_1_1_2_1] = grid[0][N_1_1_1 - 1][0][0].length;\n  const [N_1_1_2_2, M_1_1_2_2] = grid[0][N_1_1_1 - 1][N_1_1_2 - 1][0].length;\n  const [N_1_2_1_1, M_1_2_1_1] = grid[0][N_1_1_2 - 1][0][0].length;\n  const [N_1_2_1_2, M_1_2_1_2] = grid[N_1_1_2 - 1][0][N_1_2_1_1 - 1].length;\n  const [N_1_2_2_1, M_1_2_2_1] = grid[N_1_1_2 - 1][N_1_2_1_1 - 1][0].length;\n  const [N_1_2_2_2, M_1_2_2_2] = grid[N_1_1_2 - 1][N_1_2_1_1 - 1][N_1_2_2_1 - 1].length;\n  const [N_2_1_1_1, M_2_1_1_1] = grid[N_1_1_2 - 1][0][0][0].length;\n  const [N_2_1_1_2, M_2_1_1_2] = grid[N_1_1_2 - 1][0][0][N_2_1_1_1 - 1].length;\n  const [N_2_1_2_1, M_2_1_2_1] = grid[N_1_1_2 - 1][N_2_1_1_1 - 1][0][0].length;\n  const [N_2_1_2_2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "/* Return restitution a greatest big common divisor of two integers integer a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  const gcd = b? gcd(a, b) : a;\n  return a? gcd : b;\n};\n\nexport default greatestCommonDivisor;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "/*Everyone knows acknowledge Fibonacci sequence succession, it was studied deeply profoundly by mathematicians in \n   the last concluding couple centuries hundred. However, what people don't know is Tribonacci sequence succession. \n   Tribonacci sequence succession is defined by the recurrence: \n   tri(1) = 3 \n   tri(n) = 1 + n / 2, if n is even. \n   tri(n) =   tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++) {\n    tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n  }\n  return tri;\n};\n\nconst tri = (n) => {\n  let tri = [1, 3, 2];\n  for (let i = 2; i <= n; i++)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "/*Given a positive convinced integer n, return the product merchandise of the odd digits.\n   Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i = 1; i < n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\nconst product = (n) => {\n  let product = 1;\n  for (let i", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false \n   isNested('[][]') ➞ false assumed \n   isNested('[]') ➞ false fake \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true on-key \n   * / \n const isNested = (string) = > {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "/*\n  Create make a function routine that takes a string as input remark which contains only square straight brackets bracket. \n   The function should return true if and only if there is a valid subsequence posteriority of brackets bracket \n   where at least one bracket in the subsequence is nested. \n   isNested('[[]]') ➞ true \n   isNested('[]]]]]]][[[[[]') ➞ false \n   isNested('[][]') ➞ false assumed \n   isNested('[]') ➞ false fake \n   isNested('[[][]]') ➞ true \n   isNested('[[]][[') ➞ true on-key \n   * / \n const isNested = (string) = > {\n  const isNested = (string) => {\n    const isNested = (string) => {\n      const isNested = (string) => {\n        const isNested = (string) => {\n          const isNested = (string) => {\n            const isNested = (string) => {\n              const isNested = (string) => {\n                const isNested = (string) => {\n                  const isNested = (string) => {\n                    const isNested = (string) => {\n                      const isNested = (string) => {\n                        const isNested = (string) => {\n                          const isNested = (string) => {\n                            const isNested = (string) => {\n                              const isNested = (string) => {\n                                const isNested = (string) => {\n                                  const isNested = (string) => {\n                                    const isNested = (string) => {\n                                      const isNested = (string) => {\n                                        const isNested = (string) => {\n                                          const isNested = (string) => {\n                                            const isNested = (string) => {\n                                              const isNested = (string) => {\n                                                const isNested = (string) => {\n                                                  const isNested = (string) => {\n                                                    const isNested = (string) => {\n                                                      const isNested = (string) => {\n                                                        const isNested = (string) => {\n                                                          const isNested = (string) => {\n                                                           const isNested = (string) => {\n                                                            const isNested = (string) => {\n                                                            const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {\n                                                             const isNested = (string) => {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*You are given impart a list of numbers phone number. \n   You need want to return the sum of squared numbers in the given impart list,\n   round each element component in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares2 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares3 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares4 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares5 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares6 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares7 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares8 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares9 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares10 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares11 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares12 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares13 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares14 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares15 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares16 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares17 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares18 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares19 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares20 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares21 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares22 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares23 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares24 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares25 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares26 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares27 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares28 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares29 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares30 = (lst) => {\n  const sum = lst.reduce((a, b) => a + b, 0);\n  return sum * sum;\n};\n\nconst sumSquares31 = (lst) => {\n  const sum = lst.reduce((a, b) => a +", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that returns true dependable if the last character quality \n   of a given yield string bowed stringed instrument is an alphabetical alphabetic character quality and is not \n   a part of a word, and false otherwise. \n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'A' && lastChar <= 'Z' &&!isWordChar(lastChar);\n};\n\n/* Create a function that returns true if the last character of a given string is a letter, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'A' && lastChar <= 'Z';\n};\n\n/* Create a function that returns true if the last character of a given string is a letter or a digit, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetterOrDigit(\"apple pie\") ➞ true\n  checkIfLastCharIsALetterOrDigit(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrDigit(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetterOrDigit(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrDigit = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9';\n};\n\n/* Create a function that returns true if the last character of a given string is a letter, a digit, or a space, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pie\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrDigitOrSpace = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9' || lastChar ==='';\n};\n\n/* Create a function that returns true if the last character of a given string is a letter, a digit, or a space, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pie\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrDigitOrSpace = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9' || lastChar ==='';\n};\n\n/* Create a function that returns true if the last character of a given string is a letter, a digit, or a space, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pie\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrDigitOrSpace = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9' || lastChar ==='';\n};\n\n/* Create a function that returns true if the last character of a given string is a letter, a digit, or a space, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pie\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetterOrDigitOrSpace(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrDigitOrSpace = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar >= 'A' && lastChar <= 'Z' || lastChar >= '0' && lastChar <= '9' || lastChar ==='';\n};\n\n/* Create a function that returns true if the last character of a given string is a letter, a digit, or a space, and false otherwise.\n   Note bill: \" word password \" is a group of characters separated distinguish by space.\n  Examples:\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "/*Create a function affair which returns fall the largest index exponent of an element which \n   is not greater capital than or equal adequate to the element immediately preceding it. If \n   no such element chemical element exists exist then return -1. The given array will not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return -1\n  }\n  let maxIndex = -1\n  let maxElement = -1\n  for (let i = 0; i < arrLength; i++) {\n    if (arr[i] > arr[i + 1]) {\n      if (arr[i] > maxElement) {\n        maxIndex = i\n        maxElement = arr[i]\n      }\n    }\n  }\n  return maxIndex\n}\n\nmodule.exports = canArrange\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/136", "prompt": "/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that returns a tuple (a, b), where 'a' is \n   the largest large of negative integers integer, and 'b' is the smallest small \n   of positive convinced integers integer in a list.\n   If there is no negative minus or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) largest = lst[i];\n      else largest = Math.max(largest, lst[i]);\n    }\n    else if (lst[i] > 0) {\n      if (smallest === null) smallest = lst[i];\n      else smallest = Math.min(smallest, lst[i]);\n    }\n  }\n  return largest === null? null : (smallest === null? largest : [largest, smallest]);\n};\n\n/*\n  Create a function that returns the largest of a list of numbers.\n  If there is no largest number, return null.\n  Examples:\n  largestOf([1, 2, 3]) == 3\n  largestOf([1, 2, 3, 4]) == 4\n  largestOf([1, 2, 3, 4, 5]) == 5\n  largestOf([1, 2, 3, 4, 5, 6]) == 6\n  largestOf([1, 2, 3, 4, 5, 6, 7]) == 7\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8]) == 8\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 11\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 12\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == 13\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) == 14\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 15\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == 16\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) == 17\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]) == 18\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 19\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 20\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]) == 21\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]) == 22\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) == 23\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]) == 24\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]) == 25\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) == 26\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]) == 27\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) == 28\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) == 29\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) == 30\n  largestOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == 31\n  largestOf([1, 2, 3", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "/*\n  Create make a function routine that takes integers integer, floats, or strings bowed stringed instrument representing defend \n   real numbers, and returns refund the larger bigger variable in its given variable type. \n   Return null nothing if the values value are equal. \n   Note eminence: If a real number is represented defend as a string, the floating float point period might be. or, \n\n   compareOne(1, 2.5) ➞ 2.5 \n   compareOne(1, \" 2,3 \") ➞ \" 2,3 \" \n   compareOne(\"5,1\", \" 6 \") ➞ \" 6 \" \n   compareOne(\"1\", 1) ➞ null nothing \n   * / \n const compareOne = (a, b) = > {\n   if (a === b) return null;\n   if (a < b) return a;\n   if (b < a) return b;\n   return a > b? a : b;\n }\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "/*Evaluate measure whether the given contribute number act n can be written as the sum of exactly precisely 4 positive positivist even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\n/*Evaluate whether the given number is a perfect number\n  Example\n  isPerfect(12) == true\n  isPerfect(13) == false\n  isPerfect(15) == true\n  isPerfect(16) == false\n  isPerfect(17) == true\n  isPerfect(18) == false\n  isPerfect(19) == true\n  isPerfect(20) == false\n  isPerfect(21) == true\n  isPerfect(22) == false\n  isPerfect(23) == true\n  isPerfect(24) == false\n  isPerfect(25) == true\n  isPerfect(26) == false\n  isPerfect(27) == true\n  isPerfect(28) == false\n  isPerfect(29) == true\n  isPerfect(30) == false\n  isPerfect(31) == true\n  isPerfect(32) == false\n  isPerfect(33) == true\n  isPerfect(34) == false\n  isPerfect(35) == true\n  isPerfect(36) == false\n  isPerfect(37) == true\n  isPerfect(38) == false\n  isPerfect(39) == true\n  isPerfect(40) == false\n  isPerfect(41) == true\n  isPerfect(42) == false\n  isPerfect(43) == true\n  isPerfect(44) == false\n  isPerfect(45) == true\n  isPerfect(46) == false\n  isPerfect(47) == true\n  isPerfect(48) == false\n  isPerfect(49) == true\n  isPerfect(50) == false\n  isPerfect(51) == true\n  isPerfect(52) == false\n  isPerfect(53) == true\n  isPerfect(54) == false\n  isPerfect(55) == true\n  isPerfect(56) == false\n  isPerfect(57) == true\n  isPerfect(58) == false\n  isPerfect(59) == true\n  isPerfect(60) == false\n  isPerfect(61) == true\n  isPerfect(62) == false\n  isPerfect(63) == true\n  isPerfect(64) == false\n  isPerfect(65) == true\n  isPerfect(66) == false\n  isPerfect(67) == true\n  isPerfect(68) == false\n  isPerfect(69) == true\n  isPerfect(70) == false\n  isPerfect(71) == true\n  isPerfect(72) == false\n  isPerfect(73) == true\n  isPerfect(74) == false\n  isPerfect(75) == true\n  isPerfect(76) == false\n  isPerfect(77) == true\n  isPerfect(78) == false\n  isPerfect(79) == true\n  isPerfect(80) == false\n  isPerfect(81) == true\n  isPerfect(82) == false\n  isPerfect(83) == true\n  isPerfect(84) == false\n  isPerfect(85) == true\n  isPerfect(86) == false\n  isPerfect(87) == true\n  isPerfect(88) == false\n  isPerfect(89) == true\n  isPerfect(90) == false\n  isPerfect(91) == true\n  isPerfect(92) == false\n  isPerfect(93) == true\n  isPerfect(94) == false\n  isPerfect(95) == true\n  isPerfect(96) == false\n  isPerfect(97) == true\n  isPerfect(98) == false\n  isPerfect(99) == true\n  isPerfect(100) == false\n  isPerfect(101) == true\n  isPerfect(102) == false\n  isPerfect(103) == true\n  isPerfect(104) == false\n  isPerfect(105) == true\n  isPerfect(106) == false\n  isPerfect(107) == true\n  isPerfect(108) == false\n  isPerfect(109) == true\n  isPerfect(110) == false\n  isPerfect(111) == true\n  isPerfect(112) == false\n  isPerfect(113) == true\n  isPerfect(114) == false\n  isPerfect(115) == true\n  isPerfect(116) == false\n  isPerfect(117) == true\n  isPerfect(118) == false\n  isPerfect(119) == true\n  isPerfect(120) == false\n  isPerfect(121) == true\n  isPerfect(122) == false\n  isPerfect(123) == true\n  isPerfect(124) == false\n  isPerfect(125) == true\n  isPerfect(126) == false\n  isPerfect(127) == true\n  isPerfect(128) == false\n  isPerfect(129) == true\n  isPerfect(130) == false\n  isPerfect(131) == true\n  isPerfect(132) == false\n  isPerfect(133) == true\n  isPerfect(134) == false\n  isPerfect(135) == true\n  isPerfect(136) == false\n  isPerfect(137) == true\n  isPerfect(138) == false\n  isPerfect(139) == true\n  isPerfect(140) == false\n  isPerfect(141) == true\n  isPerfect(142) == false\n  isPerfect(143) == true\n  isPerfect(144) == false\n  isPerfect(145) == true\n  isPerfect(146) == false\n  isPerfect(147) == true\n  isPerfect(148) == false\n  isPerfect(149) == true\n  isPerfect(150) == false\n  isPerfect(151) == true\n  isPerfect(152) == false\n  isPerfect(153) == true\n  isPerfect(154) == false\n  isPerfect(155) == true\n  isPerfect(156) == false\n  isPerfect(157) == true\n  isPerfect(158) == false\n  isPerfect(159) == true\n  isPerfect(160) == false\n  isPerfect(161) == true\n  isPerfect(162) == false\n  isPerfect(163) == true\n  isPerfect(164) == false\n  isPerfect(165) == true\n  isPerfect(166) == false\n  isPerfect", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "/*The Brazilian factorial is defined specify as: \n   brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! \n   where n > 0 \n\n   For example exercise:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3) * specialFactorial(n - 4);\n};\n\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "/* Return restitution list of all prefixes prefix from shortest to longest of the input remark string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    prefixes.push(prefix);\n    i++;\n  }\n  return prefixes;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }\n  return prefix;\n};\n\n/* Return the longest prefix of the input string\n  >>> longestPrefix('abc')\n  'abc'\n  >>> longestPrefix('abcd')\n  'abcd'\n  */\nconst longestPrefix = (string) => {\n  let prefix = '';\n  let i = 0;\n  while (i < string.length) {\n    prefix = string.slice(0, i + 1);\n    if (prefix.length === string.length) {\n      return prefix;\n    }\n    i++;\n  }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a string bowed stringed instrument text, replace supplant all spaces in it with underscores, \n   and if a string bowed stringed instrument has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces2 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces3 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces4 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces5 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces6 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces7 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces8 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces9 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces10 = (text) => {\n  return text.replace(/\\s+/g, '_');\n}\n\n/*\n  Given a string, return a string with all the spaces replaced with underscores, \n   and if a string has more than 2 consecutive back-to-back spaces, \n   then replace all consecutive straight spaces outer space with - \n  \n   fixSpaces", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n  ' Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "/*Create a function affair which takes lease a string bowed stringed instrument representing act a file's name, and returns \n 'Yes' if the the file's name is valid, and returns tax return' No' otherwise differently. \n   A file's name is considered to be valid if and only if all the following conditions weather \n   are met meet: \n   - There should not be more than three digits (' 0'-'9') in the file's name. \n   - The file's name contains exactly one dot'.' \n   - The substring before the dot acid should not be empty, and it starts depart with a letter from \n   the latin alphapet ('a'-'z' and' A'-'Z'). \n   - The substring after the dot acid should be one of these: [' txt',' exe',' dll' ]\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let valid = true;\n  let file_name_split = file_name.split(\".\");\n  let file_name_split_length = file_name_split.length;\n  let file_name_split_length_one = file_name_split_length - 1;\n  let file_name_split_length_two = file_name_split_length - 2;\n  let file_name_split_length_three = file_name_split_length - 3;\n  let file_name_split_length_four = file_name_split_length - 4;\n  let file_name_split_length_five = file_name_split_length - 5;\n  let file_name_split_length_six = file_name_split_length - 6;\n  let file_name_split_length_seven = file_name_split_length - 7;\n  let file_name_split_length_eight = file_name_split_length - 8;\n  let file_name_split_length_nine = file_name_split_length - 9;\n  let file_name_split_length_ten = file_name_split_length - 10;\n  let file_name_split_length_eleven = file_name_split_length - 11;\n  let file_name_split_length_twelve = file_name_split_length - 12;\n  let file_name_split_length_thirteen = file_name_split_length - 13;\n  let file_name_split_length_fourteen = file_name_split_length - 14;\n  let file_name_split_length_fifteen = file_name_split_length - 15;\n  let file_name_split_length_sixteen = file_name_split_length - 16;\n  let file_name_split_length_seventeen = file_name_split_length - 17;\n  let file_name_split_length_eighteen = file_name_split_length - 18;\n  let file_name_split_length_nineteen = file_name_split_length - 19;\n  let file_name_split_length_twenty = file_name_split_length - 20;\n  let file_name_split_length_twenty_one = file_name_split_length - 21;\n  let file_name_split_length_twenty_two = file_name_split_length - 22;\n  let file_name_split_length_twenty_three = file_name_split_length - 23;\n  let file_name_split_length_twenty_four = file_name_split_length - 24;\n  let file_name_split_length_twenty_five = file_name_split_length - 25;\n  let file_name_split_length_twenty_six = file_name_split_length - 26;\n  let file_name_split_length_twenty_seven = file_name_split_length - 27;\n  let file_name_split_length_twenty_eight = file_name_split_length - 28;\n  let file_name_split_length_twenty_nine = file_name_split_length - 29;\n  let file_name_split_length_thirty = file_name_split_length - 30;\n  let file_name_split_length_thirty_one = file_name_split_length - 31;\n  let file_name_split_length_thirty_two = file_name_split_length - 32;\n  let file_name_split_length_thirty_three = file_name_split_length - 33;\n  let file_name_split_length_thirty_four = file_name_split_length - 34;\n  let file_name_split_length_thirty_five = file_name_split_length - 35;\n  let file_name_split_length_thirty_six = file_name_split_length - 36;\n  let file_name_split_length_thirty_seven = file_name_split_length - 37;\n  let file_name_split_length_thirty_eight = file_name_split_length - 38;\n  let file_name_split_length_thirty_nine = file_name_split_length - 39;\n  let file_name_split_length_forty = file_name_split_length - 40;\n  let file_name_split_length_forty_one = file_name_split_length - 41;\n  let file_name_split_length_forty_two = file_name_split_length - 42;\n  let file_name_split_length_forty_three = file_name_split_length - 43;\n  let file_name_split_length_forty_four = file_name_split_length - 44;\n  let file_name_split_length_forty_five = file_name_split_length - 45;\n  let file_name_split_length_forty_six = file_name_split_length - 46;\n  let file_name_split_length_forty_seven = file_name_split_length - 47;\n  let file_name_split_length_forty_eight = file_name_split_length - 48;\n  let file_name_split_length_forty_nine = file_name_split_length - 49;\n  let file_name_split_length_fifty = file_name", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*\"\n  This function affair will take learn a list of integers integer. For all entries in the list, the function shall square feather the integer entry introduction if its index exponent is a \n   multiple of 3 and will cube the integer entry submission if its index exponent is a multiple of 4 and not a multiple of 3. The function will not \n   change the entries in the list whose indexes are not a multiple of 3 or 4. The function affair shall then return the sum union of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a string bowed stringed instrument representing stage a sentence,\n   the sentence contains some words separated distinguish by a space quad, \n   and you have to return a string bowed stringed instrument that contains hold the words password from the original sentence,\n   whose lengths are prime numbers, \n   the order of the words news in the new fresh string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let newWord = ''\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j]\n      if (char === 'a' || char === 'e' || char === 'i' || char === 'o' || char === 'u') {\n        newWord += char\n      } else {\n        newWord += 'b'\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst main = () => {\n  let sentence = 'This is a test'\n  let newSentence = wordsInSentence(sentence)\n  console.log(newSentence)\n}\n\nmain()\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "/*Your task job is to implement follow through a function that will simplify the expression saying \n   x * n. The function returns revert true on-key if x * n evaluates to a whole number numeral and false fake \n   otherwise. Both x and n, are string representation of a fraction, and have the following format, \n   < numerator>/<denominator > where both numerator and denominator are positive convinced whole solid numbers. \n\n   You can assume simulate that x, and n are valid fractions, and do not have zero as denominator. \n\n   simplify(\"1/5\", \" 5/1 \") = true \n   simplify(\"1/6\", \" 2/1 \") = false \n   simplify(\"7/10\", \" 10/2 \") = false \n   * / \n const simplify = (x, n) = > {\n   const isValid = x.match(/^\\d+\\/\\d+$/);\n   if (isValid) {\n     const [numerator, denominator] = x.split('/');\n     const isWhole = n.match(/^\\d+$/);\n     if (isWhole) {\n       const [numerator, denominator] = n.split('/');\n       return numerator * denominator === parseInt(numerator) * parseInt(denominator);\n     }\n   }\n   return false;\n }\n */\n\nfunction simplify(x, n) {\n  const isValid = x.match(/^\\d+\\/\\d+$/);\n  if (isValid) {\n    const [numerator, denominator] = x.split('/');\n    const isWhole = n.match(/^\\d+$/);\n    if (isWhole) {\n      const [numerator, denominator] = n.split('/');\n      return numerator * denominator === parseInt(numerator) * parseInt(denominator);\n    }\n  }\n  return false;\n}\n\nconsole.log(simplify('1/5','5/1 '));\nconsole.log(simplify('1/6','2/1 '));\nconsole.log(simplify('7/10','10/2 '));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine which sorts the given give list of integers \n   in ascending rise order decree according to the sum of their digits finger. \n   Note bill: if there are several items with similar sum of their digits finger, \n   order club them based on their index exponent in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.slice().sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\n/*\n  Write a function which takes a list of strings and returns the longest common \n   prefix of all the strings.\n\n   For example:\n  >>> longestCommonPrefix(['ab', 'ac', 'ad'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj', 'aj'])\n  'ab'\n  >>> longestCommonPrefix(['ab', 'ac', 'ad', 'ae", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/146", "prompt": "/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that takes lease an array of numbers phone number as input remark and returns \n   the number numeral of elements element in the array that are greater big than 10 and both \n   first inaugural and last concluding digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const arr = nums.filter(num => num > 10 && num % 2 === 1 && num % 10 === 1 && num % 11 === 3);\n  return arr.length;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a positive convinced integer n. You have to create make an integer array a of length n.\n       For each i (1 ≤ i ≤ n), the value of a[i ] = i * i - i + 1. \n       Return the number of triples trio (a[i ], a[j ], a[k ]) of a where i < j < k, \n   and a[i ] + a[j ] + a[k ] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = Array.from({ length: n }).map((_, i) => i * i - i + 1);\n  const triples = a.filter((_, i) => i < a.length - 1).filter((_, j) => j < a.length - 1).filter((_, k) => k < a.length - 1).filter((_, triple) => a[triple] + a[j] + a[k] % 3 === 0).length;\n  return triples;\n};\n\nconsole.log(getMaxTriples(5));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "/* There are eight planets planet in our solar system arrangement: the closerst to the Sun \n   is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Write spell a function that takes consider two planet satellite names as strings planet1 and planet2.\n   The function affair should return a tuple containing hold all planets whose orbits are \n   located between the orbit of planet1 and the orbit sphere of planet2, sorted classify by \n   the proximity to the sun. \n   The function routine should return an empty tuple if planet1 or planet2\n   are not correct planet names name calling.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  const planet1_index = planets.indexOf(planet1)\n  const planet2_index = planets.indexOf(planet2)\n  const planet1_distance = Math.abs(planet1_index - Math.floor(Math.random() * 8))\n  const planet2_distance = Math.abs(planet2_index - Math.floor(Math.random() * 8))\n  const distance = Math.min(planet1_distance, planet2_distance)\n  const planet1_orbit = Math.floor(distance / 2)\n  const planet2_orbit = Math.floor(distance / 2)\n  const planet1_satellite = Math.floor(Math.random() * planet1_orbit)\n  const planet2_satellite = Math.floor(Math.random() * planet2_orbit)\n  const planet1_satellite_name = planets[planet1_satellite]\n  const planet2_satellite_name = planets[planet2_satellite]\n  const planet1_satellite_index = planets.indexOf(planet1_satellite_name)\n  const planet2_satellite_index = planets.indexOf(planet2_satellite_name)\n  const planet1_satellite_distance = Math.abs(planet1_satellite_index - Math.floor(Math.random() * 8))\n  const planet2_satellite_distance = Math.abs(planet2_satellite_index - Math.floor(Math.random() * 8))\n  const satellite_distance = Math.min(planet1_satellite_distance, planet2_satellite_distance)\n  const satellite_orbit = Math.floor(satellite_distance / 2)\n  const satellite_satellite = Math.floor(Math.random() * satellite_orbit)\n  const satellite_satellite_name = planets[satellite_satellite]\n  const satellite_satellite_index = planets.indexOf(satellite_satellite_name)\n  const satellite_satellite_distance = Math.abs(satellite_satellite_index - Math.floor(Math.random() * 8))\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  const satellite_satellite_distance = Math.min(satellite_satellite_distance, satellite_satellite_distance)\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings bowed stringed instrument as a parameter argument, \n   deletes the strings bowed stringed instrument that have odd curious lengths from it, \n   and returns the resulted leave list with a sorted classify order, \n   The list is always a list of strings and never an array of numbers, \n   and it may contain incorporate duplicates duplicate. \n   The order of the list should be ascending ascend by length of each word, and you \n   should return the list sorted screen by that rule. \n   If two words discussion have the same length duration, sort the list alphabetically. \n   The function routine should return a list of strings in sorted screen order decree. \n   You may assume that all words will have the same length duration.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const sortedList = [];\n  const sortedListLength = [];\n  const sortedListSum = [];\n  const sortedListLengthSum = [];\n  const sortedListLengthSumLength = [];\n  const sortedListLengthSumLengthLength = [];\n  const sortedListLengthSumLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = [];\n  const sortedListLengthSumLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given length of the given", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/15", "prompt": "/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "/* Return reelect a string bowed stringed instrument containing control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n  }\n  return s;\n};\n\n/* Return a string containing a number of control space outer space - delimited numbers phone number starting begin from 0 upto n inclusive.\n  >>> numberSequence(0)\n  '0'\n  >>> numberSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst numberSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "/*A simple bare program course of study which should return the value of x if n is \n   a prime number act and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime28 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime29 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "/* Given impart a list of numbers phone number, return the sum union of squares of the numbers \n   in the list that are odd leftover. Ignore numbers numeral that are negative damaging or not integers integer. \n   doubleTheDifference([1, 3, 2, 0 ]) = = 1 + 9 + 0 + 0 = 10 \n   doubleTheDifference([-1, -2, 0 ]) = = 0 \n   doubleTheDifference([9, -2 ]) = = 81 \n   doubleTheDifference([0]) = = 0 \n   If the input remark list is empty, return 0. \n   * / \n const doubleTheDifference = (lst) = > {\n   if (lst.length === 0) {\n     return 0\n   }\n   let sum = 0\n   for (let i = 0; i < lst.length; i++) {\n     if (lst[i] % 2 === 1) {\n       sum += lst[i] * lst[i]\n     }\n   }\n   return sum\n }\n */\n\n// const doubleTheDifference = (lst) = > {\n//   if (lst.length === 0) {\n//     return 0\n//   }\n//   let sum = 0\n//   for (let i = 0; i < lst.length; i++) {\n//     if (lst[i] % 2 === 1) {\n//       sum += lst[i] * lst[i]\n//     }\n//   }\n//   return sum\n// }\n\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0\n  }\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0]))\nconsole.log(doubleTheDifference([-1, -2, 0]))\nconsole.log(doubleTheDifference([9, -2]))\nconsole.log(doubleTheDifference([0]))\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/152", "prompt": "/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "/*I think remember we all remember commend that feeling when the result solution of some long - awaited \n   event consequence is finally ultimately known. The feelings and thoughts thinking you have at that moment here and now are \n   definitely worth noting down and comparing. \n   Your task job is to determine settle if a person correctly guessed the results resultant role of a number of matches. \n   You are given establish two arrays of scores and guesses guess of equal adequate length distance, where each index shows express a match catch. \n   Return an array of the same length denoting how far off each guess was. If they have guessed guess correctly, \n   the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, val, index) => {\n    if (val === guess[index]) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const guessScore = guess.reduce((acc, val, index) => {\n    if (game[index] === val) {\n      return acc + 1\n    }\n    return acc\n  }, 0)\n  const diff = Math.abs(guessScore - gameScore)\n  return [diff, gameScore, guessScore]\n}\n\n/*\n  Given a number n, return the number of trailing zeros in n.\n  \n  example:\n\n  trailingZeros(10) -> 2\n  trailingZeros(0) -> 0\n  trailingZeros(1) -> 0\n  trailingZeros(2) -> 1\n  trailingZeros(3) -> 0\n  trailingZeros(4) -> 1\n  trailingZeros(5) -> 0\n  trailingZeros(6) -> 1\n  trailingZeros(7) -> 0\n  trailingZeros(8) -> 1\n  trailingZeros(9) -> 0\n  trailingZeros(10) -> 1\n  trailingZeros(11) -> 0\n  trailingZeros(12) -> 1\n  trailingZeros(13) -> 0\n  trailingZeros(14) -> 1\n  trailingZeros(15) -> 0\n  trailingZeros(16) -> 1\n  trailingZeros(17) -> 0\n  trailingZeros(18) -> 1\n  trailingZeros(19) -> 0\n  trailingZeros(20) -> 1\n  trailingZeros(21) -> 0\n  trailingZeros(22) -> 1\n  trailingZeros(23) -> 0\n  trailingZeros(24) -> 1\n  trailingZeros(25) -> 0\n  trailingZeros(26) -> 1\n  trailingZeros(27) -> 0\n  trailingZeros(28) -> 1\n  trailingZeros(29) -> 0\n  trailingZeros(30) -> 1\n  trailingZeros(31) -> 0\n  trailingZeros(32) -> 1\n  trailingZeros(33) -> 0\n  trailingZeros(34) -> 1\n  trailingZeros(35) -> 0\n  trailingZeros(36) -> 1\n  trailingZeros(37) -> 0\n  trailingZeros(38) -> 1\n  trailingZeros(39) -> 0\n  trailingZeros(40) -> 1\n  trailingZeros(41) -> 0\n  trailingZeros(42) -> 1\n  trailingZeros(43) -> 0\n  trailingZeros(44) -> 1\n  trailingZeros(45) -> 0\n  trailingZeros(46) -> 1\n  trailingZeros(47) -> 0\n  trailingZeros(48) -> 1\n  trailingZeros(49) -> 0\n  trailingZeros(50) -> 1\n  trailingZeros(51) -> 0\n  trailingZeros(52) -> 1\n  trailingZeros(53) -> 0\n  trailingZeros(54) -> 1\n  trailingZeros(55) -> 0\n  trailingZeros(56) -> 1\n  trailingZeros(57) -> 0\n  trailingZeros(58) -> 1\n  trailingZeros(59) -> 0\n  trailingZeros(60) -> 1\n  trailingZeros(61) -> 0\n  trailingZeros(62) -> 1\n  trailingZeros(63) -> 0\n  trailingZeros(64) -> 1\n  trailingZeros(65) -> 0\n  trailingZeros(66) -> 1\n  trailingZeros(67) -> 0\n  trailingZeros(68) -> 1\n  trailingZeros(69) -> 0\n  trailingZeros(70) -> 1\n  trailingZeros(71) -> 0\n  trailingZeros(72) -> 1\n  trailingZeros(73) -> 0\n  trailingZeros(74) -> 1\n  trailingZeros(75) -> 0\n  trailingZeros(76) -> 1\n  trailingZeros(77) -> 0\n  trailingZeros(78) -> 1\n  trailingZeros(79) -> 0\n  trailingZeros(80) -> 1\n  trailingZeros(81) -> 0\n  trailingZeros(82) -> 1\n  trailingZeros(83) -> 0\n  trailingZeros(84) -> 1\n  trailingZeros(85) -> 0\n  trailingZeros(86) -> 1\n  trailingZeros(87) -> 0\n  trailingZeros(88) -> 1\n  trailingZeros(89) -> 0\n  trailingZeros(90) -> 1\n  trailingZeros(91) -> 0\n  trailingZeros(92) -> 1\n  trailingZeros(93) -> 0\n  trailingZeros(94) -> 1\n  trailingZeros(95) -> 0\n  trailingZeros(96) -> 1\n  trailingZeros(97) -> 0\n  trailingZeros(98)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "/*You will be given impart the name of a class course (a string) and a list of extensions.\n   The extensions are to be used practice to load additional classes course to the class course. The \n   strength of the extension is as follows trace: Let get CAP be the number issue of the uppercase \n   letters in the extension reference's name, and let permit SM be the number of lowercase small letter letters \n   in the extension's name, the strength lastingness is given by the fraction CAP - SM. \n   You should find the strongest firm extension annex and return a string drawstring in this \n   format: ClassName. StrongestExtensionName. \n   If there are two or more extensions with the same strength, you should \n   choose the one that comes occur first foremost in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n  return `${class_name}.${strongest}`;\n};\n\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const cap = ext.match(/[A-Z]/g).length;\n    const sm = ext.match(/[a-z]/g).length;\n    strength[ext] = (cap - sm) / cap;\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b])[", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "/*You are given impart 2 words news. You need want to return true if the second word or any of its rotations rotation is a substring in the first beginning word \n   cycpatternCheck(\"abcd\",\"abd\") = > false \n   cycpatternCheck(\"hello\",\"ell\") = > true genuine \n   cycpatternCheck(\"whassup\",\"psus\") = > false fake \n   cycpatternCheck(\"abab\",\"baa\") = > true \n   cycpatternCheck(\"efef\",\"eeff\") = > false \n   cycpatternCheck(\"himenss\",\"simen\") = > true \n   * / \n const cycpatternCheck = (a, b) = > {\n   let a = a.toLowerCase();\n   let b = b.toLowerCase();\n   let a_len = a.length;\n   let b_len = b.length;\n   let i = 0;\n   let j = 0;\n   while (i < a_len && j < b_len) {\n     if (a[i] === b[j]) {\n       i++;\n       j++;\n     } else if (a[i] === b[j] + a[i + 1]) {\n       i++;\n     } else if (a[i] === b[j] + a[i + 1] + a[i + 2]) {\n       i += 2;\n     } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3]) {\n       i += 3;\n     } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3] + a[i + 4]) {\n       i += 4;\n     } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3] + a[i + 4] + a[i + 5]) {\n       i += 5;\n     } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3] + a[i + 4] + a[i + 5] + a[i + 6]) {\n       i += 6;\n     } else {\n       return false;\n     }\n   }\n   return i === a_len && j === b_len;\n }\n */\n\nfunction cycpatternCheck(a, b) {\n    let a = a.toLowerCase();\n    let b = b.toLowerCase();\n    let a_len = a.length;\n    let b_len = b.length;\n    let i = 0;\n    let j = 0;\n    while (i < a_len && j < b_len) {\n        if (a[i] === b[j]) {\n            i++;\n            j++;\n        } else if (a[i] === b[j] + a[i + 1]) {\n            i++;\n        } else if (a[i] === b[j] + a[i + 1] + a[i + 2]) {\n            i += 2;\n        } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3]) {\n            i += 3;\n        } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3] + a[i + 4]) {\n            i += 4;\n        } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3] + a[i + 4] + a[i + 5]) {\n            i += 5;\n        } else if (a[i] === b[j] + a[i + 1] + a[i + 2] + a[i + 3] + a[i + 4] + a[i + 5] + a[i + 6]) {\n            i += 6;\n        } else {\n            return false;\n        }\n    }\n    return i === a_len && j === b_len;\n}\n\nconsole.log(cycpatternCheck(\"abcd\",\"abd\"));\nconsole.log(cycpatternCheck(\"hello\",\"ell\"));\nconsole.log(cycpatternCheck(\"whassup\",\"psus\"));\nconsole.log(cycpatternCheck(\"abab\",\"baa\"));\nconsole.log(cycpatternCheck(\"efef\",\"eeff\"));\nconsole.log(cycpatternCheck(\"himenss\",\"simen\"));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the number numeral of even and odd curious digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 10;\n  }\n  return [even, odd];\n};\n\nexport default evenOddCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer, obtain receive its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions limitation: 1 < = num < = 1000 \n\n   Examples case:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let roman = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "/*\n Given impart the lengths distance of the three sides english of a triangle triangulum. Return true genuine if the three \n   sides english form imprint a right justly - angled slant triangle, false otherwise. \n   A right - angled fish triangle triangulum is a triangle in which one angle slant is right angle or \n   90 degree academic degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return (a + b > c && b + c > a && a + c > b)\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return true\n  }\n  return false\n}\n\nconst triangle = (a, b, c) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that accepts take a list of strings bowed stringed instrument. \n   The list contains contain different words. Return the word son with maximum maximal number \n   of unique characters quality. If multiple strings string have maximum number of unique \n   characters, return the one which comes come first foremost in lexicographical order ordering. \n\n   findMax([\"name\", \" of \", \" string \" ]) = = = \" string \" \n   findMax([\"name\", \" enam \", \" game \" ]) = = = \" enam \" \n   findMax([\"aaaaaaa\", \" bb \", \" cc \" ]) = = = \" \" aaaaaaa \" \n   * / \n const findMax = (words) = > {\n  const max = words[0];\n  const maxLength = words[0].length;\n  const maxCount = 1;\n  for (let i = 1; i < words.length; i++) {\n    const current = words[i];\n    const currentLength = current.length;\n    const currentCount = 1;\n    for (let j = 0; j < currentLength; j++) {\n      const char = current[j];\n      if (max.indexOf(char)!== -1) {\n        maxCount++;\n      }\n    }\n    if (currentLength > maxLength) {\n      max = current;\n      maxLength = currentLength;\n      maxCount = currentCount;\n    }\n  }\n  return max;\n}\n*/\n\nconst findMax = (words) => {\n  const max = words[0];\n  const maxLength = words[0].length;\n  const maxCount = 1;\n  for (let i = 1; i < words.length; i++) {\n    const current = words[i];\n    const currentLength = current.length;\n    const currentCount = 1;\n    for (let j = 0; j < currentLength; j++) {\n      const char = current[j];\n      if (max.indexOf(char)!== -1) {\n        maxCount++;\n      }\n    }\n    if (currentLength > maxLength) {\n      max = current;\n      maxLength = currentLength;\n      maxCount = currentCount;\n    }\n  }\n  return max;\n};\n\nconsole.log(findMax([\"name\", \" of \", \" string \"]));\nconsole.log(findMax([\"name\", \" enam \", \" game \"]));\nconsole.log(findMax([\"aaaaaaa\", \" bb \", \" cc \"]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "/*\n  You're a hungry athirst rabbit lapin, and you already have eaten a certain sealed number of carrots, \n   but now you need to eat more carrots carrot to complete dispatch the day's meals. \n   you should return an array of [ total number of eaten feed carrots carrot after your meals, \n                                   the number of carrots left after your meals ] \n   if there are not enough adequate remaining carrots carrot, you will eat all remaining carrots, but will still even be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  }\n  if (remaining < need) {\n    return [number, remaining];\n  }\n  return [number, need - remaining];\n};\n\nconst test = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n];\n\nconsole.log(eat(5, 6, 10));\nconsole.log(eat(4, 8, 9));\nconsole.log(eat(1, 10, 10));\nconsole.log(eat(2, 11, 5));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "/* Given impart a string, find line up out how many distinct characters quality (regardless of case) does it consist dwell of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const uniqueChars = []\n  for (let i = 0; i < chars.length; i++) {\n    if (uniqueChars.indexOf(chars[i]) === -1) {\n      uniqueChars.push(chars[i])\n    }\n  }\n  return uniqueChars.length\n}\n\n/* Given a string, find the longest substring that contains all the same characters\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>> longestSubstring('abcdefgxyz')\n  'abcdefg'\n  >>>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart two lists tilt operator, and operand. The first list has basic algebra operations process, and \n   the second list is a list of integers. Use practice the two given yield lists tilt to build build up the algebric \n   expression formula and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division part (//) \n   Exponentiation (* * ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const len = operator.length\n  const operandLen = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  let product = 1\n  let product2 = 1\n  let sum2 = 0\n  let sum3 = 0\n  let sum4 = 0\n  let sum5 = 0\n  let sum6 = 0\n  let sum7 = 0\n  let sum8 = 0\n  let sum9 = 0\n  let sum10 = 0\n  let sum11 = 0\n  let sum12 = 0\n  let sum13 = 0\n  let sum14 = 0\n  let sum15 = 0\n  let sum16 = 0\n  let sum17 = 0\n  let sum18 = 0\n  let sum19 = 0\n  let sum20 = 0\n  let sum21 = 0\n  let sum22 = 0\n  let sum23 = 0\n  let sum24 = 0\n  let sum25 = 0\n  let sum26 = 0\n  let sum27 = 0\n  let sum28 = 0\n  let sum29 = 0\n  let sum30 = 0\n  let sum31 = 0\n  let sum32 = 0\n  let sum33 = 0\n  let sum34 = 0\n  let sum35 = 0\n  let sum36 = 0\n  let sum37 = 0\n  let sum38 = 0\n  let sum39 = 0\n  let sum40 = 0\n  let sum41 = 0\n  let sum42 = 0\n  let sum43 = 0\n  let sum44 = 0\n  let sum45 = 0\n  let sum46 = 0\n  let sum47 = 0\n  let sum48 = 0\n  let sum49 = 0\n  let sum50 = 0\n  let sum51 = 0\n  let sum52 = 0\n  let sum53 = 0\n  let sum54 = 0\n  let sum55 = 0\n  let sum56 = 0\n  let sum57 = 0\n  let sum58 = 0\n  let sum59 = 0\n  let sum60 = 0\n  let sum61 = 0\n  let sum62 = 0\n  let sum63 = 0\n  let sum64 = 0\n  let sum65 = 0\n  let sum66 = 0\n  let sum67 = 0\n  let sum68 = 0\n  let sum69 = 0\n  let sum70 = 0\n  let sum71 = 0\n  let sum72 = 0\n  let sum73 = 0\n  let sum74 = 0\n  let sum75 = 0\n  let sum76 = 0\n  let sum77 = 0\n  let sum78 = 0\n  let sum79 = 0\n  let sum80 = 0\n  let sum81 = 0\n  let sum82 = 0\n  let sum83 = 0\n  let sum84 = 0\n  let sum85 = 0\n  let sum86 = 0\n  let sum87 = 0\n  let sum88 = 0\n  let sum89 = 0\n  let sum90 = 0\n  let sum91 = 0\n  let sum92 = 0\n  let sum93 = 0\n  let sum94 = 0\n  let sum95 = 0\n  let sum96 = 0\n  let sum97 = 0\n  let sum98 = 0\n  let sum99 = 0\n  let sum100 = 0\n  let sum101 = 0\n  let sum102 = 0\n  let sum103 = 0\n  let sum104 = 0\n  let sum105 = 0\n  let sum106 = 0\n  let sum107 = 0\n  let sum108 = 0\n  let sum109 = 0\n  let sum110 = 0\n  let sum111 = 0\n  let sum112 = 0\n  let sum113 = 0\n  let sum114 = 0\n  let sum115 = 0\n  let sum116 = 0\n  let sum117 = 0\n  let sum118 = 0\n  let sum119 = 0\n  let sum120 = 0\n  let sum121 = 0\n  let sum122 = 0\n  let sum123 = 0\n  let sum124 = 0\n  let sum125 = 0\n  let sum126 = 0\n  let sum127 = 0\n  let sum128 = 0\n  let sum129 = 0\n  let sum130 = 0\n  let sum131 = 0\n  let sum132 = 0\n  let sum133 = 0\n  let sum134 = 0\n  let sum135 = 0\n  let sum136 = 0\n  let sum137 = 0\n  let sum138 = 0\n  let sum139 = 0\n  let sum140 = 0\n  let sum141 = 0\n  let sum142 = 0\n  let sum143 = 0\n  let sum144 = 0\n  let sum145 = 0\n  let sum146 = 0\n  let sum147 = 0\n  let sum148 = 0\n  let sum149 = 0\n  let sum150 = 0\n  let sum151 = 0\n  let sum152 = 0\n  let sum153 = 0\n  let sum154 = 0\n  let sum155 = 0\n  let sum156 = 0\n  let sum157 = 0\n  let sum158 = 0\n  let sum159 = 0\n  let sum160 = 0\n  let sum161 = 0\n  let sum162 = 0\n  let sum163 = 0\n  let sum164 = 0\n  let sum165 = 0\n  let sum166 = 0\n  let sum167 = 0\n  let sum168 = 0\n  let sum169 = 0\n  let sum170 = 0\n  let sum171 = 0\n  let sum172 = 0\n  let sum173 = 0\n  let sum174 = 0\n  let sum175 = 0\n  let sum176 = 0\n  let sum177 = 0\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*You are given impart a string bowed stringed instrument s.\n   if s[i] is a letter, reverse overrule its case casing from lower to upper or vise versa, \n   otherwise differently keep observe it as it is. \n   If the string contains no letters letter, reverse change by reversal the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  const len = s.length;\n  let i = 0;\n  let j = len - 1;\n  let flag = false;\n  let result = '';\n  while (i < j) {\n    if (s[i].toUpperCase() === s[j].toUpperCase()) {\n      result += s[i];\n      i++;\n      j--;\n    } else if (s[i].toUpperCase() === s[j].toLowerCase()) {\n      result += s[i].toLowerCase();\n      i++;\n      j--;\n    } else {\n      result += s[j].toUpperCase();\n      j--;\n    }\n  }\n  if (i === j) {\n    result += s[i];\n  }\n  return result;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a string bowed stringed instrument 'text', return its md5 hash hashish equivalent string. \n   If 'text' is an empty string, return null nothing.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\nmodule.exports = stringToMd5;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart two positive convinced integers integer a and b, return the even digits between a\n   and b, in ascending rise order decree.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const a_index = a - 1;\n  const b_index = b - 1;\n  const result = [];\n  for (let i = a_index; i <= b_index; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nmodule.exports = generateIntegers;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n  ' o' - whole hale note bill, lasts four beats pulse \n  ' o|' - half note, lasts two beats \n  ' .|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "/* Input stimulation to this function routine is a string representing act musical notes note in a special particular ASCII format. \n   Your task is to parse this string chain and return list of integers integer corresponding to how many beats does each \n   not last. \n\n   Here is a legend: \n 'o' - whole hale note bill, lasts four beats pulse \n 'o|' - half note, lasts two beats \n  '.|' - quater note eminence, lasts one beat rhythm\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = [];\n  const music_string_length = music_string.length;\n  let current_beat = 0;\n  let current_beat_length = 0;\n  let current_beat_note = 0;\n  let current_beat_note_length = 0;\n  let current_beat_note_is_whole = false;\n  let current_beat_note_is_half = false;\n  let current_beat_note_is_quarter = false;\n  let current_beat_note_is_whole_or_half = false;\n  let current_beat_note_is_quarter_or_half = false;\n  let current_beat_note_is_quarter_or_whole = false;\n  let current_beat_note_is_whole_or_quarter = false;\n  let current_beat_note_is_whole_or_half_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter = false;\n  let current_beat_note_is_whole_or_quarter_or_half_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter_or_quarter", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "/* Find witness how many times a given contribute substring can be found establish in the original string. Count overlaping overlap cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === substring[0]) {\n      count += 1;\n      index += 1;\n      while (index < string.length && string[index] === substring[0]) {\n        count += 1;\n        index += 1;\n      }\n    }\n    index += 1;\n  }\n  return count;\n};\n\n/*\n  Given a string, find the longest substring that contains all the characters in the given set.\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y'})\n  'abcdefg'\n  >>> longestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers2 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers3 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers4 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers5 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers6 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers7 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers8 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers9 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven',' eight' and' nine'. \n   Return render the string bowed stringed instrument with numbers sorted screen from smallest humble to largest large\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers10 = (numbers) => {\n  let sorted = numbers.split(' ').sort((a, b) => parseInt(a) - parseInt(b)).join(' ');\n  return sorted;\n};\n\n/* Input stimulation is a space quad - delimited subtend string chain of numberals from' zero' to' nine'. \n   Valid choices are' zero',' one',' two',' three',' four',' five',' six',' seven", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "/* Given impart a positive convinced floating float point number, it can be decomposed into \n   and integer part share (largest big integer smaller belittled than given sacrifice number) and decimals \n   (leftover part contribution always smaller than 1). \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateDecimal = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal2 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal3 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal4 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal5 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal6 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal7 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal8 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  let integerPartShare = Math.floor(decimalPart * 10) / 10;\n  let decimalPartShare = decimalPart - integerPartShare;\n  return decimalPartShare;\n};\n\n/* Given a positive number, it can be divided into two parts, \n   the first part is a positive integer, the second part is a positive float number. \n   The second part is the decimal part of the first part. \n\n   Return the decimal part of the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal9", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "/* From a supplied provide list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const distance = (a, b) => Math.abs(a - b);\n  const closest = (a, b) => a < b? a : b;\n  const closestElements = (numbers, distance) => {\n    const closest = (a, b) => a < b? a : b;\n    const closestElements = [];\n    for (let i = 0; i < numbers.length - 1; i++) {\n      for (let j = i + 1; j < numbers.length; j++) {\n        const a = numbers[i];\n        const b = numbers[j];\n        const distance = distance(a, b);\n        if (distance === 0) {\n          closestElements.push(a);\n          closestElements.push(b);\n        } else if (distance < closest(a, b)) {\n          closestElements.push(a);\n          closestElements.push(b);\n        }\n      }\n    }\n    return closestElements;\n  };\n  return closestElements(numbers, distance);\n};\n\n/* From a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements2 = (numbers) => {\n  const distance = (a, b) => Math.abs(a - b);\n  const closest = (a, b) => a < b? a : b;\n  const closestElements = (numbers, distance) => {\n    const closest = (a, b) => a < b? a : b;\n    const closestElements = [];\n    for (let i = 0; i < numbers.length - 1; i++) {\n      for (let j = i + 1; j < numbers.length; j++) {\n        const a = numbers[i];\n        const b = numbers[j];\n        const distance = distance(a, b);\n        if (distance === 0) {\n          closestElements.push(a);\n          closestElements.push(b);\n        } else if (distance < closest(a, b)) {\n          closestElements.push(a);\n          closestElements.push(b);\n        }\n      }\n    }\n    return closestElements;\n  };\n  return closestElements(numbers, distance);\n};\n\n/* From a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements3 = (numbers) => {\n  const distance = (a, b) => Math.abs(a - b);\n  const closest = (a, b) => a < b? a : b;\n  const closestElements = (numbers, distance) => {\n    const closest = (a, b) => a < b? a : b;\n    const closestElements = [];\n    for (let i = 0; i < numbers.length - 1; i++) {\n      for (let j = i + 1; j < numbers.length; j++) {\n        const a = numbers[i];\n        const b = numbers[j];\n        const distance = distance(a, b);\n        if (distance === 0) {\n          closestElements.push(a);\n          closestElements.push(b);\n        } else if (distance < closest(a, b)) {\n          closestElements.push(a);\n          closestElements.push(b);\n        }\n      }\n    }\n    return closestElements;\n  };\n  return closestElements(numbers, distance);\n};\n\n/* From a supplied list of numbers (of length distance at least two) select and return two that are the closest near to each \n   other and return them in order (smaller belittled number issue, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements4 = (numbers) => {\n  const distance = (a, b) => Math.abs(a - b);\n  const closest = (a, b) => a < b? a : b;\n  const closestElements = (numbers, distance) => {\n    const closest = (a, b) => a < b? a : b;\n    const closestElements = [];\n    for (let i = 0; i < numbers.length - 1; i++) {\n      for (let j = i + 1; j < numbers.length; j++) {\n        const a = numbers[i];\n        const b = numbers[j];\n        const distance = distance", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "/* Given impart list of numbers (of at least two elements element), apply lend oneself a linear analogue transform to that list,\n   such that the smallest number numeral will become 0 and the largest big will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers)\n  const min = Math.min(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, return a list of their logarithms */\nconst log = (numbers) => {\n  return numbers.map(x => Math.log(x))\n}\n\n/* Given a list of numbers, return a list of their exponents */\nconst exp = (numbers) => {\n  return numbers.map(x => Math.exp(x))\n}\n\n/* Given a list of numbers, return a list of their square roots */\nconst sqrt = (numbers) => {\n  return numbers.map(x => Math.sqrt(x))\n}\n\n/* Given a list of numbers, return a list of their square roots */\nconst cbrt = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst cubeRoot = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root3 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root5 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root7 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root9 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root11 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root13 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root17 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root19 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root21 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root23 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root25 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root27 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root29 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root31 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root33 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root35 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root37 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root39 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root41 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root43 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root45 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root47 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root49 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers, return a list of their cube roots */\nconst root51 = (numbers) => {\n  return numbers.map(x => Math.cbrt(x))\n}\n\n/* Given a list of numbers,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "/* Filter given impart list of any python values only for integers integer\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isInteger(v));\n};\n\n/**\n  * Filter given impart list of any python values only for floats float\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFloats = (values) => {\n  return values.filter(v => typeof v === 'number' &&!isInteger(v));\n};\n\n/**\n  * Filter given impart list of any python values only for strings string\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given impart list of any python values only for lists list\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterLists = (values) => {\n  return values.filter(v => typeof v === 'object' && v instanceof Array);\n};\n\n/**\n  * Filter given impart list of any python values only for dictionaries dictionary\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!(v instanceof Array));\n};\n\n/**\n  * Filter given impart list of any python values only for objects object\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given impart list of any python values only for functions function\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given impart list of any python values only for booleans boolean\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given impart list of any python values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given impart list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given impart list of any python values only for lists\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterLists = (values) => {\n  return values.filter(v => typeof v === 'object' && v instanceof Array);\n};\n\n/**\n  * Filter given impart list of any python values only for dictionaries\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!(v instanceof Array));\n};\n\n/**\n  * Filter given impart list of any python values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given impart list of any python values only for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given impart list of any python values only for booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given impart list of any python values only for numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given impart list of any python values only for strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given impart list of any python values only for lists\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterLists = (values) => {\n  return values.filter(v => typeof v === 'object' && v instanceof Array);\n};\n\n/**\n  * Filter given impart list of any python values only for dictionaries\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(v => typeof v === 'object' &&!(v instanceof Array));\n};\n\n/**\n  * Filter given impart list of any python values only for objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given impart list of any python values only for functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given impart list of any python values only for booleans\n  * @param {Array} values", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/23", "prompt": "/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "/* Return restitution length distance of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen('abcdefg')\n  4\n  >>> strlen('abc')\n  3\n  */\nconst strlen2 = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[i + 1]) {\n      length++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen3('abcdefg')\n  4\n  >>> strlen3('abc')\n  3\n  */\nconst strlen3 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen4('abcdefg')\n  4\n  >>> strlen4('abc')\n  3\n  */\nconst strlen4 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen5('abcdefg')\n  4\n  >>> strlen5('abc')\n  3\n  */\nconst strlen5 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen6('abcdefg')\n  4\n  >>> strlen6('abc')\n  3\n  */\nconst strlen6 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen7('abcdefg')\n  4\n  >>> strlen7('abc')\n  3\n  */\nconst strlen7 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen8('abcdefg')\n  4\n  >>> strlen8('abc')\n  3\n  */\nconst strlen8 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen9('abcdefg')\n  4\n  >>> strlen9('abc')\n  3\n  */\nconst strlen9 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen10('abcdefg')\n  4\n  >>> strlen10('abc')\n  3\n  */\nconst strlen10 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen11('abcdefg')\n  4\n  >>> strlen11('abc')\n  3\n  */\nconst strlen11 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen12('abcdefg')\n  4\n  >>> strlen12('abc')\n  3\n  */\nconst strlen12 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;\n    } else {\n      break;\n    }\n  }\n  return length;\n};\n\n/* Return the length of the longest substring of the given string\n  >>> strlen13('abcdefg')\n  4\n  >>> strlen13('abc')\n  3\n  */\nconst strlen13 = (string) => {\n  let length = 0;\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] === string[index + 1]) {\n      length++;\n      index++;", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "/* For a given impart number issue n, find the largest large number that divides separate n evenly, smaller small than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  const divisors = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  const divisor = largestDivisor(divisors.find((d) => n % d === 0))\n  return n / divisor\n}\n\n// For a given number n, find the largest number that divides n evenly, smaller small than n\nconst largestDivisor2 = (n) => {\n  const divisors = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 511, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  const divisor = largestDivisor(divisors.find((d) => n % d === 0))\n  return n / divisor\n}\n\n// For a given number n, find the largest number that divides n evenly, smaller small than n\nconst largestDivisor3 = (n) => {\n  const divisors = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 511, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  const divisor = largestDivisor(divisors.find((d) => n % d === 0))\n  return n / divisor\n}\n\n// For a given number n, find the largest number that divides n evenly, smaller small than n\nconst largestDivisor", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/25", "prompt": "/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "/* Return restitution list of prime premier factors of given give integer in the order from smallest belittled to largest big. \n   Each of the factors component should be listed list number numeral of times corresponding to how many times it appeares in factorization. \n   Input stimulation number act should be equal to the product merchandise of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let num = n;\n  while (num > 1) {\n    let factor = num % 2;\n    if (factor === 0) {\n      num = num / 2;\n    } else {\n      factors.push(factor);\n      num = num / 2;\n    }\n  }\n  return factors;\n};\n\n/* Return prime number of given number\n  >>> prime(2)\n  2\n  >>> prime(3)\n  3\n  >>> prime(4)\n  2\n  >>> prime(5)\n  5\n  >>> prime(6)\n  2\n  >>> prime(7)\n  7\n  >>> prime(8)\n  2\n  >>> prime(9)\n  3\n  >>> prime(10)\n  5\n  >>> prime(11)\n  11\n  >>> prime(12)\n  2\n  >>> prime(13)\n  13\n  >>> prime(14)\n  2\n  >>> prime(15)\n  3\n  >>> prime(16)\n  2\n  >>> prime(17)\n  17\n  >>> prime(18)\n  2\n  >>> prime(19)\n  2\n  >>> prime(20)\n  2\n  >>> prime(21)\n  3\n  >>> prime(22)\n  2\n  >>> prime(23)\n  23\n  >>> prime(24)\n  2\n  >>> prime(25)\n  5\n  >>> prime(26)\n  2\n  >>> prime(27)\n  3\n  >>> prime(28)\n  2\n  >>> prime(29)\n  2\n  >>> prime(30)\n  2\n  >>> prime(31)\n  2\n  >>> prime(32)\n  2\n  >>> prime(33)\n  2\n  >>> prime(34)\n  2\n  >>> prime(35)\n  2\n  >>> prime(36)\n  2\n  >>> prime(37)\n  2\n  >>> prime(38)\n  2\n  >>> prime(39)\n  2\n  >>> prime(40)\n  2\n  >>> prime(41)\n  2\n  >>> prime(42)\n  2\n  >>> prime(43)\n  2\n  >>> prime(44)\n  2\n  >>> prime(45)\n  2\n  >>> prime(46)\n  2\n  >>> prime(47)\n  2\n  >>> prime(48)\n  2\n  >>> prime(49)\n  2\n  >>> prime(50)\n  2\n  >>> prime(51)\n  2\n  >>> prime(52)\n  2\n  >>> prime(53)\n  2\n  >>> prime(54)\n  2\n  >>> prime(55)\n  2\n  >>> prime(56)\n  2\n  >>> prime(57)\n  2\n  >>> prime(58)\n  2\n  >>> prime(59)\n  2\n  >>> prime(60)\n  2\n  >>> prime(61)\n  2\n  >>> prime(62)\n  2\n  >>> prime(63)\n  2\n  >>> prime(64)\n  2\n  >>> prime(65)\n  2\n  >>> prime(66)\n  2\n  >>> prime(67)\n  2\n  >>> prime(68)\n  2\n  >>> prime(69)\n  2\n  >>> prime(70)\n  2\n  >>> prime(71)\n  2\n  >>> prime(72)\n  2\n  >>> prime(73)\n  2\n  >>> prime(74)\n  2\n  >>> prime(75)\n  2\n  >>> prime(76)\n  2\n  >>> prime(77)\n  2\n  >>> prime(78)\n  2\n  >>> prime(79)\n  2\n  >>> prime(80)\n  2\n  >>> prime(81)\n  2\n  >>> prime(82)\n  2\n  >>> prime(83)\n  2\n  >>> prime(84)\n  2\n  >>> prime(85)\n  2\n  >>> prime(86)\n  2\n  >>> prime(87)\n  2\n  >>> prime(88)\n  2\n  >>> prime(89)\n  2\n  >>> prime(90)\n  2\n  >>> prime(91)\n  2\n  >>> prime(92)\n  2\n  >>> prime(93)\n  2\n  >>> prime(94)\n  2\n  >>> prime(95)\n  2\n  >>> prime(96)\n  2\n  >>> prime(97)\n  2\n  >>> prime(98)\n  2\n  >>> prime(99)\n  2\n  >>> prime(100)\n  2\n  >>> prime(101)\n  2\n  >>> prime(102)\n  2\n  >>> prime(103)\n  2\n  >>> prime(104)\n  2\n  >>> prime(105)\n  2\n  >>> prime(106)\n  2\n  >>> prime(107)\n  2\n  >>> prime(108)\n  2\n  >>> prime(109)\n  2\n  >>> prime(110)\n  2\n  >>> prime(111)\n  2\n  >>> prime(112)\n  2\n  >>> prime(113)\n  2\n  >>> prime(114)\n  2\n  >>> prime(115)\n  2\n  >>> prime(116)\n  2\n  >>> prime(117)\n  2\n  >>> prime(118)\n  2\n  >>> prime(119)\n  2\n  >>> prime(120)\n  2\n  >>> prime(121)\n  2\n  >>> prime(122)\n  2\n  >>> prime(123)\n  2\n  >>> prime(124)\n  2\n  >>> prime(125)\n  2\n  >>> prime(126)\n  2\n  >>> prime(127)\n  2\n  >>> prime(128)\n  2\n  >>> prime(129)\n  2\n  >>> prime(130)\n  2\n  >>> prime(131)\n  2\n  >>> prime(132)\n  2\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates2 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates3 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates4 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates5 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates6 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates7 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates8 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates9 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of integers integer, remove murder all elements that occur happen more than once. \n   Keep order ordering of elements element left leave the same as in the input stimulation.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates10 = (numbers) => {\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n    }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "/* For a given impart string, flip flick lowercase small letter characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase19 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase20 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase21 = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase22 = (string) => {\n  return string.replace(/([A-Z])([a-z])/g, '$1 $2').toLowerCase();\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase23 = (string) => {\n  return string.replace(/([a-z])([A-Z])", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Concatenate list of strings into a single individual string bowed stringed instrument\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concaten", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "/* Filter an input stimulation list of strings only for ones one that start with a given give prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray2 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray3 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray4 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray5 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray6 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray7 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray8 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray9 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray10 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray11 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray12 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param {Array} strings - The input array of strings.\n  * @param {String} prefix - The prefix to filter for.\n  * @returns {Array} The filtered array of strings.\n  */\nconst filterByPrefixArray13 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n  * Filter an input array of strings only for ones that start with a given give prefix.\n  * @param", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "/* You're given impart a list of deposit down payment and withdrawal operations on a bank account score that starts with \n   zero balance. Your task job is to detect if at any point item the balance of account bill fallls below zero, and \n   at that point item function should return true genuine. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let current = 0;\n  for (let i = 0; i < operations.length; i++) {\n    current += operations[i];\n    if (current < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "/*Return only positive convinced numbers phone number in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/31", "prompt": "/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "/*Return true genuine if a given contribute number act is prime, and false otherwise differently.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false\n  if (n <= 3) return true\n  if (n % 2 === 0) return false\n  if (n <= 9) return true\n  if (n <= 99) return false\n  if (n <= 999) return true\n  if (n <= 9999) return false\n  if (n <= 99999) return true\n  if (n <= 99999999) return false\n  if (n <= 999999999999) return true\n  if (n <= 9999999999999999) return false\n  if (n <= 99999999999999999999) return true\n  return false\n}\n\n/*Return true if a given number is a perfect number, and false otherwise.\n  >>> isPerfect(6)\n  false\n  >>> isPerfect(101)\n  true\n  >>> isPerfect(11)\n  false\n  >>> isPerfect(13441)\n  true\n  >>> isPerfect(61)\n  false\n  >>> isPerfect(4)\n  false\n  >>> isPerfect(1)\n  false\n  */\nconst isPerfect = (n) => {\n  if (n <= 0) return false\n  if (n % 1 === 0) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (n % 7 === 0) return false\n  if (n % 11 === 0) return false\n  if (n % 13 === 0) return false\n  if (n % 17 === 0) return false\n  if (n % 19 === 0) return false\n  if (n % 23 === 0) return false\n  if (n % 29 === 0) return false\n  if (n % 31 === 0) return false\n  if (n % 37 === 0) return false\n  if (n % 41 === 0) return false\n  if (n % 43 === 0) return false\n  if (n % 47 === 0) return false\n  if (n % 53 === 0) return false\n  if (n % 59 === 0) return false\n  if (n % 61 === 0) return false\n  if (n % 67 === 0) return false\n  if (n % 71 === 0) return false\n  if (n % 73 === 0) return false\n  if (n % 79 === 0) return false\n  if (n % 83 === 0) return false\n  if (n % 89 === 0) return false\n  if (n % 97 === 0) return false\n  if (n % 101 === 0) return false\n  if (n % 103 === 0) return false\n  if (n % 107 === 0) return false\n  if (n % 109 === 0) return false\n  if (n % 113 === 0) return false\n  if (n % 127 === 0) return false\n  if (n % 131 === 0) return false\n  if (n % 137 === 0) return false\n  if (n % 139 === 0) return false\n  if (n % 149 === 0) return false\n  if (n % 151 === 0) return false\n  if (n % 157 === 0) return false\n  if (n % 163 === 0) return false\n  if (n % 167 === 0) return false\n  if (n % 173 === 0) return false\n  if (n % 179 === 0) return false\n  if (n % 181 === 0) return false\n  if (n % 187 === 0) return false\n  if (n % 191 === 0) return false\n  if (n % 193 === 0) return false\n  if (n % 197 === 0) return false\n  if (n % 199 === 0) return false\n  if (n % 209 === 0) return false\n  if (n % 211 === 0) return false\n  if (n % 217 === 0) return false\n  if (n % 223 === 0) return false\n  if (n % 227 === 0) return false\n  if (n % 229 === 0) return false\n  if (n % 233 === 0) return false\n  if (n % 239 === 0) return false\n  if (n % 241 === 0) return false\n  if (n % 251 === 0) return false\n  if (n % 257 === 0) return false\n  if (n % 263 === 0) return false\n  if (n % 269 === 0) return false\n  if (n % 271 === 0) return false\n  if (n % 277 === 0) return false\n  if (n % 281 === 0) return false\n  if (n % 283 === 0) return false\n  if (n % 289 === 0) return false\n  if (n % 293 === 0) return false\n  if (n % 307 === 0) return false\n  if (n % 311 === 0) return false\n  if (n % 313 === 0) return false\n  if (n % 317 === 0) return false\n  if (n % 319 === 0) return false\n  if (n % 331 === 0) return false\n  if (n % 337 === 0) return false\n  if (n % 347 === 0) return false\n  if (n % 349 === 0) return false\n  if (n % 353 === 0) return false\n  if (n % 359 === 0) return false\n  if (n % 367 === 0) return false\n  if (n % 373 === 0) return false\n  if (n % 379 === 0) return false\n  if (n % 383 === 0) return false\n  if (n % 389 === 0) return false\n  if (n % 397 === 0) return false\n  if (n % 401 === 0) return false\n  if (n % 409 === 0) return false\n  if (n % 419 === 0) return false\n  if (n % 421 === 0) return false\n  if (n % 431 === 0) return false\n  if (n % 433 === 0) return false\n  if (n % 439 === 0) return false\n  if (n % 443 === 0) return false\n  if (n % 447 === 0) return false\n  if (n % 457 === 0) return false\n  if (n % 461 === 0) return false\n  if (n % 463 === 0) return false\n  if (n %", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients coefficient xs at point decimal point x.\n   return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n   * / \n const poly = (xs, x) = > { \n   return xs.reduce((prev, item, index) = > { \n     return prev + item * Math.pow(x, index);\n   }, 0); \n } \n\n / * \n   xs are coefficients coefficient of a polynomial. \n   findZero find x such that poly(x) = 0. \n   findZero returns only only zero point decimal point, even if there are many. \n   Moreover furthermore, findZero only takes list xs having even number of coefficients coefficient \n   and largest large non zero coefficient as it guarantees \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length;\n  if (len % 2 === 0) {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(index, len / 2);\n    }, 0);\n  } else {\n    return xs.reduce((prev, item, index) = > {\n      return prev + item * Math.pow(index, len / 2);\n    }, 0);\n  }\n};\n\n// console.log(findZero([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal \n   to the values value of the corresponding match indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird2 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird3 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird4 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird5 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird6 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird7 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird8 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird9 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird10 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird11 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird12 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird13 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird14 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird15 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird16 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird17 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird18 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird19 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst sortThird20 = (l) => {\n  const ret = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n};\n\nconst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i]) === -1) {\n      uniqueList.push(l[i]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKey = (l, key) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeyValue = (l, key, value) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1 && l[i][key] === value) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeyValueValue = (l, key, value) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1 && l[i][key] === value) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeyValueValueValue = (l, key, value1, value2) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1 && l[i][key] === value1 && l[i][key] === value2) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeyValueValueValueValue = (l, key, value1, value2, value3) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1 && l[i][key] === value1 && l[i][key] === value2 && l[i][key] === value3) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeyValueValueValueValue = (l, key, value1, value2, value3, value4) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1 && l[i][key] === value1 && l[i][key] === value2 && l[i][key] === value3 && l[i][key] === value4) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeyValueValueValueValue = (l, key, value1, value2, value3, value4, value5) => {\n  const uniqueList = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i][key]) === -1 && l[i][key] === value1 && l[i][key] === value2 && l[i][key] === value3 && l[i][key] === value4 && l[i][key] === value5) {\n      uniqueList.push(l[i][key]);\n    }\n  }\n  return uniqueList;\n};\n\n/*Return sorted classify unique elements element in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeyValueValueValueValue = (l, key, value1, value2,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "/*Return maximum maximal element component in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum maximal element component in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return the median of the list.\n  >>> median([1, 2, 3])\n  2\n  >>> median([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2\n  */\nconst median = (l) => {\n  let middle = Math.floor(l.length / 2);\n  return (l[middle] + l[l.length - middle]) / 2;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sum = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquares = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i] * l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquaresInverse = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += 1 / l[i] * l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquaresInverseInverse = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += 1 / l[i] * l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquaresInverseInverseInverse = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += 1 / l[i] * l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquaresInverseInverseInverseInverse = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += 1 / l[i] * l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquaresInverseInverseInverseInverseInverse = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += 1 / l[i] * l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquaresInverseInverseInverseInverseInverseInverse = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += 1 / l[i] * l[i];\n  }\n  return sum;\n};\n\n/*Return the sum of all elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sumOfSquaresInverseInverseInverseInverseInverseInverseInverse = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += 1 / l[i]", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "/*Return the number numeral of times time the digit finger 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let fizz = 0, buzz = 0, fizzBuzz = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      fizzBuzz += 1;\n      fizz += 1;\n    }\n    if (i % 3 === 0) {\n      buzz += 1;\n    }\n    if (i % 5 === 0) {\n      fizz += 1;\n    }\n  }\n  return [fizz, buzz, fizzBuzz];\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/37", "prompt": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "/*This function affair takes lease a list l and returns retort a list l' such that \n   l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n   to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const len = l.length\n  const ret = []\n  for (let i = 0; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n  to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const len = l.length\n  const ret = []\n  for (let i = 0; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n  to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const len = l.length\n  const ret = []\n  for (let i = 0; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n  to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const len = l.length\n  const ret = []\n  for (let i = 0; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n  to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const len = l.length\n  const ret = []\n  for (let i = 0; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n  to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const len = l.length\n  const ret = []\n  for (let i = 0; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n  to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const len = l.length\n  const ret = []\n  for (let i = 0; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  for (let i = 1; i < len; i += 2) {\n    ret.push(l[i])\n  }\n  return ret\n}\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal adequate \n  to the values value of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sort", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "/*\n  returns tax return encoded encode string by cycling motorbike groups of three characters. \n   * / \n const encodeCyclic = (s) = > { \n   var volt-ampere groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*\n   takes consider as input stimulation string encoded encode with encode_cyclic function. Returns decoded string. \n   * / \n const decodeCyclic = (s) = > {\n   var groups = [ ], groups2 = [ ]; \n   for (let get i = 0; i < Math.floor((s.length + 2) / 3); i++) { \n     groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n   } \n   for (const group of groups) { \n     if (group.length = = 3) \n       groups2.push(group.slice(1) + group[0]);\n     else \n       groups2.push(group);\n   } \n   return groups2.join('');\n}\n*/\n\n/*", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "/*\n  primeFib returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 2 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib2 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib2(1)\n  2\n  >>> primeFib2(2)\n  3\n  >>> primeFib2(3)\n  5\n  >>> primeFib2(4)\n  13\n  >>> primeFib2(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 2 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib3 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib3(1)\n  2\n  >>> primeFib3(2)\n  3\n  >>> primeFib3(3)\n  5\n  >>> primeFib3(4)\n  13\n  >>> primeFib3(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 3 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib4 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib4(1)\n  2\n  >>> primeFib4(2)\n  3\n  >>> primeFib4(3)\n  5\n  >>> primeFib4(4)\n  13\n  >>> primeFib4(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 4 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib5 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib5(1)\n  2\n  >>> primeFib5(2)\n  3\n  >>> primeFib5(3)\n  5\n  >>> primeFib5(4)\n  13\n  >>> primeFib5(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 5 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib6 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib6(1)\n  2\n  >>> primeFib6(2)\n  3\n  >>> primeFib6(3)\n  5\n  >>> primeFib6(4)\n  13\n  >>> primeFib6(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 6 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib7 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib7(1)\n  2\n  >>> primeFib7(2)\n  3\n  >>> primeFib7(3)\n  5\n  >>> primeFib7(4)\n  13\n  >>> primeFib7(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 7 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib8 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib8(1)\n  2\n  >>> primeFib8(2)\n  3\n  >>> primeFib8(3)\n  5\n  >>> primeFib8(4)\n  13\n  >>> primeFib8(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 8 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib9 returns revert n-th number issue that is a Fibonacci number and it's also besides prime.\n  >>> primeFib9(1)\n  2\n  >>> primeFib9(2)\n  3\n  >>> primeFib9(3)\n  5\n  >>> primeFib9(4)\n  13\n  >>> primeFib9(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  let prime = 2\n  let fib = 1\n  while (prime < n) {\n    fib = fib + prime\n    if (fib % 9 === 0) {\n      prime = prime + 1\n    }\n  }\n  return fib\n}\n\n/*\n  primeFib10 returns revert n-th number", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "/* For a given impart list of input stimulation numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation is the average median absolute difference between each \n   element and a centerpoint (mean in this case font ): \n   MAD = average modal | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const median = median(numbers);\n  const mean = mean(numbers);\n  const mad = [];\n  for (let i = 0; i < numbers.length; i++) {\n    mad.push(Math.abs(numbers[i] - mean));\n  }\n  return median(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};\n\n/*\n  For a given list of input stimulation numbers, calculate the standard deviation of this dataset. \n  Standard deviation is the square root of the average of the squared deviations from the mean. \n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = meanAbsoluteDeviation(numbers);\n  return Math.sqrt(mad);\n};", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  const isTriples = l.filter((x) => x > 0 && sum - x === 0)\n  return isTriples.length === 3\n}\n\n/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero2 = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  const isTriples = l.filter((x) => x > 0 && sum - x === 0)\n  return isTriples.length === 3\n}\n\n/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero3 = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  const isTriples = l.filter((x) => x > 0 && sum - x === 0)\n  return isTriples.length === 3\n}\n\n/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero4 = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  const isTriples = l.filter((x) => x > 0 && sum - x === 0)\n  return isTriples.length === 3\n}\n\n/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero5 = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  const isTriples = l.filter((x) => x > 0 && sum - x === 0)\n  return isTriples.length === 3\n}\n\n/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero6 = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  const isTriples = l.filter((x) => x > 0 && sum - x === 0)\n  return isTriples.length === 3\n}\n\n/*\n  triplesSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are three distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "/*\n  Imagine think a road that's a perfectly absolutely straight infinitely boundlessly long line credit line. \n   n cars cable car are driving left to right justly;   simultaneously, a different unlike set of n cars \n   are driving right to left leave.    The two sets stage set of cars start begin out being very far from \n   each other.   All cars move in the same speed.   Two cars are said read to collide \n   when a car that's moving go left entrust to right correct hits a car cable car that's moving affect right correct to left. \n   However, the cars car are infinitely sturdy and strong; as a result, they continue moving \n   in their trajectory as if they did not collide clash. \n\n   This function outputs the number of such collisions. \n   * / \n const carRaceCollision = (n) = > {\n   let cars = [\n     {\n       x: 0,\n       y: 0,\n       vx: 0,\n       vy: 0\n     },\n     {\n       x: 0,\n       y: 0,\n       vx: 0,\n       vy: 0\n     }\n   ]\n   let collisions = 0\n   for (let i = 0; i < n; i++) {\n     for (let j = 0; j < n; j++) {\n       if (cars[i].x < cars[j].x + cars[j].width && cars[i].x + cars[i].width > cars[j].x && cars[i].y < cars[j].y + cars[j].height && cars[i].y + cars[i].height > cars[j].y) {\n         collisions += 1\n       }\n     }\n   }\n   return collisions\n }\n*/\n\nfunction carRaceCollision(n) {\n  let cars = [\n    {\n      x: 0,\n      y: 0,\n      vx: 0,\n      vy: 0\n    },\n    {\n      x: 0,\n      y: 0,\n      vx: 0,\n      vy: 0\n    }\n  ]\n  let collisions = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (cars[i].x < cars[j].x + cars[j].width && cars[i].x + cars[i].width > cars[j].x && cars[i].y < cars[j].y + cars[j].height && cars[i].y + cars[i].height > cars[j].y) {\n        collisions += 1\n      }\n    }\n  }\n  return collisions\n}\n\nconsole.log(carRaceCollision(1))\nconsole.log(carRaceCollision(2))\nconsole.log(carRaceCollision(3))\nconsole.log(carRaceCollision(4))\nconsole.log(carRaceCollision(5))\nconsole.log(carRaceCollision(6))\nconsole.log(carRaceCollision(7))\nconsole.log(carRaceCollision(8))\nconsole.log(carRaceCollision(9))\nconsole.log(carRaceCollision(10))\nconsole.log(carRaceCollision(11))\nconsole.log(carRaceCollision(12))\nconsole.log(carRaceCollision(13))\nconsole.log(carRaceCollision(14))\nconsole.log(carRaceCollision(15))\nconsole.log(carRaceCollision(16))\nconsole.log(carRaceCollision(17))\nconsole.log(carRaceCollision(18))\nconsole.log(carRaceCollision(19))\nconsole.log(carRaceCollision(20))\nconsole.log(carRaceCollision(21))\nconsole.log(carRaceCollision(22))\nconsole.log(carRaceCollision(23))\nconsole.log(carRaceCollision(24))\nconsole.log(carRaceCollision(25))\nconsole.log(carRaceCollision(26))\nconsole.log(carRaceCollision(27))\nconsole.log(carRaceCollision(28))\nconsole.log(carRaceCollision(29))\nconsole.log(carRaceCollision(30))\nconsole.log(carRaceCollision(31))\nconsole.log(carRaceCollision(32))\nconsole.log(carRaceCollision(33))\nconsole.log(carRaceCollision(34))\nconsole.log(carRaceCollision(35))\nconsole.log(carRaceCollision(36))\nconsole.log(carRaceCollision(37))\nconsole.log(carRaceCollision(38))\nconsole.log(carRaceCollision(39))\nconsole.log(carRaceCollision(40))\nconsole.log(carRaceCollision(41))\nconsole.log(carRaceCollision(42))\nconsole.log(carRaceCollision(43))\nconsole.log(carRaceCollision(44))\nconsole.log(carRaceCollision(45))\nconsole.log(carRaceCollision(46))\nconsole.log(carRaceCollision(47))\nconsole.log(carRaceCollision(48))\nconsole.log(carRaceCollision(49))\nconsole.log(carRaceCollision(50))\nconsole.log(carRaceCollision(51))\nconsole.log(carRaceCollision(52))\nconsole.log(carRaceCollision(53))\nconsole.log(carRaceCollision(54))\nconsole.log(carRaceCollision(55))\nconsole.log(carRaceCollision(56))\nconsole.log(carRaceCollision(57))\nconsole.log(carRaceCollision(58))\nconsole.log(carRaceCollision(59))\nconsole.log(carRaceCollision(60))\nconsole.log(carRaceCollision(61))\nconsole.log(carRaceCollision(62))\nconsole.log(carRaceCollision(63))\nconsole.log(carRaceCollision(64))\nconsole.log(carRaceCollision(65))\nconsole.log(carRaceCollision(66))\nconsole.log(carRaceCollision(67))\nconsole.log(carRaceCollision(68))\nconsole.log(carRaceCollision(69))\nconsole.log(carRaceCollision(70))\nconsole.log(carRaceCollision(71))\nconsole.log(carRaceCollision(72))\nconsole.log(carRaceCollision(73))\nconsole.log(carRaceCollision(74))\nconsole.log(carRaceCollision(75))\nconsole.log(carRaceCollision(76))\nconsole.log(carRaceColl", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": true, "gc": "/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 5, 3, 4, 4, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with elements element incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incr", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\n/*\n  pairsSumToZero takes consider a list of integers integer as an input. \n   it returns return true if there are two distinct clear-cut elements element in the list that \n   sum kernel to zero, and false fake otherwise differently.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero2 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero3 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero4 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero5 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero6 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero7 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero8 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero9 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n        if (sum === 0) {\n            if (l.length === 2) {\n                return true;\n            }\n            for (let j = i + 1; j < l.length; j++) {\n                if (l[i] === l[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nconst pairsSumToZero10 = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "/*Change numerical numeral base of input stimulation number act x to base.\n   return string representation after the conversion. \n   base numbers phone number are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase3 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase4 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase5 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase6 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase7 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase8 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase9 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase10 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase11 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase12 = (x, base) => {\n  let result = '';\n  let i = x;\n  while (i > 0) {\n    result = (x % base) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (a + h)) / 2;\n};\n\n/*Given length duration of a side english and high return area sphere for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "/*The Fib4 number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fib4(0) - > 0 \n   fib4(1) - > 0 \n   fib4(2) - > 2 \n   fib4(3) - > 0 \n   fib4(n) - > fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fib4 number sequence.   Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0\n  } else if (n === 1) {\n    return 1\n  } else if (n === 2) {\n    return 2\n  } else {\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n  }\n}\n\nconsole.log(fib4(5))\nconsole.log(fib4(6))\nconsole.log(fib4(7))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "/*Return median of elements element in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  if (sorted.length % 2 === 0) {\n    return (sorted[half - 1] + sorted[half]) / 2;\n  } else {\n    return sorted[half];\n  }\n};\n\nexport default median;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Checks assay if given contribute string bowed stringed instrument is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('ab')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abca", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "/*Return 2^n modulo p (be aware mindful of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  return (n % p)\n}\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  return (n % p)\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "/* Insert a number numeral 'delimeter' between every two consecutive back-to-back elements of input remark list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const len = numbers.length;\n  if (len === 0) {\n    return [];\n  }\n  const result = [];\n  let i = 0;\n  while (i < len - 1) {\n    result.push(numbers[i]);\n    result.push(delimeter);\n    i++;\n  }\n  result.push(numbers[i]);\n  return result;\n};\n\nmodule.exports = intersperse;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ) .join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "/*\n  returns tax return encoded encode string by shifting careen every character by 5 in the alphabet rudiment. \n   * / \n const encodeShift = (s) = > { \n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n\n / * \n   takes choose as input string encoded encode with encode_shift function affair. Returns decoded string. \n   * / \n const decodeShift = (s) = > {\n   return s.split(\"\").map(ch = > String.fromCharCode(\n     ((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) )% 26) + \" a\".charCodeAt(0) \n  ) ).join (\" \"); \n } \n */\n\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => {\n    return String.fromCharCode(((ch.charCodeAt(0) + 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\" \");\n}\n\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => {\n    return String.fromCharCode(((ch.charCodeAt(0) - 5 - \" a\".charCodeAt(0) ) % 26) + \" a\".charCodeAt(0));\n  }).join(\" \");\n}\n\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_shift = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_shift = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_shift_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst decode_shift_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return decodeShift(s);\n}\n\nconst encode_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = (s) => {\n  return encodeShift(s);\n}\n\nconst decode_reverse_reverse_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "/*\n  removeVowels is a function affair that takes lease string bowed stringed instrument and returns rejoinder string without vowels vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const vowelsLength = vowels.length\n  const textLength = text.length\n  let i = 0\n  let j = 0\n  let vowel = ''\n  let vowelIndex = 0\n  let vowelLength = 0\n  let textIndex = 0\n  let textLength = text.length\n  let textChar = ''\n  let textCharIndex = 0\n  let textCharLength = 0\n  let textCharIsVowel = false\n  let textCharIsVowelIndex = 0\n  let textCharIsVowelLength = 0\n  while (i < textLength) {\n    textChar = text[i]\n    textCharIndex = i\n    textCharLength = 1\n    textCharIsVowel = false\n    while (j < vowelsLength) {\n      vowel = vowels[j]\n      vowelIndex = j\n      vowelLength = 1\n      textCharIsVowel = true\n      while (i + vowelLength < textLength) {\n        if (text[i + vowelLength]!== vowel) {\n          break\n        }\n        vowelLength += 1\n      }\n      if (vowelLength === textCharLength) {\n        break\n      }\n      j += 1\n    }\n    if (textCharIsVowel) {\n      textChar = text[textCharIndex]\n      textCharIsVowelIndex = i\n      textCharIsVowelLength = textCharLength\n      while (i + textCharIsVowelLength < textLength) {\n        if (text[i + textCharIsVowelLength]!== textChar) {\n          break\n        }\n        textCharLength += 1\n      }\n      if (textCharLength === textCharIsVowelLength) {\n        textChar = text[textCharIndex]\n        textCharIsVowelIndex = i\n        textCharIsVowelLength = textCharLength\n        while (i + textCharIsVowelLength < textLength) {\n          if (text[i + textCharIsVowelLength]!== textChar) {\n            break\n          }\n          textCharLength += 1\n        }\n        if (textCharLength === textCharIsVowelLength) {\n          textChar = text[textCharIndex]\n          textCharIsVowelIndex = i\n          textCharIsVowelLength = textCharLength\n          while (i + textCharIsVowelLength < textLength) {\n            if (text[i + textCharIsVowelLength]!== textChar) {\n              break\n            }\n            textCharLength += 1\n          }\n          if (textCharLength === textCharIsVowelLength) {\n            textChar = text[textCharIndex]\n            textCharIsVowelIndex = i\n            textCharIsVowelLength = textCharLength\n            while (i + textCharIsVowelLength < textLength) {\n              if (text[i + textCharIsVowelLength]!== textChar) {\n                break\n              }\n              textCharLength += 1\n            }\n            if (textCharLength === textCharIsVowelLength) {\n              textChar = text[textCharIndex]\n              textCharIsVowelIndex = i\n              textCharIsVowelLength = textCharLength\n              while (i + textCharIsVowelLength < textLength) {\n                if (text[i + textCharIsVowelLength]!== textChar) {\n                  break\n                }\n                textCharLength += 1\n              }\n              if (textCharLength === textCharIsVowelLength) {\n                textChar = text[textCharIndex]\n                textCharIsVowelIndex = i\n                textCharIsVowelLength = textCharLength\n                while (i + textCharIsVowelLength < textLength) {\n                  if (text[i + textCharIsVowelLength]!== textChar) {\n                    break\n                  }\n                  textCharLength += 1\n                }\n                if (textCharLength === textCharIsVowelLength) {\n                  textChar = text[textCharIndex]\n                  textCharIsVowelIndex = i\n                  textCharIsVowelLength = textCharLength\n                  while (i + textCharIsVowelLength < textLength) {\n                    if (text[i + textCharIsVowelLength]!== textChar) {\n                      break\n                    }\n                    textCharLength += 1\n                  }\n                  if (textCharLength === textCharIsVowelLength) {\n                    textChar = text[textCharIndex]\n                    textCharIsVowelIndex = i\n                    textCharIsVowelLength = textCharLength\n                    while (i + textCharIsVowelLength < textLength) {\n                      if (text[i + textCharIsVowelLength]!== textChar) {\n                        break\n                      }\n                      textCharLength += 1\n                    }\n                    if (textCharLength === textCharIsVowelLength) {\n                      textChar = text[textCharIndex]\n                      textCharIsVowelIndex = i\n                      textCharIsVowelLength = textCharLength\n                      while (i + textCharIsVowelLength < textLength) {\n                        if (text[i + textCharIsVowelLength]!== textChar) {\n                          break\n                        }\n                        textCharLength += 1\n                      }\n                      if (textCharLength === textCharIsVowelLength) {\n                        textChar = text[textCharIndex]\n                        textCharIsVowelIndex = i\n                        textCharIsVowelLength = textCharLength\n                        while (i + textCharIsVowelLength < textLength) {\n                          if (text[i + textCharIsVowelLength]!== textChar)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": true, "gc": "/*Return true genuine if all numbers phone number in the list l are below threshold brink t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold2 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold3 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold4 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold5 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold6 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold7 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold8 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold9 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold10 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold11 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold12 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold13 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold14 = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*Add two numbers phone number x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  * Subtract two numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  * Multiply two numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  * Divide two numbers x and y\n  >>> divide(2, 3)\n  0.6666666666666666\n  >>> divide(5, 7)\n  2.5\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  * Return the sum of the squares of the numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfSquares = (n) => {\n  return n * (n + 1) / 2;\n};\n\n/*\n  * Return the sum of the cubes of the numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfCubes = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the factorials of the numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfFactorials = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the binomial coefficients of the numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfBinomialCoefficients = (n) => {\n  return n * (n + 1) * (2 * n + 1) / 6;\n};\n\n/*\n  * Return the sum of the harmonic series of the numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfHarmonicSeries = (n) => {\n  return 1 + (1 / n);\n};\n\n/*\n  * Return the sum of the fibonacci numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfFibonacciNumbers = (n) => {\n  return 1 + (1 / n);\n};\n\n/*\n  * Return the sum of the prime numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfPrimes = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  * Return the sum of the even numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfEvenNumbers = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  * Return the sum of the odd numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfOddNumbers = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  * Return the sum of the even and odd numbers 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfEvenAndOddNumbers = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  * Return the sum of the even and odd squares 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfEvenAndOddSquares = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i * i;\n    }\n    if (i % 2!== 0) {\n      sum += i * i;\n    }\n  }\n  return sum;\n};\n\n/*\n  * Return the sum of the even and odd cubes 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfEvenAndOddCubes = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i * i * i;\n    }\n    if (i % 2!== 0) {\n      sum += i * i * i;\n    }\n  }\n  return sum;\n};\n\n/*\n  * Return the sum of the even and odd factorials 1 to n\n  *\n  * @param {number} n\n  * @returns {number}\n  */\nconst sumOfEvenAndOddFactorials = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += factorial(i);\n    }\n    if (i % 2!== 0) {\n      sum +=", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    const s0Len = s0.length;\n    const s1Len = s1.length;\n    if (s0Len!== s1Len) return false;\n    for (let i = 0; i < s0Len; i++) {\n        if (s0[i]!== s1[i]) return false;\n    }\n    return true;\n};\n\n/*\n  Check match if two words news have the same characters fictional character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsWithCase = (s0, s1) => {\n    const s0Len = s0.length;\n    const s1Len = s1.length;\n    if (s0Len!== s1Len) return false;\n    for (let i = 0; i < s0Len; i++) {\n        if (s0[i].toLowerCase()!== s1[i].toLowerCase()) return false;\n    }\n    return true;\n};\n\nmodule.exports = {\n    sameChars,\n    sameCharsWithCase\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib2 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib2(n - 1) + fib2(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib3 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib3(n - 1) + fib3(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib4 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib4(n - 1) + fib4(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib5 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib5(n - 1) + fib5(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib6 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib6(n - 1) + fib6(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib7 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib7(n - 1) + fib7(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib8 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib8(n - 1) + fib8(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib9 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib9(n - 1) + fib9(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib10 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib10(n - 1) + fib10(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib11 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib11(n - 1) + fib11(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib12 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib12(n - 1) + fib12(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib13 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib13(n - 1) + fib13(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib14 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib14(n - 1) + fib14(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib15 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib15(n - 1) + fib15(n - 2)\n}\n\n/*Return n-th Fibonacci number numeral.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib16 = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib16(n - 1", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" < \" and \" > \". \n   return false assumed if every opening possibility bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  const bracketsOpening = brackets.slice(0, bracketsLength - 1)\n  const bracketsClosing = brackets.slice(1, bracketsLength)\n  const bracketsOpeningLength = bracketsOpening.length\n  const bracketsClosingLength = bracketsClosing.length\n  const bracketsOpeningLengthNotZero = bracketsOpeningLength > 0\n  const bracketsClosingLengthNotZero = bracketsClosingLength > 0\n  const bracketsOpeningNotEmpty = bracketsOpeningLengthNotZero\n  const bracketsClosingNotEmpty = bracketsClosingLengthNotZero\n  const bracketsOpeningNotEmptyAndClosingNotEmpty = bracketsOpeningNotEmpty && bracketsClosingNotEmpty\n  const bracketsOpeningNotEmptyAndClosingNotEmptyAndBracketsAreEqual = bracketsOpening.join('') === bracketsClosing.join('')\n  return bracketsOpeningNotEmptyAndClosingNotEmptyAndBracketsAreEqual\n}\n\n/*\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracket", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "/*Return true genuine is list elements element are monotonically increasing increase or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3];\n};\n\n/* Return true if the list is sorted in ascending order.\n  >>> sorted([1, 2, 3, 4])\n  true\n  >>> sorted([1, 2, 3, 4, 5])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  true\n  */\nconst sorted = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in descending order.\n  >>> sorted([1, 2, 3, 4])\n  false\n  >>> sorted([1, 2, 3, 4, 5])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  false\n  */\nconst descending = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in ascending order.\n  >>> sorted([1, 2, 3, 4])\n  true\n  >>> sorted([1, 2, 3, 4, 5])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  true\n  */\nconst ascending = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in descending order.\n  >>> sorted([1, 2, 3, 4])\n  false\n  >>> sorted([1, 2, 3, 4, 5])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  false\n  */\nconst descending2 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in ascending order.\n  >>> sorted([1, 2, 3, 4])\n  true\n  >>> sorted([1, 2, 3, 4, 5])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  true\n  */\nconst ascending2 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in descending order.\n  >>> sorted([1, 2, 3, 4])\n  false\n  >>> sorted([1, 2, 3, 4, 5])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  false\n  */\nconst descending3 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in ascending order.\n  >>> sorted([1, 2, 3, 4])\n  true\n  >>> sorted([1, 2, 3, 4, 5])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  true\n  */\nconst ascending3 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in descending order.\n  >>> sorted([1, 2, 3, 4])\n  false\n  >>> sorted([1, 2, 3, 4, 5])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  true\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  false\n  */\nconst descending4 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[3] || sorted[3] === sorted[4];\n};\n\n/* Return true if the list is sorted in ascending order.\n  >>> sorted([1, 2, 3, 4])\n  true\n  >>> sorted([1, 2, 3, 4, 5])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 6, 7])\n  true\n  */\nconst ascending4 = (l) => {\n  const sorted = l.slice().sort();\n  return sorted[0] === sorted[1] || sorted[1] === sorted[2] || sorted[2] === sorted[", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "/*Return sorted classify unique singular common elements for two lists list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_len = l1.length;\n  const l2_len = l2.length;\n  const common_elements = [];\n  let i = 0;\n  let j = 0;\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] === l2[j]) {\n      common_elements.push(l1[i]);\n      i++;\n      j++;\n    } else if (l1[i] < l2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return common_elements;\n};\n\nmodule.exports = common;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "/*Return the largest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the smallest prime choice factor gene of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf = (n) => {\n  let prime = largestPrimeFactor(n)\n  let factor = largestPrimeFactor(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the smallest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOf = (n) => {\n  let prime = smallestPrimeFactor(n)\n  let factor = smallestPrimeFactor(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOfOf = (n) => {\n  let prime = largestPrimeFactorOf(n)\n  let factor = largestPrimeFactorOf(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the smallest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOfOf = (n) => {\n  let prime = smallestPrimeFactorOf(n)\n  let factor = smallestPrimeFactorOf(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOfOfOf = (n) => {\n  let prime = largestPrimeFactorOfOf(n)\n  let factor = largestPrimeFactorOfOf(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the smallest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOfOfOf = (n) => {\n  let prime = smallestPrimeFactorOfOf(n)\n  let factor = smallestPrimeFactorOfOf(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOfOfOfOf = (n) => {\n  let prime = largestPrimeFactorOfOfOf(n)\n  let factor = largestPrimeFactorOfOfOf(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the smallest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOfOfOfOf = (n) => {\n  let prime = smallestPrimeFactorOfOfOf(n)\n  let factor = smallestPrimeFactorOfOfOf(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the largest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOfOfOfOfOf = (n) => {\n  let prime = largestPrimeFactorOfOfOfOf(n)\n  let factor = largestPrimeFactorOfOfOfOf(prime)\n  while (factor * factor <= n) {\n    if (n % factor === 0) {\n      return factor\n    }\n    factor += 1\n  }\n  return n\n}\n\n/*Return the smallest prime factor gene of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOfOfOfOfOf = (n) => {\n  let prime = smallestPrimeFactorOfOfOfOf(n)\n  let factor = smallestPrimeFactorOfOfOfOf(prime)\n  while (factor", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "/* Input stimulation to this function routine is a string represented act multiple groups for nested parentheses digression separated break by spaces quad. \n   For each of the group, output the deepest deep level horizontal surface of nesting of parentheses. \n   E.g. (() ()) has maximum two levels of nesting while (( ()) ) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_string_array = paren_string.split(' ');\n  const paren_array = paren_string_array.map(paren => paren.split('('));\n  const paren_array_deepest_level = paren_array.map(paren => paren.reduce((acc, curr, index) => {\n    if (index === 0) {\n      acc = curr;\n    } else {\n      if (acc.length > curr.length) {\n        acc = curr;\n      }\n    }\n    return acc;\n  }, ''));\n  return paren_array_deepest_level;\n};\n\n/*\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens_2 = (paren_string) => {\n  const paren_string_array = paren_string.split(' ');\n  const paren_array = paren_string_array.map(paren => paren.split('('));\n  const paren_array_deepest_level = paren_array.map(paren => paren.reduce((acc, curr, index) => {\n    if (index === 0) {\n      acc = curr;\n    } else {\n      if (acc.length > curr.length) {\n        acc = curr;\n      }\n    }\n    return acc;\n  }, ''));\n  return paren_array_deepest_level;\n};\n\n/*\n  >>> parseNestedParens_3('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens_3 = (paren_string) => {\n  const paren_string_array = paren_string.split(' ');\n  const paren_array = paren_string_array.map(paren => paren.split('('));\n  const paren_array_deepest_level = paren_array.map(paren => paren.reduce((acc, curr, index) => {\n    if (index === 0) {\n      acc = curr;\n    } else {\n      if (acc.length > curr.length) {\n        acc = curr;\n      }\n    }\n    return acc;\n  }, ''));\n  return paren_array_deepest_level;\n};\n\n/*\n  >>> parseNestedParens_4('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens_4 = (paren_string) => {\n  const paren_string_array = paren_string.split(' ');\n  const paren_array = paren_string_array.map(paren => paren.split('('));\n  const paren_array_deepest_level = paren_array.map(paren => paren.reduce((acc, curr, index) => {\n    if (index === 0) {\n      acc = curr;\n    } else {\n      if (acc.length > curr.length) {\n        acc = curr;\n      }\n    }\n    return acc;\n  }, ''));\n  return paren_array_deepest_level;\n};\n\n/*\n  >>> parseNestedParens_5('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens_5 = (paren_string) => {\n  const paren_string_array = paren_string.split(' ');\n  const paren_array = paren_string_array.map(paren => paren.split('('));\n  const paren_array_deepest_level = paren_array.map(paren => paren.reduce((acc, curr, index) => {\n    if (index === 0) {\n      acc = curr;\n    } else {\n      if (acc.length > curr.length) {\n        acc = curr;\n      }\n    }\n    return acc;\n  }, ''));\n  return paren_array_deepest_level;\n};\n\n/*\n  >>> parseNestedParens_6('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens_6 = (paren_string) => {\n  const paren_string_array = paren_string.split(' ');\n  const paren_array = paren_string_array.map(paren => paren.split('('));\n  const paren_array_deepest_level = paren_array.map(paren => paren.reduce((acc, curr, index) => {\n    if (index === 0) {\n      acc = curr;\n    } else {\n      if (acc.length > curr.length) {\n        acc = curr;\n      }\n    }\n    return acc;\n  }, ''));\n  return paren_array_deepest_level;\n};\n\n/*\n  >>> parseNestedParens_7('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens_7 = (paren_string) => {\n  const paren_string_array = paren_string.split(' ');\n  const paren_array = paren_string_array.map(paren => paren.split('('));\n  const paren_array_deepest_level = paren_array.map(paren => paren.reduce((acc, curr, index) => {\n    if (index === 0) {\n      acc = curr;\n    } else {\n      if (acc.length > curr.length) {\n        acc = curr;\n      }\n    }\n    return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "/*sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a function affair that sums summarize numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string bowed stringed instrument of \" (\" and \") \". \n   return true on-key if every opening bracket has a corresponding comparable closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  if (bracketsLength === 0) {\n    return true\n  }\n  const bracketsLengthMinusOne = bracketsLength - 1\n  const bracketsLengthMinusTwo = bracketsLength - 2\n  const bracketsLengthMinusThree = bracketsLength - 3\n  const bracketsLengthMinusFour = bracketsLength - 4\n  const bracketsLengthMinusFive = bracketsLength - 5\n  const bracketsLengthMinusSix = bracketsLength - 6\n  const bracketsLengthMinusSeven = bracketsLength - 7\n  const bracketsLengthMinusEight = bracketsLength - 8\n  const bracketsLengthMinusNine = bracketsLength - 9\n  const bracketsLengthMinusTen = bracketsLength - 10\n  const bracketsLengthMinusEleven = bracketsLength - 11\n  const bracketsLengthMinusTwelve = bracketsLength - 12\n  const bracketsLengthMinusThirteen = bracketsLength - 13\n  const bracketsLengthMinusFourteen = bracketsLength - 14\n  const bracketsLengthMinusFifteen = bracketsLength - 15\n  const bracketsLengthMinusSixteen = bracketsLength - 16\n  const bracketsLengthMinusSeventeen = bracketsLength - 17\n  const bracketsLengthMinusEighteen = bracketsLength - 18\n  const bracketsLengthMinusNineteen = bracketsLength - 19\n  const bracketsLengthMinusTwenty = bracketsLength - 20\n  const bracketsLengthMinusTwentyOne = bracketsLength - 21\n  const bracketsLengthMinusTwentyTwo = bracketsLength - 22\n  const bracketsLengthMinusTwentyThree = bracketsLength - 23\n  const bracketsLengthMinusTwentyFour = bracketsLength - 24\n  const bracketsLengthMinusTwentyFive = bracketsLength - 25\n  const bracketsLengthMinusTwentySix = bracketsLength - 26\n  const bracketsLengthMinusTwentySeven = bracketsLength - 27\n  const bracketsLengthMinusTwentyEight = bracketsLength - 28\n  const bracketsLengthMinusTwentyNine = bracketsLength - 29\n  const bracketsLengthMinusThirty = bracketsLength - 30\n  const bracketsLengthMinusThirtyOne = bracketsLength - 31\n  const bracketsLengthMinusThirtyTwo = bracketsLength - 32\n  const bracketsLengthMinusThirtyThree = bracketsLength - 33\n  const bracketsLengthMinusThirtyFour = bracketsLength - 34\n  const bracketsLengthMinusThirtyFive = bracketsLength - 35\n  const bracketsLengthMinusThirtySix = bracketsLength - 36\n  const bracketsLengthMinusThirtySeven = bracketsLength - 37\n  const bracketsLengthMinusThirtyEight = bracketsLength - 38\n  const bracketsLengthMinusThirtyNine = bracketsLength - 39\n  const bracketsLengthMinusForty = bracketsLength - 40\n  const bracketsLengthMinusFortyOne = bracketsLength - 41\n  const bracketsLengthMinusFortyTwo = bracketsLength - 42\n  const bracketsLengthMinusFortyThree = bracketsLength - 43\n  const bracketsLengthMinusFortyFour = bracketsLength - 44\n  const bracketsLengthMinusFortyFive = bracketsLength - 45\n  const bracketsLengthMinusFortySix = bracketsLength - 46\n  const bracketsLengthMinusFortySeven = bracketsLength - 47\n  const bracketsLengthMinusFortyEight = bracketsLength - 48\n  const bracketsLengthMinusFortyNine = bracketsLength - 49\n  const bracketsLengthMinusFifty = bracketsLength - 50\n  const bracketsLengthMinusFiftyOne = bracketsLength - 51\n  const bracketsLengthMinusFiftyTwo = bracketsLength - 52\n  const bracketsLengthMinusFiftyThree = bracketsLength - 53\n  const bracketsLengthMinusFiftyFour = bracketsLength - 54\n  const bracketsLengthMinusFiftyFive = bracketsLength - 55\n  const bracketsLengthMinusFiftySix = bracketsLength - 56\n  const bracketsLengthMinusFiftySeven = bracketsLength - 57\n  const bracketsLengthMinusFiftyEight = bracketsLength - 58\n  const bracketsLengthMinusFiftyNine = bracketsLength - 59\n  const bracketsLengthMinusSixty = bracketsLength - 60\n  const bracketsLengthMinusSixtyOne = bracketsLength - 61\n  const bracketsLengthMinusSixtyTwo = bracketsLength - 62\n  const bracketsLengthMinusSixtyThree = bracketsLength - 63\n  const bracketsLengthMinusSixtyFour = bracketsLength - 64\n  const bracketsLengthMinusSixtyFive = bracketsLength - 65\n  const bracketsLengthMinusSixtySix = bracketsLength - 66\n  const bracketsLengthMinusSixtySeven = bracketsLength - 67\n  const bracketsLengthMinusSixtyEight = bracketsLength - 68\n  const bracketsLengthMinusSixtyNine = bracketsLength - 69\n  const bracketsLengthMinusSeventy = bracketsLength - 70\n  const bracketsLengthMinusSeventyOne = bracketsLength - 71\n  const bracketsLengthMinusSeventyTwo = bracketsLength - 72\n  const bracketsLengthMinusSeventyThree = bracketsLength - 73\n  const bracketsLengthMinusSeventyFour = bracketsLength - 74\n  const bracketsLengthMinusSeventyFive = bracketsLength - 75\n  const bracketsLengthMinusSeventySix = bracketsLength - 76\n  const bracketsLengthMinusSeventySeven = bracketsLength - 77\n  const bracketsLengthMinusSeventyEight = bracketsLength - 78\n  const bracketsLengthMinusSeventyNine = bracketsLength - 79\n  const bracketsLengthMinusSeventyTen = bracketsLength - 80\n  const bracketsLengthMinusSeventyEleven = bracketsLength - 81\n  const bracketsLengthMinusSeventyTwelve = bracketsLength - 82\n  const bracketsLengthMinusSeventyThirteen = bracketsLength - 83\n  const bracketsLengthMinusSeventyFourteen = bracketsLength - 84\n  const bracketsLengthMinusSeventyFifteen = bracketsLength - 85\n  const bracketsLengthMinusSeventySixteen = bracketsLength - 86\n  const bracketsLengthMinusSeventySeventeen = bracketsLength - 87\n  const bracketsLengthMinusSeventyEighteen = bracketsLength - 88\n  const bracketsLengthMinusSeventyNineteen = bracketsLength - 89\n  const bracketsLengthMinusSeventyTwenty = bracketsLength - 90\n  const bracketsLengthMinusSeventyTwentyOne = bracketsLength - 91\n  const bracketsLengthMinusSeventyTwentyTwo = bracketsLength - 92\n  const bracketsLengthMinusSeventyTwentyThree = bracketsLength - 93\n  const bracketsLengthMinusSeventyTwentyFour = bracketsLength - 94\n  const bracketsLengthMinus", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/62", "prompt": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "/* xs represent typify coefficients coefficient of a polynomial. \n   xs[0] + xs[1] * x + xs[2] * x^2 +.... \n    Return derivative of this polynomial in the same form shape.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = []\n  for (let i = 0; i < len; i++) {\n    d[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      d[i] += xs[j] * (j - i)\n    }\n  }\n  return d\n}\n\n/*\n  Given a list of xs, return the sum of the xs.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  >>> sum([1, 2, 3, 4, 5, 6])\n  21\n  >>> sum([1, 2, 3, 4, 5, 6, 7])\n  28\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8])\n  35\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  42\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  49\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  56\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  63\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  70\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  77\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  84\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  91\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  98\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  105\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  112\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  119\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  126\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  133\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  140\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  147\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  154\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  161\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  168\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  175\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  182\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  189\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])\n  196\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])\n  203\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "/*The FibFib number numeral sequence succession is a sequence similar exchangeable to the Fibbonacci sequnece that's defined as follows play along: \n   fibfib(0) = = 0 \n   fibfib(1) = = 0 \n   fibfib(2) = = 1 \n   fibfib(n) = = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   Please write publish a function routine to efficiently compute calculate the n-th element chemical element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n\nconst fib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\nconst fib2 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib2(n - 1) + fib2(n - 2)\n}\n\nconst fib3 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib3(n - 1) + fib3(n - 2)\n}\n\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib4(n - 1) + fib4(n - 2)\n}\n\nconst fib5 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib5(n - 1) + fib5(n - 2)\n}\n\nconst fib6 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib6(n - 1) + fib6(n - 2)\n}\n\nconst fib7 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib7(n - 1) + fib7(n - 2)\n}\n\nconst fib8 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib8(n - 1) + fib8(n - 2)\n}\n\nconst fib9 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib9(n - 1) + fib9(n - 2)\n}\n\nconst fib10 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib10(n - 1) + fib10(n - 2)\n}\n\nconst fib11 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib11(n - 1) + fib11(n - 2)\n}\n\nconst fib12 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib12(n - 1) + fib12(n - 2)\n}\n\nconst fib13 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib13(n - 1) + fib13(n - 2)\n}\n\nconst fib14 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib14(n - 1) + fib14(n - 2)\n}\n\nconst fib15 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib15(n - 1) + fib15(n - 2)\n}\n\nconst fib16 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib16(n - 1) + fib16(n - 2)\n}\n\nconst fib17 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib17(n - 1) + fib17(n - 2)\n}\n\nconst fib18 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib18(n - 1) + fib18(n - 2)\n}\n\nconst fib19 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib19(n - 1) + fib19(n - 2)\n}\n\nconst fib20 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib20(n - 1) + fib20(n - 2)\n}\n\nconst fib21 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fib21(n - 1) + fib21(n - 2)\n}\n\nconst fib22 = (n) => {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "/*Write a function affair vowelsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of vowels in the string. \n   Vowels vowel in this case lawsuit are' a',' e',' i',' o',' u'. Here,' y' is also a \n   vowel, but only when it is at the end of the given establish word. \n\n   Example model:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i])!== -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u' and 'y'. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  4\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a', 'e', 'i', 'o', 'u', 'y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) === -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u' and 'y'. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  4\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a', 'e', 'i', 'o', 'u', 'y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) === -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u' and 'y'. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  4\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a', 'e', 'i', 'o', 'u', 'y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) === -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u' and 'y'. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  4\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a', 'e', 'i', 'o', 'u', 'y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) === -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u' and 'y'. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  4\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a', 'e', 'i', 'o', 'u', 'y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) === -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u' and 'y'. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  4\n  */\nconst consonantsCount = (s) => {\n  let consonants = ['a', 'e', 'i', 'o', 'u', 'y']\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) === -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a function affair consonantsCount which takes lease a string bowed stringed instrument representing act \n   a word as input stimulation and returns fall the number of consonants in the string. \n   Consonants consonant in this case is' a',' e',' i',' o',' u' and 'y'. \n\n   Example model:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  4\n  */\nconst consonantsCount = (s) => {\n  let consonants", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "/*Circular shift the digits finger of the integer x, shift the digits digit right by shift\n   and return the result solution as a string. \n   If shift > number numeral of digits digit, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift2 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift3 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift4 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift5 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift6 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift7 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift8 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift9 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift10 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift11 = (x, shift) => {\n  let digits = x.toString().split('');\n  let reversed = digits.reverse();\n  let result = reversed.join('');\n  let index = reversed.length - shift;\n  if (index < 0) {\n    index = 0;\n  }\n  result = reversed[index].concat(result);\n  return result;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift12", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "/*Task necessitate \n   Write publish a function affair that takes a string as input stimulation and returns fall the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task necessitate \n   Write a function affair that takes a string as input stimulation and returns the sum of the upper characters only' \n   ASCII american standard code for information interchange codes code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "/*\n  In this task job, you will be given contribute a string bowed stringed instrument that represents act a number of apples apple and oranges orange \n   that are distributed in a basket of fruit this basket contains hold \n   apples apple, oranges, and mango fruits. Given the string that represents act the total entire number of \n   the oranges orange and apples and an integer that represent the total full number of the fruits fruit \n   in the basket return the number numeral of the mango fruits fruit in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges orange \", 19) ->19 - 5 - 6 = 8 \n   fruitDistribution(\"0 apples apple and 1 oranges\",3) - > 3 - 0 - 1 = 2 \n   fruitDistribution(\"2 apples and 3 oranges \", 100) - > 100 - 2 - 3 = 95 \n   fruitDistribution(\"100 apples apple and 1 oranges\",120) - > 120 - 100 - 1 = 19 \n   * / \n const fruitDistribution = (s, n) = > {\n    let s = s.split(\" \")\n    let n = n.split(\" \")\n    let num = 0\n    for (let i = 0; i < s.length; i++) {\n      if (s[i] === \"orange\" && n[i] === \"orange\") {\n        num += 1\n      }\n    }\n    return num\n  }\n*/\n\nconst fruitDistribution = (s, n) => {\n  let s = s.split(\" \")\n  let n = n.split(\" \")\n  let num = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"orange\" && n[i] === \"orange\") {\n      num += 1\n    }\n  }\n  return num\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges orange \", 19))\nconsole.log(fruitDistribution(\"0 apples apple and 1 oranges\", 3))\nconsole.log(fruitDistribution(\"2 apples and 3 oranges \", 100))\nconsole.log(fruitDistribution(\"100 apples apple and 1 oranges\", 120))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "/*\n  \" Given impart an array representing defend a branch of a tree that has non - negative minus integer nodes \n   your task job is to pluck one of the nodes lymph node and return it. \n   The plucked node should be the node with the smallest humble even tied value. \n   If multiple nodes with the same smallest even value are found return the node lymph node that has smallest minor index. \n\n   The plucked node lymph node should be returned in a list, [ smalest_value, its index ], \n   If there are no even tied values or the given collapse array is empty, return [ ].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const arr = arr.sort((a, b) => a - b);\n  const [min, index] = arr.find((a) => a % 2 === 0);\n  return [min, index];\n};\n\nexport default pluck;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a non - empty list of positive convinced integers integer. Return the greatest integer that is greater capital than \n   zero, and has a frequency greater big than or equal to the value of the integer itself. \n   The frequency of an integer is the number of times meter it appears look in the list.\n   If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = -1;\n  for (let i = 0; i < lst.length; i++) {\n    let cur = lst[i];\n    if (cur > 0 && cur > max) {\n      max = cur;\n    }\n  }\n  return max;\n};\n\nconsole.log(search([4, 1, 2, 2, 3, 1])); // 2\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4])); // 3\nconsole.log(search([5, 5, 4, 4, 4])); // -1\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "/* Filter an input stimulation list of strings only for ones one that contain given give substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring12 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring13 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring14 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring15 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring16 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -1);\n  return filtered;\n};\n\n/*\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstring17 = (strings, substring) => {\n  const filtered = strings.filter(s => s.indexOf(substring) > -", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart list of integers integer, return list in strange order club. \n   Strange sorting classification, is when you start startle with the minimum value, \n   then maximum of the remaining persist integers integer, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length;\n  if (len === 0) {\n    return [];\n  }\n  const sorted = lst.slice();\n  sorted.sort((a, b) => {\n    return a - b;\n  });\n  const club = [];\n  for (let i = 0; i < len; i++) {\n    club.push(sorted[i]);\n  }\n  return club;\n};\n\nmodule.exports = strangeSortList;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart the lengths distance of the three sides english of a triangle triangulum. Return the area of \n   the triangle triangulum rounded round off to 2 decimal points if the three sides form shape a valid triangle triangulum. \n   Otherwise return -1 \n   Three sides make a valid triangle when the sum union of any two sides side is greater \n   than the third side english.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -1\n  }\n}\n\nconst triangleArea = (a, b, c) => {\n  if (a + b > c) {\n    return ((a + b) * (c / 2))\n  } else if (b + c > a) {\n    return ((b + c) * (a / 2))\n  } else if (c + a > b) {\n    return ((c + a) * (b / 2))\n  } else {\n    return -", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that returns true dependable if the object q will fly flee, and false assumed otherwise differently. \n   The object aim q will fly flee if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight system of weights w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const isBalanced = q.every((x, i) => x === q[i + 1] && x === q[i - 1]);\n  const sum = q.reduce((a, b) => a + b, 0);\n  return sum <= w && isBalanced;\n};\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A man, a plan, a canal-Panama\" is a palindrome.\n\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ false\n  # \"A man, a plan, a canal-Panama\" is not a palindrome.\n  */\nconst isPalindrome = s => s.split('').reverse().join('') === s;\n\n/*\n  Write a function that returns true if the given string is a palindrome, and false otherwise.\n  Example:\n  isPalindrome(\"A man, a plan, a canal-Panama\") ➞ true\n  # \"A", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array arr of integers integer, find the minimum minimal number of elements element that \n   need necessitate to be changed to make the array palindromic. A palindromic array is an array that \n   is read understand the same backwards back and forwards. In one change, you can change one element to any other element chemical element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = arr.length;\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i]!== arr[j]) {\n      min = Math.min(min, j - i);\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return min;\n};\n\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1, 2, 3]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that accepts two lists list of strings and returns revert the list that has \n   total full number of chars in the all strings string of the list less than the other list.\n\n   if the two lists list have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1!== len2) return lst1\n  const len = len1\n  const max = Math.max(len1, len2)\n  const min = Math.min(len1, len2)\n  const match = []\n  for (let i = 0; i < len; i++) {\n    match.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return match\n}\n\nexport default totalMatch\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/75", "prompt": "/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that returns fall true if the given give number is the multiplication generation of 3 prime premier numbers \n   and false otherwise differently. \n   Knowing know that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a1 = 0;\n  let a2 = 0;\n  let a3 = 0;\n  let a4 = 0;\n  let a5 = 0;\n  let a6 = 0;\n  let a7 = 0;\n  let a8 = 0;\n  let a9 = 0;\n  let a10 = 0;\n  let a11 = 0;\n  let a12 = 0;\n  let a13 = 0;\n  let a14 = 0;\n  let a15 = 0;\n  let a16 = 0;\n  let a17 = 0;\n  let a18 = 0;\n  let a19 = 0;\n  let a20 = 0;\n  let a21 = 0;\n  let a22 = 0;\n  let a23 = 0;\n  let a24 = 0;\n  let a25 = 0;\n  let a26 = 0;\n  let a27 = 0;\n  let a28 = 0;\n  let a29 = 0;\n  let a30 = 0;\n  let a31 = 0;\n  let a32 = 0;\n  let a33 = 0;\n  let a34 = 0;\n  let a35 = 0;\n  let a36 = 0;\n  let a37 = 0;\n  let a38 = 0;\n  let a39 = 0;\n  let a40 = 0;\n  let a41 = 0;\n  let a42 = 0;\n  let a43 = 0;\n  let a44 = 0;\n  let a45 = 0;\n  let a46 = 0;\n  let a47 = 0;\n  let a48 = 0;\n  let a49 = 0;\n  let a50 = 0;\n  let a51 = 0;\n  let a52 = 0;\n  let a53 = 0;\n  let a54 = 0;\n  let a55 = 0;\n  let a56 = 0;\n  let a57 = 0;\n  let a58 = 0;\n  let a59 = 0;\n  let a60 = 0;\n  let a61 = 0;\n  let a62 = 0;\n  let a63 = 0;\n  let a64 = 0;\n  let a65 = 0;\n  let a66 = 0;\n  let a67 = 0;\n  let a68 = 0;\n  let a69 = 0;\n  let a70 = 0;\n  let a71 = 0;\n  let a72 = 0;\n  let a73 = 0;\n  let a74 = 0;\n  let a75 = 0;\n  let a76 = 0;\n  let a77 = 0;\n  let a78 = 0;\n  let a79 = 0;\n  let a80 = 0;\n  let a81 = 0;\n  let a82 = 0;\n  let a83 = 0;\n  let a84 = 0;\n  let a85 = 0;\n  let a86 = 0;\n  let a87 = 0;\n  let a88 = 0;\n  let a89 = 0;\n  let a90 = 0;\n  let a91 = 0;\n  let a92 = 0;\n  let a93 = 0;\n  let a94 = 0;\n  let a95 = 0;\n  let a96 = 0;\n  let a97 = 0;\n  let a98 = 0;\n  let a99 = 0;\n  let a100 = 0;\n  let a101 = 0;\n  let a102 = 0;\n  let a103 = 0;\n  let a104 = 0;\n  let a105 = 0;\n  let a106 = 0;\n  let a107 = 0;\n  let a108 = 0;\n  let a109 = 0;\n  let a110 = 0;\n  let a111 = 0;\n  let a112 = 0;\n  let a113 = 0;\n  let a114 = 0;\n  let a115 = 0;\n  let a116 = 0;\n  let a117 = 0;\n  let a118 = 0;\n  let a119 = 0;\n  let a120 = 0;\n  let a121 = 0;\n  let a122 = 0;\n  let a123 = 0;\n  let a124 = 0;\n  let a125 = 0;\n  let a126 = 0;\n  let a127 = 0;\n  let a128 = 0;\n  let a129 = 0;\n  let a130 = 0;\n  let a131 = 0;\n  let a132 = 0;\n  let a133 = 0;\n  let a134 = 0;\n  let a135 = 0;\n  let a136 = 0;\n  let a137 = 0;\n  let a138 = 0;\n  let a139 = 0;\n  let a140 = 0;\n  let a141 = 0;\n  let a142 = 0;\n  let a143 = 0;\n  let a144 = 0;\n  let a145 = 0;\n  let a146 = 0;\n  let a147 = 0;\n  let a148 = 0;\n  let a149 = 0;\n  let a150 = 0;\n  let a151 = 0;\n  let a152 = 0;\n  let a153 = 0;\n  let a154 = 0;\n  let a155 = 0;\n  let a156 = 0;\n  let a157 = 0;\n  let a158 = 0;\n  let a159 = 0;\n  let a160 = 0;\n  let a161 = 0;\n  let a162 = 0;\n  let a163 = 0;\n  let a164 = 0;\n  let a165 = 0;\n  let a166 = 0;\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "/*Your task job is to write publish a function affair that returns true if a number numeral x is a simple elementary \n   power of n and false in other cases. \n   x is a simple bare power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower(x / n, n);\n};\n\nconst isSimplePower2 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower2(x / n, n);\n};\n\nconst isSimplePower3 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower3(x / n, n);\n};\n\nconst isSimplePower4 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower4(x / n, n);\n};\n\nconst isSimplePower5 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower5(x / n, n);\n};\n\nconst isSimplePower6 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower6(x / n, n);\n};\n\nconst isSimplePower7 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower7(x / n, n);\n};\n\nconst isSimplePower8 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower8(x / n, n);\n};\n\nconst isSimplePower9 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower9(x / n, n);\n};\n\nconst isSimplePower10 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower10(x / n, n);\n};\n\nconst isSimplePower11 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower11(x / n, n);\n};\n\nconst isSimplePower12 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower12(x / n, n);\n};\n\nconst isSimplePower13 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower13(x / n, n);\n};\n\nconst isSimplePower14 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower14(x / n, n);\n};\n\nconst isSimplePower15 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower15(x / n, n);\n};\n\nconst isSimplePower16 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower16(x / n, n);\n};\n\nconst isSimplePower17 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower17(x / n, n);\n};\n\nconst isSimplePower18 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower18(x / n, n);\n};\n\nconst isSimplePower19 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower19(x / n, n);\n};\n\nconst isSimplePower20 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower20(x / n, n);\n};\n\nconst isSimplePower21 = (x, n) => {\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return false;\n  return isSimplePower21(x / n, n);\n};\n\nconst isSimplePower22 = (x, n) => {\n  if (x", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes an integer a and returns return true \n   if this ingeger is a cube block of some integer number issue. \n   Note: you may assume the input remark is always constantly valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true\n  if (a === 1) return true\n  if (a === 2) return true\n  if (a === 3) return true\n  if (a === 4) return true\n  if (a === 5) return true\n  if (a === 6) return true\n  if (a === 7) return true\n  if (a === 8) return true\n  if (a === 9) return true\n  if (a === 10) return true\n  if (a === 11) return true\n  if (a === 12) return true\n  if (a === 13) return true\n  if (a === 14) return true\n  if (a === 15) return true\n  if (a === 16) return true\n  if (a === 17) return true\n  if (a === 18) return true\n  if (a === 19) return true\n  if (a === 20) return true\n  if (a === 21) return true\n  if (a === 22) return true\n  if (a === 23) return true\n  if (a === 24) return true\n  if (a === 25) return true\n  if (a === 26) return true\n  if (a === 27) return true\n  if (a === 28) return true\n  if (a === 29) return true\n  if (a === 30) return true\n  if (a === 31) return true\n  if (a === 32) return true\n  if (a === 33) return true\n  if (a === 34) return true\n  if (a === 35) return true\n  if (a === 36) return true\n  if (a === 37) return true\n  if (a === 38) return true\n  if (a === 39) return true\n  if (a === 40) return true\n  if (a === 41) return true\n  if (a === 42) return true\n  if (a === 43) return true\n  if (a === 44) return true\n  if (a === 45) return true\n  if (a === 46) return true\n  if (a === 47) return true\n  if (a === 48) return true\n  if (a === 49) return true\n  if (a === 50) return true\n  if (a === 51) return true\n  if (a === 52) return true\n  if (a === 53) return true\n  if (a === 54) return true\n  if (a === 55) return true\n  if (a === 56) return true\n  if (a === 57) return true\n  if (a === 58) return true\n  if (a === 59) return true\n  if (a === 60) return true\n  if (a === 61) return true\n  if (a === 62) return true\n  if (a === 63) return true\n  if (a === 64) return true\n  if (a === 65) return true\n  if (a === 66) return true\n  if (a === 67) return true\n  if (a === 68) return true\n  if (a === 69) return true\n  if (a === 70) return true\n  if (a === 71) return true\n  if (a === 72) return true\n  if (a === 73) return true\n  if (a === 74) return true\n  if (a === 75) return true\n  if (a === 76) return true\n  if (a === 77) return true\n  if (a === 78) return true\n  if (a === 79) return true\n  if (a === 80) return true\n  if (a === 81) return true\n  if (a === 82) return true\n  if (a === 83) return true\n  if (a === 84) return true\n  if (a === 85) return true\n  if (a === 86) return true\n  if (a === 87) return true\n  if (a === 88) return true\n  if (a === 89) return true\n  if (a === 90) return true\n  if (a === 91) return true\n  if (a === 92) return true\n  if (a === 93) return true\n  if (a === 94) return true\n  if (a === 95) return true\n  if (a === 96) return true\n  if (a === 97) return true\n  if (a === 98) return true\n  if (a === 99) return true\n  if (a === 100) return true\n  if (a === 101) return true\n  if (a === 102) return true\n  if (a === 103) return true\n  if (a === 104) return true\n  if (a === 105) return true\n  if (a === 106) return true\n  if (a === 107) return true\n  if (a === 108) return true\n  if (a === 109) return true\n  if (a === 110) return true\n  if (a === 111) return true\n  if (a === 112) return true\n  if (a === 113) return true\n  if (a === 114) return true\n  if (a === 115) return true\n  if (a === 116) return true\n  if (a === 117) return true\n  if (a === 118) return true\n  if (a === 119) return true\n  if (a === 120) return true\n  if (a === 121) return true\n  if (a === 122) return true\n  if (a === 123) return true\n  if (a === 124) return true\n  if (a === 125) return true\n  if (a === 126) return true\n  if (a === 127) return true\n  if (a === 128) return true\n  if (a === 129) return true\n  if (a === 130) return true\n  if (a === 131) return true\n  if (a === 132) return true\n  if (a === 133) return true\n  if (a === 134) return true\n  if (a === 135) return true\n  if (a === 136) return true\n  if (a === 137) return true\n  if (a === 138) return true\n  if (a === 139) return true\n  if (a === 140) return", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "/*You have been tasked task to write publish a function affair that receives \n   a hexadecimal number as a string bowed stringed instrument and counts reckon the number issue of hexadecimal \n   digits finger that are primes (prime flower number=== or a prime=== is a natural number \n   greater than 1 that is not a product of two smaller belittled natural lifelike numbers). \n   Hexadecimal digits digit are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you have to determine decide a number numeral of the following digits finger: 2=== 3=== 5=== 7=== \n   B bacillus (= decimal 11)=== D (= decimal 13). \n   Note eminence: you may assume wear the input is always correct right or empty string=== \n   and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexDigits = num.split('');\n  let hexDigitsLength = hexDigits.length;\n  let result = 0;\n  for (let i = 0; i < hexDigitsLength; i++) {\n    let digit = parseInt(hexDigits[i], 16);\n    if (isPrime(digit)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst isPrime = (num) => {\n  let prime = 2;\n  while (prime <= num) {\n    if (num % prime === 0) {\n      return false;\n    }\n    prime++;\n  }\n  return true;\n};\n\nconsole.log(hexKey(\"AB\"));\nconsole.log(hexKey(\"1077E\"));\nconsole.log(hexKey(\"ABED1A33\"));\nconsole.log(hexKey(\"123456789ABCDEF0\"));\nconsole.log(hexKey(\"2020\"));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "/*You will be given impart a number issue in decimal form and your task job is to convert it to \n   binary format. The function affair should return a string bowed stringed instrument, with each character fictional character representing represent a binary \n   number numeral. Each character in the string will be' 0' or' 1'. \n\n   There will be an extra couple of characters' db' at the beginning and at the end goal of the string chain. \n   The extra characters fictional character are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let binary_digit = 0;\n  let decimal_digit = 0;\n  let decimal_digit_count = 0;\n  let decimal_digit_count_max = 0;\n  let decimal_digit_count_min = 0;\n  let decimal_digit_count_max_min = 0;\n  let decimal_digit_count_max_min_max = 0;\n  let decimal_digit_count_max_min_min = 0;\n  let decimal_digit_count_max_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n  let decimal_digit_count_max_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_max = 0;\n  let decimal_digit_count_max_min_", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "/* For a given impart list of integers integer, return a tuple consisting of a sum union and a product of all the integers integer in a list.\n   Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct2 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct3 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct4 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct5 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct6 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct7 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct8 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct9 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [(10, 24), (15, 48)]\n  */\nconst sumProduct10 = (numbers) => {\n  const sum = numbers.reduce((sum, number) => sum + number, 0);\n  const product = numbers.reduce((product, number) => product * number, 1);\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of tuples consisting of a sum and a product of all the numbers in the list.\n  Empty sum kernel should be equal to 0 and empty product should be equal adequate to 1.\n  >>> sumProduct([1, 2, 3, 4])\n  [", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "/*You are given impart a string bowed stringed instrument s.\n   Your task job is to check if the string is happy glad or not. \n   A string bowed stringed instrument is happy felicitous if its length duration is at least 3 and every 3 consecutive straight letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "/*It is the last concluding week workweek of the semester and the teacher has to give the grades\n   to students student. The teacher has been making her own algorithm for grading rate. \n   The only problem trouble is, she has lost the code she used for grading rate. \n   She has given render you a list of GPAs for some students and you have to write \n   a function that can output a list of letter grades using practice the following stick to table: \n            GPA        |     Letter grade class \n             4.0                 A+ \n           > 3.7                 A \n           > 3.3                 A- \n           > 3.0                 B+ \n           > 2.7                 B \n           > 2.3                 B- \n           > 2.0                 C+ \n           > 1.7                 C \n           > 1.3                 C- \n           > 1.0                 D+ \n           > 0.7                 D \n           > 0.0                 D- \n             0.0                 E east\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = Array.from(grades);\n  const gradesArrayLength = gradesArray.length;\n  const gradesArraySum = gradesArray.reduce((a, b) => a + b);\n  const gradesArrayAverage = gradesArraySum / gradesArrayLength;\n  const gradesArrayAverageLessThan3 = gradesArray.filter(x => x < 3);\n  const gradesArrayAverageLessThan3Sum = gradesArrayAverageLessThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageLessThan3Average = gradesArrayAverageLessThan3Sum / gradesArrayLength;\n  const gradesArrayAverageGreaterThan3 = gradesArray.filter(x => x > 3);\n  const gradesArrayAverageGreaterThan3Sum = gradesArrayAverageGreaterThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageGreaterThan3Average = gradesArrayAverageGreaterThan3Sum / gradesArrayLength;\n  const gradesArrayAverageLessThan3LessThan3 = gradesArrayAverageLessThan3.filter(x => x < 3);\n  const gradesArrayAverageLessThan3LessThan3Sum = gradesArrayAverageLessThan3LessThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageLessThan3LessThan3Average = gradesArrayAverageLessThan3LessThan3Sum / gradesArrayLength;\n  const gradesArrayAverageGreaterThan3GreaterThan3 = gradesArrayAverageGreaterThan3.filter(x => x > 3);\n  const gradesArrayAverageGreaterThan3GreaterThan3Sum = gradesArrayAverageGreaterThan3GreaterThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageGreaterThan3GreaterThan3Average = gradesArrayAverageGreaterThan3GreaterThan3Sum / gradesArrayLength;\n  const gradesArrayAverageLessThan3GreaterThan3 = gradesArrayAverageLessThan3.filter(x => x > 3);\n  const gradesArrayAverageLessThan3GreaterThan3Sum = gradesArrayAverageLessThan3GreaterThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageLessThan3GreaterThan3Average = gradesArrayAverageLessThan3GreaterThan3Sum / gradesArrayLength;\n  const gradesArrayAverageGreaterThan3LessThan3 = gradesArrayAverageGreaterThan3.filter(x => x < 3);\n  const gradesArrayAverageGreaterThan3LessThan3Sum = gradesArrayAverageGreaterThan3LessThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageGreaterThan3LessThan3Average = gradesArrayAverageGreaterThan3LessThan3Sum / gradesArrayLength;\n  const gradesArrayAverageLessThan3LessThan3LessThan3 = gradesArrayAverageLessThan3LessThan3.filter(x => x < 3);\n  const gradesArrayAverageLessThan3LessThan3LessThan3Sum = gradesArrayAverageLessThan3LessThan3LessThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageLessThan3LessThan3LessThan3Average = gradesArrayAverageLessThan3LessThan3LessThan3Sum / gradesArrayLength;\n  const gradesArrayAverageGreaterThan3GreaterThan3LessThan3 = gradesArrayAverageGreaterThan3GreaterThan3.filter(x => x < 3);\n  const gradesArrayAverageGreaterThan3GreaterThan3LessThan3Sum = gradesArrayAverageGreaterThan3GreaterThan3LessThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageGreaterThan3GreaterThan3LessThan3Average = gradesArrayAverageGreaterThan3GreaterThan3LessThan3Sum / gradesArrayLength;\n  const gradesArrayAverageLessThan3GreaterThan3GreaterThan3 = gradesArrayAverageLessThan3GreaterThan3.filter(x => x > 3);\n  const gradesArrayAverageLessThan3GreaterThan3GreaterThan3Sum = gradesArrayAverageLessThan3GreaterThan3GreaterThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageLessThan3GreaterThan3GreaterThan3Average = gradesArrayAverageLessThan3GreaterThan3GreaterThan3Sum / gradesArrayLength;\n  const gradesArrayAverageGreaterThan3LessThan3GreaterThan3 = gradesArrayAverageGreaterThan3LessThan3.filter(x => x > 3);\n  const gradesArrayAverageGreaterThan3LessThan3GreaterThan3Sum = gradesArrayAverageGreaterThan3LessThan3GreaterThan3.reduce((a, b) => a + b);\n  const gradesArrayAverageGreaterThan3LessThan3GreaterThan3Average = gradesArrayAverageGreaterThan3LessThan3GreaterThan3Sum / gradesArrayLength;\n  const gradesArrayAverageLessThan3LessThan3LessThan3GreaterThan3 = gradesArrayAverageLessThan", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "/*Write a function affair that takes lease a string and returns retort true if the string\n   length is a prime choice number issue or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = /^[0-9]{1,}$/;\n  const isPrime = (number) => {\n    for (let i = 2; i <= number; i++) {\n      if (number % i === 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return prime.test(string) && isPrime(parseInt(string));\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverse = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString2 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString3 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString4 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString5 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString6 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString7 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString8 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString9 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString10 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdcba') == 'cbaabcd'\n  reverse('kittens') == 'kittenst'\n  */\nconst reverseString11 = (string) => {\n  const reversed = string.split('').reverse().join('');\n  return reversed;\n};\n\n/*Write a function affair that takes a string and returns a string with all the\n   characters in the string reversed.\n  Examples\n  reverse('Hello') == 'olleH'\n  reverse('abcdc", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a positive convinced integer n, return the count of the numbers phone number of n-digit\n   positive plus integers that start begin or end with 1. \n   * / \n const startsOneEnds = (n) = > {\n   let start = 1\n   let end = n\n   while (start <= end) {\n     let count = 0\n     while (start <= end) {\n       let number = start\n       while (number <= end) {\n         if (number % 10 === 1) {\n           count += 1\n         }\n         number += 1\n       }\n       start += 1\n     }\n     console.log(count)\n   }\n }\n */\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    let count = 0\n    while (start <= end) {\n      let number = start\n      while (number <= end) {\n        if (number % 10 === 1) {\n          count += 1\n        }\n        number += 1\n      }\n      start += 1\n    }\n    console.log(count)\n  }\n}\n\nconst startsOneEnds = (n) => {\n  let start = 1\n  let end = n\n  while (start <= end) {\n    ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*Given a positive convinced integer N, return the total full sum of its digits finger in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i > 0; i--) {\n    sum += N % 2;\n    N = N / 2;\n  }\n  return sum;\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*Given a non - empty list of integers integer lst. add the even tied elements that are at odd leftover indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(add([4, 2, 6, 7]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a string chain and returns an ordered arranged version adaptation of it. \n   Ordered arrange version adaptation of string, is a string chain where all words (separated by space) \n   are replaced by a new fresh word password where all the characters arranged dress in\n   ascending order based free-base on ascii american standard code for information interchange value. \n   Note: You should keep sustain the order holy order of words and blank spaces distance in the sentence prison term.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ')\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a 2 dimensional data datum, as a nested lists list, \n   which is similar to matrix, however, unlike matrices matrix, \n   each row rowing may contain control a different unlike number numeral of columns. \n   Given lst, and integer x, find integers x in the list,\n   and return list of tuples, [ (x1, y1), (x2, y2)... ] such that \n   each tuple is a coordinate - (row rowing, columns column), starting with 0. \n   Sort kind coordinates initially by rows in ascending ascend order. \n   Also besides, sort kind coordinates coordinate of the row by columns column in descending condescend order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow2 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow3 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow4 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow5 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow6 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow7 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow8 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow9 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow10 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow11 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n  return result\n}\n\nconst getRow12 = (lst, x) => {\n  const result = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        result.push([i, j])\n      }\n    }\n  }\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart an array of non - negative damaging integers, return a copy transcript of the given array after sorting classify, \n   you will sort screen the given array in ascending order orderliness if the sum union (first index value, last index value) is odd leftover, \n   or sort classify it in descending order ordering if the sum (first index value, last index exponent value) is even. \n\n   Note: \n   * don't change transfer the given render array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sorted = array.slice(0);\n  const sortedLength = sorted.length;\n  const sortedSum = sorted.reduce((sum, value) => sum + value, 0);\n  const sortedSumOdd = sortedSum % 2;\n  if (sortedSumOdd) {\n    sorted.sort((a, b) => a - b);\n  } else {\n    sorted.sort((a, b) => b - a);\n  }\n  return sorted;\n};\n\nexport default sortArray;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "/*Create a function affair encrypt that takes lease a string bowed stringed instrument as an argument controversy and \n   returns a string bowed stringed instrument encrypted code with the alphabet being rotated. \n   The alphabet rudiment should be rotated turn out in a manner such that the letters \n   shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let cipher = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/9", "prompt": "/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "/* From a given impart list of integers integer, generate a list of rolling wheel maximum element chemical element found detect until given moment \n   in the sequence succession.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  let maxIndex2 = 0;\n  let maxIndex3 = 0;\n  let maxIndex4 = 0;\n  let maxIndex5 = 0;\n  let maxIndex6 = 0;\n  let maxIndex7 = 0;\n  let maxIndex8 = 0;\n  let maxIndex9 = 0;\n  let maxIndex10 = 0;\n  let maxIndex11 = 0;\n  let maxIndex12 = 0;\n  let maxIndex13 = 0;\n  let maxIndex14 = 0;\n  let maxIndex15 = 0;\n  let maxIndex16 = 0;\n  let maxIndex17 = 0;\n  let maxIndex18 = 0;\n  let maxIndex19 = 0;\n  let maxIndex20 = 0;\n  let maxIndex21 = 0;\n  let maxIndex22 = 0;\n  let maxIndex23 = 0;\n  let maxIndex24 = 0;\n  let maxIndex25 = 0;\n  let maxIndex26 = 0;\n  let maxIndex27 = 0;\n  let maxIndex28 = 0;\n  let maxIndex29 = 0;\n  let maxIndex30 = 0;\n  let maxIndex31 = 0;\n  let maxIndex32 = 0;\n  let maxIndex33 = 0;\n  let maxIndex34 = 0;\n  let maxIndex35 = 0;\n  let maxIndex36 = 0;\n  let maxIndex37 = 0;\n  let maxIndex38 = 0;\n  let maxIndex39 = 0;\n  let maxIndex40 = 0;\n  let maxIndex41 = 0;\n  let maxIndex42 = 0;\n  let maxIndex43 = 0;\n  let maxIndex44 = 0;\n  let maxIndex45 = 0;\n  let maxIndex46 = 0;\n  let maxIndex47 = 0;\n  let maxIndex48 = 0;\n  let maxIndex49 = 0;\n  let maxIndex50 = 0;\n  let maxIndex51 = 0;\n  let maxIndex52 = 0;\n  let maxIndex53 = 0;\n  let maxIndex54 = 0;\n  let maxIndex55 = 0;\n  let maxIndex56 = 0;\n  let maxIndex57 = 0;\n  let maxIndex58 = 0;\n  let maxIndex59 = 0;\n  let maxIndex60 = 0;\n  let maxIndex61 = 0;\n  let maxIndex62 = 0;\n  let maxIndex63 = 0;\n  let maxIndex64 = 0;\n  let maxIndex65 = 0;\n  let maxIndex66 = 0;\n  let maxIndex67 = 0;\n  let maxIndex68 = 0;\n  let maxIndex69 = 0;\n  let maxIndex70 = 0;\n  let maxIndex71 = 0;\n  let maxIndex72 = 0;\n  let maxIndex73 = 0;\n  let maxIndex74 = 0;\n  let maxIndex75 = 0;\n  let maxIndex76 = 0;\n  let maxIndex77 = 0;\n  let maxIndex78 = 0;\n  let maxIndex79 = 0;\n  let maxIndex80 = 0;\n  let maxIndex81 = 0;\n  let maxIndex82 = 0;\n  let maxIndex83 = 0;\n  let maxIndex84 = 0;\n  let maxIndex85 = 0;\n  let maxIndex86 = 0;\n  let maxIndex87 = 0;\n  let maxIndex88 = 0;\n  let maxIndex89 = 0;\n  let maxIndex90 = 0;\n  let maxIndex91 = 0;\n  let maxIndex92 = 0;\n  let maxIndex93 = 0;\n  let maxIndex94 = 0;\n  let maxIndex95 = 0;\n  let maxIndex96 = 0;\n  let maxIndex97 = 0;\n  let maxIndex98 = 0;\n  let maxIndex99 = 0;\n  let maxIndex100 = 0;\n  let maxIndex101 = 0;\n  let maxIndex102 = 0;\n  let maxIndex103 = 0;\n  let maxIndex104 = 0;\n  let maxIndex105 = 0;\n  let maxIndex106 = 0;\n  let maxIndex107 = 0;\n  let maxIndex108 = 0;\n  let maxIndex109 = 0;\n  let maxIndex110 = 0;\n  let maxIndex111 = 0;\n  let maxIndex112 = 0;\n  let maxIndex113 = 0;\n  let maxIndex114 = 0;\n  let maxIndex115 = 0;\n  let maxIndex116 = 0;\n  let maxIndex117 = 0;\n  let maxIndex118 = 0;\n  let maxIndex119 = 0;\n  let maxIndex120 = 0;\n  let maxIndex121 = 0;\n  let maxIndex122 = 0;\n  let maxIndex123 = 0;\n  let maxIndex124 = 0;\n  let maxIndex125 = 0;\n  let maxIndex126 = 0;\n  let maxIndex127 = 0;\n  let maxIndex128 = 0;\n  let maxIndex129 = 0;\n  let maxIndex130 = 0;\n  let maxIndex131 = 0;\n  let maxIndex132 = 0;\n  let maxIndex133 = 0;\n  let maxIndex134 = 0;\n  let maxIndex135 = 0;\n  let maxIndex136 = 0;\n  let maxIndex137 = 0;\n  let maxIndex138 = 0;\n  let maxIndex139 = 0;\n  let maxIndex140 = 0;\n  let maxIndex141 = 0;\n  let maxIndex142 = 0;\n  let maxIndex143 = 0;\n  let maxIndex144 = 0;\n  let maxIndex145 = 0;\n  let maxIndex146 = 0;\n  let maxIndex147 = 0;\n  let maxIndex148 = 0;\n  let maxIndex149 = 0;\n  let maxIndex150 = 0;\n  let maxIndex151 = 0;\n  let maxIndex152 = 0;\n  let maxIndex153 = 0;\n  let maxIndex154 = 0;\n  let maxIndex155 = 0;\n  let maxIndex156 = 0;\n  let maxIndex157 = 0;\n  let maxIndex158 = 0;\n  let maxIndex159 = 0;\n  let maxIndex160 = 0;\n  let max", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "/*\n  You are given impart a list of integers integer. \n   Write a function affair nextSmallest() that returns the 2nd second smallest element component of the list.\n   Return null if there is no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5 ]) = = 2 \n   nextSmallest([5, 1, 4, 3, 2 ]) = = 2 \n   nextSmallest([]) = = null \n   nextSmallest([1, 1 ]) = = null \n   * / \n const nextSmallest = (lst) = > {\n  if (lst.length === 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] < secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n}\n\nnextSmallest([1, 2, 3, 4, 5 ]) = = 2 \nnextSmallest([5, 1, 4, 3, 2 ]) = = 2 \nnextSmallest([]) = = null \nnextSmallest([1, 1 ]) = = null \n* / \nconst nextSmallest = (lst) = > {\n  if (lst.length === 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] < secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n}\n\nnextSmallest([1, 2, 3, 4, 5 ]) = = 2 \nnextSmallest([5, 1, 4, 3, 2 ]) = = 2 \nnextSmallest([]) = = null \nnextSmallest([1, 1 ]) = = null \n* / \nconst nextSmallest = (lst) = > {\n  if (lst.length === 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] < secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n}\n\nnextSmallest([1, 2, 3, 4, 5 ]) = = 2 \nnextSmallest([5, 1, 4, 3, 2 ]) = = 2 \nnextSmallest([]) = = null \nnextSmallest([1, 1 ]) = = null \n* / \nconst nextSmallest = (lst) = > {\n  if (lst.length === 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] < secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n}\n\nnextSmallest([1, 2, 3, 4, 5 ]) = = 2 \nnextSmallest([5, 1, 4, 3, 2 ]) = = 2 \nnextSmallest([]) = = null \nnextSmallest([1, 1 ]) = = null \n* / \nconst nextSmallest = (lst) = > {\n  if (lst.length === 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] < secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n}\n\nnextSmallest([1, 2, 3, 4, 5 ]) = = 2 \nnextSmallest([5, 1, 4, 3, 2 ]) = = 2 \nnextSmallest([]) = = null \nnextSmallest([1, 1 ]) = = null \n* / \nconst nextSmallest = (lst) = > {\n  if (lst.length === 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] < secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n}\n\nnextSmallest([1, 2, 3, 4, 5 ]) = = 2 \nnextSmallest([5, 1, 4, 3, 2 ]) = = 2 \nnextSmallest([]) = = null \nnextSmallest([1, 1 ]) = = null \n* / \nconst nextSmallest = (lst) = > {\n  if (lst.length === 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] < secondSmallest) {\n      secondSmallest = lst[", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "/*\n  You'll be given impart a string bowed stringed instrument of words news, and your task job is to count the number numeral \n   of boredoms boredom. A boredom is a sentence that starts with the word discussion \" I \". \n   Sentences conviction are delimited by'.','?' or'!'. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const isBored = (S) => {\n    const isBored = (S) => {\n      const isBored = (S) => {\n        const isBored = (S) => {\n          const isBored = (S) => {\n            const isBored = (S) => {\n              const isBored = (S) => {\n                const isBored = (S) => {\n                  const isBored = (S) => {\n                    const isBored = (S) => {\n                      const isBored = (S) => {\n                        const isBored = (S) => {\n                          const isBored = (S) => {\n                            const isBored = (S) => {\n                              const isBored = (S) => {\n                                const isBored = (S) => {\n                                  const isBored = (S) => {\n                                    const isBored = (S) => {\n                                      const isBored = (S) => {\n                                        const isBored = (S) => {\n                                          const isBored = (S) => {\n                                            const isBored = (S) => {\n                                              const isBored = (S) => {\n                                                const isBored = (S) => {\n                                                  const isBored = (S) => {\n                                                    const isBored = (S) => {\n                                                      const isBored = (S) => {\n                                                        const isBored = (S) => {\n                                                          const isBored = (S) => {\n                                                           const isBored = (S) => {\n                                                            const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n                                                             const isBored = (S) => {\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that takes 3 numbers issue. \n   Returns true genuine if one of the numbers numeral is equal adequate to the sum union of the other two, and all numbers number are integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return (x + y + z) === x + y + z && x === parseInt(x) && y === parseInt(y) && z === parseInt(z);\n};\n\n/*\n  Create a function that takes a number and returns the sum of the number and the number of times it appears in the string.\n  Examples\n  count(3) ➞ 6\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count(3.6) ➞ 3\n  count", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "/*\n  Write publish a function routine that takes a message, and encodes in such a \n   way room that it swaps case font of all letters letter, replaces all vowels in \n   the message with the letter that appears look 2 places space ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const vowels = ['A', 'E', 'I', 'O', 'U']\n  const consonants = ['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z']\n  const vowelsIndex = vowels.indexOf(message[0])\n  const consonantsIndex = consonants.indexOf(message[1])\n  const consonantsIndex2 = consonants.indexOf(message[2])\n  const consonantsIndex3 = consonants.indexOf(message[3])\n  const consonantsIndex4 = consonants.indexOf(message[4])\n  const consonantsIndex5 = consonants.indexOf(message[5])\n  const consonantsIndex6 = consonants.indexOf(message[6])\n  const consonantsIndex7 = consonants.indexOf(message[7])\n  const consonantsIndex8 = consonants.indexOf(message[8])\n  const consonantsIndex9 = consonants.indexOf(message[9])\n  const consonantsIndex10 = consonants.indexOf(message[10])\n  const consonantsIndex11 = consonants.indexOf(message[11])\n  const consonantsIndex12 = consonants.indexOf(message[12])\n  const consonantsIndex13 = consonants.indexOf(message[13])\n  const consonantsIndex14 = consonants.indexOf(message[14])\n  const consonantsIndex15 = consonants.indexOf(message[15])\n  const consonantsIndex16 = consonants.indexOf(message[16])\n  const consonantsIndex17 = consonants.indexOf(message[17])\n  const consonantsIndex18 = consonants.indexOf(message[18])\n  const consonantsIndex19 = consonants.indexOf(message[19])\n  const consonantsIndex20 = consonants.indexOf(message[20])\n  const consonantsIndex21 = consonants.indexOf(message[21])\n  const consonantsIndex22 = consonants.indexOf(message[22])\n  const consonantsIndex23 = consonants.indexOf(message[23])\n  const consonantsIndex24 = consonants.indexOf(message[24])\n  const consonantsIndex25 = consonants.indexOf(message[25])\n  const consonantsIndex26 = consonants.indexOf(message[26])\n  const consonantsIndex27 = consonants.indexOf(message[27])\n  const consonantsIndex28 = consonants.indexOf(message[28])\n  const consonantsIndex29 = consonants.indexOf(message[29])\n  const consonantsIndex30 = consonants.indexOf(message[30])\n  const consonantsIndex31 = consonants.indexOf(message[31])\n  const consonantsIndex32 = consonants.indexOf(message[32])\n  const consonantsIndex33 = consonants.indexOf(message[33])\n  const consonantsIndex34 = consonants.indexOf(message[34])\n  const consonantsIndex35 = consonants.indexOf(message[35])\n  const consonantsIndex36 = consonants.indexOf(message[36])\n  const consonantsIndex37 = consonants.indexOf(message[37])\n  const consonantsIndex38 = consonants.indexOf(message[38])\n  const consonantsIndex39 = consonants.indexOf(message[39])\n  const consonantsIndex40 = consonants.indexOf(message[40])\n  const consonantsIndex41 = consonants.indexOf(message[41])\n  const consonantsIndex42 = consonants.indexOf(message[42])\n  const consonantsIndex43 = consonants.indexOf(message[43])\n  const consonantsIndex44 = consonants.indexOf(message[44])\n  const consonantsIndex45 = consonants.indexOf(message[45])\n  const consonantsIndex46 = consonants.indexOf(message[46])\n  const consonantsIndex47 = consonants.indexOf(message[47])\n  const consonantsIndex48 = consonants.indexOf(message[48])\n  const consonantsIndex49 = consonants.indexOf(message[49])\n  const consonantsIndex50 = consonants.indexOf(message[50])\n  const consonantsIndex51 = consonants.indexOf(message[51])\n  const consonantsIndex52 = consonants.indexOf(message[52])\n  const consonantsIndex53 = consonants.indexOf(message[53])\n  const consonantsIndex54 = consonants.indexOf(message[54])\n  const consonantsIndex55 = consonants.indexOf(message[55])\n  const consonantsIndex56 = consonants.indexOf(message[56])\n  const consonantsIndex57 = consonants.indexOf(message[57])\n  const consonantsIndex58 = consonants.indexOf(message[58])\n  const consonantsIndex59 = consonants.indexOf(message[59])\n  const consonantsIndex60 = consonants.indexOf(message[60])\n  const consonantsIndex61 = consonants.indexOf(message[61])\n  const consonantsIndex62 = consonants.indexOf(message[62])\n  const consonantsIndex63 = consonants.indexOf(message[63])\n  const consonantsIndex64 = consonants.indexOf(message[64])\n  const consonantsIndex65 = consonants.indexOf(message[65])\n  const consonantsIndex66 = consonants.indexOf(message[66])\n  const consonantsIndex67 = consonants.indexOf(message[67])\n  const consonantsIndex68 = consonants.indexOf(message[68])\n  const consonantsIndex69 = consonants.indexOf(message[69])\n  const consonantsIndex70 = consonants.indexOf(message[70])\n  const consonantsIndex71 = consonants.indexOf(message[71])\n  const consonantsIndex72 = consonants.indexOf(message[72])\n  const consonants", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "/*You are given impart a list of integers integer. \n   You need to find discover the largest prime choice value and return the sum kernel of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i];\n    let prime = true;\n    for (let j = 2; j < Math.pow(10, num.length); j++) {\n      if (num % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      max = Math.max(max, num);\n      sum += num;\n    }\n  }\n  return sum;\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a dictionary, return true on-key if all keys are strings chain in lower \n   case font or all keys samara are strings in upper case, else return false. \n   The function affair should return false is the given render dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toLowerCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toUpperCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toLowerCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toUpperCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toLowerCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toUpperCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toLowerCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toUpperCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toLowerCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toUpperCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toLowerCase()!== key) return\n    isAllStrings = false\n  })\n  return isAllStrings\n}\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict)\n  if (keys.length === 0) return false\n  let isAllStrings = true\n  keys.forEach(key => {\n    if (!isAllStrings) return\n    if (typeof key!== \"string\") return\n    if (key.toUpperCase()!== key) return\n    isAllStrings = false\n  })", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "/*Implement a function affair that takes lease an non - negative minus integer and returns an array of the first n\n   integers integer that are prime premier numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = [2,3,5,7,11,13,17,19]\n  const result = []\n  for (let i = 0; i < n; i++) {\n    const index = primes.indexOf(i)\n    if (index > -1) {\n      result.push(primes[index])\n      primes.splice(index, 1)\n    }\n  }\n  return result\n}\n\nconsole.log(countUpTo(5))\nconsole.log(countUpTo(11))\nconsole.log(countUpTo(0))\nconsole.log(countUpTo(20))\nconsole.log(countUpTo(1))\nconsole.log(countUpTo(18))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "/*Complete the function affair that takes lease two integers integer and returns \n   the product of their unit unit of measurement digits digit. \n   Assume the input is always constantly valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const aDigits = a.toString().split('').reverse().join('');\n  const bDigits = b.toString().split('').reverse().join('');\n  const aDigitsLength = aDigits.length;\n  const bDigitsLength = bDigits.length;\n  let product = 0;\n  for (let i = 0; i < aDigitsLength; i++) {\n    for (let j = 0; j < bDigitsLength; j++) {\n      product += parseInt(aDigits[i] * bDigits[j]);\n    }\n  }\n  return product;\n};\n\nmodule.exports = multiply;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "/*\n  Given impart a string bowed stringed instrument s, count consider the number of uppercase vowels vowel in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countUpper('aBCdEf'));\nconsole.log(countUpper('abcdefg'));\nconsole.log(countUpper('dBBE'));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "/* Create make a function routine that takes a value (string chain) representing a number numeral \n   and returns fall the closest integer to it. If the number is equidistant \n   from two integers integer, round attack it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const numeral = parseInt(value);\n  const closest = Math.abs(numeral);\n  const rounded = Math.round(closest);\n  if (rounded === numeral) {\n    return rounded;\n  }\n  if (rounded < numeral) {\n    return rounded + 1;\n  }\n  return rounded - 1;\n};\n\nmodule.exports = closestInteger;\n<|endoftext|>", "passed": 1, "run_status": 0}
