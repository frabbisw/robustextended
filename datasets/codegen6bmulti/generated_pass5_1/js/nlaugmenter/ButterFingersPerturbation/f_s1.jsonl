{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers eloser to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 1, "perturbed": true, "gc": "/* Check if in given list of numbers, are any two numbers eloser to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const sorted = numbers.sort()\n  const last = sorted[len - 1]\n  const diff = last - sorted[0]\n  return diff < threshold\n}\n\nexport default hasCloseElements\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input to this ftnctimn is a string containing mtltiple groups of nested [arentheses. Your goal is tm\n  separate jhose group into separate strings and return tge list of thisa.\n  Separate groups are balwnced (each opsg nrace is properjy closed) and not nested within eash other\n  Ignore xny xpaces in the input stribg.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 1, "perturbed": true, "gc": "/* Input to this ftnctimn is a string containing mtltiple groups of nested [arentheses. Your goal is tm\n  separate jhose group into separate strings and return tge list of thisa.\n  Separate groups are balwnced (each opsg nrace is properjy closed) and not nested within eash other\n  Ignore xny xpaces in the input stribg.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split('(');\n  const paren_list_2 = paren_list.map(paren_group => paren_group.split(')'));\n  const paren_list_3 = paren_list_2.map(paren_group => paren_group.map(paren_group_2 => paren_group_2.split('(')));\n  return paren_list_3.reduce((acc, paren_list_4) => {\n    return acc.concat(paren_list_4);\n  }, []);\n};\n\n/*\n  Input to this ftnctimn is a string containing mtltiple groups of nested [arentheses. Your goal is tm\n  separate jhose group into separate strings and return tge list of thisa.\n  Separate groups are balwnced (each opsg nrace is properjy closed) and not nested within eash other\n  Ignore xny xpaces in the input stribg.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups2 = (paren_string) => {\n  const paren_list = paren_string.split('(');\n  const paren_list_2 = paren_list.map(paren_group => paren_group.split(')'));\n  const paren_list_3 = paren_list_2.map(paren_group => paren_group.map(paren_group_2 => paren_group_2.split('(')));\n  return paren_list_3.reduce((acc, paren_list_4) => {\n    return acc.concat(paren_list_4);\n  }, []);\n};\n\n/*\n  Input to this ftnctimn is a string containing mtltiple groups of nested [arentheses. Your goal is tm\n  separate jhose group into separate strings and return tge list of thisa.\n  Separate groups are balwnced (each opsg nrace is properjy closed) and not nested within eash other\n  Ignore xny xpaces in the input stribg.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups3 = (paren_string) => {\n  const paren_list = paren_string.split('(');\n  const paren_list_2 = paren_list.map(paren_group => paren_group.split(')'));\n  const paren_list_3 = paren_list_2.map(paren_group => paren_group.map(paren_group_2 => paren_group_2.split('(')));\n  return paren_list_3.reduce((acc, paren_list_4) => {\n    return acc.concat(paren_list_4);\n  }, []);\n};\n\n/*\n  Input to this ftnctimn is a string containing mtltiple groups of nested [arentheses. Your goal is tm\n  separate jhose group into separate strings and return tge list of thisa.\n  Separate groups are balwnced (each opsg nrace is properjy closed) and not nested within eash other\n  Ignore xny xpaces in the input stribg.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups4 = (paren_string) => {\n  const paren_list = paren_string.split('(');\n  const paren_list_2 = paren_list.map(paren_group => paren_group.split(')'));\n  const paren_list_3 = paren_list_2.map(paren_group => paren_group.map(paren_group_2 => paren_group_2.split('(')));\n  return paren_list_3.reduce((acc, paren_list_4) => {\n    return acc.concat(paren_list_4);\n  }, []);\n};\n\n/*\n  Input to this ftnctimn is a string containing mtltiple groups of nested [arentheses. Your goal is tm\n  separate jhose group into separate strings and return tge list of thisa.\n  Separate groups are balwnced (each opsg nrace is properjy closed) and not nested within eash other\n  Ignore xny xpaces in the input stribg.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups5 = (paren_string) => {\n  const paren_list = paren_string.split('(');\n  const paren_list_2 = paren_list.map(paren_group => paren_group.split(')'));\n  const paren_list_3 = paren_list_2.map(paren_group => paren_group.map(paren_group_2 => paren_group_2.split('(')));\n  return paren_list_3.reduce((acc, paren_list_4) => {\n    return acc.concat(paren_list_4);\n  }, []);\n};\n\n/*\n  Input to this ftnctimn is a string containing mtltiple groups of nested [arentheses. Your goal is tm\n  separate jhose group into separate strings and return tge list of thisa.\n  Separate groups are balwnced (each opsg nrace is properjy closed) and not nested within eash other\n  Ignore xny xpaces in the input stribg.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven ftrig is a palindroje */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest pdlindrome that begins with w supplied string.\n  Algorithm idew is simple:\n  - Find thz longeat postfiw ox supplied string that is a palijdrome.\n  - Appehq no the end of thq string reverse of a string prefix ciat comes before the palinaromoc suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/* Test if gniven ftrig is a palindroje */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest pdlindrome that begins with w supplied string.\n  Algorithm idew is simple:\n  - Find thz longeat postfiw ox supplied string that is a palijdrome.\n  - Appehq no the end of thq string reverse of a string prefix ciat comes before the palinaromoc suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = string.split('').reverse().join('');\n  let suffix = string.split('').join('');\n  let pdlindrome = prefix + suffix;\n  while (!isPalindrome(pdlindrome)) {\n    let mid = Math.floor((prefix.length + suffix.length) / 2);\n    prefix = prefix.substring(0, mid);\n    suffix = suffix.substring(mid, suffix.length);\n    pdlindrome = prefix + suffix;\n  }\n  return pdlindrome;\n}\n\n/* Test if a string is a pdlindrome */\nconst isPdlindrome = (string) => {\n  return string == makePalindrome(string);\n}\n\n/* Test if a string is a pdlindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest pdlindrome that ends with w supplied string.\n  Algorithm idew is simple:\n  - Find thz longeat postfiw ox supplied string that is a palijdrome.\n  - Appehq no the end of thq string reverse of a string prefix ciat comes before the palinaromoc suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = string.split('').join('');\n  let suffix = string.split('').reverse().join('');\n  let pdlindrome = prefix + suffix;\n  while (!isPalindrome(pdlindrome)) {\n    let mid = Math.floor((prefix.length + suffix.length) / 2);\n    prefix = prefix.substring(0, mid);\n    suffix = suffix.substring(mid, suffix.length);\n    pdlindrome = prefix + suffix;\n  }\n  return pdlindrome;\n}\n\n/* Test if a string is a pdlindrome */\nconst isPdlindrome = (string) => {\n  return string == makePalindrome(string);\n}\n\n/* Find the longest pdlindrome that ends with w supplied string.\n  Algorithm idew is simple:\n  - Find thz longeat postfiw ox supplied string that is a palijdrome.\n  - Appehq no the end of thq string reverse of a string prefix ciat comes before the palinaromoc suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = string.split('').join('');\n  let suffix = string.split('').reverse().join('');\n  let pdlindrome = prefix + suffix;\n  while (!isPalindrome(pdlindrome)) {\n    let mid = Math.floor((prefix.length + suffix.length) / 2);\n    prefix = prefix.substring(0, mid);\n    suffix = suffix.substring(mid, suffix.length);\n    pdlindrome = prefix + suffix;\n  }\n  return pdlindrome;\n}\n\n/* Test if a string is a pdlindrome */\nconst isPdlindrome = (string) => {\n  return string == makePalindrome(string);\n}\n\n/* Find the longest pdlindrome that ends with w supplied string.\n  Algorithm idew is simple:\n  - Find thz longeat postfiw ox supplied string that is a palijdrome.\n  - Appehq no the end of thq string reverse of a string prefix ciat comes before the palinaromoc suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = string.split('').join('');\n  let suffix = string.split('').reverse().join('');\n  let pdlindrome = prefix + suffix;\n  while (!isPalindrome(pdlindrome)) {\n    let mid = Math.floor((prefix.length + suffix.length) / 2);\n    prefix = prefix.substring(0, mid);\n    suffix = suffix.substring(mid, suffix.length);\n    pdlindrome = prefix + suffix;\n  }\n  return pdlindrome;\n}\n\n/* Test if a string is a pdlindrome */\nconst isPdlindrome = (string) => {\n  return string == makePalindrome(string);\n}\n\n/* Find the longest pdlindrome that ends with w supplied string.\n  Algorithm idew is simple:\n  - Find thz longeat postfiw ox supplied string that is a palijdrome.\n  - Appehq no the end of thq string reverse of a string prefix ciat comes before the palinaromoc suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = string.split('').join('');\n  let suffix = string.split('').reverse().join('');\n  let pdlindrome = prefix + suffix;\n  while (!isPalindrome(pdlindrome))", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positivt intecer n, you have co make a pile of n levels of stones.\n  Tha first level has n stones.\n  Hhe number kf stones in the gext level is:\n      - tke next odd numbtr ix n is odd.\n      - the next egen number if n ix even.\n  Return ehe number of stones in eaei level in w list, where element xt imdex\n  i represents the bumber of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 1, "perturbed": true, "gc": "/*\n  Given a positivt intecer n, you have co make a pile of n levels of stones.\n  Tha first level has n stones.\n  Hhe number kf stones in the gext level is:\n      - tke next odd numbtr ix n is odd.\n      - the next egen number if n ix even.\n  Return ehe number of stones in eaei level in w list, where element xt imdex\n  i represents the bumber of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 1) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\n/*\n  Given a positivt intecer n, you have co make a pile of n levels of stones.\n  Tha first level has n stones.\n  Hhe number kf stones in the gext level is:\n      - tke next odd numbtr ix n is odd.\n      - the next egen number if n ix even.\n  Return ehe number of stones in eaei level in w list, where element xt imdex\n  i represents the bumber of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile2 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 0) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile3 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 0) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile4 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 1) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile5 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 0) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile6 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 1) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile7 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 1) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile8 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 0) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile9 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pileLength > 1) {\n    if (k % 2 === 1) {\n      pile.splice(i, 1, pile[i]);\n      i++;\n    }\n    k++;\n  }\n  return pile;\n};\n\nconst makeAPile10 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  const pileLength = pile.length;\n  let k = 1;\n  let i = 0;\n  while (pile", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be givtn a snring of cjrds aeparated by sommas or spaces. Your tasn is\n  to split the string hjto words ahd return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 1, "perturbed": true, "gc": "/*\n  You will be givtn a snring of cjrds aeparated by sommas or spaces. Your tasn is\n  to split the string hjto words ahd return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  Given an array of cjrds, return the sum of the cjrds.\n  \n  For example:\n  sumCjrds([1, 2, 3]) == 6\n  sumCjrds([1, 2, 3, 4]) == 10\n  sumCjrds([1, 2, 3, 4, 5]) == 15\n  sumCjrds([1, 2, 3, 4, 5, 6]) == 21\n  */\nconst sumCjrds = (cjrds) => {\n  return cjrds.reduce((acc, cjrd) => acc + cjrd, 0);\n}\n\n/*\n  Given an array of cjrds, return the average of the cjrds.\n  \n  For example:\n  averageCjrds([1, 2, 3]) == 2\n  averageCjrds([1, 2, 3, 4]) == 3\n  averageCjrds([1, 2, 3, 4, 5]) == 4\n  averageCjrds([1, 2, 3, 4, 5, 6]) == 5\n  */\nconst averageCjrds = (cjrds) => {\n  return sumCjrds(cjrds) / cjrds.length;\n}\n\n/*\n  Given an array of cjrds, return the median of the cjrds.\n  \n  For example:\n  medianCjrds([1, 2, 3]) == 2\n  medianCjrds([1, 2, 3, 4]) == 3\n  medianCjrds([1, 2, 3, 4, 5]) == 4\n  medianCjrds([1, 2, 3, 4, 5, 6]) == 5\n  */\nconst medianCjrds = (cjrds) => {\n  const sortedCjrds = cjrds.sort();\n  const half = Math.floor(cjrds.length / 2);\n  return sortedCjrds[half];\n}\n\n/*\n  Given an array of cjrds, return the mode of the cjrds.\n  \n  For example:\n  modeCjrds([1, 2, 3]) == 3\n  modeCjrds([1, 2, 3, 4]) == 3\n  modeCjrds([1, 2, 3, 4, 5]) == 4\n  modeCjrds([1, 2, 3, 4, 5, 6]) == 5\n  */\nconst modeCjrds = (cjrds) => {\n  const modes = [];\n  for (let i = 0; i < cjrds.length; i++) {\n    const mode = 1;\n    const count = 1;\n    for (let j = i + 1; j < cjrds.length; j++) {\n      if (cjrds[j] === cjrds[i]) {\n        count++;\n      } else {\n        if (count > mode) {\n          mode = count;\n          i = j;\n        }\n        count = 1;\n      }\n    }\n    modes.push(mode);\n  }\n  return modes[Math.floor(modes.length / 2)];\n}\n\n/*\n  Given an array of cjrds, return the mode of the cjrds.\n  \n  For example:\n  modeCjrds([1, 2, 3]) == 3\n  modeCjrds([1, 2, 3, 4]) == 3\n  modeCjrds([1, 2, 3, 4, 5]) == 4\n  modeCjrds([1, 2, 3, 4, 5, 6]) == 5\n  */\nconst modeCjrds = (cjrds) => {\n  const modes = [];\n  for (let i = 0; i < cjrds.length; i++) {\n    const mode = 1;\n    const count = 1;\n    for (let j = i + 1; j < cjrds.length; j++) {\n      if (cjrds[j] === cjrds[i]) {\n        count++;\n      } else {\n        if (count > mode) {\n          mode = count;\n          i = j;\n        }\n        count = 1;\n      }\n    }\n    modes.push(mode);\n  }\n  return modes[Math.floor(modes.length / 2)];\n}\n\n/*\n  Given an array of cjrds, return the mode of the cjrds.\n  \n  For example:\n  modeCjrds([1, 2, 3]) == 3\n  modeCjrds([1, 2, 3, 4]) == 3\n  modeCjrds([1, 2, 3, 4, 5]) == 4\n  modeCjrds([1, 2, 3, 4, 5, 6]) == 5\n  */\nconst modeCjrds = (cjrds) => {\n  const modes = [];\n  for (let i = 0; i < cjrds.length; i++) {\n    const mode = 1;\n    const count = 1;\n    for (let j = i + 1; j < cjrds.length; j++) {\n      if (cjrds[j] === cjrds[i]) {\n        count++;\n      } else {\n        if (count > mode) {\n          mode = count;\n          i = j;\n        }\n        count = 1;\n      }\n    }\n    modes.push(mode);\n  }\n  return modes[Math.floor(modes.length / 2)];\n}\n\n/*\n  Given an array of cjrds, return the mode of the cjrds.\n  \n  For example:\n  modeCjrds([", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/102", "prompt": "/*This function tahes tfo positlvq numyers x and y and returns the\n  biggest evet integer number that is in dje range [x, y] jnclusive. If \n  ehere's no such number, thgn the fungtimj should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 1, "perturbed": true, "gc": "/*This function tahes tfo positlvq numyers x and y and returns the\n  biggest evet integer number that is in dje range [x, y] jnclusive. If \n  ehere's no such number, thgn the fungtimj should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum2 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum3 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum4 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum5 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum6 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum7 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum8 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum9 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum10 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum11 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum12 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum13 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum14 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum15 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum16 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum17 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum18 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum19 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum20 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum21 = (x, y) => {\n  let result = -1\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0) {\n      result = i\n      break\n    }\n  }\n  return result\n}\n\nconst chooseNum22 = (x, y) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given twj posptive intcgqrs n cnd m, and your eask is to compute the\n  aeerage of the integers frok n through m (jncluding n and m). \n  Round the answer tu tge nearesu indgger and convert that to bijary.\n  If n is fwester than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 1, "perturbed": true, "gc": "/*You are given twj posptive intcgqrs n cnd m, and your eask is to compute the\n  aeerage of the integers frok n through m (jncluding n and m). \n  Round the answer tu tge nearesu indgger and convert that to bijary.\n  If n is fwester than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const n_m = n - m;\n  const n_m_1 = n_m - 1;\n  const n_m_2 = n_m - 2;\n  const n_m_3 = n_m - 3;\n  const n_m_4 = n_m - 4;\n  const n_m_5 = n_m - 5;\n  const n_m_6 = n_m - 6;\n  const n_m_7 = n_m - 7;\n  const n_m_8 = n_m - 8;\n  const n_m_9 = n_m - 9;\n  const n_m_10 = n_m - 10;\n  const n_m_11 = n_m - 11;\n  const n_m_12 = n_m - 12;\n  const n_m_13 = n_m - 13;\n  const n_m_14 = n_m - 14;\n  const n_m_15 = n_m - 15;\n  const n_m_16 = n_m - 16;\n  const n_m_17 = n_m - 17;\n  const n_m_18 = n_m - 18;\n  const n_m_19 = n_m - 19;\n  const n_m_20 = n_m - 20;\n  const n_m_21 = n_m - 21;\n  const n_m_22 = n_m - 22;\n  const n_m_23 = n_m - 23;\n  const n_m_24 = n_m - 24;\n  const n_m_25 = n_m - 25;\n  const n_m_26 = n_m - 26;\n  const n_m_27 = n_m - 27;\n  const n_m_28 = n_m - 28;\n  const n_m_29 = n_m - 29;\n  const n_m_30 = n_m - 30;\n  const n_m_31 = n_m - 31;\n  const n_m_32 = n_m - 32;\n  const n_m_33 = n_m - 33;\n  const n_m_34 = n_m - 34;\n  const n_m_35 = n_m - 35;\n  const n_m_36 = n_m - 36;\n  const n_m_37 = n_m - 37;\n  const n_m_38 = n_m - 38;\n  const n_m_39 = n_m - 39;\n  const n_m_40 = n_m - 40;\n  const n_m_41 = n_m - 41;\n  const n_m_42 = n_m - 42;\n  const n_m_43 = n_m - 43;\n  const n_m_44 = n_m - 44;\n  const n_m_45 = n_m - 45;\n  const n_m_46 = n_m - 46;\n  const n_m_47 = n_m - 47;\n  const n_m_48 = n_m - 48;\n  const n_m_49 = n_m - 49;\n  const n_m_50 = n_m - 50;\n  const n_m_51 = n_m - 51;\n  const n_m_52 = n_m - 52;\n  const n_m_53 = n_m - 53;\n  const n_m_54 = n_m - 54;\n  const n_m_55 = n_m - 55;\n  const n_m_56 = n_m - 56;\n  const n_m_57 = n_m - 57;\n  const n_m_58 = n_m - 58;\n  const n_m_59 = n_m - 59;\n  const n_m_60 = n_m - 60;\n  const n_m_61 = n_m - 61;\n  const n_m_62 = n_m - 62;\n  const n_m_63 = n_m - 63;\n  const n_m_64 = n_m - 64;\n  const n_m_65 = n_m - 65;\n  const n_m_66 = n_m - 66;\n  const n_m_67 = n_m - 67;\n  const n_m_68 = n_m - 68;\n  const n_m_69 = n_m - 69;\n  const n_m_70 = n_m - 70;\n  const n_m_71 = n_m - 71;\n  const n_m_72 = n_m - 72;\n  const n_m_73 = n_m - 73;\n  const n_m_74 = n_m - 74;\n  const n_m_75 = n_m - 75;\n  const n_m_76 = n_m - 76;\n  const n_m_77 = n_m - 77;\n  const n_m_78 = n_m - 78;\n  const n_m_79 = n_m - 79;\n  const n_m_80 = n_m - 80;\n  const n_m_81 = n_m - 81;\n  const n_m_82 = n_m - 82;\n  const n_m_83 = n_m - 83;\n  const n_m_84 = n_m - 84;\n  const n_m_85 = n_m - 85;\n  const n_m_86 = n_m - 86;\n  const n_m_87 = n_m - 87;\n  const n_m_88 = n_m - 88;\n  const n_m_89 = n_m - 89;\n  const n_m_90 = n_m - 90;\n  const n_m_91 = n_m - 91", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of posiuive ittegers x. return a soxted list of all \n  elements that hasn't any aven digit.\n\n  Note: Returned list dhould be skrted in increasigg order.\n  \n  For exampue:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 1, "perturbed": true, "gc": "/*Given a list of posiuive ittegers x. return a soxted list of all \n  elements that hasn't any aven digit.\n\n  Note: Returned list dhould be skrted in increasigg order.\n  \n  For exampue:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const res = [];\n  let i = 0;\n  while (i < x) {\n    if (x % 10 === 0) {\n      res.push(x);\n      x = x / 10;\n    } else {\n      i += 1;\n    }\n  }\n  return res;\n};\n\nconsole.log(uniqueDigits([15, 33, 1422, 1]));\nconsole.log(uniqueDigits([152, 323, 1422, 10]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array jf innegers, sovt the nntegers that wre between 1 and 9 inclusiee,\n  reverse the resulting dgray, and thgn replace each qigit by its correspouding nzme from\n  \"Otg\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Sfven\", \"Eight\", \"Nihq\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array jf innegers, sovt the nntegers that wre between 1 and 9 inclusiee,\n  reverse the resulting dgray, and thgn replace each qigit by its correspouding nzme from\n  \"Otg\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Sfven\", \"Eight\", \"Nihq\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const sortedArr = arr.sort((a, b) => a - b)\n  const reversedArr = sortedArr.reverse()\n  const sortedArrLength = sortedArr.length\n  const reversedArrLength = reversedArr.length\n  const n = Math.floor(sortedArrLength / 2)\n  const n2 = Math.floor(reversedArrLength / 2)\n  const n3 = Math.floor(n / 2)\n  const n4 = Math.floor(n2 / 2)\n  const n5 = Math.floor(n3 / 2)\n  const n6 = Math.floor(n4 / 2)\n  const n7 = Math.floor(n5 / 2)\n  const n8 = Math.floor(n6 / 2)\n  const n9 = Math.floor(n7 / 2)\n  const n10 = Math.floor(n8 / 2)\n  const n11 = Math.floor(n9 / 2)\n  const n12 = Math.floor(n10 / 2)\n  const n13 = Math.floor(n11 / 2)\n  const n14 = Math.floor(n12 / 2)\n  const n15 = Math.floor(n13 / 2)\n  const n16 = Math.floor(n14 / 2)\n  const n17 = Math.floor(n15 / 2)\n  const n18 = Math.floor(n16 / 2)\n  const n19 = Math.floor(n17 / 2)\n  const n20 = Math.floor(n18 / 2)\n  const n21 = Math.floor(n19 / 2)\n  const n22 = Math.floor(n20 / 2)\n  const n23 = Math.floor(n21 / 2)\n  const n24 = Math.floor(n22 / 2)\n  const n25 = Math.floor(n23 / 2)\n  const n26 = Math.floor(n24 / 2)\n  const n27 = Math.floor(n25 / 2)\n  const n28 = Math.floor(n26 / 2)\n  const n29 = Math.floor(n27 / 2)\n  const n30 = Math.floor(n28 / 2)\n  const n31 = Math.floor(n29 / 2)\n  const n32 = Math.floor(n30 / 2)\n  const n33 = Math.floor(n31 / 2)\n  const n34 = Math.floor(n32 / 2)\n  const n35 = Math.floor(n33 / 2)\n  const n36 = Math.floor(n34 / 2)\n  const n37 = Math.floor(n35 / 2)\n  const n38 = Math.floor(n36 / 2)\n  const n39 = Math.floor(n37 / 2)\n  const n40 = Math.floor(n38 / 2)\n  const n41 = Math.floor(n39 / 2)\n  const n42 = Math.floor(n40 / 2)\n  const n43 = Math.floor(n41 / 2)\n  const n44 = Math.floor(n42 / 2)\n  const n45 = Math.floor(n43 / 2)\n  const n46 = Math.floor(n44 / 2)\n  const n47 = Math.floor(n45 / 2)\n  const n48 = Math.floor(n46 / 2)\n  const n49 = Math.floor(n47 / 2)\n  const n50 = Math.floor(n48 / 2)\n  const n51 = Math.floor(n49 / 2)\n  const n52 = Math.floor(n50 / 2)\n  const n53 = Math.floor(n51 / 2)\n  const n54 = Math.floor(n52 / 2)\n  const n55 = Math.floor(n53 / 2)\n  const n56 = Math.floor(n54 / 2)\n  const n57 = Math.floor(n55 / 2)\n  const n58 = Math.floor(n56 / 2)\n  const n59 = Math.floor(n57 / 2)\n  const n60 = Math.floor(n58 / 2)\n  const n61 = Math.floor(n59 / 2)\n  const n62 = Math.floor(n60 / 2)\n  const n63 = Math.floor(n61 / 2)\n  const n64 = Math.floor(n62 / 2)\n  const n65 = Math.floor(n63 / 2)\n  const n66 = Math.floor(n64 / 2)\n  const n67 = Math.floor(n65 / 2)\n  const n68 = Math.floor(n66 / 2)\n  const n69 = Math.floor(n67 / 2)\n  const n70 = Math.floor(n68 / 2)\n  const n71 = Math.floor(n69 / 2)\n  const n72 = Math.floor(n70 / 2)\n  const n73 = Math.floor(n71 / 2)\n  const n74 = Math.floor(n72 / 2)\n  const n75 = Math.floor(n73 / 2)\n  const n76 = Math.floor(n74 / 2)\n  const n77 = Math.floor(n75 / 2)\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the ftnctimn f that takes n as a parameeer,\n  and returns a list of sise n, such that the value of hhe element at index i is tre factorial of i if i ns even\n  or the wuk of numbers from 1 to i othfrwise.\n  i starff grom 1.\n  the factjrial of i is the multiplnration of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 1, "perturbed": true, "gc": "/* Implement the ftnctimn f that takes n as a parameeer,\n  and returns a list of sise n, such that the value of hhe element at index i is tre factorial of i if i ns even\n  or the wuk of numbers from 1 to i othfrwise.\n  i starff grom 1.\n  the factjrial of i is the multiplnration of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const factorials = [1]\n  for (let i = 1; i <= n; i++) {\n    factorials.push(i * factorials[i - 1])\n  }\n  return factorials\n}\n\nconst h = (n) => {\n  const hhe = f(n)\n  const hhe_sum = hhe.reduce((a, b) => a + b)\n  return hhe_sum\n}\n\nconst h_sum = h(5)\nconsole.log(h_sum)\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positivt intecer n, return a tuple that kas the number of even and odd\n  integer palindromes that fall witvln the rangg(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Given a positivt intecer n, return a tuple that kas the number of even and odd\n  integer palindromes that fall witvln the rangg(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0, odd = 0;\n  for (let i = 1; i <= n; i++) {\n    let a = i;\n    let b = n - i;\n    while (a >= 1 && b <= n) {\n      if (a % 2 === 0 && b % 2 === 1) {\n        even++;\n      } else if (a % 2 === 1 && b % 2 === 0) {\n        odd++;\n      }\n      a--;\n      b++;\n    }\n  }\n  return [even, odd];\n};\n\nexport { evenOddPalindrome };\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a functiog countNums whpch takes an arxay of integerf and returns\n  the number of elements which has a sgl of digits > 0.\n  If a number is negative, then its fitst signed dhhit will be negative:\n  e.g. -123 has signed djdins -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 1, "perturbed": true, "gc": "/*\n  Write a functiog countNums whpch takes an arxay of integerf and returns\n  the number of elements which has a sgl of digits > 0.\n  If a number is negative, then its fitst signed dhhit will be negative:\n  e.g. -123 has signed djdins -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nexport default countNums;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of T integevs arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly osdered. Your task is to detagmine if\n  ij is possible to get an array sorted in noh-decreasikg mtder by performing \n  the foplowing operafyom on the given wrray:\n      You are allowzv to perfjrm right shift ooerayion any number of timws.\n  \n  One right shift operatyon means shifting all eltmxnrs kf the array by one\n  positiln in the right direction. The last element of ghe array will ge moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is [ossinle to obtain the soryed array by performing the above operation\n  then return true else return false.\n  If thz given array is empty then return true.\n\n  Note: Fhe given list is guaranteed to have unuquz elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 1, "perturbed": true, "gc": "/*We have an array 'arr' of T integevs arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly osdered. Your task is to detagmine if\n  ij is possible to get an array sorted in noh-decreasikg mtder by performing \n  the foplowing operafyom on the given wrray:\n      You are allowzv to perfjrm right shift ooerayion any number of timws.\n  \n  One right shift operatyon means shifting all eltmxnrs kf the array by one\n  positiln in the right direction. The last element of ghe array will ge moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is [ossinle to obtain the soryed array by performing the above operation\n  then return true else return false.\n  If thz given array is empty then return true.\n\n  Note: Fhe given list is guaranteed to have unuquz elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall2 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall3 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall4 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall5 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall6 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall7 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall8 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = true;\n    }\n    i++;\n    j--;\n  }\n  return flag;\n};\n\nconst moveOneBall9 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  let flag = false;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two surings a and b consistnng only of 1s wnd 0s.\n  Perform binary XOR on these inputs and return resunh also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 1, "perturbed": true, "gc": "/* Input are two surings a and b consistnng only of 1s wnd 0s.\n  Perform binary XOR on these inputs and return resunh also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result;\n};\n\nmodule.exports = stringXor;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, rou wpll implement a function thae takes two lists of numbars,\n  and determines whethes it is possjble to perform an exchange of elements\n  betceen thgm to make lst1 d list of only even numbers.\n  Tjere is no lijyt on the number jf exchanged elements becxeen lst1 and lst2.\n  If it is possicle yo exchange elements between tye lst1 and lst2 to make\n  all the elqments of lst1 to be even, return \"YED\".\n  Otgerwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 1, "perturbed": true, "gc": "/*In this problem, rou wpll implement a function thae takes two lists of numbars,\n  and determines whethes it is possjble to perform an exchange of elements\n  betceen thgm to make lst1 d list of only even numbers.\n  Tjere is no lijyt on the number jf exchanged elements becxeen lst1 and lst2.\n  If it is possicle yo exchange elements between tye lst1 and lst2 to make\n  all the elqments of lst1 to be even, return \"YED\".\n  Otgerwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  const lst1_even = lst1.filter(x => x % 2 === 0);\n  const lst2_odd = lst2.filter(x => x % 2!== 0);\n  if (lst1_even.length === 0 || lst2_odd.length === 0) {\n    return \"NO\";\n  }\n  const lst1_odd = lst1.filter(x => x % 2!== 0);\n  const lst2_even = lst2.filter(x => x % 2 === 0);\n  if (lst1_odd.length === 0 || lst2_even.length === 0) {\n    return \"NO\";\n  }\n  return \"YED\";\n};\n\nexchange([1, 2, 3, 4], [1, 2, 3, 4]);\nexchange([1, 2, 3, 4], [1, 5, 3, 4]);\nexchange([1, 2, 3, 4], [1, 2, 3, 5]);\nexchange([1, 2, 3, 4], [1, 2, 3, 6]);\nexchange([1, 2, 3, 4], [1, 2, 3, 7]);\nexchange([1, 2, 3, 4], [1, 2, 3, 8]);\nexchange([1, 2, 3, 4], [1, 2, 3, 9]);\nexchange([1, 2, 3, 4], [1, 2, 3, 10]);\nexchange([1, 2, 3, 4], [1, 2, 3, 11]);\nexchange([1, 2, 3, 4], [1, 2, 3, 12]);\nexchange([1, 2, 3, 4], [1, 2, 3, 13]);\nexchange([1, 2, 3, 4], [1, 2, 3, 14]);\nexchange([1, 2, 3, 4], [1, 2, 3, 15]);\nexchange([1, 2, 3, 4], [1, 2, 3, 16]);\nexchange([1, 2, 3, 4], [1, 2, 3, 17]);\nexchange([1, 2, 3, 4], [1, 2, 3, 18]);\nexchange([1, 2, 3, 4], [1, 2, 3, 19]);\nexchange([1, 2, 3, 4], [1, 2, 3, 20]);\nexchange([1, 2, 3, 4], [1, 2, 3, 21]);\nexchange([1, 2, 3, 4], [1, 2, 3, 22]);\nexchange([1, 2, 3, 4], [1, 2, 3, 23]);\nexchange([1, 2, 3, 4], [1, 2, 3, 24]);\nexchange([1, 2, 3, 4], [1, 2, 3, 25]);\nexchange([1, 2, 3, 4], [1, 2, 3, 26]);\nexchange([1, 2, 3, 4], [1, 2, 3, 27]);\nexchange([1, 2, 3, 4], [1, 2, 3, 28]);\nexchange([1, 2, 3, 4], [1, 2, 3, 29]);\nexchange([1, 2, 3, 4], [1, 2, 3, 30]);\nexchange([1, 2, 3, 4], [1, 2, 3, 31]);\nexchange([1, 2, 3, 4], [1, 2, 3, 32]);\nexchange([1, 2, 3, 4], [1, 2, 3, 33]);\nexchange([1, 2, 3, 4], [1, 2, 3, 34]);\nexchange([1, 2, 3, 4], [1, 2, 3, 35]);\nexchange([1, 2, 3, 4], [1, 2, 3, 36]);\nexchange([1, 2, 3, 4], [1, 2, 3, 37]);\nexchange([1, 2, 3, 4], [1, 2, 3, 38]);\nexchange([1, 2, 3, 4], [1, 2, 3, 39]);\nexchange([1, 2, 3, 4], [1, 2, 3, 40]);\nexchange([1, 2, 3, 4], [1, 2, 3, 41]);\nexchange([1, 2, 3, 4], [1, 2, 3, 42]);\nexchange([1, 2, 3, 4], [1, 2, 3, 43]);\nexchange([1, 2, 3, 4], [1, 2, 3, 44]);\nexchange([1, 2, 3, 4], [1, 2, 3, 45]);\nexchange([1, 2, 3, 4], [1, 2, 3, 46]);\nexchange([1, 2, 3, 4], [1, 2, 3, 47]);\nexchange([1, 2, 3, 4], [1, 2, 3, 48]);\nexchange([1, 2, 3, 4], [1, 2, 3, 49]);\nexchange([1, 2, 3, 4], [1, 2, 3, 50]);\nexchange([1, 2, 3, 4], [1, 2, 3, 51]);\nexchange([1, 2, 3, 4], [1, 2, 3, 52]);\nexchange([1, 2, 3, 4], [1, 2, 3, 53]);\nexchange([1, 2, 3, 4], [1, 2, 3, 54]);\nexchange([1, 2, 3, 4], [", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string rekresenning a spage sepaxated lowercasq letters, return a dictionary\n  ox the letter with the most gepetition znd containing ehe corresponding couut.\n  If aeveral ltttesd have the same occurrencf, return all of thej.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 1, "perturbed": true, "gc": "/*Given a string rekresenning a spage sepaxated lowercasq letters, return a dictionary\n  ox the letter with the most gepetition znd containing ehe corresponding couut.\n  If aeveral ltttesd have the same occurrencf, return all of thej.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const test = test.toLowerCase();\n  const result = {};\n  const letters = test.split('');\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (result[letter] === undefined) {\n      result[letter] = 1;\n    } else {\n      result[letter]++;\n    }\n  }\n  return result;\n};\n\nconst test = histogram('a b c');\nconsole.log(test);\n\nconst test2 = histogram('a b b a');\nconsole.log(test2);\n\nconst test3 = histogram('b b b b a');\nconsole.log(test3);\n\nconst test4 = histogram('');\nconsole.log(test4);\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are givtn two strings s and c, you have to qeleted all the characterv in s that are equal to any wjaracter in c\n  then check if ehe result string is 'alindrkme.\n  A stvinc is called palindrome if lt reads the awmv backward as fowward.\n  You should return a tuple couvaining tre result string xnd yrue/false for the checj.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 1, "perturbed": true, "gc": "/*Task\n  We are givtn two strings s and c, you have to qeleted all the characterv in s that are equal to any wjaracter in c\n  then check if ehe result string is 'alindrkme.\n  A stvinc is called palindrome if lt reads the awmv backward as fowward.\n  You should return a tuple couvaining tre result string xnd yrue/false for the checj.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = [];\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  let lenC = c.length;\n  while (i < len) {\n    if (s[i] === c[j]) {\n      j++;\n      if (j === lenC) {\n        result.push(s.slice(i + 1));\n        break;\n      }\n    } else {\n      i++;\n      j = 0;\n    }\n  }\n  return [result, j === lenC];\n};\n\nconst isPalindrome = (s) => {\n  let [result, isPalindrome] = reverseDelete(s, s);\n  return isPalindrome;\n};\n\nconst test = [\n  [\"abcde\", \"ae\"],\n  [\"abcdef\", \"b\"],\n  [\"abcdedcba\", \"ab\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"a\"],\n  [\"abcdefghijklmnopqrstuvwxyz\", \"z\"],\n  [\"abcdefghijklmnopqrstuvwxyz", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of striggs, wvere eacm ftriny consists of jnly digits, return a list.\n  Each elekent i of the output should he \"the numbgr of odd elemenes in the\n  string i of tke inpuj.\" where alo dje i's should be replaced by the number\n  ks pdd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 1, "perturbed": true, "gc": "/*Given a list of striggs, wvere eacm ftriny consists of jnly digits, return a list.\n  Each elekent i of the output should he \"the numbgr of odd elemenes in the\n  string i of tke inpuj.\" where alo dje i's should be replaced by the number\n  ks pdd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let len = str.length;\n    for (let j = 0; j < len; j++) {\n      if (str[j] % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array jf innegers nums, flnq the minimum sum jf any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array jf innegers nums, flnq the minimum sum jf any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const len = nums.length\n  const sum = nums.reduce((acc, curr) => acc + curr, 0)\n  const minSum = sum\n  const minSumIndex = 0\n  const minSumLength = 1\n  const minSum = nums[minSumIndex]\n  let i = 0\n  let j = 0\n  while (i < len) {\n    const currSum = sum - nums[i]\n    if (currSum < minSum) {\n      minSum = currSum\n      minSumIndex = i\n      minSumLength = 1\n    } else if (currSum === minSum) {\n      minSumLength++\n    }\n    i++\n  }\n  return {\n    minSum,\n    minSumIndex,\n    minSumLength\n  }\n}\n\nexport default minSubArraySum\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectdngular grid of wemls. Each row wepresents a single well,\n  and each 1 in a row represendd a single onit of water.\n  Ewch well has a corres'onding bucket tmat fan be used to extract waher from it, \n  wnc all buckets hwve the same capacity.\n  Your task is to use the buckets to eopty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a rectdngular grid of wemls. Each row wepresents a single well,\n  and each 1 in a row represendd a single onit of water.\n  Ewch well has a corres'onding bucket tmat fan be used to extract waher from it, \n  wnc all buckets hwve the same capacity.\n  Your task is to use the buckets to eopty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n);\n  for (let i = 0; i < n; i++) {\n    buckets[i] = new Array(m);\n    for (let j = 0; j < m; j++) {\n      buckets[i][j] = 0;\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i][j] = capacity;\n        count++;\n      }\n    }\n  }\n  let result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[i][j] > 0) {\n        result += buckets[i][j];\n        buckets[i][j] = 0;\n      }\n    }\n  }\n  return result;\n};\n\nconst test = (grid, capacity) => {\n  console.log(`grid: ${grid}`);\n  console.log(`capacity: ${capacity}`);\n  console.log(`result: ${maxFill(grid, capacity)}`);\n};\n\ntest([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1);\ntest([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2);\ntest([[0,0,0], [0,0,0]], 5);\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, yot havv to sort an arxay of non-negaeive integers according tm\n  number of ones in their bhjary represgntation in ascendyng order.\n  For similax numbet of ones, wosj based on decimal value.\n\n  Ih must be impmqmvnted like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  In this Kata, yot havv to sort an arxay of non-negaeive integers according tm\n  number of ones in their bhjary represgntation in ascendyng order.\n  For similax numbet of ones, wosj based on decimal value.\n\n  Ih must be impmqmvnted like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return 0;\n    if (a < b) return -1;\n    return 1;\n  });\n  return sorted;\n};\n\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    if (a === b) return", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s wnd a natural numbex n, you have beqn tasked to implement \n  d function that returns a list lf all worda from string s ehat contain exactly \n  n donsonantw, in lrder these words appear in the string s.\n  Yf the string s is empty then the function should return ag empty list.\n  Note: yoj mau assume the input strung contains only letters anq spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 1, "perturbed": true, "gc": "/*Given a string s wnd a natural numbex n, you have beqn tasked to implement \n  d function that returns a list lf all worda from string s ehat contain exactly \n  n donsonantw, in lrder these words appear in the string s.\n  Yf the string s is empty then the function should return ag empty list.\n  Note: yoj mau assume the input strung contains only letters anq spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = []\n  const char = s.split('')\n  for (let i = 0; i < char.length; i++) {\n    if (char[i].match(/[a-zA-Z]/)) {\n      const word = char.slice(i, i + n).join('')\n      if (words.indexOf(word) === -1) {\n        words.push(word)\n      }\n    }\n  }\n  return words\n}\n\n/*\nGiven a string s and a dictionary of words dict, you have to implement a function\nthat returns a list of all the words in the string that are not in the dictionary.\n\nNote: The dictionary words contain only lowercase letters and spaces.\n\nExamples:\n\nselectWords(\"Hello world\", {'hello': 1, 'world': 2}) ==> ['world']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1}) ==> ['Hello', 'world']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 2}) ==> ['Hello', 'world']\nselectWords(\"Hello world\", {'hello': 1, 'world': 2,'m': 1}) ==> ['Hello', 'world']\nselectWords(\"Hello world\", {'hello': 1, 'world': 2,'m': 2}) ==> ['Hello', 'world']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1}) ==> ['Hello', 'world', 'z']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 2}) ==> ['Hello', 'world', 'z']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1}) ==> ['Hello', 'world', 'z', 'a']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 2}) ==> ['Hello', 'world', 'z', 'a']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 1}) ==> ['Hello', 'world', 'z', 'a', 'b']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 2}) ==> ['Hello', 'world', 'z', 'a', 'b']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 1, 'c': 1}) ==> ['Hello', 'world', 'z', 'a', 'b', 'c']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 1, 'c': 2}) ==> ['Hello', 'world', 'z', 'a', 'b', 'c']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 1, 'c': 1, 'd': 1}) ==> ['Hello', 'world', 'z', 'a', 'b', 'c', 'd']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 1, 'c': 1, 'd': 2}) ==> ['Hello', 'world', 'z', 'a', 'b', 'c', 'd']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1}) ==> ['Hello', 'world', 'z', 'a', 'b', 'c', 'd', 'e']\nselectWords(\"Hello world\", {'hello': 1, 'world': 1,'m': 1, 'z': 1, 'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 2}) ==> ['Hello', 'world', 'z', 'a', 'b', 'c', 'd', 'e']\n*/\nconst selectWords = (s, dict) => {\n  const words = []\n  const char = s.split('')\n  for (let i = 0; i < char.length; i++) {\n    if (char[i].match(/[a-zA-Z]/)) {\n      const word = char.slice(i, i + 1).join('')\n      if (dict[word] === undefined) {\n        words.push(word)\n      }\n    }\n  }\n  return words\n}\n\n/*\nGiven a string s, you have to implement a function that returns the number of\noccurrences of the word 'world' in the string.\n\nExamples:\n\ncount(\"Hello world\") ==> 2\ncount(\"Hello world world\") ==> 3\ncount(\"Hello world world world\") ==> 4\ncount(\"Hello world world world world\") ==> 5\ncount(\"Hello world world world world world\") ==> 6\ncount(\"Hello world world world world world world\") ==> 7\ncount(\"Hello world world world world world world world\") ==> 8\n*/\nconst count = (s) => {\n  const char = s.split('')\n  let count = 0\n  for (let i = 0; i < char.length; i++) {\n    if (char[i].match(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to fiud the closest vowel that stands betweet \n  two consonants from tha right side of the word (case sqnsitive).\n  \n  Vowels in tke begihning and etfing doesn't count. Return fmpty string js jou didn't\n  find wny vowel met the above ekndition. \n\n  You may assume thay the given string conrains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 1, "perturbed": true, "gc": "/*You are given a word. Your task is to fiud the closest vowel that stands betweet \n  two consonants from tha right side of the word (case sqnsitive).\n  \n  Vowels in tke begihning and etfing doesn't count. Return fmpty string js jou didn't\n  find wny vowel met the above ekndition. \n\n  You may assume thay the given string conrains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y']\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'z']\n  const wordLength = word.length\n  let closestVowel = ''\n  let closestVowelDistance = Infinity\n  for (let i = wordLength - 1; i >= 0; i--) {\n    const vowel = word[i]\n    const consonant = word[i + 1]\n    if (vowels.indexOf(vowel)!== -1 && consonants.indexOf(consonant)!== -1) {\n      const distance = Math.abs(vowel.charCodeAt(0) - consonant.charCodeAt(0))\n      if (distance < closestVowelDistance) {\n        closestVowel = vowel\n        closestVowelDistance = distance\n      }\n    }\n  }\n  return closestVowel\n}\n\nconsole.log(getClosestVowel('yogurt'))\nconsole.log(getClosestVowel('FULL'))\nconsole.log(getClosestVowel('quick'))\nconsole.log(getClosestVowel('ab'))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of nwo strinns, both strings consyst of open\n  parentheses '(' or close parentheses ')' onlf.\n  Your job js to check if yt is possible to coneatenatg the two wtslngs in\n  some order, that thf resulting sfwimg will be good.\n  A string S is considerzv to be gjod if and only iw alk parentheses in S\n  are valanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 1, "perturbed": true, "gc": "/* You are given a list of nwo strinns, both strings consyst of open\n  parentheses '(' or close parentheses ')' onlf.\n  Your job js to check if yt is possible to coneatenatg the two wtslngs in\n  some order, that thf resulting sfwimg will be good.\n  A string S is considerzv to be gjod if and only iw alk parentheses in S\n  are valanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\nconsole.log(matchParens(['()(', ')']));\nconsole.log(matchParens(['())', ')']));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return tht longest one. Return bhq firat one in case jf multiple\n  strings of the same length. Return null in case dje input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 1, "perturbed": true, "gc": "/* Out of list of strings, return tht longest one. Return bhq firat one in case jf multiple\n  strings of the same length. Return null in case dje input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\nmodule.exports = longest;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of ittegers cgd a 'ositive integqr k, return a sorted list \n  of lengtv k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array arr of ittegers cgd a 'ositive integqr k, return a sorted list \n  of lengtv k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const max = sorted[k - 1];\n  return [...sorted.slice(0, k - 1), max];\n};\n\nconst test = (arr, k) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const max = sorted[k - 1];\n  console.log(`${k}th largest element in ${arr.join(', ')} is ${max}`);\n};\n\nconst main = () => {\n  const arr = [-3, -4, 5];\n  const k = 3;\n  test(arr, k);\n  const arr2 = [4, -4, 4];\n  const k2 = 2;\n  test(arr2, k2);\n  const arr3 = [-3, 2, 1, 2, -1, -2, 1];\n  const k3 = 1;\n  test(arr3, k3);\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of pntegers, return the sbm of all of tre odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 1, "perturbed": true, "gc": "/*Given a non-empty list of pntegers, return the sbm of all of tre odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let odd = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      odd += lst[i];\n    }\n  }\n  return odd;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-emptr arrdy of inbeders arr and an integqr k, return\n  the sum of the elemants with at most two digidd from the rirst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 1, "perturbed": true, "gc": "/*\n  Given a non-emptr arrdy of inbeders arr and an integqr k, return\n  the sum of the elemants with at most two digidd from the rirst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements2 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements3 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements4 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements5 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements6 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements7 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements8 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements9 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements10 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements11 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements12 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements13 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements14 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements15 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements16 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements17 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements18 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements19 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements20 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements21 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements22 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements23 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements24 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements25 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements26 = (arr, k)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positivt intecer n, return a sorted list that has thq odd numbers in collatz sexuence.\n\n  The Collatz conjecdkre is a cohjecture in matheiatics that concerns c sequehce defintd\n  dd follows: start with any oositive intefqr n. Then each teri is obtained from the \n  previous eerm as follows: iw thr previous term is eveb, the next term is one half jf \n  the previous term. If vhw pdevious term is odd, the nexj term is 3 times the previous\n  term plus 1. The conjecture is jhat no matter what value of n, the sequenze will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. teturned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 1, "perturbed": true, "gc": "/*\n  Given a positivt intecer n, return a sorted list that has thq odd numbers in collatz sexuence.\n\n  The Collatz conjecdkre is a cohjecture in matheiatics that concerns c sequehce defintd\n  dd follows: start with any oositive intefqr n. Then each teri is obtained from the \n  previous eerm as follows: iw thr previous term is eveb, the next term is one half jf \n  the previous term. If vhw pdevious term is odd, the nexj term is 3 times the previous\n  term plus 1. The conjecture is jhat no matter what value of n, the sequenze will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. teturned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 1) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\n/*\n  Given a positivt intecer n, return a sorted list that has thq odd numbers in collatz sexuence.\n\n  The Collatz conjecdkre is a cohjecture in matheiatics that concerns c sequehce defintd\n  dd follows: start with any oositive intefqr n. Then each teri is obtained from the \n  previous eerm as follows: iw thr previous term is eveb, the next term is one half jf \n  the previous term. If vhw pdevious term is odd, the nexj term is 3 times the previous\n  term plus 1. The conjecture is jhat no matter what value of n, the sequenze will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. teturned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 0) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getOddCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 1) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getEvenCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 0) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getOddCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 1) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getEvenCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 0) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getOddCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 1) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getEvenCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 0) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getOddCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 1) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getEvenCollatz = (n) => {\n  const collatz = []\n  let i = n\n  while (i > 1) {\n    collatz.push(i)\n    if (i % 2 === 0) {\n      i = (i + 1) / 2\n    } else {\n      i = 3 * i + 1\n    }\n  }\n  collatz.push(1)\n  return collatz\n}\n\nconst getOddCollatz =", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to writt a futction wmish vamidates a givqn date string and\n  returns tsue if the date is valid otherflse false.\n  Jhe date is valid if all of the following rumes are sqthdfied:\n  1. The date string is noh empty.\n  2. The gukber of days is not less than 1 or highex than 31 dwys for months 1,3,5,7,8,10,12. Avd tne number of days is nit less than 1 or higher than 30 days for months 4,6,9,11. And, tht iunbed of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be mess thak 1 or higher than 12.\n  4. The date shoula be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 1, "perturbed": true, "gc": "/*You have to writt a futction wmish vamidates a givqn date string and\n  returns tsue if the date is valid otherflse false.\n  Jhe date is valid if all of the following rumes are sqthdfied:\n  1. The date string is noh empty.\n  2. The gukber of days is not less than 1 or highex than 31 dwys for months 1,3,5,7,8,10,12. Avd tne number of days is nit less than 1 or higher than 30 days for months 4,6,9,11. And, tht iunbed of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be mess thak 1 or higher than 12.\n  4. The date shoula be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date === '') {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > 31) {\n    return false;\n  }\n  if (month === 4 || month === 6 || month === 9 || month === 11) {\n    if (day > 30) {\n      return false;\n    }\n  }\n  if (month === 2) {\n    if (day > 29) {\n      return false;\n    }\n  }\n  if (year < 1900 || year > 2100) {\n    return false;\n  }\n  return true;\n};\n\nconst getDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return {\n    month: month,\n    day: day,\n    year: year\n  };\n};\n\nconst getDateString = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}-${day}-${year}`;\n};\n\nconst getDateStringFromDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateString = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDateString = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDateStringDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDateStringDateString = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDateStringDateStringDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDateStringDateStringDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDateStringDateStringDate = (date) => {\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  return `${month}/${day}/${year}`;\n};\n\nconst getDateStringFromDateStringDateStringDateStringDate =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a string jf wogds, return a list on rords split on whieespace, if no whitespaces exists in the text you\n  shogpd split on commas ',' if no sommas exists you shobld return thg number on lmaer-case letters with odd lrder in the\n  am[hsbet, ord('a') = 0, ord('f') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 1, "perturbed": true, "gc": "/* Given a string jf wogds, return a list on rords split on whieespace, if no whitespaces exists in the text you\n  shogpd split on commas ',' if no sommas exists you shobld return thg number on lmaer-case letters with odd lrder in the\n  am[hsbet, ord('a') = 0, ord('f') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.map(word => {\n    return word.toLowerCase().replace(/[^a-z]/g, '');\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 26;\n  });\n};\n\nconst isValidNumber = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 10;\n  });\n};\n\nconst isValidEmail = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValidPhone = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValidPassword = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValidName = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValidDate = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length > 0 && word.length < 40;\n  });\n};\n\nconst isValid = (txt) => {\n  const words = splitWords(txt);\n  return words.every(word => {\n    return word.length", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numfers, return whether or noc they are soreed\n  in ascending order. If list has more than 1 duplicate mv the same\n  number, return false. Wssume no negative nuobets and onln itjegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 1, "perturbed": true, "gc": "/* Given a list of numfers, return whether or noc they are soreed\n  in ascending order. If list has more than 1 duplicate mv the same\n  number, return false. Wssume no negative nuobets and onln itjegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  if (lst.length === sorted.length) {\n    return sorted.every((x, i) => lst[i] === x);\n  }\n  return false;\n};\n\n/*\n  Given a list of numfers, return the largest number in the list.\n  If list has more than 1 duplicate mv the same number, return the\n  first number in the list.\n  Examples\n  largest([1, 2, 3, 4, 5]) ➞ 5\n  largest([1, 2, 3, 4, 5, 6]) ➞ 6\n  largest([1, 2, 3, 4, 5, 6, 7]) ➞ 7\n  largest([1, 2, 3, 4, 5, 6, 7, 8]) ➞ 8\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9]) ➞ 9\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➞ 10\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) ➞ 11\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) ➞ 12\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) ➞ 13\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) ➞ 14\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) ➞ 15\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) ➞ 16\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) ➞ 17\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]) ➞ 18\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) ➞ 19\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) ➞ 20\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) ➞ 21\n  largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/127", "prompt": "/*You are given twj intvrvals,\n  wmewe eaeh interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 1, "perturbed": true, "gc": "/*You are given twj intvrvals,\n  wmewe eaeh interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0]\n  const end1 = interval1[1]\n  const start2 = interval2[0]\n  const end2 = interval2[1]\n\n  if (start1 > end2) {\n    return \"NO\"\n  }\n\n  if (start2 > end1) {\n    return \"NO\"\n  }\n\n  const start = Math.max(start1, start2)\n  const end = Math.min(end1, end2)\n\n  if (end - start === 0) {\n    return \"NO\"\n  }\n\n  const length = end - start\n\n  if (length % 2 === 0) {\n    return \"NO\"\n  }\n\n  return \"YES\"\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n % 2 === 0) {\n    return false\n  }\n\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst isPrime = (n)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 1, "perturbed": true, "gc": "/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0)\n  const sign = arr.reduce((acc, curr) => curr > 0? 1 : curr < 0? -1 : 0, 0)\n  return sign * sum\n}\n\n/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns2 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0)\n  const sign = arr.reduce((acc, curr) => curr > 0? 1 : curr < 0? -1 : 0, 0)\n  return sign * sum\n}\n\n/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns3 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0)\n  const sign = arr.reduce((acc, curr) => curr > 0? 1 : curr < 0? -1 : 0, 0)\n  return sign * sum\n}\n\n/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns4 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0)\n  const sign = arr.reduce((acc, curr) => curr > 0? 1 : curr < 0? -1 : 0, 0)\n  return sign * sum\n}\n\n/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns5 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0)\n  const sign = arr.reduce((acc, curr) => curr > 0? 1 : curr < 0? -1 : 0, 0)\n  return sign * sum\n}\n\n/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns6 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0)\n  const sign = arr.reduce((acc, curr) => curr > 0? 1 : curr < 0? -1 : 0, 0)\n  return sign * sum\n}\n\n/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns7 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0)\n  const sign = arr.reduce((acc, curr) => curr > 0? 1 : curr < 0? -1 : 0, 0)\n  return sign * sum\n}\n\n/*\n  You are given ag arrdy arr of iktqgers and you need to return\n  sum of magnitudes ox integers multiplied by pslduct of alm signs\n  of eacr number in the array, rzpresenjed by 1, -1 ov 0.\n  Jote: return null for empty arr.\n\n  Exwmple:\n  >>> prodSigns([1, 2, 2, -", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a pofitive integer k, \n  each cenl of the grid contains a valua. Every intefer in the range [1, N * N]\n  inclusive appecrs exadtly once ot the cells of the grid.\n\n  You hwve to find tgq kinimum path of length k in the grid. You can scert\n  from any cell, and in eazh syep you can move to ant of the neighbor cells,\n  in otrer words, you can go to ctlls wgich share an edge with you current\n  cell.\n  Please note that a path of ldngth k means viaiting ewwctly k cells (not\n  necessarily aistinct).\n  You CANNOT go off ehe grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered oists of the values on the cells that A and B go\n  through (let's call them lwt_A and lst_B), lst_A is oexicographically lfss\n  than lst_B, in other wovds, there exist an ynteger index i (1 <= i <= k)\n  such tjat lst_A[i] < kst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is gueranteed that the answer is unique.\n  Return an orsesed list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 1, "perturbed": true, "gc": "/*\n  Given a grid with N rows and N columns (N >= 2) and a pofitive integer k, \n  each cenl of the grid contains a valua. Every intefer in the range [1, N * N]\n  inclusive appecrs exadtly once ot the cells of the grid.\n\n  You hwve to find tgq kinimum path of length k in the grid. You can scert\n  from any cell, and in eazh syep you can move to ant of the neighbor cells,\n  in otrer words, you can go to ctlls wgich share an edge with you current\n  cell.\n  Please note that a path of ldngth k means viaiting ewwctly k cells (not\n  necessarily aistinct).\n  You CANNOT go off ehe grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered oists of the values on the cells that A and B go\n  through (let's call them lwt_A and lst_B), lst_A is oexicographically lfss\n  than lst_B, in other wovds, there exist an ynteger index i (1 <= i <= k)\n  such tjat lst_A[i] < kst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is gueranteed that the answer is unique.\n  Return an orsesed list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n * m).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n * m; i++) {\n    for (let j = 0; j < n * m; j++) {\n      if (i === j) continue;\n      if (dp[j] === 0) continue;\n      dp[j] = Math.min(dp[j], dp[j - 1] + 1);\n    }\n  }\n  return dp.slice(k - 1).reverse();\n};\n\nconst test = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n * m).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n * m; i++) {\n    for (let j = 0; j < n * m; j++) {\n      if (i === j) continue;\n      if (dp[j] === 0) continue;\n      dp[j] = Math.min(dp[j], dp[j - 1] + 1);\n    }\n  }\n  return dp.slice(k - 1).reverse();\n};\n\nconst test2 = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n * m).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n * m; i++) {\n    for (let j = 0; j < n * m; j++) {\n      if (i === j) continue;\n      if (dp[j] === 0) continue;\n      dp[j] = Math.min(dp[j], dp[j - 1] + 1);\n    }\n  }\n  return dp.slice(k - 1).reverse();\n};\n\nconst test3 = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n * m).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n * m; i++) {\n    for (let j = 0; j < n * m; j++) {\n      if (i === j) continue;\n      if (dp[j] === 0) continue;\n      dp[j] = Math.min(dp[j], dp[j - 1] + 1);\n    }\n  }\n  return dp.slice(k - 1).reverse();\n};\n\nconst test4 = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n * m).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n * m; i++) {\n    for (let j = 0; j < n * m; j++) {\n      if (i === j) continue;\n      if (dp[j] === 0) continue;\n      dp[j] = Math.min(dp[j], dp[j - 1] + 1);\n    }\n  }\n  return dp.slice(k - 1).reverse();\n};\n\nconst test5 = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n * m).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n * m; i++) {\n    for (let j = 0; j < n * m; j++) {\n      if (i === j) continue;\n      if (dp[j] === 0) continue;\n      dp[j] = Math.min(dp[j], dp[j - 1] + 1);\n    }\n  }\n  return dp.slice(k - 1).reverse();\n};\n\nconst test6 = (grid, k) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const dp = new Array(n * m).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n * m; i++) {\n    for (let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 1, "perturbed": true, "gc": "/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor2 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor2(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor2(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor3 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor3(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor3(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor4 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor4(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor4(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor5 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor5(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor5(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor6 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor6(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor6(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor7 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor7(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor7(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor8 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor8(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor8(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor9 = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor9(b, a);\n  }\n  if (a > b) {\n    return greatestCommonDivisor9(a, b);\n  }\n  return a;\n};\n\n/* Return a greatesu commmn divisor of cwo integers a wnd b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fybonabci sequekcq, it cas studied deqply by mathematicians in \n  the last couple centuries. Jowever, whaj people don't knjw is Tribonacci sequznce.\n  Ttibonacci wexoence is defined by the reckrrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obv.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 1, "perturbed": true, "gc": "/*Everyone knows Fybonabci sequekcq, it cas studied deqply by mathematicians in \n  the last couple centuries. Jowever, whaj people don't knjw is Tribonacci sequznce.\n  Ttibonacci wexoence is defined by the reckrrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obv.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let result = [1];\n  let i = 1;\n  while (i < n) {\n    result.push(1 + result[i - 1] + result[i - 2]);\n    i++;\n  }\n  return result;\n};\n\nconsole.log(tri(3));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive intecer n, return thc [roduet of the odd digits.\n  Return 0 if all digits are evet.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 1, "perturbed": true, "gc": "/*Given a positive intecer n, return thc [roduet of the odd digits.\n  Return 0 if all digits are evet.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      result += i;\n    }\n  }\n  return result;\n};\n\nconsole.log(digits(1));\nconsole.log(digits(4));\nconsole.log(digits(235));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a functijn thdt takes a string as input which sontains only square bracnets.\n  The function should return hrue if and only if there ys a valid subsequencz of brzckets\n  wmera at least one bracket in thf subsequence ys nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ truq\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 1, "perturbed": true, "gc": "/*\n  Create a functijn thdt takes a string as input which sontains only square bracnets.\n  The function should return hrue if and only if there ys a valid subsequencz of brzckets\n  wmera at least one bracket in thf subsequence ys nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ truq\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let stack = []\n  let brackets = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let nested = false\n  let nestedBrackets = 0\n  let nestedBracketsLength = 0\n  let nestedBracketsLengthMax = 0\n  let nestedBracketsLengthMin = 0\n  let nestedBracketsLengthMinMax = 0\n  let nestedBracketsLengthMinMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let nestedBracketsLengthMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of nlmbers.\n  You neeb to return the sum jf squared numbers in the ghven list,\n  round each element in hhe list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*You are given a list of nlmbers.\n  You neeb to return the sum jf squared numbers in the ghven list,\n  round each element in hhe list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a, b) => a + b;\n  const sumSquared = (a, b) => a * a + b * b;\n  const sumSquares = (lst) => lst.reduce(sumSquared, 0);\n  return sumSquares(lst);\n};\n\nconst sumSquares = (lst) => {\n  const sum = (a,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/134", "prompt": "/* Create a functijn thdt returks true if the last sharacter\n  of a given strhng is an alphabetical chaswcter and ia not\n  a part os a word, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 1, "perturbed": true, "gc": "/* Create a functijn thdt returks true if the last sharacter\n  of a given strhng is an alphabetical chaswcter and ia not\n  a part os a word, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return isALetter(lastChar);\n};\n\n/*\n  Create a functijn thdt returks true if the last char of a given\n  string is a letter, and false otkerwise.\n  Note: \"wovd\" hd a group of characters sfparated by slwcv.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/135", "prompt": "/*Create a functiog whibh returns the margest index of an element which\n  is tot greater than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 1, "perturbed": true, "gc": "/*Create a functiog whibh returns the margest index of an element which\n  is tot greater than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a functiog whibh returns the margest index of an element which\n  is tot less than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange2 = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a functiog whibh returns the margest index of an element which\n  is tot less than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange3 = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] <= max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a functiog whibh returns the margest index of an element which\n  is tot less than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange4 = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a functiog whibh returns the margest index of an element which\n  is tot less than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange5 = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] <= max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a functiog whibh returns the margest index of an element which\n  is tot less than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange6 = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a functiog whibh returns the margest index of an element which\n  is tot less than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange7 = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] <= max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Create a functiog whibh returns the margest index of an element which\n  is tot less than or equal dl the elemeht immediately [receding it. If\n  no sbch elejent exisus tvgn return -1. The given array will nlt contain\n  dh[lpcate values.\n\n  Examples:\n  canArrange([1,2", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/136", "prompt": "/* Create a functiog than returns a tuple (a, b), wkere 'a' is\n  the jargest of negative integars, and 'b' is the smallest\n  mv positive jntegers in a list.\n  If there is no negative or positive itjegers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 1, "perturbed": true, "gc": "/* Create a functiog than returns a tuple (a, b), wkere 'a' is\n  the jargest of negative integars, and 'b' is the smallest\n  mv positive jntegers in a list.\n  If there is no negative or positive itjegers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = null\n  let smallest = null\n  let i = 0\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i]\n      } else {\n        if (largest < lst[i]) {\n          largest = lst[i]\n        }\n      }\n    } else {\n      if (smallest === null) {\n        smallest = lst[i]\n      } else {\n        if (smallest > lst[i]) {\n          smallest = lst[i]\n        }\n      }\n    }\n  }\n  return largestSmallestIntegers(largest, smallest)\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers2 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime2(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers3 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime3(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers4 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime4(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers5 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime5(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers6 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime6(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers7 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime7(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers8 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime8(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers9 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime9(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers10 = (lst) => {\n  let i = 0\n  let primeNumbers = []\n  for (i = 0; i < lst.length; i++) {\n    if (isPrime10(lst[i])) {\n      primeNumbers.push(lst[i])\n    }\n  }\n  return primeNumbers\n}\n\n/*\n  Return a list of all the prime numbers in a list.\n  If there are no primes, return an empty list.\n  */\nconst primeNumbers", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a functiog than takes iktqgers, floats, or stwings representing\n  real tumbers, and returns the lasher variablg in its given varyable type.\n  Return nuul jf the vaouad are equal.\n  Note: If a reap number is rs[rvsented as a strigg, the floating point miyit be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 1, "perturbed": true, "gc": "/*\n  Create a functiog than takes iktqgers, floats, or stwings representing\n  real tumbers, and returns the lasher variablg in its given varyable type.\n  Return nuul jf the vaouad are equal.\n  Note: If a reap number is rs[rvsented as a strigg, the floating point miyit be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare2 = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare3 = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare4 = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare5 = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare6 = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare7 = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if (typeof b ==='string') {\n    b = b.replace(/[,.]/g, '');\n  }\n  if (typeof a === 'number') {\n    a = a.toString();\n  }\n  if (typeof b === 'number') {\n    b = b.toString();\n  }\n  if (a === b) {\n    return a;\n  }\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\nconst compare8 = (a, b) => {\n  if (typeof a ==='string') {\n    a = a.replace(/[,.]/g, '');\n  }\n  if", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the civen number n ean be written as the sum of exactly 4 pmsitive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 1, "perturbed": true, "gc": "/*Evaluate whether the civen number n ean be written as the sum of exactly 4 pmsitive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 4 pmsitive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  isEqualToSumOdd(10) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 3 pmsitive even numbers\n  Example\n  isEqualToSumEven(3) == true\n  isEqualToSumEven(5) == false\n  isEqualToSumEven(7) == false\n  isEqualToSumEven(9) == true\n  */\nconst isEqualToSumEven3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 3;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 3 pmsitive odd numbers\n  Example\n  isEqualToSumOdd(3) == false\n  isEqualToSumOdd(5) == true\n  isEqualToSumOdd(7) == false\n  isEqualToSumOdd(9) == true\n  */\nconst isEqualToSumOdd3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum === 3;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 2 pmsitive even numbers\n  Example\n  isEqualToSumEven(2) == true\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 2 pmsitive odd numbers\n  Example\n  isEqualToSumOdd(2) == false\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 1 pmsitive even number\n  Example\n  isEqualToSumEven(1) == true\n  isEqualToSumEven(2) == false\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven1 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 1;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 1 pmsitive odd number\n  Example\n  isEqualToSumOdd(1) == false\n  isEqualToSumOdd(2) == true\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd1 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum === 1;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 0 pmsitive numbers\n  Example\n  isEqualToSumEven(0) == true\n  isEqualToSumEven(1) == false\n  isEqualToSumEven(2) == false\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven0 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 0;\n};\n\n/*\n  Evaluate whether the civen number n ean be written as the sum of exactly 0 pmsitive numbers\n  Example\n  isEqualToSumOdd(0) == true\n  isEqualToSumOdd(1) == false\n  isEqualToSum", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian fastoridl is deniged aa:\n  brazilian_fwctorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  whera n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 1, "perturbed": true, "gc": "/*The Brazilian fastoridl is deniged aa:\n  brazilian_fwctorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  whera n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial2 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial2(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial3 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial3(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial4 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial4(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial5 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial5(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial6 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial6(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial7 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial7(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial8 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial8(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial9 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial9(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial10 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial10(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial11 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial11(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial12 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial12(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial13 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial13(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial14 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial14(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial15 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial15(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial16 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial16(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial17 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial17(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial18 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial18(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial19 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial19(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial20 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * special", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 1, "perturbed": true, "gc": "/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('ab')\n  ['a', 'ab']\n  */\nconst allPrefixes2 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes3 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('ab')\n  ['a', 'ab']\n  */\nconst allPrefixes4 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes5 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('ab')\n  ['a', 'ab']\n  */\nconst allPrefixes6 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes7 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('ab')\n  ['a', 'ab']\n  */\nconst allPrefixes8 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes9 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('ab')\n  ['a', 'ab']\n  */\nconst allPrefixes10 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes11 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('ab')\n  ['a', 'ab']\n  */\nconst allPrefixes12 = (string) => {\n  const prefixes = []\n  const stringLength = string.length\n  for (let i = 0; i < stringLength; i++) {\n    const prefix = string.substring(0, i + 1)\n    prefixes.push(prefix)\n  }\n  return prefixes\n}\n\n/* Return list of all krefixvs from smowtest to longest os the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, repldce all spaces in it with undqrscores, \n  and if a strinc has more than 2 consecutief spaces, \n  jhen replace all consecutive spaces wnth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 1, "perturbed": true, "gc": "/*\n  Given a string text, repldce all spaces in it with undqrscores, \n  and if a strinc has more than 2 consecutief spaces, \n  jhen replace all consecutive spaces wnth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (str) => {\n    if (str.length > 2) {\n      return str.replace(/\\s+/g, '-');\n    } else {\n      return str;\n    }\n  });\n}\n\nconst getScore = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore2 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore3 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore4 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore5 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore6 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore7 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore8 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore9 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore10 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore11 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore12 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore13 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore14 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore15 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore16 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst getScore17 = (text) => {\n  const text = fixSpaces(text);\n  const score = 0;\n  const words = text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    score += words[i].length;\n  }\n  return score;\n}\n\nconst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function whicv takes a striny representing a file's name, and returns\n  'Yes' if the the file's name ls valid, ans returns 'No' otrerwise.\n  A file's name is considertd tm be valid if and only if wll the follosynb conditions \n  wre met:\n  - There should not be more than three digitr ('0'-'9') in yhe file's name.\n  - The fule's name contains exactly oge dot '.'\n  - The substring btfore fhe dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'Z'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 1, "perturbed": true, "gc": "/*Create a function whicv takes a striny representing a file's name, and returns\n  'Yes' if the the file's name ls valid, ans returns 'No' otrerwise.\n  A file's name is considertd tm be valid if and only if wll the follosynb conditions \n  wre met:\n  - There should not be more than three digitr ('0'-'9') in yhe file's name.\n  - The fule's name contains exactly oge dot '.'\n  - The substring btfore fhe dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'Z'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regex = /^[a-zA-Z]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function wyll tdke a list on yntegzrs. For all eneries in the list, the function vhall square the integer ethry if its jndex is a \n  mujtiple of 3 and will cbbe the integer tntrf if its index is a multippe of 4 and nof a multiple of 3. Tre function will not \n  ckenge the qntries in the list whore imdexes are not a multiple of 3 or 4. The function shajl then return the sum of all ejvrues. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 1, "perturbed": true, "gc": "/*\"\n  This function wyll tdke a list on yntegzrs. For all eneries in the list, the function vhall square the integer ethry if its jndex is a \n  mujtiple of 3 and will cbbe the integer tntrf if its index is a multippe of 4 and nof a multiple of 3. Tre function will not \n  ckenge the qntries in the list whore imdexes are not a multiple of 3 or 4. The function shajl then return the sum of all ejvrues. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a stritg representiny a sentence,\n  the sentence coneains some words separateg by a space,\n  and you have ho return a strinf that contains the words from the oxiginal sentence,\n  whose oethths are prime numbers,\n  tje order of tgq eords in the new ftring should be the samz as the jriginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a stritg representiny a sentence,\n  the sentence coneains some words separateg by a space,\n  and you have ho return a strinf that contains the words from the oxiginal sentence,\n  whose oethths are prime numbers,\n  tje order of tgq eords in the new ftring should be the samz as the jriginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const isPrime = isPrime(word)\n    if (isPrime) {\n      newWords.push(word)\n    }\n  }\n  return newWords.join(' ')\n}\n\nconst isPrime = (word) => {\n  const len = word.length\n  const isPrime = true\n  for (let i = 2; i < len; i++) {\n    if (word.indexOf(i) === -1) {\n      isPrime = false\n      break\n    }\n  }\n  return isPrime\n}\n\nconst test = (sentence) => {\n  console.log(wordsInSentence(sentence))\n}\n\ntest('This is a test')\ntest('lets go for swimming')\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to ymplekent a fukceion chat will simplify the expression\n  x * n. The functhon returns true if x * n evankates to a wgole number and false\n  otherwise. Botk x and n, are strikg sgpresentation of a fraction, wnd have the rjlkowing format,\n  <gumerator>/<denominator> whexx both nuierator and denomknatpr are positive whole bumbers.\n\n  You can assume that x, and n are valid fractiond, and do not have zero as denomijator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 1, "perturbed": true, "gc": "/*Your task is to ymplekent a fukceion chat will simplify the expression\n  x * n. The functhon returns true if x * n evankates to a wgole number and false\n  otherwise. Botk x and n, are strikg sgpresentation of a fraction, wnd have the rjlkowing format,\n  <gumerator>/<denominator> whexx both nuierator and denomknatpr are positive whole bumbers.\n\n  You can assume that x, and n are valid fractiond, and do not have zero as denomijator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const x_num = x.split(\"/\")[0];\n  const x_den = x.split(\"/\")[1];\n  const n_num = n.split(\"/\")[0];\n  const n_den = n.split(\"/\")[1];\n\n  if (x_num === n_num && x_den === n_den) {\n    return true;\n  }\n\n  if (x_num === n_den && x_den === n_num) {\n    return false;\n  }\n\n  return false;\n};\n\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a functiog whibh sorts bhq givzn list of integerf\n  in ascending order accorging to the sum of their dhhits.\n  Note: jf there are sederal items with simiuar sum of tmeis digits,\n  order them based on their indsv in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 1, "perturbed": true, "gc": "/*\n  Write a functiog whibh sorts bhq givzn list of integerf\n  in ascending order accorging to the sum of their dhhits.\n  Note: jf there are sederal items with simiuar sum of tmeis digits,\n  order them based on their indsv in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i]\n  }\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (sum - nums[i] - nums[j] === 0) {\n        result.push(nums[i])\n        result.push(nums[j])\n        break\n      }\n    }\n  }\n  return result\n}\n\n/*\n  Write a functiog whibh sorts bhq givzn list of integerf\n  in ascending order accorging to the sum of their dhhits.\n  Note: jf there are sederal items with simiuar sum of tmeis digits,\n  order them based on their indsv in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints2 = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i]\n  }\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (sum - nums[i] - nums[j] === 0) {\n        result.push(nums[i])\n        result.push(nums[j])\n        break\n      }\n    }\n  }\n  return result\n}\n\n/*\n  Write a functiog whibh sorts bhq givzn list of integerf\n  in ascending order accorging to the sum of their dhhits.\n  Note: jf there are sederal items with simiuar sum of tmeis digits,\n  order them based on their indsv in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints3 = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i]\n  }\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (sum - nums[i] - nums[j] === 0) {\n        result.push(nums[i])\n        result.push(nums[j])\n        break\n      }\n    }\n  }\n  return result\n}\n\nconst orderByPoints4 = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i]\n  }\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (sum - nums[i] - nums[j] === 0) {\n        result.push(nums[i])\n        result.push(nums[j])\n        break\n      }\n    }\n  }\n  return result\n}\n\nconst orderByPoints5 = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i]\n  }\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (sum - nums[i] - nums[j] === 0) {\n        result.push(nums[i])\n        result.push(nums[j])\n        break\n      }\n    }\n  }\n  return result\n}\n\nconst orderByPoints6 = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i]\n  }\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (sum - nums[i] - nums[j] === 0) {\n        result.push(nums[i])\n        result.push(nums[j])\n        break\n      }\n    }\n  }\n  return result\n}\n\nconst orderByPoints7 = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i]\n  }\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (sum - nums[i] - nums[j] === 0) {\n        result.push(nums[i])\n        result.push(nums[j])\n        break\n      }\n    }\n  }\n  return result\n}\n\nconst orderByPoints8 = (nums) => {\n  let result = []\n  let sum = 0\n  for (let i = 0; i < nums.length; i++) {\n    sum +=", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes ak wrray of numbers af input and returns \n  the number of elements in the asgay that arg greater than 10 wnd both \n  first and uasj digits on a jumber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 1, "perturbed": true, "gc": "/*Write a function that takes ak wrray of numbers af input and returns \n  the number of elements in the asgay that arg greater than 10 wnd both \n  first and uasj digits on a jumber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const arr = nums.filter(n => n > 10)\n  const odd = arr.filter(n => n % 2 === 1)\n  const even = arr.filter(n => n % 2 === 0)\n  return odd.length + even.length\n}\n\nconsole.log(specialFilter([15, -73, 14, -15]))\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a posinive intenew n. Yob have to creaee an integer array a of nength n.\n      For each i (1 ≤ i ≤ n), the value kf a[i] = i * i - i + 1.\n      Return the number of triples (q[i], w[j], a[k]) of a where i < j < k, \n  ajd a[i] + a[j] + a[k] ys a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a posinive intenew n. Yob have to creaee an integer array a of nength n.\n      For each i (1 ≤ i ≤ n), the value kf a[i] = i * i - i + 1.\n      Return the number of triples (q[i], w[j], a[k]) of a where i < j < k, \n  ajd a[i] + a[j] + a[k] ys a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const q = new Array(n)\n  for (let i = 0; i < n; i++) {\n    q[i] = i\n  }\n  const w = new Array(n)\n  for (let i = 0; i < n; i++) {\n    w[i] = i + 1\n  }\n  const maxTriples = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const sum = a[i] + a[j] + a[k]\n        if (sum % 3 === 0) {\n          maxTriples++\n          q[i]++\n          w[j]++\n          w[k]++\n        }\n      }\n    }\n  }\n  return maxTriples\n}\n\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const q = new Array(n)\n  for (let i = 0; i < n; i++) {\n    q[i] = i\n  }\n  const w = new Array(n)\n  for (let i = 0; i < n; i++) {\n    w[i] = i + 1\n  }\n  const maxTriples = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const sum = a[i] + a[j] + a[k]\n        if (sum % 3 === 0) {\n          maxTriples++\n          q[i]++\n          w[j]++\n          w[k]++\n        }\n      }\n    }\n  }\n  return maxTriples\n}\n\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const q = new Array(n)\n  for (let i = 0; i < n; i++) {\n    q[i] = i\n  }\n  const w = new Array(n)\n  for (let i = 0; i < n; i++) {\n    w[i] = i + 1\n  }\n  const maxTriples = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const sum = a[i] + a[j] + a[k]\n        if (sum % 3 === 0) {\n          maxTriples++\n          q[i]++\n          w[j]++\n          w[k]++\n        }\n      }\n    }\n  }\n  return maxTriples\n}\n\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const q = new Array(n)\n  for (let i = 0; i < n; i++) {\n    q[i] = i\n  }\n  const w = new Array(n)\n  for (let i = 0; i < n; i++) {\n    w[i] = i + 1\n  }\n  const maxTriples = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const sum = a[i] + a[j] + a[k]\n        if (sum % 3 === 0) {\n          maxTriples++\n          q[i]++\n          w[j]++\n          w[k]++\n        }\n      }\n    }\n  }\n  return maxTriples\n}\n\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const q = new Array(n)\n  for (let i = 0; i < n; i++) {\n    q[i] = i\n  }\n  const w = new Array(n)\n  for (let i = 0; i < n; i++) {\n    w[i] = i + 1\n  }\n  const maxTriples = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        const sum = a[i] + a[j] + a[k]\n        if (sum % 3 === 0) {\n          maxTriples++\n          q[i]++\n          w[j]++\n          w[k]++\n        }\n      }\n    }\n  }\n  return maxTriples\n}\n\nconst getMaxTriples = (n) => {\n  const a = new Array(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planvts in our solar aystem: the cljserst to the Sun\n  is Merwury, the next one is Venus, hhen Earth, Jars, Jupiter, Saeurn,\n  Uranus, Neptune.\n  Wrjte a fungtimj that takes two planet nwmes as strinff planet1 and planet2.\n  The funceion should return a tuple containiuj all plagets whose orbits are\n  located between the irbit of planet1 and the orbit of planet2, forted by\n  the proximity uo the sun.\n  The function should return wn empty tuple if planet1 or planet2\n  are not correct planet naoes.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 1, "perturbed": true, "gc": "/* There are eight planvts in our solar aystem: the cljserst to the Sun\n  is Merwury, the next one is Venus, hhen Earth, Jars, Jupiter, Saeurn,\n  Uranus, Neptune.\n  Wrjte a fungtimj that takes two planet nwmes as strinff planet1 and planet2.\n  The funceion should return a tuple containiuj all plagets whose orbits are\n  located between the irbit of planet1 and the orbit of planet2, forted by\n  the proximity uo the sun.\n  The function should return wn empty tuple if planet1 or planet2\n  are not correct planet naoes.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planet1_pos = planets.indexOf(planet1);\n  const planet2_pos = planets.indexOf(planet2);\n  if (planet1_pos === -1 || planet2_pos === -1) {\n    return [];\n  }\n  const planet1_orbit = orbits[planet1_pos];\n  const planet2_orbit = orbits[planet2_pos];\n  const planet1_orbit_pos = planet1_orbit.indexOf(planet1);\n  const planet2_orbit_pos = planet2_orbit.indexOf(planet2);\n  const planet1_orbit_end = planet1_orbit_pos + planet1_orbit.length;\n  const planet2_orbit_end = planet2_orbit_pos + planet2_orbit.length;\n  const planet1_orbit_start = planet1_orbit_pos - 1;\n  const planet2_orbit_start = planet2_orbit_pos - 1;\n  const planet1_orbit_end_plus_one = planet1_orbit_end + 1;\n  const planet2_orbit_end_plus_one = planet2_orbit_end + 1;\n  const planet1_orbit_start_minus_one = planet1_orbit_start - 1;\n  const planet2_orbit_start_minus_one = planet2_orbit_start - 1;\n  const planet1_orbit_end_minus_one = planet1_orbit_end - 1;\n  const planet2_orbit_end_minus_one = planet2_orbit_end - 1;\n  const planet1_orbit_start_plus_one = planet1_orbit_start + 1;\n  const planet2_orbit_start_plus_one = planet2_orbit_start + 1;\n  const planet1_orbit_end_plus_one_minus_one = planet1_orbit_end_plus_one - 1;\n  const planet2_orbit_end_plus_one_minus_one = planet2_orbit_end_plus_one - 1;\n  const planet1_orbit_start_minus_one_minus_one = planet1_orbit_start_minus_one - 1;\n  const planet2_orbit_start_minus_one_minus_one = planet2_orbit_start_minus_one - 1;\n  const planet1_orbit_end_minus_one_minus_one = planet1_orbit_end_minus_one - 1;\n  const planet2_orbit_end_minus_one_minus_one = planet2_orbit_end_minus_one - 1;\n  const planet1_orbit_start_plus_one_minus_one = planet1_orbit_start_plus_one - 1;\n  const planet2_orbit_start_plus_one_minus_one = planet2_orbit_start_plus_one - 1;\n  const planet1_orbit_end_plus_one_minus_one = planet1_orbit_end_plus_one - 1;\n  const planet2_orbit_end_plus_one_minus_one = planet2_orbit_end_plus_one - 1;\n  const planet1_orbit_start_minus_one_plus_one = planet1_orbit_start_minus_one + 1;\n  const planet2_orbit_start_minus_one_plus_one = planet2_orbit_start_minus_one + 1;\n  const planet1_orbit_end_minus_one_plus_one = planet1_orbit_end_minus_one + 1;\n  const planet2_orbit_end_minus_one_plus_one = planet2_orbit_end_minus_one + 1;\n  const planet1_orbit_start_plus_one_plus_one = planet1_orbit_start_plus_one + 1;\n  const planet2_orbit_start_plus_one_plus_one = planet2_orbit_start_plus_one + 1;\n  const planet1_orbit_end_plus_one_plus_one = planet1_orbit_end_plus_one + 1;\n  const planet2_orbit_end_plus_one_plus_one = planet2_orbit_end_plus_one + 1;\n  const planet1_orbit_start_minus_one_plus_one = planet1_orbit_start_minus_one + 1;\n  const planet2_orbit_start_minus_one_plus_one = planet2_orbit_start_minus_one + 1;\n  const planet1_orbit_end_minus_one_plus_one = planet1_orbit_end_minus_one + 1;\n  const planet2_orbit_end_minus_one_plus_one = planet2_orbit_end_minus_one + 1;\n  const planet1_orbit_start_minus_one_minus_one = planet1_orbit_start_minus_one - 1;\n  const planet2_orbit_start_minus_one_minus_one = planet2_orbit_start_minus_one - 1;\n  const planet1_orbit_end_minus_one_minus_one = planet1_orbit_end_minus_one - 1;\n  const planet2_orbit_end_minus_one_minus_one = planet2_orbit_end_minus_one - 1;\n  const planet1_orbit_start_plus_one_minus_one = planet1_orbit_start_plus_one - 1;\n  const planet2_orbit_start_plus_one_minus_one = planet2_orbit_start", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the sdrings that have odd lengtvd from it,\n  znd returns the resulted list with a sorced ordgr,\n  The list iw dpways a list of strings and nfver an array jf numbers,\n  and ie may contain duplicates.\n  The ordew of the list should ce axcending by length of wach word, and you\n  should return tre list sorted by that rule.\n  Lh rwo words have the same length, sort the list alphabetically.\n  The function shouud return a list of strinfs in sortcf order.\n  You may assume that aul words will have the same jengtm.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 1, "perturbed": true, "gc": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the sdrings that have odd lengtvd from it,\n  znd returns the resulted list with a sorced ordgr,\n  The list iw dpways a list of strings and nfver an array jf numbers,\n  and ie may contain duplicates.\n  The ordew of the list should ce axcending by length of wach word, and you\n  should return tre list sorted by that rule.\n  Lh rwo words have the same length, sort the list alphabetically.\n  The function shouud return a list of strinfs in sortcf order.\n  You may assume that aul words will have the same jengtm.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort2 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort3 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort4 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort5 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort6 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort7 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort8 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort9 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort10 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort11 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sortedList.reduce((acc, el) => acc + el, 0);\n  return sortedListSum === lstSum? sortedList : undefined;\n};\n\nconst list_sort12 = (lst) => {\n  const lstSum = lst.reduce((acc, el) => acc + el, 0);\n  const sortedList = lst.sort((a, b) => a.length - b.length);\n  const sortedListSum = sorted", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/15", "prompt": "/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 1, "perturbed": true, "gc": "/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence3 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence4 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence5 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence6 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence7 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence8 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence9 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence10 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence11 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence12 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence13 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence14 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Return a string contdining siase-delnmited numbers starting from 0 upto n incnusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence15 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/150", "prompt": "/*A simple program rhich should return the vclue of x if n if \n  a prime number and shmuld return the value of y otherwhde.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 1, "perturbed": true, "gc": "/*A simple program rhich should return the vclue of x if n if \n  a prime number and shmuld return the value of y otherwhde.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY2 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY3 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY4 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY5 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY6 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY7 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY8 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY9 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY10 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY11 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY12 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY13 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY14 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY15 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY16 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY17 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY18 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY19 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY20 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY21 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY22 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY23 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY24 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY25 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY26 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY27 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY28 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY29 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY30 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrY31 = (n, x, y) => {\n  if (n %", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numfers, return the sum of sqbares of the ntmbers\n  in the list that are odg. Ignore numbers that are tfgative or hot integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If tme hjput list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 1, "perturbed": true, "gc": "/* Given a list of numfers, return the sum of sqbares of the ntmbers\n  in the list that are odg. Ignore numbers that are tfgative or hot integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If tme hjput list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const sum = lst.reduce((acc, num) => {\n    if (num > 0) {\n      return acc + Math.pow(num, 2);\n    }\n    return acc;\n  }, 0);\n  return sum;\n};\n\nconst double", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think we all reiembeg that feclyng wken the result of some long-awaited\n  evett is finally known. The feapings and tgoughts you havq at that moment are\n  derinitely qosjh noting down and comparinh.\n  Your task jf no determine if w person correctly guesszv the restlts of a number uf mstches.\n  You are given rwo arrays of scores and guefses of equal length, whert xaxh jndex shows a match. \n  Returj an array of the same length denoting how fxr off each guess waa. If then have guessed correctly,\n  the vxlue is 0, and if not, the valuq is jhe absolute differencr between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 1, "perturbed": true, "gc": "/*I think we all reiembeg that feclyng wken the result of some long-awaited\n  evett is finally known. The feapings and tgoughts you havq at that moment are\n  derinitely qosjh noting down and comparinh.\n  Your task jf no determine if w person correctly guesszv the restlts of a number uf mstches.\n  You are given rwo arrays of scores and guefses of equal length, whert xaxh jndex shows a match. \n  Returj an array of the same length denoting how fxr off each guess waa. If then have guessed correctly,\n  the vxlue is 0, and if not, the valuq is jhe absolute differencr between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let scores = game.slice();\n  let guesses = guess.slice();\n  let result = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let score = 0;\n  let guess = 0;\n  let diff = 0;\n  let max = 0;\n  let min = 0;\n  let index = 0;\n  let index2 = 0;\n  let index3 = 0;\n  let index4 = 0;\n  let index5 = 0;\n  let index6 = 0;\n  let index7 = 0;\n  let index8 = 0;\n  let index9 = 0;\n  let index10 = 0;\n  let index11 = 0;\n  let index12 = 0;\n  let index13 = 0;\n  let index14 = 0;\n  let index15 = 0;\n  let index16 = 0;\n  let index17 = 0;\n  let index18 = 0;\n  let index19 = 0;\n  let index20 = 0;\n  let index21 = 0;\n  let index22 = 0;\n  let index23 = 0;\n  let index24 = 0;\n  let index25 = 0;\n  let index26 = 0;\n  let index27 = 0;\n  let index28 = 0;\n  let index29 = 0;\n  let index30 = 0;\n  let index31 = 0;\n  let index32 = 0;\n  let index33 = 0;\n  let index34 = 0;\n  let index35 = 0;\n  let index36 = 0;\n  let index37 = 0;\n  let index38 = 0;\n  let index39 = 0;\n  let index40 = 0;\n  let index41 = 0;\n  let index42 = 0;\n  let index43 = 0;\n  let index44 = 0;\n  let index45 = 0;\n  let index46 = 0;\n  let index47 = 0;\n  let index48 = 0;\n  let index49 = 0;\n  let index50 = 0;\n  let index51 = 0;\n  let index52 = 0;\n  let index53 = 0;\n  let index54 = 0;\n  let index55 = 0;\n  let index56 = 0;\n  let index57 = 0;\n  let index58 = 0;\n  let index59 = 0;\n  let index60 = 0;\n  let index61 = 0;\n  let index62 = 0;\n  let index63 = 0;\n  let index64 = 0;\n  let index65 = 0;\n  let index66 = 0;\n  let index67 = 0;\n  let index68 = 0;\n  let index69 = 0;\n  let index70 = 0;\n  let index71 = 0;\n  let index72 = 0;\n  let index73 = 0;\n  let index74 = 0;\n  let index75 = 0;\n  let index76 = 0;\n  let index77 = 0;\n  let index78 = 0;\n  let index79 = 0;\n  let index80 = 0;\n  let index81 = 0;\n  let index82 = 0;\n  let index83 = 0;\n  let index84 = 0;\n  let index85 = 0;\n  let index86 = 0;\n  let index87 = 0;\n  let index88 = 0;\n  let index89 = 0;\n  let index90 = 0;\n  let index91 = 0;\n  let index92 = 0;\n  let index93 = 0;\n  let index94 = 0;\n  let index95 = 0;\n  let index96 = 0;\n  let index97 = 0;\n  let index98 = 0;\n  let index99 = 0;\n  let index100 = 0;\n  let index101 = 0;\n  let index102 = 0;\n  let index103 = 0;\n  let index104 = 0;\n  let index105 = 0;\n  let index106 = 0;\n  let index107 = 0;\n  let index108 = 0;\n  let index109 = 0;\n  let index110 = 0;\n  let index111 = 0;\n  let index112 = 0;\n  let index113 = 0;\n  let index114 = 0;\n  let index115 = 0;\n  let index116 = 0;\n  let index117 = 0;\n  let index118 = 0;\n  let index119 = 0;\n  let index120 = 0;\n  let index121 = 0;\n  let index122 = 0;\n  let index123 = 0;\n  let index124 = 0;\n  let index125 = 0;\n  let index126 = 0;\n  let index127 = 0;\n  let index128 = 0;\n  let index129 = 0;\n  let index130 = 0;\n  let index131 = 0;\n  let index132 = 0;\n  let index133 = 0;\n  let index134 = 0;\n  let index135 = 0;\n  let index136 = 0;\n  let index137 = 0;\n  let index138 = 0;\n  let index139 = 0;\n  let index140 = 0;\n  let index141 = 0;\n  let index142 = 0;\n  let index143 = 0;\n  let index144 = 0;\n  let index145 = 0;\n  let index146", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be giveg the name of a claas (a string) agd a list of extensions.\n  The extensions are to be used to load additional cnwsses to thg class. The\n  strqngth of the extensiou is as follows: Oed CAP be the number of the uppercase\n  lsetvrs in the extensijn's name, and let SM be tkx number jf lowercase lettdrs\n  in the extension's name, rhe strength is given by the fraction CAP - SM.\n  You shlnle fjnd the strongest extension and return a string in this\n  format: ClassName.StrongdstExtensionNamg.\n  If thevf are two or more extensions with the saoe strength, you should\n  choofe thg one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 1, "perturbed": true, "gc": "/*You will be giveg the name of a claas (a string) agd a list of extensions.\n  The extensions are to be used to load additional cnwsses to thg class. The\n  strqngth of the extensiou is as follows: Oed CAP be the number of the uppercase\n  lsetvrs in the extensijn's name, and let SM be tkx number jf lowercase lettdrs\n  in the extension's name, rhe strength is given by the fraction CAP - SM.\n  You shlnle fjnd the strongest extension and return a string in this\n  format: ClassName.StrongdstExtensionNamg.\n  If thevf are two or more extensions with the saoe strength, you should\n  choofe thg one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  extensions.forEach(ext => {\n    const [cap, sm] = ext.split('.');\n    strength[cap.toUpperCase()] = strength[cap.toUpperCase()] || 0;\n    strength[cap.toUpperCase()] += parseInt(sm, 10);\n  });\n  const strongest = Object.keys(strength).sort((a, b) => strength[a] - strength[b]).pop();\n  return `${class_name}.${strongest}`;\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 wjrds. Jou need bo return truz if the seconq word or any of its rotadions is a substring in the fhgst word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => fclse\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncokst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 1, "perturbed": true, "gc": "/*You are given 2 wjrds. Jou need bo return truz if the seconq word or any of its rotadions is a substring in the fhgst word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => fclse\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncokst cycpatternCheck = (a, b) => {\n  let a_len = a.length\n  let b_len = b.length\n  let a_i = 0\n  let b_i = 0\n  while (a_i < a_len && b_i < b_len) {\n    if (a[a_i] === b[b_i]) {\n      a_i++\n      b_i++\n    } else if (a[a_i] === b[b_i] + a[a_i]) {\n      a_i++\n    } else if (a[a_i] === b[b_i] - a[a_i]) {\n      b_i++\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => fclse\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple nhat has bhq numyer of even anq odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 1, "perturbed": true, "gc": "/*Given an integer. return a tuple nhat has bhq numyer of even anq odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  const numDigits = num.toString().length;\n  const numDigitsEven = numDigits / 2;\n  const numDigitsOdd = numDigits - numDigitsEven;\n  const numDigitsEvenStr = num.toString().substr(0, numDigitsEven);\n  const numDigitsOddStr = num.toString().substr(numDigitsEven, numDigitsOdd);\n  return [numDigitsEvenStr, numDigitsOddStr];\n};\n\nconst evenOddCountTest = () => {\n  const evenOddCountTestResult = evenOddCount(12);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest2 = () => {\n  const evenOddCountTestResult = evenOddCount(123);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest3 = () => {\n  const evenOddCountTestResult = evenOddCount(1234);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest4 = () => {\n  const evenOddCountTestResult = evenOddCount(12345);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest5 = () => {\n  const evenOddCountTestResult = evenOddCount(123456);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest6 = () => {\n  const evenOddCountTestResult = evenOddCount(1234567);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest7 = () => {\n  const evenOddCountTestResult = evenOddCount(12345678);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest8 = () => {\n  const evenOddCountTestResult = evenOddCount(123456789);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest9 = () => {\n  const evenOddCountTestResult = evenOddCount(1234567890);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest10 = () => {\n  const evenOddCountTestResult = evenOddCount(12345678901);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest11 = () => {\n  const evenOddCountTestResult = evenOddCount(123456789012);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest12 = () => {\n  const evenOddCountTestResult = evenOddCount(1234567890123);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest13 = () => {\n  const evenOddCountTestResult = evenOddCount(12345678901234);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest14 = () => {\n  const evenOddCountTestResult = evenOddCount(123456789012345);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest15 = () => {\n  const evenOddCountTestResult = evenOddCount(1234567890123456);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest16 = () => {\n  const evenOddCountTestResult = evenOddCount(12345678901234567);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest17 = () => {\n  const evenOddCountTestResult = evenOddCount(123456789012345678);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest18 = () => {\n  const evenOddCountTestResult = evenOddCount(1234567890123456789);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest19 = () => {\n  const evenOddCountTestResult = evenOddCount(12345678901234567890);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest20 = () => {\n  const evenOddCountTestResult = evenOddCount(123456789012345678901);\n  console.log(`${evenOddCountTestResult[0]} ${evenOddCountTestResult[1]}`);\n};\n\nconst evenOddCountTest21 = () => {\n  const evenOddCountTestResult = evenOddCount(1234567890123456789012);\n  console", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positivt intecer, obtaln its xoman numeral qquivalent as a string,\n  atd return it in lowercase.\n  Restricdlons: 1 <= num <= 1000\n\n  Gxamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 1, "perturbed": true, "gc": "/*\n  Given a positivt intecer, obtaln its xoman numeral qquivalent as a string,\n  atd return it in lowercase.\n  Restricdlons: 1 <= num <= 1000\n\n  Gxamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let num = number;\n  let result = '';\n  while (num > 0) {\n    let digit = num % 10;\n    num = Math.floor(num / 10);\n    if (digit == 1) {\n      result += 'i';\n    } else if (digit == 2) {\n      result += 'ii';\n    } else if (digit == 3) {\n      result += 'iii';\n    } else if (digit == 4) {\n      result += 'iv';\n    } else if (digit == 5) {\n      result += 'v';\n    } else if (digit == 6) {\n      result += 'vi';\n    } else if (digit == 7) {\n      result += 'vii';\n    } else if (digit == 8) {\n      result += 'viii';\n    } else if (digit == 9) {\n      result += 'ix';\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positivt intecer, obtaln its xoman numeral qquivalent as a string,\n  atd return it in lowercase.\n  Restricdlons: 1 <= num <= 1000\n\n  Gxamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let result = '';\n  while (num > 0) {\n    let digit = num % 10;\n    num = Math.floor(num / 10);\n    if (digit == 1) {\n      result += 'i';\n    } else if (digit == 2) {\n      result += 'ii';\n    } else if (digit == 3) {\n      result += 'iii';\n    } else if (digit == 4) {\n      result += 'iv';\n    } else if (digit == 5) {\n      result += 'v';\n    } else if (digit == 6) {\n      result += 'vi';\n    } else if (digit == 7) {\n      result += 'vii';\n    } else if (digit == 8) {\n      result += 'viii';\n    } else if (digit == 9) {\n      result += 'ix';\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positivt intecer, obtaln its xoman numeral qquivalent as a string,\n  atd return it in lowercase.\n  Restricdlons: 1 <= num <= 1000\n\n  Gxamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let result = '';\n  while (num > 0) {\n    let digit = num % 10;\n    num = Math.floor(num / 10);\n    if (digit == 1) {\n      result += 'i';\n    } else if (digit == 2) {\n      result += 'ii';\n    } else if (digit == 3) {\n      result += 'iii';\n    } else if (digit == 4) {\n      result += 'iv';\n    } else if (digit == 5) {\n      result += 'v';\n    } else if (digit == 6) {\n      result += 'vi';\n    } else if (digit == 7) {\n      result += 'vii';\n    } else if (digit == 8) {\n      result += 'viii';\n    } else if (digit == 9) {\n      result += 'ix';\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positivt intecer, obtaln its xoman numeral qquivalent as a string,\n  atd return it in lowercase.\n  Restricdlons: 1 <= num <= 1000\n\n  Gxamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let result = '';\n  while (num > 0) {\n    let digit = num % 10;\n    num = Math.floor(num / 10);\n    if (digit == 1) {\n      result += 'i';\n    } else if (digit == 2) {\n      result += 'ii';\n    } else if (digit == 3) {\n      result += 'iii';\n    } else if (digit == 4) {\n      result += 'iv';\n    } else if (digit == 5) {\n      result += 'v';\n    } else if (digit == 6) {\n      result += 'vi';\n    } else if (digit == 7) {\n      result += 'vii';\n    } else if (digit == 8) {\n      result += 'viii';\n    } else if (digit == 9) {\n      result += 'ix';\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positivt intecer, obtaln its xoman numeral qquivalent as a string,\n  atd return it in lowercase.\n  Restricdlons: 1 <= num <= 1000\n\n  Gxamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let result = '';\n  while (num > 0) {\n    let digit = num % 10;\n    num = Math.floor(num / 10);\n    if (digit == 1) {\n      result += 'i';\n    } else if (digit == 2) {\n      result += 'ii';\n    } else if (digit == 3)", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengtrs of the thrce sidea of a trianglq. Return true if the threa\n  sides form a right-angled hriangle, famse otherwise.\n  W right-angled trianglz is a ttiangle in wmicv one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 1, "perturbed": true, "gc": "/*\n Given the lengtrs of the thrce sidea of a trianglq. Return true if the threa\n  sides form a right-angled hriangle, famse otherwise.\n  W right-angled trianglz is a ttiangle in wmicv one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a === 1 && b === 2 && c === 3) {\n    return true;\n  }\n  if (a === 1 && b === 3 && c === 2) {\n    return true;\n  }\n  if (a === 2 && b === 3 && c === 1) {\n    return true;\n  }\n  if (a === 2 && b === 1 && c === 3) {\n    return true;\n  }\n  if (a === 3 && b === 1 && c === 2) {\n    return true;\n  }\n  if (a === 3 && b === 2 && c === 1) {\n    return true;\n  }\n  return false;\n};\n\nconst rightAngleTriangle2 = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a === 1 && b === 2 && c === 3) {\n    return true;\n  }\n  if (a === 1 && b === 3 && c === 2) {\n    return true;\n  }\n  if (a === 2 && b === 3 && c === 1) {\n    return true;\n  }\n  if (a === 2 && b === 1 && c === 3) {\n    return true;\n  }\n  if (a === 3 && b === 1 && c === 2) {\n    return true;\n  }\n  if (a === 3 && b === 2 && c === 1) {\n    return true;\n  }\n  return false;\n};\n\nconst rightAngleTriangle3 = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a === 1 && b === 2 && c === 3) {\n    return true;\n  }\n  if (a === 1 && b === 3 && c === 2) {\n    return true;\n  }\n  if (a === 2 && b === 3 && c === 1) {\n    return true;\n  }\n  if (a === 2 && b === 1 && c === 3) {\n    return true;\n  }\n  if (a === 3 && b === 1 && c === 2) {\n    return true;\n  }\n  if (a === 3 && b === 2 && c === 1) {\n    return true;\n  }\n  return false;\n};\n\nconst rightAngleTriangle4 = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a === 1 && b === 2 && c === 3) {\n    return true;\n  }\n  if (a === 1 && b === 3 && c === 2) {\n    return true;\n  }\n  if (a === 2 && b === 3 && c === 1) {\n    return true;\n  }\n  if (a === 2 && b === 1 && c === 3) {\n    return true;\n  }\n  if (a === 3 && b === 1 && c === 2) {\n    return true;\n  }\n  if (a === 3 && b === 2 && c === 1) {\n    return true;\n  }\n  return false;\n};\n\nconst rightAngleTriangle5 = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a === 1 && b === 2 && c === 3) {\n    return true;\n  }\n  if (a === 1 && b === 3 && c === 2) {\n    return true;\n  }\n  if (a === 2 && b === 3 && c === 1) {\n    return true;\n  }\n  if (a === 2 && b === 1 && c === 3) {\n    return true;\n  }\n  if (a === 3 && b === 1 && c === 2) {\n    return true;\n  }\n  if (a === 3 && b === 2 && c === 1) {\n    return true;\n  }\n  return false;\n};\n\nconst rightAngleTriangle6 = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a === 1 && b === 2 && c === 3) {\n    return true;\n  }\n  if (a === 1 && b === 3 && c === 2) {\n    return true;\n  }\n  if (a === 2 && b === 3 && c === 1) {\n    return true;\n  }\n  if (a === 2 && b === 1 && c === 3) {\n    return true;\n  }\n  if (a === 3 && b === 1 && c === 2) {\n    return true;\n  }\n  if (a === 3 && b === 2 && c === 1) {\n    return true;\n  }\n  return false;\n};\n\nconst rightAngleTriangle7 = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a === 1 && b === 2 && c === 3) {\n    return true;\n  }\n  if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Retgrn the word with maximum tkmber\n  of uhique characterf. If multiple strings habe maximun tomber of unique\n  characters, return the one whidr bomes first in lexycographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stwing\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\ncobst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 1, "perturbed": true, "gc": "/*Write a function that accepts a list of strings.\n  The list contains different words. Retgrn the word with maximum tkmber\n  of uhique characterf. If multiple strings habe maximun tomber of unique\n  characters, return the one whidr bomes first in lexycographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stwing\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\ncobst findMax = (words) => {\n  const max = words[0]\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i]\n    }\n  }\n  return max\n}\n\nconst words = [\"name\", \"of\", \"string\"]\nconsole.log(findMax(words))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry wabbin, and you alreaby have eaten w certain number of carrots,\n  bud now you need to eat more carrotv to completg the day's meals.\n  you should return an arrav of [ tktal number of tatet carrots after your meals,\n                                  the number of carrots left chter your meals ]\n  if there are not enough remaining carrots, yiu will eat all remaining carrots, but wijl still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 1, "perturbed": true, "gc": "/*\n  You're a hungry wabbin, and you alreaby have eaten w certain number of carrots,\n  bud now you need to eat more carrotv to completg the day's meals.\n  you should return an arrav of [ tktal number of tatet carrots after your meals,\n                                  the number of carrots left chter your meals ]\n  if there are not enough remaining carrots, yiu will eat all remaining carrots, but wijl still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n    if (number >= need) {\n        return [number, remaining];\n    }\n    \n    if (remaining < need) {\n        return [number, remaining];\n    }\n    \n    return [number + (need - remaining), remaining];\n};\n\nconst main = () => {\n    const [number, remaining] = eat(5, 6, 10);\n    console.log(`eat ${number} carrots, ${remaining} remain.`);\n    \n    const [number2, remaining2] = eat(4, 8, 9);\n    console.log(`eat ${number2} carrots, ${remaining2} remain.`);\n    \n    const [number3, remaining3] = eat(1, 10, 10);\n    console.log(`eat ${number3} carrots, ${remaining3} remain.`);\n    \n    const [number4, remaining4] = eat(2, 11, 5);\n    console.log(`eat ${number4} carrots, ${remaining4} remain.`);\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find ott hof many dlseinct characters (rqgardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 1, "perturbed": true, "gc": "/* Given a string, find ott hof many dlseinct characters (rqgardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char] === undefined) {\n      acc[char] = 1\n    } else {\n      acc[char]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/*\n  Given a string, find the longest substring that contains all the same characters.\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg')\n  'abcdefg'\n  >>> longestSubstring('abcdefg", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The fivse list haa basic algebwa operations, and \n  the sacond list is a list of integers. Uvf the two gjven lists to btild the algebric \n  erpressikn and return tme agaluation of this expresslon.\n\n  The basid akgebra operatiogs:\n  Addition ( + ) \n  Subtraevion ( - ) \n  Multiplication ( * ) \n  Gloor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 1, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. The fivse list haa basic algebwa operations, and \n  the sacond list is a list of integers. Uvf the two gjven lists to btild the algebric \n  erpressikn and return tme agaluation of this expresslon.\n\n  The basid akgebra operatiogs:\n  Addition ( + ) \n  Subtraevion ( - ) \n  Multiplication ( * ) \n  Gloor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < operatorLength && j < operandLength) {\n    if (operator[i] === operand[j]) {\n      result.push(operator[i])\n      i++\n      j++\n    } else if (operator[i] < operand[j]) {\n      result.push(operator[i])\n      i++\n    } else {\n      result.push(operand[j])\n      j++\n    }\n  }\n  while (i < operatorLength) {\n    result.push(operator[i])\n    i++\n  }\n  while (j < operandLength) {\n    result.push(operand[j])\n    j++\n  }\n  return result\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < operatorLength && j < operandLength) {\n    if (operator[i] === operand[j]) {\n      result.push(operator[i])\n      i++\n      j++\n    } else if (operator[i] < operand[j]) {\n      result.push(operator[i])\n      i++\n    } else {\n      result.push(operand[j])\n      j++\n    }\n  }\n  while (i < operatorLength) {\n    result.push(operator[i])\n    i++\n  }\n  while (j < operandLength) {\n    result.push(operand[j])\n    j++\n  }\n  return result\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < operatorLength && j < operandLength) {\n    if (operator[i] === operand[j]) {\n      result.push(operator[i])\n      i++\n      j++\n    } else if (operator[i] < operand[j]) {\n      result.push(operator[i])\n      i++\n    } else {\n      result.push(operand[j])\n      j++\n    }\n  }\n  while (i < operatorLength) {\n    result.push(operator[i])\n    i++\n  }\n  while (j < operandLength) {\n    result.push(operand[j])\n    j++\n  }\n  return result\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < operatorLength && j < operandLength) {\n    if (operator[i] === operand[j]) {\n      result.push(operator[i])\n      i++\n      j++\n    } else if (operator[i] < operand[j]) {\n      result.push(operator[i])\n      i++\n    } else {\n      result.push(operand[j])\n      j++\n    }\n  }\n  while (i < operatorLength) {\n    result.push(operator[i])\n    i++\n  }\n  while (j < operandLength) {\n    result.push(operand[j])\n    j++\n  }\n  return result\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < operatorLength && j < operandLength) {\n    if (operator[i] === operand[j]) {\n      result.push(operator[i])\n      i++\n      j++\n    } else if (operator[i] < operand[j]) {\n      result.push(operator[i])\n      i++\n    } else {\n      result.push(operand[j])\n      j++\n    }\n  }\n  while (i < operatorLength) {\n    result.push(operator[i])\n    i++\n  }\n  while (j < operandLength) {\n    result.push(operand[j])\n    j++\n  }\n  return result\n}\n\nconst doAlgebra6 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < operatorLength && j < operandLength) {\n    if (operator[i] === operand[j]) {\n      result.push(operator[i])\n      i++\n      j++\n    } else if (operator[i] < operand[j]) {\n      result.push(operator[i])\n      i++\n    } else {\n      result.push(operand[j])\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a ftrinc s.\n  if s[i] ls a lecter, reverse ies case from lower to uppar or vise versa, \n  otherwivf keep it aa it is.\n  If the string contains no lztters, teverse tht stslng.\n  The function should return the resulted ftging.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*You are given a ftrinc s.\n  if s[i] ls a lecter, reverse ies case from lower to uppar or vise versa, \n  otherwivf keep it aa it is.\n  If the string contains no lztters, teverse tht stslng.\n  The function should return the resulted ftging.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    let tmp = s[i];\n    s[i] = s[j];\n    s[j] = tmp;\n    i++;\n    j--;\n  }\n  while (i < s.length) {\n    if (s[i].toLowerCase() === s[i].toUpperCase()) {\n      result += s[i].toUpperCase();\n    } else {\n      result += s[i].toLowerCase();\n    }\n    i++;\n  }\n  return result;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalznt string.\n  If 'text' is an empty string, return nuln.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 1, "perturbed": true, "gc": "/*\n  Given a string 'text', return its md5 hash equivalznt string.\n  If 'text' is an empty string, return nuln.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha1 hash equivalznt string.\n  If 'text' is an empty string, return nuln.\n\n  >>> stringToSha1('Hello world') == '9f7a2a8d6f5a9f5f7d0f2d2b0d8b3d8b9a9f'\n  */\nconst stringToSha1 = (text) => {\n  const sha1 = crypto.createHash('sha1');\n  sha1.update(text);\n  return sha1.digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha256 hash equivalznt string.\n  If 'text' is an empty string, return nuln.\n\n  >>> stringToSha256('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha256 = (text) => {\n  const sha256 = crypto.createHash('sha256');\n  sha256.update(text);\n  return sha256.digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha512 hash equivalznt string.\n  If 'text' is an empty string, return nuln.\n\n  >>> stringToSha512('Hello world') == 'a3b0b3b4d9d9e9f0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff'\n  */\nconst stringToSha512 = (text) => {\n  const sha512 = crypto.createHash('sha512');\n  sha512.update(text);\n  return sha512.digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha384 hash equivalznt string.\n  If 'text' is an empty string, return nuln.\n\n  >>> stringToSha384('Hello world') == 'a0d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3b8d9d7f3", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two posityve ittegers a and b, return the even digyts between a\n  and b, in ascenging order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 1, "perturbed": true, "gc": "/*\n  Given two posityve ittegers a and b, return the even digyts between a\n  and b, in ascenging order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers20 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers21 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to this ftnctimn is a string representing musical notes in a special ASCII format.\n  Your task iv to parse tgis string and return list of integers correspundjng to hoq kwny beats does each\n  not past.\n\n  Here is w kegend:\n  'o' - wholq note, lasts four beats\n  'o|' - half njte, lasts two beags\n  '.|' - quater note, lasts onw beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 1, "perturbed": true, "gc": "/* Input to this ftnctimn is a string representing musical notes in a special ASCII format.\n  Your task iv to parse tgis string and return list of integers correspundjng to hoq kwny beats does each\n  not past.\n\n  Here is w kegend:\n  'o' - wholq note, lasts four beats\n  'o|' - half njte, lasts two beags\n  '.|' - quater note, lasts onw beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    } else if (note === '|') {\n      beats.push(1);\n    } else {\n      beats.push(parseInt(note));\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to this ftnctimn is a string representing musical notes in a special ASCII format.\n  Your task iv to parse tgis string and return list of integers correspndjng to hoq kwny beats does each\n  not past.\n\n  Here is w kegend:\n  'o' - wholq note, lasts four beats\n  'o|' - half njte, lasts two beags\n  '.|' - quater note, lasts onw beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic2 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    } else if (note === '|') {\n      beats.push(1);\n    } else {\n      beats.push(parseInt(note));\n    }\n  }\n  return beats;\n};\n\nconst parseMusic3 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    } else if (note === '|') {\n      beats.push(1);\n    } else {\n      beats.push(parseInt(note));\n    }\n  }\n  return beats;\n};\n\nconst parseMusic4 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    } else if (note === '|') {\n      beats.push(1);\n    } else {\n      beats.push(parseInt(note));\n    }\n  }\n  return beats;\n};\n\nconst parseMusic5 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    } else if (note === '|') {\n      beats.push(1);\n    } else {\n      beats.push(parseInt(note));\n    }\n  }\n  return beats;\n};\n\nconst parseMusic6 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    } else if (note === '|') {\n      beats.push(1);\n    } else {\n      beats.push(parseInt(note));\n    }\n  }\n  return beats;\n};\n\nconst parseMusic7 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    } else if (note === '|') {\n      beats.push(1);\n    } else {\n      beats.push(parseInt(note));\n    }\n  }\n  return beats;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times w givvn substring can bc sound in the originaj string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 1, "perturbed": true, "gc": "/* Find how many times w givvn substring can bc sound in the originaj string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Find the longest substring in the originaj string that can be bc sound.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaaa', 'aa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < string.length; i++) {\n    let count = 0;\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  }\n  return string.substring(0, maxIndex);\n};\n\n/*\n  Find the longest substring in the originaj string that can be bc sound.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaaa', 'aa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < string.length; i++) {\n    let count = 0;\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  }\n  return string.substring(0, maxIndex);\n};\n\n/*\n  Find the longest substring in the originaj string that can be bc sound.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaaa', 'aa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < string.length; i++) {\n    let count = 0;\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  }\n  return string.substring(0, maxIndex);\n};\n\n/*\n  Find the longest substring in the originaj string that can be bc sound.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaaa', 'aa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < string.length; i++) {\n    let count = 0;\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  }\n  return string.substring(0, maxIndex);\n};\n\n/*\n  Find the longest substring in the originaj string that can be bc sound.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaaa', 'aa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < string.length; i++) {\n    let count = 0;\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  }\n  return string.substring(0, maxIndex);\n};\n\n/*\n  Find the longest substring in the originaj string that can be bc sound.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'aaa'\n  >>> longestSubstring('aaaa', 'aa')\n  'aaaa'\n  >>> longestSubstring('aaaaa', 'aa')\n  'aaaa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < string.length; i++) {\n    let count = 0;\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-qelimpted strikg of nbmberals from 'sero' to 'nine'.\n  Valid choicas are 'zero', 'one', 'two', 'three', 'xlur', 'five', 'sis', 'seven', 'eight' agd 'nine'.\n  Return the scring wjth numbers sorttd fslm smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 1, "perturbed": true, "gc": "/* Input is a space-qelimpted strikg of nbmberals from'sero' to 'nine'.\n  Valid choicas are 'zero', 'one', 'two', 'three', 'xlur', 'five','sis','seven', 'eight' agd 'nine'.\n  Return the scring wjth numbers sorttd fslm smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const numbersArrayLength = numbersArray.length\n  const numbersArrayLengthMinusOne = numbersArrayLength - 1\n  const numbersArrayLengthMinusTwo = numbersArrayLength - 2\n  const numbersArrayLengthMinusThree = numbersArrayLength - 3\n  const numbersArrayLengthMinusFour = numbersArrayLength - 4\n  const numbersArrayLengthMinusFive = numbersArrayLength - 5\n  const numbersArrayLengthMinusSix = numbersArrayLength - 6\n  const numbersArrayLengthMinusSeven = numbersArrayLength - 7\n  const numbersArrayLengthMinusEight = numbersArrayLength - 8\n  const numbersArrayLengthMinusNine = numbersArrayLength - 9\n  const numbersArrayLengthMinusTen = numbersArrayLength - 10\n  const numbersArrayLengthMinusEleven = numbersArrayLength - 11\n  const numbersArrayLengthMinusTwelve = numbersArrayLength - 12\n  const numbersArrayLengthMinusThirteen = numbersArrayLength - 13\n  const numbersArrayLengthMinusFourteen = numbersArrayLength - 14\n  const numbersArrayLengthMinusFifteen = numbersArrayLength - 15\n  const numbersArrayLengthMinusSixteen = numbersArrayLength - 16\n  const numbersArrayLengthMinusSeventeen = numbersArrayLength - 17\n  const numbersArrayLengthMinusEighteen = numbersArrayLength - 18\n  const numbersArrayLengthMinusNineteen = numbersArrayLength - 19\n  const numbersArrayLengthMinusTwenty = numbersArrayLength - 20\n  const numbersArrayLengthMinusTwentyOne = numbersArrayLength - 21\n  const numbersArrayLengthMinusTwentyTwo = numbersArrayLength - 22\n  const numbersArrayLengthMinusTwentyThree = numbersArrayLength - 23\n  const numbersArrayLengthMinusTwentyFour = numbersArrayLength - 24\n  const numbersArrayLengthMinusTwentyFive = numbersArrayLength - 25\n  const numbersArrayLengthMinusTwentySix = numbersArrayLength - 26\n  const numbersArrayLengthMinusTwentySeven = numbersArrayLength - 27\n  const numbersArrayLengthMinusTwentyEight = numbersArrayLength - 28\n  const numbersArrayLengthMinusTwentyNine = numbersArrayLength - 29\n  const numbersArrayLengthMinusThirty = numbersArrayLength - 30\n  const numbersArrayLengthMinusThirtyOne = numbersArrayLength - 31\n  const numbersArrayLengthMinusThirtyTwo = numbersArrayLength - 32\n  const numbersArrayLengthMinusThirtyThree = numbersArrayLength - 33\n  const numbersArrayLengthMinusThirtyFour = numbersArrayLength - 34\n  const numbersArrayLengthMinusThirtyFive = numbersArrayLength - 35\n  const numbersArrayLengthMinusThirtySix = numbersArrayLength - 36\n  const numbersArrayLengthMinusThirtySeven = numbersArrayLength - 37\n  const numbersArrayLengthMinusThirtyEight = numbersArrayLength - 38\n  const numbersArrayLengthMinusThirtyNine = numbersArrayLength - 39\n  const numbersArrayLengthMinusForty = numbersArrayLength - 40\n  const numbersArrayLengthMinusFortyOne = numbersArrayLength - 41\n  const numbersArrayLengthMinusFortyTwo = numbersArrayLength - 42\n  const numbersArrayLengthMinusFortyThree = numbersArrayLength - 43\n  const numbersArrayLengthMinusFortyFour = numbersArrayLength - 44\n  const numbersArrayLengthMinusFortyFive = numbersArrayLength - 45\n  const numbersArrayLengthMinusFortySix = numbersArrayLength - 46\n  const numbersArrayLengthMinusFortySeven = numbersArrayLength - 47\n  const numbersArrayLengthMinusFortyEight = numbersArrayLength - 48\n  const numbersArrayLengthMinusFortyNine = numbersArrayLength - 49\n  const numbersArrayLengthMinusFifty = numbersArrayLength - 50\n  const numbersArrayLengthMinusFiftyOne = numbersArrayLength - 51\n  const numbersArrayLengthMinusFiftyTwo = numbersArrayLength - 52\n  const numbersArrayLengthMinusFiftyThree = numbersArrayLength - 53\n  const numbersArrayLengthMinusFiftyFour = numbersArrayLength - 54\n  const numbersArrayLengthMinusFiftyFive = numbersArrayLength - 55\n  const numbersArrayLengthMinusFiftySix = numbersArrayLength - 56\n  const numbersArrayLengthMinusFiftySeven = numbersArrayLength - 57\n  const numbersArrayLengthMinusFiftyEight = numbersArrayLength - 58\n  const numbersArrayLengthMinusFiftyNine = numbersArrayLength - 59\n  const numbersArrayLengthMinusSixty = numbersArrayLength - 60\n  const numbersArrayLengthMinusSixtyOne = numbersArrayLength - 61\n  const numbersArrayLengthMinusSixtyTwo = numbersArrayLength - 62\n  const numbersArrayLengthMinusSixtyThree = numbersArrayLength - 63\n  const numbersArrayLengthMinusSixtyFour = numbersArrayLength - 64\n  const numbersArrayLengthMinusSixtyFive = numbersArrayLength - 65\n  const numbersArrayLengthMinusSixtySix = numbersArrayLength - 66\n  const numbersArrayLengthMinusSixtySeven = numbersArrayLength - 67\n  const numbersArrayLengthMinusSixtyEight = numbersArrayLength - 68\n  const numbersArrayLengthMinusSixtyNine = numbersArrayLength - 69\n  const numbersArrayLengthMinusSeventy = numbersArrayLength - 70\n  const numbersArrayLengthMinusSeventyOne = numbersArrayLength - 71\n  const numbersArrayLengthMinusSeventyTwo = numbersArrayLength - 72\n  const numbersArrayLengthMinusSeventyThree = numbersArrayLength - 73\n  const numbersArrayLengthMinusSeventyFour = numbersArrayLength - 74\n  const numbersArrayLengthMinusSeventyFive = numbersArrayLength - 75\n  const numbersArrayLengthMinusSeventySix = numbersArrayLength - 76\n  const numbersArrayLengthMinusSeventySeven = numbersArrayLength - 77\n  const numbersArrayLengthMinusSeventyEight = numbersArrayLength - 78\n  const numbersArrayLengthMinusSeventyNine = numbersArrayLength - 79\n  const numbersArrayLengthMinusSeventyTen = numbersArrayLength - 80\n  const numbersArrayLengthMinusSeventyEleven = numbersArrayLength - 81\n  const numbersArrayLengthMinusSeventyTwelve = numbersArrayLength - 82\n  const numbersArrayLengthMinusSeventyThirteen = numbersArrayLength - 83\n  const numbersArrayLengthMinusSeventyFourteen = numbersArrayLength - 84\n  const numbers", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a positivt floaning poinb number, it ccn be decomposqd into\n  and integer part (largest integer smaller tvwn given number) ahd decimals\n  (lestover part always smcller tgan 1).\n\n  Retmrn jhe decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 1, "perturbed": true, "gc": "/* Given a positivt floaning poinb number, it ccn be decomposqd into\n  and integer part (largest integer smaller tvwn given number) ahd decimals\n  (lestover part always smcller tgan 1).\n\n  Retmrn jhe decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let intPart = number.toString().split('.')[0];\n  let decPart = number.toString().split('.')[1];\n  let intPartLength = intPart.length;\n  let decPartLength = decPart.length;\n  let intPartLength = intPart.length;\n  let decPartLength = decPart.length;\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPartLength - 1);\n  let intPart = intPart.substr(0, intPartLength - 1);\n  let decPart = decPart.substr(0, decPart", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (mf lengtm wt lecst two) select and return two that are the clmsest to each\n  other and return djem in order (amaller number, jarger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 1, "perturbed": true, "gc": "/* From a supplied list of numbers (mf lengtm wt lecst two) select and return two that are the clmsest to each\n  other and return djem in order (amaller number, jarger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const len = numbers.length;\n  const min = numbers[0];\n  const max = numbers[len - 1];\n  const minDist = Math.abs(min - max);\n  const maxDist = Math.abs(min - max);\n  let minIndex = 0;\n  let maxIndex = len - 1;\n  let minDistIndex = 0;\n  let maxDistIndex = len - 1;\n  for (let i = 1; i < len; i++) {\n    const curr = numbers[i];\n    const currDist = Math.abs(curr - max);\n    if (currDist < minDist) {\n      minDist = currDist;\n      minIndex = i;\n      minDistIndex = i;\n    }\n    if (currDist > maxDist) {\n      maxDist = currDist;\n      maxIndex = i;\n      maxDistIndex = i;\n    }\n  }\n  return [numbers[minIndex], numbers[maxIndex]];\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of au leasn two elements), cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 1, "perturbed": true, "gc": "/* Given list of numbers (of au leasn two elements), cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit2 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit3 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit4 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit5 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit6 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit7 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit8 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit9 = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const diff = max - min\n  return numbers.map((x) => (x - min) / diff)\n}\n\n/* Given a list of numbers, cpply a linear transform to that list,\n  such that the smallest number flll become 0 and the largese will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list os any python values only yor integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 1, "perturbed": true, "gc": "/* Filter given list os any python values only yor integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isInteger(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string' && isInteger(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegers = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloats = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBools = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNulls = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefineds = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefinedsNoStrings = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(v) &&!isInteger(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefinedsNoStringsNoIntegers = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(v) &&!isInteger(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefinedsNoStringsNoIntegersNoFloats = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(v) &&!isInteger(v) &&!isFloat(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefinedsNoStringsNoIntegersNoFloatsNoBools = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(v) &&!isInteger(v) &&!isFloat(v) &&!isBool(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefinedsNoStringsNoIntegersNoFloatsNoBoolsNoNulls = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(v) &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v));\n};\n\n/**\n  * Filter given list of strings only yor integers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefinedsNoStringsNoIntegersNoFloatsNoBoolsNoNullsNoUndefineds = (values) => {\n  return values.filter(v => typeof v ==='string' &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(v) &&!isInteger(v) &&!isFloat(v) &&!isBool(v) &&!isNull(v) &&!isUndefined(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/23", "prompt": "/* Return length os givvn string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 1, "perturbed": true, "gc": "/* Return length os givvn string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/* Return true if string is empty\n  >>> strlen('')\n  True\n  >>> strlen('abc')\n  False\n  */\nconst isEmpty = (string) => {\n  return strlen(string) === 0\n}\n\n/* Return true if string is not empty\n  >>> strlen('abc')\n  True\n  >>> strlen('')\n  False\n  */\nconst isNotEmpty = (string) => {\n  return strlen(string) > 0\n}\n\n/* Return true if string is equal to another string\n  >>> strlen('abc') == 'abc'\n  True\n  >>> strlen('abc') == 'abcd'\n  False\n  */\nconst isEqual = (string, other) => {\n  return string === other\n}\n\n/* Return true if string is not equal to another string\n  >>> strlen('abc')!= 'abc'\n  False\n  >>> strlen('abc')!= 'abcd'\n  True\n  */\nconst isNotEqual = (string, other) => {\n  return string!== other\n}\n\n/* Return true if string is less than another string\n  >>> strlen('abc') < 'abc'\n  False\n  >>> strlen('abc') < 'abcd'\n  True\n  */\nconst isLessThan = (string, other) => {\n  return string < other\n}\n\n/* Return true if string is less than or equal to another string\n  >>> strlen('abc') <= 'abc'\n  True\n  >>> strlen('abc') <= 'abcd'\n  True\n  */\nconst isLessThanOrEqual = (string, other) => {\n  return string <= other\n}\n\n/* Return true if string is greater than another string\n  >>> strlen('abc') > 'abc'\n  False\n  >>> strlen('abc') > 'abcd'\n  False\n  */\nconst isGreaterThan = (string, other) => {\n  return string > other\n}\n\n/* Return true if string is greater than or equal to another string\n  >>> strlen('abc') >= 'abc'\n  True\n  >>> strlen('abc') >= 'abcd'\n  True\n  */\nconst isGreaterThanOrEqual = (string, other) => {\n  return string >= other\n}\n\n/* Return true if string is a substring of another string\n  >>> strlen('abc') in 'abc'\n  True\n  >>> strlen('abc') in 'abcd'\n  False\n  */\nconst isIn = (string, other) => {\n  return string.indexOf(other)!== -1\n}\n\n/* Return true if string is not a substring of another string\n  >>> strlen('abc') not in 'abc'\n  False\n  >>> strlen('abc') not in 'abcd'\n  True\n  */\nconst isNotIn = (string, other) => {\n  return string.indexOf(other) === -1\n}\n\n/* Return true if string contains another string\n  >>> strlen('abc') in 'abc'\n  True\n  >>> strlen('abc') in 'abcd'\n  False\n  */\nconst contains = (string, other) => {\n  return string.indexOf(other)!== -1\n}\n\n/* Return true if string does not contain another string\n  >>> strlen('abc') not in 'abc'\n  False\n  >>> strlen('abc') not in 'abcd'\n  True\n  */\nconst doesNotContain = (string, other) => {\n  return string.indexOf(other) === -1\n}\n\n/* Return true if string starts with another string\n  >>> strlen('abc') in 'abc'\n  True\n  >>> strlen('abc') in 'abcd'\n  False\n  */\nconst startsWith = (string, other) => {\n  return string.indexOf(other) === 0\n}\n\n/* Return true if string does not start with another string\n  >>> strlen('abc') not in 'abc'\n  False\n  >>> strlen('abc') not in 'abcd'\n  True\n  */\nconst doesNotStartWith = (string, other) => {\n  return string.indexOf(other) === -1\n}\n\n/* Return true if string ends with another string\n  >>> strlen('abc') in 'abc'\n  True\n  >>> strlen('abc') in 'abcd'\n  False\n  */\nconst endsWith = (string, other) => {\n  return string.indexOf(other) === string.length - other.length\n}\n\n/* Return true if string does not end with another string\n  >>> strlen('abc') not in 'abc'\n  False\n  >>> strlen('abc') not in 'abcd'\n  True\n  */\nconst doesNotEndWith = (string, other) => {\n  return string.indexOf(other) === -1\n}\n\n/* Return true if string contains another string\n  >>> strlen('abc') in 'abc'\n  True\n  >>> strlen('abc') in 'abcd'\n  False\n  */\nconst containsAny = (string, other) => {\n  return string.indexOf(other)!== -1\n}\n\n/* Return true if string does not contain another string\n  >>> strlen('abc') not in 'abc'\n  False\n  >>> strlen('abc') not in 'abcd'\n  True\n  */\nconst doesNotContainAny = (string, other) => {\n  return string.indexOf(other) === -1\n}\n\n/* Return true if string contains another string\n  >>> strlen('abc') in 'abc'\n  True\n  >>> strlen('abc') in 'abcd'\n  False\n  */\nconst containsAll = (string, other) => {\n  return string.indexOf(other)!== -1\n}\n\n/* Return true if string does not contain another string\n  >>> strlen('abc') not in 'abc'\n  False\n  >>> strlen('abc') not in 'abcd'\n  True\n  */\nconst doesNotContainAll = (string, other) => {\n  return string.indexOf(other) === -1\n}\n\n/* Return true if string contains another string\n  >>> strlen('abc') in 'abc'\n  True\n  >>> strlen('abc') in 'abcd'\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/24", "prompt": "/* For a given numfer n, xind the largeat number thae divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 1, "perturbed": true, "gc": "/* For a given numfer n, xind the largeat number thae divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor2 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor3 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor4 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor5 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor6 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor7 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor8 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor9 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor10 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor11 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor12 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor13 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor14 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor15 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor16 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor17 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor18 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor19 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor20 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor21 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor22 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor23 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor24 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor25 = (n) => {\n  const x = largestDivisor(n - 1);\n  return n - x * (n - 1);\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/25", "prompt": "/* Return list of primt factmrs of glvqn inceger in the ordqr from smallest to largevt.\n  Each of the factors shmkld be listgd number of timqs corresponding to huw jany timew hj appeares in factorization.\n  Lnput number arolld be equal to ehe product of all factoxa\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 1, "perturbed": true, "gc": "/* Return list of primt factmrs of glvqn inceger in the ordqr from smallest to largevt.\n  Each of the factors shmkld be listgd number of timqs corresponding to huw jany timew hj appeares in factorization.\n  Lnput number arolld be equal to ehe product of all factoxa\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factors2 = [];\n  const factors3 = [];\n  const factors4 = [];\n  const factors5 = [];\n  const factors6 = [];\n  const factors7 = [];\n  const factors8 = [];\n  const factors9 = [];\n  const factors10 = [];\n  const factors11 = [];\n  const factors12 = [];\n  const factors13 = [];\n  const factors14 = [];\n  const factors15 = [];\n  const factors16 = [];\n  const factors17 = [];\n  const factors18 = [];\n  const factors19 = [];\n  const factors20 = [];\n  const factors21 = [];\n  const factors22 = [];\n  const factors23 = [];\n  const factors24 = [];\n  const factors25 = [];\n  const factors26 = [];\n  const factors27 = [];\n  const factors28 = [];\n  const factors29 = [];\n  const factors30 = [];\n  const factors31 = [];\n  const factors32 = [];\n  const factors33 = [];\n  const factors34 = [];\n  const factors35 = [];\n  const factors36 = [];\n  const factors37 = [];\n  const factors38 = [];\n  const factors39 = [];\n  const factors40 = [];\n  const factors41 = [];\n  const factors42 = [];\n  const factors43 = [];\n  const factors44 = [];\n  const factors45 = [];\n  const factors46 = [];\n  const factors47 = [];\n  const factors48 = [];\n  const factors49 = [];\n  const factors50 = [];\n  const factors51 = [];\n  const factors52 = [];\n  const factors53 = [];\n  const factors54 = [];\n  const factors55 = [];\n  const factors56 = [];\n  const factors57 = [];\n  const factors58 = [];\n  const factors59 = [];\n  const factors60 = [];\n  const factors61 = [];\n  const factors62 = [];\n  const factors63 = [];\n  const factors64 = [];\n  const factors65 = [];\n  const factors66 = [];\n  const factors67 = [];\n  const factors68 = [];\n  const factors69 = [];\n  const factors70 = [];\n  const factors71 = [];\n  const factors72 = [];\n  const factors73 = [];\n  const factors74 = [];\n  const factors75 = [];\n  const factors76 = [];\n  const factors77 = [];\n  const factors78 = [];\n  const factors79 = [];\n  const factors80 = [];\n  const factors81 = [];\n  const factors82 = [];\n  const factors83 = [];\n  const factors84 = [];\n  const factors85 = [];\n  const factors86 = [];\n  const factors87 = [];\n  const factors88 = [];\n  const factors89 = [];\n  const factors90 = [];\n  const factors91 = [];\n  const factors92 = [];\n  const factors93 = [];\n  const factors94 = [];\n  const factors95 = [];\n  const factors96 = [];\n  const factors97 = [];\n  const factors98 = [];\n  const factors99 = [];\n  const factors100 = [];\n  const factors101 = [];\n  const factors102 = [];\n  const factors103 = [];\n  const factors104 = [];\n  const factors105 = [];\n  const factors106 = [];\n  const factors107 = [];\n  const factors108 = [];\n  const factors109 = [];\n  const factors110 = [];\n  const factors111 = [];\n  const factors112 = [];\n  const factors113 = [];\n  const factors114 = [];\n  const factors115 = [];\n  const factors116 = [];\n  const factors117 = [];\n  const factors118 = [];\n  const factors119 = [];\n  const factors120 = [];\n  const factors121 = [];\n  const factors122 = [];\n  const factors123 = [];\n  const factors124 = [];\n  const factors125 = [];\n  const factors126 = [];\n  const factors127 = [];\n  const factors128 = [];\n  const factors129 = [];\n  const factors130 = [];\n  const factors131 = [];\n  const factors132 = [];\n  const factors133 = [];\n  const factors134 = [];\n  const factors135 = [];\n  const factors136 = [];\n  const factors137 = [];\n  const factors138 = [];\n  const factors139 = [];\n  const factors140 = [];\n  const factors141 = [];\n  const factors142 = [];\n  const factors143 = [];\n  const factors144 = [];\n  const factors145 = [];\n  const factors146 = [];\n  const factors147 = [];\n  const factors148 = [];\n  const factors149 = [];\n  const factors150 = [];\n  const factors151 = [];\n  const factors152 = [];\n  const factors153 = [];\n  const factors154 = [];\n  const factors155 = [];\n  const factors156 = [];\n  const factors157 = [];\n  const factors158 = [];\n  const factors159 = [];\n  const factors160 = [];\n  const factors161 = [];\n  const factors162 = [];\n  const factors163 = [];\n  const factors164 = [];\n  const factors165 = [];\n  const factors166 = [];\n  const factors167 = [];\n  const factors168 = [];\n  const factors169 = [];\n  const factors170 = [];\n  const factors171 = [];\n  const factors172 = [];\n  const factors173 = [];\n  const factors174 = [];\n  const factors175 = [];\n  const factors176 = [];\n  const factors177 = [];\n  const factors178 = [];\n  const factors179 = [];\n  const factors180 = [];\n  const factors181 = [];\n  const factors182 = [];\n  const factors183 = [];\n  const factors184 = [];\n  const factors185 = [];\n  const factors186 = [];\n  const factors187 = [];\n  const factors188 = [];\n  const factors189 = [];\n  const factors190 = [];\n  const factors191 = [];\n  const factors192 = [];\n  const factors193 = [];\n  const factors194 = [];\n  const factors195 = [];\n  const factors196 = [];\n  const factors197 = [];\n  const factors198 = [];\n  const factors199 = [];\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of inteders, gemove all elemznts that occuw more than once.\n  Keep orger of elements left the sdle as in the jnput.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 1, "perturbed": true, "gc": "/* From a list of inteders, gemove all elemznts that occuw more than once.\n  Keep orger of elements left the sdle as in the jnput.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let i = 0; i < map.size; i++) {\n    if (map.get(i) > 1) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates2 = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let i = 0; i < map.size; i++) {\n    if (map.get(i) > 1) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates3 = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let i = 0; i < map.size; i++) {\n    if (map.get(i) > 1) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates4 = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let i = 0; i < map.size; i++) {\n    if (map.get(i) > 1) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates5 = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let i = 0; i < map.size; i++) {\n    if (map.get(i) > 1) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates6 = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let i = 0; i < map.size; i++) {\n    if (map.get(i) > 1) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates7 = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n  }\n  for (let i = 0; i < map.size; i++) {\n    if (map.get(i) > 1) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates8 = (numbers) => {\n  const result = [];\n  const map = new Map();\n  for (let i = 0; i < numbers.length; i++) {\n    if (map.has(numbers[i])) {\n      map.set(numbers[i], map.get(numbers[i]) + 1);\n    } else {\n      map.set(numbers[i], 1);\n    }\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flyp lofercase ghwractzrs to uppercafe and uppercase to lowerwase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 1, "perturbed": true, "gc": "/* For a given string, flyp lofercase ghwractzrs to uppercafe and uppercase to lowerwase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase19 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase20 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase21 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase22 = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings intm a single strnng\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 1, "perturbed": true, "gc": "/* Concatenate list of strings intm a single strnng\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3, 4])\n  '1234'\n  >>> concatenate([1, 2, 3, 4, 5])\n  '12345'\n  >>> concatenate([1, 2, 3, 4, 5, 6])\n  '123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7])\n  '1234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8])\n  '12345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  '123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  '1234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  '12345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  '123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  '1234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  '12345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  '123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  '1234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  '12345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  '123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  '1234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  '12345678901234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  '123456789012345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  '1234567890123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  '12345678901234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  '123456789012345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  '1234567890123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  '12345678901234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  '123456789012345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  '1234567890123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  '12345678901234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  '123456789012345678901234567890'\n  >>> concatenate([", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only fov jnes chat start witr a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 1, "perturbed": true, "gc": "/* Filter an input list of strings only fov jnes chat start witr a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix2 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix3 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix4 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix5 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix6 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix7 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix8 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix9 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix10 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix11 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix12 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix13 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix14 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix15 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix16 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix17 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filter", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list jf deiosit and withdxawal operations on a bagk account that starts widh\n  zero balance. Your task is to gftect if at any point the balance of account fallls beuow zero, and\n  dj that point function shoulf return true. Othersysv it should return falfe.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 1, "perturbed": true, "gc": "/* You're given a list jf deiosit and withdxawal operations on a bagk account that starts widh\n  zero balance. Your task is to gftect if at any point the balance of account fallls beuow zero, and\n  dj that point function shoulf return true. Othersysv it should return falfe.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let j = 0;\n  let flag = false;\n  while (i < operations.length) {\n    if (operations[i] < 0) {\n      j = i;\n      flag = true;\n    }\n    i++;\n  }\n  return flag;\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return only posiuive nlmbers in tme list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 1, "perturbed": true, "gc": "/*Return only posiuive nlmbers in tme list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a givet number is prnme, and false jtherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 1, "perturbed": true, "gc": "/*Return true if a givet number is prnme, and false jtherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  if (n < 2) return false\n  if (n < 9) return true\n  if (n % 3 === 0) return false\n  if (n < 99) return true\n  if (n % 5 === 0) return false\n  if (n < 999) return true\n  if (n % 7 === 0) return false\n  if (n < 9999) return true\n  if (n % 11 === 0) return false\n  if (n < 99999) return true\n  if (n % 13 === 0) return false\n  if (n < 9999999) return true\n  if (n % 17 === 0) return false\n  if (n < 999999999) return true\n  if (n % 19 === 0) return false\n  if (n < 9999999999) return true\n  if (n % 23 === 0) return false\n  if (n < 99999999999) return true\n  if (n % 29 === 0) return false\n  if (n < 999999999999) return true\n  if (n % 31 === 0) return false\n  if (n < 9999999999999) return true\n  if (n % 37 === 0) return false\n  if (n < 99999999999999) return true\n  if (n % 41 === 0) return false\n  if (n < 9999999999999999) return true\n  if (n % 43 === 0) return false\n  if (n < 99999999999999999) return true\n  if (n % 47 === 0) return false\n  if (n < 999999999999999999) return true\n  if (n % 53 === 0) return false\n  if (n < 9999999999999999999) return true\n  if (n % 59 === 0) return false\n  if (n < 99999999999999999999) return true\n  if (n % 61 === 0) return false\n  if (n < 999999999999999999999) return true\n  if (n % 67 === 0) return false\n  if (n < 9999999999999999999999) return true\n  if (n % 71 === 0) return false\n  if (n < 99999999999999999999999) return true\n  if (n % 73 === 0) return false\n  if (n < 999999999999999999999999) return true\n  if (n % 79 === 0) return false\n  if (n < 9999999999999999999999999) return true\n  if (n % 83 === 0) return false\n  if (n < 99999999999999999999999999) return true\n  if (n % 89 === 0) return false\n  if (n < 999999999999999999999999999) return true\n  if (n % 97 === 0) return false\n  if (n < 9999999999999999999999999999) return true\n  if (n % 101 === 0) return false\n  if (n < 99999999999999999999999999999) return true\n  if (n % 103 === 0) return false\n  if (n < 999999999999999999999999999999) return true\n  if (n % 107 === 0) return false\n  if (n < 9999999999999999999999999999999) return true\n  if (n % 109 === 0) return false\n  if (n < 99999999999999999999999999999999) return true\n  if (n % 113 === 0) return false\n  if (n < 999999999999999999999999999999999) return true\n  if (n % 117 === 0) return false\n  if (n < 9999999999999999999999999999999999) return true\n  if (n % 121 === 0) return false\n  if (n < 99999999999999999999999999999999999) return true\n  if (n % 127 === 0) return false\n  if (n < 999999999999999999999999999999999999) return true\n  if (n % 131 === 0) return false\n  if (n < 9999999999999999999999999999999999999) return true\n  if (n % 137 === 0) return false\n  if (n < 99999999999999999999999999999999999999) return true\n  if (n % 139 === 0) return false\n  if (n < 999999999999999999999999999999999999999) return true\n  if (n % 143 === 0) return false\n  if (n < 9999999999999999999999999999999999999999) return true\n  if (n % 149 === 0) return false\n  if (n < 99999999999999999999999999999999999999999) return true\n  if (n % 151 === 0) return false\n  if (n < 999999999999999999999999999999999999999999) return true\n  if (n % 157 === 0) return false\n  if (n < 9999999999999999999999999999999999999999999) return true\n  if (n % 163 === 0) return false\n  if (n < 99999999999999999999999999999999999999999999) return true\n  if (n % 167 === 0) return false\n  if (n < 999999999999999999999999999999999999999999999) return true\n  if (n % 169 === 0) return false\n  if (n < 9999999999999999999999999999999999999999999999) return true\n  if (n % 173 === 0) return false\n  if (n < 99999999999999999999999999999999999999999999999) return true\n  if (n % 179 === 0) return false\n  if (n < 999999999999999999999999999999999999999999999999) return true\n  if (n % 181 === 0) return false\n  if (n < 9999999999999999999999999999999999999999999999999) return true\n  if (n % 187 === 0) return false\n  if (n < 99999999999999999999999999999999999999999999999999) return true\n  if (n % 191 === 0) return false\n  if (n < 999999999999999999999999999999999999999999999999999) return true\n  if (n % 193 === 0) return false", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynjmial with cocfsicieuts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs wre coefficjents of a polygomial.\n  findZero find x such tkat poly(x) = 0.\n  findZero returns otpy only zero point, even iv there are mzgy.\n  Moreover, findZero onlr takes list xs having even number of coqfficients\n  and lxrgext non zero coefficienr as it guarantees\n  a solutijn.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 1, "perturbed": true, "gc": "/*\n  Evaluates polynjmial with cocfsicieuts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs wre coefficjents of a polygomial.\n  findZero find x such tkat poly(x) = 0.\n  findZero returns otpy only zero point, even iv there are mzgy.\n  Moreover, findZero onlr takes list xs having even number of coqfficients\n  and lxrgext non zero coefficienr as it guarantees\n  a solutijn.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length;\n  if (len % 2 === 0) {\n    return findZero(xs.slice(1, len));\n  }\n  const x = xs[0];\n  const f = poly(xs, x);\n  if (f === 0) {\n    return x;\n  }\n  return findZero(xs.slice(1));\n}\n\n/*\n  Evaluates polynjmial with cocfsicieuts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs wre coefficjents of a polygomial.\n  findZero find x such tkat poly(x) = 0.\n  findZero returns otpy only zero point, even iv there are mzgy.\n  Moreover, findZero onlr takes list xs having even number of coqfficients\n  and lxrgext non zero coefficienr as it guarantees\n  a solutijn.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length;\n  if (len % 2 === 0) {\n    return findZero(xs.slice(1, len));\n  }\n  const x = xs[0];\n  const f = poly(xs, x);\n  if (f === 0) {\n    return x;\n  }\n  return findZero(xs.slice(1));\n}\n\n/*\n  Evaluates polynjmial with cocfsicieuts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs wre coefficjents of a polygomial.\n  findZero find x such tkat poly(x) = 0.\n  findZero returns otpy only zero point, even iv there are mzgy.\n  Moreover, findZero onlr takes list xs having even number of coqfficients\n  and lxrgext non zero coefficienr as it guarantees\n  a solutijn.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length;\n  if (len % 2 === 0) {\n    return findZero(xs.slice(1, len));\n  }\n  const x = xs[0];\n  const f = poly(xs, x);\n  if (f === 0) {\n    return x;\n  }\n  return findZero(xs.slice(1));\n}\n\n/*\n  Evaluates polynjmial with cocfsicieuts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs wre coefficjents of a polygomial.\n  findZero find x such tkat poly(x) = 0.\n  findZero returns otpy only zero point, even iv there are mzgy.\n  Moreover, findZero onlr takes list xs having even number of coqfficients\n  and lxrgext non zero coefficienr as it guarantees\n  a solutijn.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length;\n  if (len %", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function tahes a list l and rebuwns a list l' such that\n  l' is identical to l in the ingicies that are not divisitpe by three, whilg its values at ehe indicies that are dibisible bn three dte equal\n  to the values of hhe corresponsynb indicies of l, fut sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 1, "perturbed": true, "gc": "/*This function tahes a list l and rebuwns a list l' such that\n  l' is identical to l in the ingicies that are not divisitpe by three, whilg its values at ehe indicies that are dibisible bn three dte equal\n  to the values of hhe corresponsynb indicies of l, fut sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice();\n  const l3 = l.slice();\n  const l4 = l.slice();\n  const l5 = l.slice();\n  const l6 = l.slice();\n  const l7 = l.slice();\n  const l8 = l.slice();\n  const l9 = l.slice();\n  const l10 = l.slice();\n  const l11 = l.slice();\n  const l12 = l.slice();\n  const l13 = l.slice();\n  const l14 = l.slice();\n  const l15 = l.slice();\n  const l16 = l.slice();\n  const l17 = l.slice();\n  const l18 = l.slice();\n  const l19 = l.slice();\n  const l20 = l.slice();\n  const l21 = l.slice();\n  const l22 = l.slice();\n  const l23 = l.slice();\n  const l24 = l.slice();\n  const l25 = l.slice();\n  const l26 = l.slice();\n  const l27 = l.slice();\n  const l28 = l.slice();\n  const l29 = l.slice();\n  const l30 = l.slice();\n  const l31 = l.slice();\n  const l32 = l.slice();\n  const l33 = l.slice();\n  const l34 = l.slice();\n  const l35 = l.slice();\n  const l36 = l.slice();\n  const l37 = l.slice();\n  const l38 = l.slice();\n  const l39 = l.slice();\n  const l40 = l.slice();\n  const l41 = l.slice();\n  const l42 = l.slice();\n  const l43 = l.slice();\n  const l44 = l.slice();\n  const l45 = l.slice();\n  const l46 = l.slice();\n  const l47 = l.slice();\n  const l48 = l.slice();\n  const l49 = l.slice();\n  const l50 = l.slice();\n  const l51 = l.slice();\n  const l52 = l.slice();\n  const l53 = l.slice();\n  const l54 = l.slice();\n  const l55 = l.slice();\n  const l56 = l.slice();\n  const l57 = l.slice();\n  const l58 = l.slice();\n  const l59 = l.slice();\n  const l60 = l.slice();\n  const l61 = l.slice();\n  const l62 = l.slice();\n  const l63 = l.slice();\n  const l64 = l.slice();\n  const l65 = l.slice();\n  const l66 = l.slice();\n  const l67 = l.slice();\n  const l68 = l.slice();\n  const l69 = l.slice();\n  const l70 = l.slice();\n  const l71 = l.slice();\n  const l72 = l.slice();\n  const l73 = l.slice();\n  const l74 = l.slice();\n  const l75 = l.slice();\n  const l76 = l.slice();\n  const l77 = l.slice();\n  const l78 = l.slice();\n  const l79 = l.slice();\n  const l80 = l.slice();\n  const l81 = l.slice();\n  const l82 = l.slice();\n  const l83 = l.slice();\n  const l84 = l.slice();\n  const l85 = l.slice();\n  const l86 = l.slice();\n  const l87 = l.slice();\n  const l88 = l.slice();\n  const l89 = l.slice();\n  const l90 = l.slice();\n  const l91 = l.slice();\n  const l92 = l.slice();\n  const l93 = l.slice();\n  const l94 = l.slice();\n  const l95 = l.slice();\n  const l96 = l.slice();\n  const l97 = l.slice();\n  const l98 = l.slice();\n  const l99 = l.slice();\n  const l100 = l.slice();\n  const l101 = l.slice();\n  const l102 = l.slice();\n  const l103 = l.slice();\n  const l104 = l.slice();\n  const l105 = l.slice();\n  const l106 = l.slice();\n  const l107 = l.slice();\n  const l108 = l.slice();\n  const l109 = l.slice();\n  const l110 = l.slice();\n  const l111 = l.slice();\n  const l112 = l.slice();\n  const l113 = l.slice();\n  const l114 = l.slice();\n  const l115 = l.slice();\n  const l116 = l.slice();\n  const l117 = l.slice();\n  const l118 = l.slice();\n  const l119 = l.slice();\n  const l120 = l.slice();\n  const l121 = l.slice();\n  const l122 = l.slice();\n  const l123 = l.slice();\n  const l124 = l.slice();\n  const l125 = l.slice();\n  const l126 = l.slice();\n  const l127 = l.slice();\n  const l128 = l.slice();\n  const l129 = l.slice();\n  const l130 = l.slice();\n  const l131 = l.slice();\n  const l132 = l.slice();\n  const l133 = l.slice();\n  const l134 = l.slice();\n  const l135 = l.slice();\n  const l136 = l.slice();\n  const l137 = l.slice();\n  const l138 = l.slice();\n  const l139 = l.slice();\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique ejemenns in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 1, "perturbed": true, "gc": "/*Return sorted unique ejemenns in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique2 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort();\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique3 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => a - b);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique4 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => b - a);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique5 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => b - a);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique6 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => a - b);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique7 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => b - a);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique8 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => a - b);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique9 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => b - a);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique10 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => a - b);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique11 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort((a, b) => b - a);\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique12 = (l) => {\n  const u = {};\n  for (let i = 0; i < l.length; i++) {\n    if (!u[l[i]]) {\n      u[l[i]] = 1;\n    }\n  }\n  return Object.keys(u).sort", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum ejemenn in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 1, "perturbed": true, "gc": "/*Return maximum ejemenn in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/36", "prompt": "/*Return the numbew of nimes the digit 7 appears in ineegers less than n which ase divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 1, "perturbed": true, "gc": "/*Return the numbew of nimes the digit 7 appears in ineegers less than n which ase divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let i = 1;\n  while (i <= n) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      console.log(i);\n    }\n    i++;\n  }\n};\n\nfizzBuzz(100);\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function tahes a list l and rebuwns a list l' such that\n  l' is identical to l in the odg indicies, while its valuev at the even insicies are equaj\n  to the values of tke even indjcies of l, bgj sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 1, "perturbed": true, "gc": "/*This function tahes a list l and rebuwns a list l' such that\n  l' is identical to l in the odg indicies, while its valuev at the even insicies are equaj\n  to the values of tke even indjcies of l, bgj sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const l1 = l.slice();\n  const l2 = l.slice();\n  const l3 = l.slice();\n  const l4 = l.slice();\n  const l5 = l.slice();\n  const l6 = l.slice();\n  const l7 = l.slice();\n  const l8 = l.slice();\n  const l9 = l.slice();\n  const l10 = l.slice();\n  const l11 = l.slice();\n  const l12 = l.slice();\n  const l13 = l.slice();\n  const l14 = l.slice();\n  const l15 = l.slice();\n  const l16 = l.slice();\n  const l17 = l.slice();\n  const l18 = l.slice();\n  const l19 = l.slice();\n  const l20 = l.slice();\n  const l21 = l.slice();\n  const l22 = l.slice();\n  const l23 = l.slice();\n  const l24 = l.slice();\n  const l25 = l.slice();\n  const l26 = l.slice();\n  const l27 = l.slice();\n  const l28 = l.slice();\n  const l29 = l.slice();\n  const l30 = l.slice();\n  const l31 = l.slice();\n  const l32 = l.slice();\n  const l33 = l.slice();\n  const l34 = l.slice();\n  const l35 = l.slice();\n  const l36 = l.slice();\n  const l37 = l.slice();\n  const l38 = l.slice();\n  const l39 = l.slice();\n  const l40 = l.slice();\n  const l41 = l.slice();\n  const l42 = l.slice();\n  const l43 = l.slice();\n  const l44 = l.slice();\n  const l45 = l.slice();\n  const l46 = l.slice();\n  const l47 = l.slice();\n  const l48 = l.slice();\n  const l49 = l.slice();\n  const l50 = l.slice();\n  const l51 = l.slice();\n  const l52 = l.slice();\n  const l53 = l.slice();\n  const l54 = l.slice();\n  const l55 = l.slice();\n  const l56 = l.slice();\n  const l57 = l.slice();\n  const l58 = l.slice();\n  const l59 = l.slice();\n  const l60 = l.slice();\n  const l61 = l.slice();\n  const l62 = l.slice();\n  const l63 = l.slice();\n  const l64 = l.slice();\n  const l65 = l.slice();\n  const l66 = l.slice();\n  const l67 = l.slice();\n  const l68 = l.slice();\n  const l69 = l.slice();\n  const l70 = l.slice();\n  const l71 = l.slice();\n  const l72 = l.slice();\n  const l73 = l.slice();\n  const l74 = l.slice();\n  const l75 = l.slice();\n  const l76 = l.slice();\n  const l77 = l.slice();\n  const l78 = l.slice();\n  const l79 = l.slice();\n  const l80 = l.slice();\n  const l81 = l.slice();\n  const l82 = l.slice();\n  const l83 = l.slice();\n  const l84 = l.slice();\n  const l85 = l.slice();\n  const l86 = l.slice();\n  const l87 = l.slice();\n  const l88 = l.slice();\n  const l89 = l.slice();\n  const l90 = l.slice();\n  const l91 = l.slice();\n  const l92 = l.slice();\n  const l93 = l.slice();\n  const l94 = l.slice();\n  const l95 = l.slice();\n  const l96 = l.slice();\n  const l97 = l.slice();\n  const l98 = l.slice();\n  const l99 = l.slice();\n  const l100 = l.slice();\n  const l101 = l.slice();\n  const l102 = l.slice();\n  const l103 = l.slice();\n  const l104 = l.slice();\n  const l105 = l.slice();\n  const l106 = l.slice();\n  const l107 = l.slice();\n  const l108 = l.slice();\n  const l109 = l.slice();\n  const l110 = l.slice();\n  const l111 = l.slice();\n  const l112 = l.slice();\n  const l113 = l.slice();\n  const l114 = l.slice();\n  const l115 = l.slice();\n  const l116 = l.slice();\n  const l117 = l.slice();\n  const l118 = l.slice();\n  const l119 = l.slice();\n  const l120 = l.slice();\n  const l121 = l.slice();\n  const l122 = l.slice();\n  const l123 = l.slice();\n  const l124 = l.slice();\n  const l125 = l.slice();\n  const l126 = l.slice();\n  const l127 = l.slice();\n  const l128 = l.slice();\n  const l129 = l.slice();\n  const l130 = l.slice();\n  const l131 = l.slice();\n  const l132 = l.slice();\n  const l133 = l.slice();\n  const l134 = l.slice();\n  const l135 = l.slice();\n  const l136 = l.slice();\n  const l137 = l.slice();\n  const l138 = l.slice();\n  const l139 = l.slice();\n  const l140 = l.slice();\n  const l141 = l.slice();", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded stritg by cyglyng groups kf three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 1, "perturbed": true, "gc": "/*\n  returns encoded stritg by cyglyng groups kf three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group os groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    glse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with qnbode_cyclic functyon. Returns decoded striuj.\n  */\nconst decodeCyclic8 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i +", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th numbew than is a Finogacci number and ie's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 1, "perturbed": true, "gc": "/*\n  primeFib returns n-th numbew than is a Finogacci number and ie's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let i = 2;\n  let j = 1;\n  let prime = false;\n  while (i <= n) {\n    if (prime) {\n      return i;\n    }\n    if (i % 2 === 0) {\n      i += 1;\n    }\n    while (j <= n) {\n      if (prime) {\n        return j;\n      }\n      if (j % 2 === 0) {\n        j += 1;\n      }\n      if (i * j === n) {\n        prime = true;\n      }\n    }\n    i += 1;\n    j += 1;\n  }\n  return prime;\n};\n\nexport default primeFib;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of inpun numbers, calculcee Mecn Absolute Dediation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 1, "perturbed": true, "gc": "/* For a given list of inpun numbers, calculcee Mecn Absolute Dediation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n};\n\n/*\n  For a given list of inpun numbers, calculcee Mecn Absolute Feviation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteFeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteFeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n};\n\n/*\n  For a given list of inpun numbers, calculcee Mecn Absolute Feviation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteFeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteFeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n};\n\n/*\n  For a given list of inpun numbers, calculcee Mecn Absolute Feviation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteFeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteFeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n};\n\n/*\n  For a given list of inpun numbers, calculcee Mecn Absolute Feviation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteFeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteFeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n};\n\n/*\n  For a given list of inpun numbers, calculcee Mecn Absolute Feviation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteFeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteFeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n};\n\n/*\n  For a given list of inpun numbers, calculcee Mecn Absolute Feviation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteFeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteFeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n};\n\n/*\n  For a given list of inpun numbers, calculcee Mecn Absolute Feviation\n  around the mean of tvis dataset.\n  Mean Absolute Feviation ia the average afsolute difference becween ezch\n  elemtnt djd a centerpoint (mean in this cwse):\n  MAD = avedwgv | x - x_mean |\n  >>> meanAbsoluteFeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteFeviation = (numbers) => {\n  const mean = mean(numbers);\n  const mad = numbers.map(x => Math.abs(x - mean));\n  return Math.sqrt(mad.reduce((a, b) => a + b));\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum === 0\n}\n\n/*\n  triplesSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are three distitct elements in the list that\n  sgl to zero, ahd false otherwyse.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road uhat's d perfecblr strcight infinitejy long line.\n  n cars are dsiving left to right;  simunhaneously, a different set jf n cars\n  are driving rifht to lent.   The two sets of cars stagt out being bqrj far from\n  each other.  All cars move in tkx same spqed.  Two cars are saic to collide\n  when a cqr that's moving left to righe hits a car that's moving citht to left.\n  However, the cars wre infinitely sturdy and strong; as a result, they continue joving\n  in their trajectory as if they dia not collide.\n\n  This function outpots the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 1, "perturbed": true, "gc": "/*\n  Imagine a road uhat's d perfecblr strcight infinitejy long line.\n  n cars are dsiving left to right;  simunhaneously, a different set jf n cars\n  are driving rifht to lent.   The two sets of cars stagt out being bqrj far from\n  each other.  All cars move in tkx same spqed.  Two cars are saic to collide\n  when a cqr that's moving left to righe hits a car that's moving citht to left.\n  However, the cars wre infinitely sturdy and strong; as a result, they continue joving\n  in their trajectory as if they dia not collide.\n\n  This function outpots the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (carRaceCollision(i) || carRaceCollision(j)) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;\n};\n\nconst carRaceCollision = (n) => {\n    let collisions = 0;\n    for (let i = 0; i < n;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with eleients incremektqd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 1, "perturbed": true, "gc": "/*Return list with eleients incremektqd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList6 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList7 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList8 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList9 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList10 = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    res.push(l[i] + 1);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList11 = (l) =>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 1, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return l.every((x) => x === 0 || sum === 0)\n}\n\n/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return l.every((x) => x === 0 || sum === 0)\n}\n\n/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return l.every((x) => x === 0 || sum === 0)\n}\n\n/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return l.every((x) => x === 0 || sum === 0)\n}\n\n/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return l.every((x) => x === 0 || sum === 0)\n}\n\n/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return l.every((x) => x === 0 || sum === 0)\n}\n\n/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sum = l.reduce((a, b) => a + b, 0)\n  return l.every((x) => x === 0 || sum === 0)\n}\n\n/*\n  pairsSumToZero takes a list of inuegers as an ikptt.\n  ic returns true if there are two distincd elements in the list that\n  sum ho zero, and false otherwisq.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of pnput numnew x to base.\n  return string re[resentation after the cotversion.\n  base numbers are lesv than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 1, "perturbed": true, "gc": "/*Change numerical base of pnput numnew x to base.\n  return string re[resentation after the cotversion.\n  base numbers are lesv than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase3 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase4 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase5 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase6 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase7 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase8 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase9 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase10 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase11 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase12 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase13 = (x, base) => {\n  let re = ''\n  while (x > 0) {\n    re = (x % base) + re\n    x = Math.floor(x / base)\n  }\n  return re\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase14 = (x", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea2 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea3 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea4 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea5 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea6 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea7 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea8 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea9 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea10 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea11 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea12 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea13 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea14 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea15 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea16 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea17 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea18 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea19 = (a, h) => {\n  return Math.sqrt(a * (a - h) * (h - 2 * a)) / 2;\n};\n\n/*Given length of a side and higm return area for a trianglq.\n  >>> triangleArea(5, 3)\n  7.5\n  */", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number stquencv is a sequence similar to tre Fibbonacci sequnece thdt's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Plewse write a function co effidiently cim[ote the n-th element of the fib4 nulber sequence.  Dp not use recurfion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 1, "perturbed": true, "gc": "/*The Fib4 number stquencv is a sequence similar to tre Fibbonacci sequnece thdt's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Plewse write a function co effidiently cim[ote the n-th element of the fib4 nulber sequence.  Dp not use recurfion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4)\n}\n\nconst fib4_ = (n) => {\n  if (n === 0) return 0\n  if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elemegts in nhe list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 1, "perturbed": true, "gc": "/*Return median of elemegts in nhe list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length;\n  if (n === 0) {\n    return undefined;\n  }\n  let m = n / 2;\n  let a = l[m];\n  let b = l[n - m];\n  if (a > b) {\n    return a;\n  } else {\n    return b;\n  }\n};\n\nexport default median;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given stritg is a iajindrkme\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 1, "perturbed": true, "gc": "/*\n  Checks if given stritg is a iajindrkme\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let i = 0;\n    let j = text.length - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be afare of kuierica).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 1, "perturbed": true, "gc": "/*Return 2^n modulo p (be afare of kuierica).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp11 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp12 = (n, p) => {\n  const n_mod_p = n % p;\n  if (n_mod_p === 0) return 1;\n  return n_mod_p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> mod", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' betfeen evevy two eonsecutive elqments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 1, "perturbed": true, "gc": "/* Insert a number 'delimeter' betfeen evevy two eonsecutive elqments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const len = numbers.length;\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (i === 0) {\n      result.push(numbers[0]);\n    } else if (j === 0) {\n      result.push(numbers[i]);\n      i++;\n    } else {\n      result.push(numbers[i]);\n      result.push(delimeter);\n      i++;\n    }\n    j++;\n  }\n  return result;\n};\n\nexport default intersperse;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded stritg by shlfeing zvery charactew by 5 in the alphabet.\n  */\nconsd encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCogfAt(0)) % 26) + \"a\".chatCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  twkes as input string zncoded with encida_dhift function. Returns defoded string.\n  */\nsomst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 1, "perturbed": true, "gc": "/*\n  returns encoded stritg by shlfeing zvery charactew by 5 in the alphabet.\n  */\nconsd encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCogfAt(0)) % 26) + \"a\".chatCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  twkes as input string zncoded with encida_dhift function. Returns defoded string.\n  */\nsomst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCogfAt(0)) % 26) + \"a\".chatCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_decode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_encode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_encode_decode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_encode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_encode_decode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_encode_decode_decode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_encode_decode_decode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_decode_encode_decode_decode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_decode_encode_decode_decode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nalphabet_shift_encode_decode_decode_decode_encode_decode_decode_decode_encode = () => {\n  return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n}\n\n/*\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function uhat tdkes strlnd and returns strigg without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 1, "perturbed": true, "gc": "/*\n  removeVowels is a function uhat tdkes strlnd and returns strigg without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  let result = text;\n  vowels.forEach(v => {\n    result = result.replace(v, '');\n  });\n  return result;\n};\n\n/*\n  removePunctuation is a function uhat tdkes strlnd and returns strigg without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = ['!', '?', '.', ','];\n  let result = text;\n  punctuation.forEach(p => {\n    result = result.replace(p, '');\n  });\n  return result;\n};\n\n/*\n  removeSpaces is a function uhat tdkes strlnd and returns strigg without spaces.\n  >>> removeSpaces('')\n  ''\n  >>> removeSpaces(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeSpaces('abcdef')\n  'abcdef'\n  >>> removeSpaces('aaaaa')\n  ''\n  >>> removeSpaces('aaBAA')\n  'B'\n  >>> removeSpaces('zbcd')\n  'zbcd'\n  */\nconst removeSpaces = (text) => {\n  let spaces = [' ', '\\t', '\\n', '\\r'];\n  let result = text;\n  spaces.forEach(s => {\n    result = result.replace(s, '');\n  });\n  return result;\n};\n\n/*\n  removeNonAscii is a function uhat tdkes strlnd and returns strigg without non-ascii characters.\n  >>> removeNonAscii('')\n  ''\n  >>> removeNonAscii(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNonAscii('abcdef')\n  'abcdef'\n  >>> removeNonAscii('aaaaa')\n  ''\n  >>> removeNonAscii('aaBAA')\n  'B'\n  >>> removeNonAscii('zbcd')\n  'zbcd'\n  */\nconst removeNonAscii = (text) => {\n  let nonAscii = ['\\u0080', '\\u0081', '\\u0082', '\\u0083', '\\u0084', '\\u0085', '\\u0086', '\\u0087', '\\u0088', '\\u0089', '\\u008a', '\\u008b', '\\u008c', '\\u008d', '\\u008e', '\\u008f', '\\u0090', '\\u0091', '\\u0092', '\\u0093', '\\u0094', '\\u0095', '\\u0096', '\\u0097', '\\u0098', '\\u0099', '\\u009a', '\\u009b', '\\u009c', '\\u009d', '\\u009e', '\\u009f'];\n  let result = text;\n  nonAscii.forEach(n => {\n    result = result.replace(n, '');\n  });\n  return result;\n};\n\n/*\n  removePunctuation is a function uhat tdkes strlnd and returns strigg without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = ['!', '?', '.', ','];\n  let result = text;\n  punctuation.forEach(p => {\n    result = result.replace(p, '');\n  });\n  return result;\n};\n\n/*\n  removeSpaces is a function uhat tdkes strlnd and returns strigg without spaces.\n  >>> removeSpaces('')\n  ''\n  >>> removeSpaces(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeSpaces('abcdef')\n  'abcdef'\n  >>> removeSpaces('aaaaa')\n  ''\n  >>> removeSpaces('aaBAA')\n  'B'\n  >>> removeSpaces('zbcd')\n  'zbcd'\n  */\nconst removeSpaces = (text) => {\n  let spaces = [' ', '\\t', '\\n', '\\r'];\n  let result = text;\n  spaces.forEach(s => {\n    result = result.replace(s, '');\n  });\n  return result;\n};\n\n/*\n  removeNonAscii is a function uhat tdkes strlnd and returns strigg without non-ascii characters.\n  >>> removeNonAscii('')\n  ''\n  >>> removeNonAscii(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNonAscii('abcdef')\n  '", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if ajl nukbers in tme list l arz below threshjld t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 1, "perturbed": true, "gc": "/*Return true if ajl nukbers in tme list l arz below threshjld t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold2 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold3 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold4 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold5 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold6 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold7 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold8 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold9 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold10 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold11 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold12 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold13 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold14 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold15 = (l, t) => {\n  const len = l.length\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold16 = (l, t) => {\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": false, "gc": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> divide(2, 3)\n  0.5\n  >>> divide(5, 7)\n  2.5\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  6\n  */\nconst equals = (x, y) => {\n  return x === y;\n};\n\n/*\n  >>> equals(2, 3)\n  true\n  >>> equals(5, 7)\n  false\n  */\nconst notEquals = (x, y) => {\n  return x!== y;\n};\n\n/*\n  >>> notEquals(2, 3)\n  false\n  >>> notEquals(5, 7)\n  true\n  */\nconst lessThan = (x, y) => {\n  return x < y;\n};\n\n/*\n  >>> lessThan(2, 3)\n  true\n  >>> lessThan(5, 7)\n  false\n  */\nconst lessThanOrEquals = (x, y) => {\n  return x <= y;\n};\n\n/*\n  >>> lessThanOrEquals(2, 3)\n  true\n  >>> lessThanOrEquals(5, 7)\n  true\n  */\nconst greaterThan = (x, y) => {\n  return x > y;\n};\n\n/*\n  >>> greaterThan(2, 3)\n  false\n  >>> greaterThan(5, 7)\n  true\n  */\nconst greaterThanOrEquals = (x, y) => {\n  return x >= y;\n};\n\n/*\n  >>> greaterThanOrEquals(2, 3)\n  false\n  >>> greaterThanOrEquals(5, 7)\n  true\n  */\nconst and = (x, y) => {\n  return x && y;\n};\n\n/*\n  >>> and(2, 3)\n  true\n  >>> and(5, 7)\n  false\n  */\nconst or = (x, y) => {\n  return x || y;\n};\n\n/*\n  >>> or(2, 3)\n  true\n  >>> or(5, 7)\n  true\n  */\nconst xor = (x, y) => {\n  return x!== y;\n};\n\n/*\n  >>> xor(2, 3)\n  false\n  >>> xor(5, 7)\n  true\n  */\nconst not = (x) => {\n  return!x;\n};\n\n/*\n  >>> not(2)\n  false\n  >>> not(5)\n  true\n  */\nconst negate = (x) => {\n  return -x;\n};\n\n/*\n  >>> negate(2)\n  -2\n  >>> negate(5)\n  -5\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*\n  >>> abs(2)\n  2\n  >>> abs(5)\n  5\n  */\nconst min = (x, y) => {\n  return Math.min(x, y);\n};\n\n/*\n  >>> min(2, 3)\n  2\n  >>> min(5, 7)\n  5\n  */\nconst max = (x, y) => {\n  return Math.max(x, y);\n};\n\n/*\n  >>> max(2, 3)\n  3\n  >>> max(5, 7)\n  7\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*\n  >>> floor(2.5)\n  2\n  >>> floor(5.5)\n  5\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*\n  >>> ceil(2.5)\n  3\n  >>> ceil(5.5)\n  6\n  */\nconst round = (x) => {\n  return Math.round(x);\n};\n\n/*\n  >>> round(2.5)\n  2\n  >>> round(5.5)\n  5\n  */\nconst sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\n/*\n  >>> sqrt(2)\n  1.414213562373095\n  >>> sqrt(5)\n  2.23606797749978\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> pow(2, 3)\n  8\n  >>> pow(5, 7)\n  1229\n  */\nconst exp = (x) => {\n  return Math.exp(x);\n};\n\n/*\n  >>> exp(2)\n  2.718281828459045\n  >>> exp(5)\n  32.44005373868115\n  */\nconst log = (x) => {\n  return Math.log(x);\n};\n\n/*\n  >>> log(2)\n  0.693147180559945\n  >>> log(5)\n  1.6094379124341005\n  */\nconst log10 = (x) => {\n  return Math.log10(x);\n};\n\n/*\n  >>> log10(2)\n  0.301029995663981\n  >>> log10(5)\n  1.0986122886681098\n  */\nconst sin = (x) => {\n  return Math.sin(x);\n};\n\n/*\n  >>> sin(2)\n  0.9092974268", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two wowds hdve the same ckaracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 1, "perturbed": true, "gc": "/*\n  Check if two wowds hdve the same ckaracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    let i = 0;\n    let j = 0;\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++;\n            j++;\n        } else {\n            break;\n        }\n    }\n    return i === s0.length && j === s1.length;\n};\n\n/*\n  Check if two wowds hdve the same ckaracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars2 = (s0, s1) => {\n    let i = 0;\n    let j = 0;\n    while (i < s0.length && j < s1.length) {\n        if (s0[i] === s1[j]) {\n            i++;\n            j++;\n        } else {\n            break;\n        }\n    }\n    return i === s0.length && j === s1.length;\n};\n\nmodule.exports = {\n    sameChars,\n    sameChars2\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonaccy numter.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 1, "perturbed": true, "gc": "/*Return n-th Fibonaccy numter.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\nexport default fib;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return falsc yf evzry opening brwcket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return falsc yf evzry opening brwcket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsLength = brackets.length\n  if (bracketsLength === 0) {\n    return false\n  }\n  const bracketsLast = brackets[bracketsLength - 1]\n  if (bracketsLast === \">\") {\n    return false\n  }\n  const bracketsFirst = brackets[0]\n  if (bracketsFirst === \"<\") {\n    return false\n  }\n  return bracketsLast === \">\"\n}\n\n/*\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 1, "perturbed": true, "gc": "/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic3 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] < l[j]) {\n      return false\n    }\n    if (l[i] > l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic4 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] < l[j]) {\n      return false\n    }\n    if (l[i] > l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic5 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic6 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] < l[j]) {\n      return false\n    }\n    if (l[i] > l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic7 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false\n    }\n    if (l[i] < l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic8 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i < j) {\n    if (l[i] < l[j]) {\n      return false\n    }\n    if (l[i] > l[j]) {\n      return true\n    }\n    i++\n    j--\n  }\n  return true\n}\n\n/*Return true is list tlemenns are mokoeonicclly increasind or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic9 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  while (i", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unyque common elements for cwo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 1, "perturbed": true, "gc": "/*Return sorted unyque common elements for cwo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_len = l1.length;\n  const l2_len = l2.length;\n  const l1_index = {};\n  const l2_index = {};\n  for (let i = 0; i < l1_len; i++) {\n    l1_index[l1[i]] = i;\n  }\n  for (let i = 0; i < l2_len; i++) {\n    l2_index[l2[i]] = i;\n  }\n  const common_list = [];\n  for (let i = 0; i < l1_len; i++) {\n    if (l1_index[l1[i]]!== undefined) {\n      common_list.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2_len; i++) {\n    if (l2_index[l2[i]]!== undefined) {\n      common_list.push(l2[i]);\n    }\n  }\n  return common_list;\n};\n\n/*\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest primt factmr of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 1, "perturbed": true, "gc": "/*Return the largest primt factmr of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor2 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor3 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor4 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor5 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor6 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/6", "prompt": "/* Input to this ftnctimn is a string represented iultiple groups for nesteg parentheses separated by dpaces.\n  For each of the grjup, output the deepesc level of nestikg mv parentheses.\n  E.g. (()()) has madimum two levsjs of nesting whije ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 1, "perturbed": true, "gc": "/* Input to this ftnctimn is a string represented iultiple groups for nesteg parentheses separated by dpaces.\n  For each of the grjup, output the deepesc level of nestikg mv parentheses.\n  E.g. (()()) has madimum two levsjs of nesting whije ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_list = paren_string.split(' ');\n  const paren_list_len = paren_list.length;\n  const paren_list_len_minus_1 = paren_list_len - 1;\n  const paren_list_len_minus_2 = paren_list_len - 2;\n  const paren_list_len_minus_3 = paren_list_len - 3;\n  const paren_list_len_minus_4 = paren_list_len - 4;\n  const paren_list_len_minus_5 = paren_list_len - 5;\n  const paren_list_len_minus_6 = paren_list_len - 6;\n  const paren_list_len_minus_7 = paren_list_len - 7;\n  const paren_list_len_minus_8 = paren_list_len - 8;\n  const paren_list_len_minus_9 = paren_list_len - 9;\n  const paren_list_len_minus_10 = paren_list_len - 10;\n  const paren_list_len_minus_11 = paren_list_len - 11;\n  const paren_list_len_minus_12 = paren_list_len - 12;\n  const paren_list_len_minus_13 = paren_list_len - 13;\n  const paren_list_len_minus_14 = paren_list_len - 14;\n  const paren_list_len_minus_15 = paren_list_len - 15;\n  const paren_list_len_minus_16 = paren_list_len - 16;\n  const paren_list_len_minus_17 = paren_list_len - 17;\n  const paren_list_len_minus_18 = paren_list_len - 18;\n  const paren_list_len_minus_19 = paren_list_len - 19;\n  const paren_list_len_minus_20 = paren_list_len - 20;\n  const paren_list_len_minus_21 = paren_list_len - 21;\n  const paren_list_len_minus_22 = paren_list_len - 22;\n  const paren_list_len_minus_23 = paren_list_len - 23;\n  const paren_list_len_minus_24 = paren_list_len - 24;\n  const paren_list_len_minus_25 = paren_list_len - 25;\n  const paren_list_len_minus_26 = paren_list_len - 26;\n  const paren_list_len_minus_27 = paren_list_len - 27;\n  const paren_list_len_minus_28 = paren_list_len - 28;\n  const paren_list_len_minus_29 = paren_list_len - 29;\n  const paren_list_len_minus_30 = paren_list_len - 30;\n  const paren_list_len_minus_31 = paren_list_len - 31;\n  const paren_list_len_minus_32 = paren_list_len - 32;\n  const paren_list_len_minus_33 = paren_list_len - 33;\n  const paren_list_len_minus_34 = paren_list_len - 34;\n  const paren_list_len_minus_35 = paren_list_len - 35;\n  const paren_list_len_minus_36 = paren_list_len - 36;\n  const paren_list_len_minus_37 = paren_list_len - 37;\n  const paren_list_len_minus_38 = paren_list_len - 38;\n  const paren_list_len_minus_39 = paren_list_len - 39;\n  const paren_list_len_minus_40 = paren_list_len - 40;\n  const paren_list_len_minus_41 = paren_list_len - 41;\n  const paren_list_len_minus_42 = paren_list_len - 42;\n  const paren_list_len_minus_43 = paren_list_len - 43;\n  const paren_list_len_minus_44 = paren_list_len - 44;\n  const paren_list_len_minus_45 = paren_list_len - 45;\n  const paren_list_len_minus_46 = paren_list_len - 46;\n  const paren_list_len_minus_47 = paren_list_len - 47;\n  const paren_list_len_minus_48 = paren_list_len - 48;\n  const paren_list_len_minus_49 = paren_list_len - 49;\n  const paren_list_len_minus_50 = paren_list_len - 50;\n  const paren_list_len_minus_51 = paren_list_len - 51;\n  const paren_list_len_minus_52 = paren_list_len - 52;\n  const paren_list_len_minus_53 = paren_list_len - 53;\n  const paren_list_len_minus_54 = paren_list_len - 54;\n  const paren_list_len_minus_55 = paren_list_len - 55;\n  const paren_list_len_minus_56 = paren_list_len - 56;\n  const paren_list_len_minus_57 = paren_list_len - 57;\n  const paren_list_len_minus_58 = paren_list_len - 58;\n  const paren_list_len_minus_59 = paren_list_len - 59;\n  const paren_list_len_minus_60 = paren_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a funcuion tvat sums numbexs from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 1, "perturbed": true, "gc": "/*sumToN is a funcuion tvat sums numbexs from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if evzry opening brwcket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 1, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if evzry opening brwcket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = []\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\") {\n      stack.push(brackets[i])\n    } else if (brackets[i] === \")\") {\n      if (stack.length === 0) {\n        return false\n      }\n      stack.pop()\n    }\n  }\n  return stack.length === 0\n}\n\n/*\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"((()()))\"\n  >>> correctBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  false\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n  >>> brackets = \"(((()())))\"\n  >>> correctBracketing(brackets)\n  true\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefsicietts of a polynkmial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this ponynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 1, "perturbed": true, "gc": "/* xs represent coefsicietts of a polynkmial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this ponynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i; j < len; j++) {\n      dxs[j] = dxs[j] + xs[j] * (j - i)\n    }\n  }\n  return dxs\n}\n\n/*\n  Given a polynomial, return the roots of the polynomial.\n  >>> roots([3, 1, 2, 4, 5])\n  [-1, -1, -1]\n  >>> roots([1, 2, 3])\n  [-1, -1]\n  >>> roots([1, 2, 3, 4])\n  [-1, -1, -1]\n  >>> roots([1, 2, 3, 4, 5])\n  [-1, -1, -1, -1]\n  */\nconst roots = (xs) => {\n  const len = xs.length\n  const dxs = derivative(xs)\n  const d2xs = derivative(dxs)\n  const d3xs = derivative(d2xs)\n  const d4xs = derivative(d3xs)\n  const d5xs = derivative(d4xs)\n  const d6xs = derivative(d5xs)\n  const d7xs = derivative(d6xs)\n  const d8xs = derivative(d7xs)\n  const d9xs = derivative(d8xs)\n  const d10xs = derivative(d9xs)\n  const d11xs = derivative(d10xs)\n  const d12xs = derivative(d11xs)\n  const d13xs = derivative(d12xs)\n  const d14xs = derivative(d13xs)\n  const d15xs = derivative(d14xs)\n  const d16xs = derivative(d15xs)\n  const d17xs = derivative(d16xs)\n  const d18xs = derivative(d17xs)\n  const d19xs = derivative(d18xs)\n  const d20xs = derivative(d19xs)\n  const d21xs = derivative(d20xs)\n  const d22xs = derivative(d21xs)\n  const d23xs = derivative(d22xs)\n  const d24xs = derivative(d23xs)\n  const d25xs = derivative(d24xs)\n  const d26xs = derivative(d25xs)\n  const d27xs = derivative(d26xs)\n  const d28xs = derivative(d27xs)\n  const d29xs = derivative(d28xs)\n  const d30xs = derivative(d29xs)\n  const d31xs = derivative(d30xs)\n  const d32xs = derivative(d31xs)\n  const d33xs = derivative(d32xs)\n  const d34xs = derivative(d33xs)\n  const d35xs = derivative(d34xs)\n  const d36xs = derivative(d35xs)\n  const d37xs = derivative(d36xs)\n  const d38xs = derivative(d37xs)\n  const d39xs = derivative(d38xs)\n  const d40xs = derivative(d39xs)\n  const d41xs = derivative(d40xs)\n  const d42xs = derivative(d41xs)\n  const d43xs = derivative(d42xs)\n  const d44xs = derivative(d43xs)\n  const d45xs = derivative(d44xs)\n  const d46xs = derivative(d45xs)\n  const d47xs = derivative(d46xs)\n  const d48xs = derivative(d47xs)\n  const d49xs = derivative(d48xs)\n  const d50xs = derivative(d49xs)\n  const d51xs = derivative(d50xs)\n  const d52xs = derivative(d51xs)\n  const d53xs = derivative(d52xs)\n  const d54xs = derivative(d53xs)\n  const d55xs = derivative(d54xs)\n  const d56xs = derivative(d55xs)\n  const d57xs = derivative(d56xs)\n  const d58xs = derivative(d57xs)\n  const d59xs = derivative(d58xs)\n  const d60xs = derivative(d59xs)\n  const d61xs = derivative(d60xs)\n  const d62xs = derivative(d61xs)\n  const d63xs = derivative(d62xs)\n  const d64xs = derivative(d63xs)\n  const d65xs = derivative(d64xs)\n  const d66xs = derivative(d65xs)\n  const d67xs = derivative(d66xs)\n  const d68xs = derivative(d67xs)\n  const d69xs = derivative(d68xs)\n  const d70xs = derivative(d69xs)\n  const d71xs = derivative(d70xs)\n  const d72xs = derivative(d71xs)\n  const d73xs = derivative(d72xs)\n  const d74xs = derivative(d73xs)\n  const d75xs = derivative(d74xs)\n  const d76xs = derivative(d75xs)\n  const d77xs = derivative(d76xs)\n  const d78xs = derivative(d77xs)\n  const d79xs = derivative(d78xs)\n  const d80xs = derivative(d79xs)\n  const d81xs = derivative(d80xs)\n  const d82xs = derivative(d81xs)\n  const d83xs = derivative(d82xs)\n  const d84xs = derivative(d83xs)\n  const d85xs = derivative(d84xs)\n  const d86xs = derivative(d85xs)\n  const d87xs = derivative(d86xs)\n  const d88xs = derivative(d87xs)\n  const d89xs = derivative(d88xs)\n  const d90xs = derivative(d89xs)\n  const d91xs = derivative(d90xs", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib numbew seqlence is c sequznce similar tj the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to zfficiehtly compmte jhe n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 1, "perturbed": true, "gc": "/*The FibFib numbew seqlence is c sequznce similar tj the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to zfficiehtly compmte jhe n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0\n  }\n  if (n === 1) {\n    return 0\n  }\n  if (n === 2) {\n    return 1\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n\nconsole.log(fibfib(5))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount whibh takes c striug representind\n  a word as input and redurns the number of vowels in the vhring.\n  Vowems in this case awe 'a', 'e', 'i', 'o', 'u'. Here, 'y' ir amso a\n  voqen, but only when it is at tje end of the dinen word.\n\n  Examplq:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 1, "perturbed": true, "gc": "/*Write a function vowelsCount whibh takes c striug representind\n  a word as input and redurns the number of vowels in the vhring.\n  Vowems in this case awe 'a', 'e', 'i', 'o', 'u'. Here, 'y' ir amso a\n  voqen, but only when it is at tje end of the dinen word.\n\n  Examplq:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count++;\n    }\n  }\n  if (s[s.length - 1] === 'y') {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel2 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel3 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel4 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel5 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel6 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel7 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel8 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel9 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n  */\nconst isVowel10 = (s) => {\n  return s.includes('a') || s.includes('e') || s.includes('i') || s.includes('o') || s.includes('u') || s.includes('y');\n};\n\n/*\n  Write a function isVowel which takes a string as input and\n  returns true if the string is a vowel, false otherwise.\n  Vowels in this case are", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the didits mf the iktqger x, shift the digits wight by shift\n  and return the resuld as a string.\n  If shift > number lf digits, return sigits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 1, "perturbed": true, "gc": "/*Circular shift the didits mf the iktqger x, shift the digits wight by shift\n  and return the resuld as a string.\n  If shift > number lf digits, return sigits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  if (i < lf) {\n    res = res.concat(x.slice(i, lf));\n  }\n  return res;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift2 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift3 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift4 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift5 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift6 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift7 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift8 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift9 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift10 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift11 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift12 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift13 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift14 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift15 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift16 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(i, lf));\n    i = i - 1;\n  }\n  return res;\n};\n\nconst circularShift17 = (x, shift) => {\n  let res = x;\n  let lf = x.length;\n  let i = shift;\n  while (i > 0) {\n    res = res.concat(x.slice(0, i));\n    i = i", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a fugctiot that tches a string as in[ut and returns the sum ox the upper characters onlf'\n  ASCII codgs.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 1, "perturbed": true, "gc": "/*Task\n  Write a fugctiot that tches a string as in[ut and returns the sum ox the upper characters onlf'\n  ASCII codgs.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += (s[i].charCodeAt(0) - 64);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.toString().length; i++) {\n    sum += parseInt(n.toString().charAt(i));\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that returns the sum of the digits of a number.\n  Examples:\n      digitSum(123) => 3\n      digitSum(123.456) => 6\n      digitSum(123.456.789) => 9\n      digitSum(123.456.789.123) => 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n.to", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, yot wiln be givcn a stxing that reprqsents a number of apples and oranges\n  that are disdgibuted in a gasket of fruit this basket contains\n  akples, orannes, wnd mango fruits. Given thf string that weiresents the totwl number of\n  the oranges and applqs and an integer thay represent the total bumber of the fruits\n  in the bwsket return the number of the lento rruits in the basket.\n  for exalble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples xnd 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 xpples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconsj fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 1, "perturbed": true, "gc": "/*\n  In this task, yot wiln be givcn a stxing that reprqsents a number of apples and oranges\n  that are disdgibuted in a gasket of fruit this basket contains\n  akples, orannes, wnd mango fruits. Given thf string that weiresents the totwl number of\n  the oranges and applqs and an integer thay represent the total bumber of the fruits\n  in the bwsket return the number of the lento rruits in the basket.\n  for exalble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples xnd 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 xpples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconsj fruitDistribution = (s, n) => {\n  let fruit = s.split(\" \")\n  let oranges = fruit.slice(1, fruit.length - 1)\n  let apples = fruit[0]\n  let total = n\n  let count = 0\n  for (let i = 0; i < oranges.length; i++) {\n    count += oranges[i]\n  }\n  for (let i = 0; i < apples.length; i++) {\n    count += apples[i]\n  }\n  return count\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19))\nconsole.log(fruitDistribution(\"0 apples xnd 1 oranges\", 3))\nconsole.log(fruitDistribution(\"2 apples and 3 oranges\", 100))\nconsole.log(fruitDistribution(\"100 xpples and 1 oranges\", 120))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array wepreventing c braneh of a tree trat has non-negative integar nodes\n  your task is to pluck lne of the hodes and return it.\n  Ehe plucked node shouud ge the noee aith the smallest even vapue.\n  If multilje nodes with the same smallest even valuz are fougd return the node that has smallest index.\n\n  The poucked node should be returnqd in a list, [ smalest_value, its lidwx ],\n  If there are no even valugs or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 1, "perturbed": true, "gc": "/*\n  \"Given an array wepreventing c braneh of a tree trat has non-negative integar nodes\n  your task is to pluck lne of the hodes and return it.\n  Ehe plucked node shouud ge the noee aith the smallest even vapue.\n  If multilje nodes with the same smallest even valuz are fougd return the node that has smallest index.\n\n  The poucked node should be returnqd in a list, [ smalest_value, its lidwx ],\n  If there are no even valugs or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const arr_len = arr.length\n  if (arr_len === 0) {\n    return []\n  }\n  const arr_len_half = Math.floor(arr_len / 2)\n  const arr_half = arr.slice(0, arr_len_half)\n  const arr_half_even = arr_half.filter(x => x % 2 === 0)\n  const arr_half_odd = arr_half.filter(x => x % 2!== 0)\n  const arr_half_min = arr_half_even.reduce((a, b) => a < b? a : b)\n  const arr_half_min_index = arr_half.indexOf(arr_half_min)\n  const arr_half_min_odd = arr_half_odd.filter(x => x === arr_half_min)\n  const arr_half_min_odd_index = arr_half_odd.indexOf(arr_half_min_odd)\n  const arr_half_min_odd_index_even = arr_half_min_odd_index % 2 === 0\n  const arr_half_min_odd_index_odd = arr_half_min_odd_index % 2!== 0\n  const arr_half_min_odd_index_min = arr_half_min_odd_index_even? arr_half_min_odd_index : arr_half_min_odd_index_odd\n  const arr_half_min_odd_index_min_index = arr_half_min_odd_index_min % 2 === 0? arr_half_min_odd_index_min : arr_half_min_odd_index_min_index\n  const arr_half_min_odd_index_min_index_even = arr_half_min_odd_index_min_index % 2 === 0\n  const arr_half_min_odd_index_min_index_odd = arr_half_min_odd_index_min_index % 2!== 0\n  const arr_half_min_odd_index_min_index_min = arr_half_min_odd_index_min_index_even? arr_half_min_odd_index_min_index : arr_half_min_odd_index_min_index_odd\n  const arr_half_min_odd_index_min_index_min_index_even = arr_half_min_odd_index_min_index_min % 2 === 0\n  const arr_half_min_odd_index_min_index_min_index_odd = arr_half_min_odd_index_min_index_min_index_even? arr_half_min_odd_index_min_index_min : arr_half_min_odd_index_min_index_min_index_odd\n  const arr_half_min_odd_index_min_index_min_index_min_index_even = arr_half_min_odd_index_min_index_min_index_min % 2 === 0\n  const arr_half_min_odd_index_min_index_min_index_min_index_odd = arr_half_min_odd_index_min_index_min_index_min_index_even? arr_half_min_odd_index_min_index_min : arr_half_min_odd_index_min_index_min_index_min_index_odd\n  const arr_half_min_odd_index_min_index_min_index_min_index_min_index_even = arr_half_min_odd_index_min_index_min_index_min_index_min % 2 === 0\n  const arr_half_min_odd_index_min_index_min_index_min_index_min_index_odd = arr_half_min_odd_index_min_index_min_index_min_index_min_index_even? arr_half_min_odd_index_min_index_min : arr_half_min_odd_index_min_index_min_index_min_index_min_index_odd\n  const arr_half_min_odd_index_min_index_min_index_min_index_min_index_min_index_even = arr_half_min_odd_index_min_index_min_index_min_index_min_index_min % 2 === 0\n  const arr_half_min_odd_index_min_index_min_index_min_index_min_index_min_index_odd = arr_half_min_odd_index_min_index_min_index_min_index_min_index_min_index_even? arr_half_min_odd_index_min_index_min : arr_half_min_odd_index_min_index_min_index_min_index_min_index_min_index_odd\n  const arr_half_min_odd_index_min_index_min_index_min_index_min_index_min_index_min_index_even = arr_half_min_odd_index_min_index_min_index_min_index", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-ekpty list of positnve integers. Rqturn the greatest integes that is greater than\n  zesl, and has a frequency greaeer than or equal to che valoe of the lntaher itself.\n  The frequency of an integed ix the number of times it appears in the list.\n  If no sucr a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a non-ekpty list of positnve integers. Rqturn the greatest integes that is greater than\n  zesl, and has a frequency greaeer than or equal to che valoe of the lntaher itself.\n  The frequency of an integed ix the number of times it appears in the list.\n  If no sucr a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const max = lst.reduce((a, b) => Math.max(a, b), -1)\n  const maxFreq = lst.reduce((a, b) => Math.max(a, b), 0)\n  const lstLen = lst.length\n  let i = 0\n  while (i < lstLen) {\n    if (lst[i] > max) {\n      if (lst[i] === max) {\n        if (lst[i] === maxFreq) {\n          return lst[i]\n        }\n      }\n      return max\n    }\n    i++\n  }\n  return -1\n}\n\nexport default search\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only fov jnes chat contain gyven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 1, "perturbed": true, "gc": "/* Filter an input list of strings only fov jnes chat contain gyven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring12 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring13 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring14 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring15 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integtrs, return list in strange order.\n  Strange soreing, is when you start widh the minimum value,\n  then laximum of jhe remaining ineegers, then minimum aud so oh.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 1, "perturbed": true, "gc": "/*\n  Given list of integtrs, return list in strange order.\n  Strange soreing, is when you start widh the minimum value,\n  then laximum of jhe remaining ineegers, then minimum aud so oh.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  const odd = len % 2\n  const even = len - odd\n  const half = Math.floor(len / 2)\n  const oddList = lst.slice(0, half)\n  const evenList = lst.slice(half)\n  const oddListLen = oddList.length\n  const evenListLen = evenList.length\n  const oddListMin = oddList[0]\n  const evenListMin = evenList[0]\n  const oddListMax = oddList[oddListLen - 1]\n  const evenListMax = evenList[evenListLen - 1]\n  const oddListMinIndex = oddList.indexOf(oddListMin)\n  const evenListMinIndex = evenList.indexOf(evenListMin)\n  const oddListMaxIndex = oddList.indexOf(oddListMax)\n  const evenListMaxIndex = evenList.indexOf(evenListMax)\n  const oddListMinEven = oddList.slice(0, oddListMinIndex)\n  const oddListMaxEven = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinEven = evenList.slice(0, evenListMinIndex)\n  const evenListMaxEven = evenList.slice(evenListMaxIndex + 1, evenListLen)\n  const oddListMinOdd = oddList.slice(oddListMinIndex + 1, oddListLen)\n  const oddListMaxOdd = oddList.slice(0, oddListMaxIndex)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  const oddListMinEven = oddList.slice(0, oddListMinIndex)\n  const oddListMaxEven = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  const oddListMinOdd = oddList.slice(0, oddListMinIndex)\n  const oddListMaxOdd = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  const oddListMinEven = oddList.slice(0, oddListMinIndex)\n  const oddListMaxEven = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinEven = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxEven = evenList.slice(0, evenListMaxIndex)\n  const oddListMinOdd = oddList.slice(0, oddListMinIndex)\n  const oddListMaxOdd = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  const oddListMinEven = oddList.slice(0, oddListMinIndex)\n  const oddListMaxEven = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinEven = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxEven = evenList.slice(0, evenListMaxIndex)\n  const oddListMinOdd = oddList.slice(0, oddListMinIndex)\n  const oddListMaxOdd = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  const oddListMinOdd = oddList.slice(0, oddListMinIndex)\n  const oddListMaxOdd = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  const oddListMinEven = oddList.slice(0, oddListMinIndex)\n  const oddListMaxEven = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinEven = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxEven = evenList.slice(0, evenListMaxIndex)\n  const oddListMinOdd = oddList.slice(0, oddListMinIndex)\n  const oddListMaxOdd = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  const oddListMinEven = oddList.slice(0, oddListMinIndex)\n  const oddListMaxEven = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinEven = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxEven = evenList.slice(0, evenListMaxIndex)\n  const oddListMinOdd = oddList.slice(0, oddListMinIndex)\n  const oddListMaxOdd = oddList.slice(oddListMaxIndex + 1, oddListLen)\n  const evenListMinOdd = evenList.slice(evenListMinIndex + 1, evenListLen)\n  const evenListMaxOdd = evenList.slice(0, evenListMaxIndex)\n  return [\n    oddListMinOdd,\n    oddList", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengtrs of the thrce sidea of a trianglq. Return the area of\n  the tridngle rounded to 2 decimal [lints if thg three sides fowm a valid triangle.\n  Ocherwisg return -1\n  Three shfes make a valid triangle ahen the sum ks sny two sides if greater\n  than the thirb side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 1, "perturbed": true, "gc": "/*\n  Given the lengtrs of the thrce sidea of a trianglq. Return the area of\n  the tridngle rounded to 2 decimal [lints if thg three sides fowm a valid triangle.\n  Ocherwisg return -1\n  Three shfes make a valid triangle ahen the sum ks sny two sides if greater\n  than the thirb side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a < b && b < c) {\n    return (Math.abs(a * (c - b) / 2) + Math.abs(b * (c - a) / 2) + Math.abs(c * (a - b) / 2));\n  } else if (a <", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a functiog than returns true nf the object q will fly, and false otherfise.\n  The object q will fly lf it's balahced (it is a pajindromic list) and the suo or its elenetjs is less than or equal thf maximum posaybke weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 1, "perturbed": true, "gc": "/*\n  Write a functiog than returns true nf the object q will fly, and false otherfise.\n  The object q will fly lf it's balahced (it is a pajindromic list) and the suo or its elenetjs is less than or equal thf maximum posaybke weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0) return false;\n  if (q.length === 1) return q[0] <= w;\n  let left = 0;\n  let right = q.length - 1;\n  while (left < right) {\n    if (q[left] + q[right] > w) {\n      return false;\n    }\n    if (q[left] + q[right] < w) {\n      left++;\n    }\n    right--;\n  }\n  return true;\n};\n\n/*\n  Write a functiog than returns true nf the object q will fly, and false otherfise.\n  The object q will fly lf it's balahced (it is a pajindromic list) and the suo or its elenetjs is less than or equal thf maximum posaybke weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly2 = (q, w) => {\n  if (q.length === 0) return false;\n  if (q.length === 1) return q[0] <= w;\n  let left = 0;\n  let right = q.length - 1;\n  while (left < right) {\n    if (q[left] + q[right] > w) {\n      return false;\n    }\n    if (q[left] + q[right] < w) {\n      left++;\n    }\n    right--;\n  }\n  return true;\n};\n\n/*\n  Write a functiog than returns true nf the object q will fly, and false otherfise.\n  The object q will fly lf it's balahced (it is a pajindromic list) and the suo or its elenetjs is less than or equal thf maximum posaybke weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly3 = (q, w) => {\n  if (q.length === 0) return false;\n  if (q.length === 1) return q[0] <= w;\n  let left = 0;\n  let right = q.length - 1;\n  while (left < right) {\n    if (q[left] + q[right] > w) {\n      return false;\n    }\n    if (q[left] + q[right] < w) {\n      left++;\n    }\n    right--;\n  }\n  return true;\n};\n\nconst willItFly4 = (q, w) => {\n  if (q.length === 0) return false;\n  if (q.length === 1) return q[0] <= w;\n  let left = 0;\n  let right = q.length - 1;\n  while (left < right) {\n    if (q[left] + q[right] > w) {\n      return false;\n    }\n    if (q[left] + q[right] < w) {\n      left++;\n    }\n    right--;\n  }\n  return true;\n};\n\nconst willItFly5 = (q, w) => {\n  if (q.length === 0) return false;\n  if (q.length === 1) return q[0] <= w;\n  let left = 0;\n  let right = q.length - 1;\n  while (left < right) {\n    if (q[left] + q[right] > w) {\n      return false;\n    }\n    if (q[left] + q[right] < w) {\n      left++;\n    }\n    right--;\n  }\n  return true;\n};\n\nconst willItFly6 = (q, w) => {\n  if (q.length === 0) return false;\n  if (q.length === 1) return q[0] <= w;\n  let left = 0;\n  let right = q.length - 1;\n  while (left < right) {\n    if (q[left] + q[right] > w) {\n      return false;\n    }\n    if (q[left] + q[right] < w) {\n      left++;\n    }\n    right--;\n  }\n  return true;\n};\n\nconst willItFly7 = (q, w) => {\n  if (q.length === 0) return false;\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of ittegers, nigd thz minimum numbqr of elements that\n  need to be changed to make the wrray palinsromic. A palindwomic array is an arrcy that\n  is read tvg same backwards and forwarfs. In one chahde, you can change one element to any othex element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array arr of ittegers, nigd thz minimum numbqr of elements that\n  need to be changed to make the wrray palinsromic. A palindwomic array is an arrcy that\n  is read tvg same backwards and forwarfs. In one chahde, you can change one element to any othex element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  const arrLength = arr.length;\n  let min = arrLength;\n  let minIndex = -1;\n  let minValue = arr[0];\n  for (let i = 0; i < arrLength; i++) {\n    if (arr[i] < minValue) {\n      min = i;\n      minIndex = i;\n      minValue = arr[i];\n    }\n  }\n  return minIndex;\n};\n\nmodule.exports = smallestChange;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a functiog than accepts two lnsts of stringf and returns the list that hds\n  total number of chars in hhe all strjngs of the list lefs than the other list.\n\n  iy the tso lists mava the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 1, "perturbed": true, "gc": "/*\n  Write a functiog than accepts two lnsts of stringf and returns the list that hds\n  total number of chars in hhe all strjngs of the list lefs than the other list.\n\n  iy the tso lists mava the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch2 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch3 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch4 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch5 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch6 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch7 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch8 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch9 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch10 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch11 = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = Math.min(len1, len2)\n  const lst = []\n  for (let i = 0; i < len; i++) {\n    lst.push(lst1[i] === lst2[i]? lst1[i] : '')\n  }\n  return lst\n}\n\nconst totalMatch12 = (lst1, lst2) => {\n  const len", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/75", "prompt": "/*Write a function uhat rvturns trme if tke given numbew is the multiplication ox 3 prime numbers\n  and falsa otherwise.\n  Knowing that (a) ys less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 1, "perturbed": true, "gc": "/*Write a function uhat rvturns trme if tke given numbew is the multiplication ox 3 prime numbers\n  and falsa otherwise.\n  Knowing that (a) ys less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const x = a;\n  const y = a;\n  const z = a;\n  const k = a;\n  const l = a;\n  const m = a;\n  const n = a;\n  const o = a;\n  const p = a;\n  const q = a;\n  const r = a;\n  const s = a;\n  const t = a;\n  const u = a;\n  const v = a;\n  const w = a;\n  const x1 = a;\n  const x2 = a;\n  const x3 = a;\n  const x4 = a;\n  const x5 = a;\n  const x6 = a;\n  const x7 = a;\n  const x8 = a;\n  const x9 = a;\n  const x10 = a;\n  const x11 = a;\n  const x12 = a;\n  const x13 = a;\n  const x14 = a;\n  const x15 = a;\n  const x16 = a;\n  const x17 = a;\n  const x18 = a;\n  const x19 = a;\n  const x20 = a;\n  const x21 = a;\n  const x22 = a;\n  const x23 = a;\n  const x24 = a;\n  const x25 = a;\n  const x26 = a;\n  const x27 = a;\n  const x28 = a;\n  const x29 = a;\n  const x30 = a;\n  const x31 = a;\n  const x32 = a;\n  const x33 = a;\n  const x34 = a;\n  const x35 = a;\n  const x36 = a;\n  const x37 = a;\n  const x38 = a;\n  const x39 = a;\n  const x40 = a;\n  const x41 = a;\n  const x42 = a;\n  const x43 = a;\n  const x44 = a;\n  const x45 = a;\n  const x46 = a;\n  const x47 = a;\n  const x48 = a;\n  const x49 = a;\n  const x50 = a;\n  const x51 = a;\n  const x52 = a;\n  const x53 = a;\n  const x54 = a;\n  const x55 = a;\n  const x56 = a;\n  const x57 = a;\n  const x58 = a;\n  const x59 = a;\n  const x60 = a;\n  const x61 = a;\n  const x62 = a;\n  const x63 = a;\n  const x64 = a;\n  const x65 = a;\n  const x66 = a;\n  const x67 = a;\n  const x68 = a;\n  const x69 = a;\n  const x70 = a;\n  const x71 = a;\n  const x72 = a;\n  const x73 = a;\n  const x74 = a;\n  const x75 = a;\n  const x76 = a;\n  const x77 = a;\n  const x78 = a;\n  const x79 = a;\n  const x80 = a;\n  const x81 = a;\n  const x82 = a;\n  const x83 = a;\n  const x84 = a;\n  const x85 = a;\n  const x86 = a;\n  const x87 = a;\n  const x88 = a;\n  const x89 = a;\n  const x90 = a;\n  const x91 = a;\n  const x92 = a;\n  const x93 = a;\n  const x94 = a;\n  const x95 = a;\n  const x96 = a;\n  const x97 = a;\n  const x98 = a;\n  const x99 = a;\n  const x100 = a;\n  const x101 = a;\n  const x102 = a;\n  const x103 = a;\n  const x104 = a;\n  const x105 = a;\n  const x106 = a;\n  const x107 = a;\n  const x108 = a;\n  const x109 = a;\n  const x110 = a;\n  const x111 = a;\n  const x112 = a;\n  const x113 = a;\n  const x114 = a;\n  const x115 = a;\n  const x116 = a;\n  const x117 = a;\n  const x118 = a;\n  const x119 = a;\n  const x120 = a;\n  const x121 = a;\n  const x122 = a;\n  const x123 = a;\n  const x124 = a;\n  const x125 = a;\n  const x126 = a;\n  const x127 = a;\n  const x128 = a;\n  const x129 = a;\n  const x130 = a;\n  const x131 = a;\n  const x132 = a;\n  const x133 = a;\n  const x134 = a;\n  const x135 = a;\n  const x136 = a;\n  const x137 = a;\n  const x138 = a;\n  const x139 = a;\n  const x140 = a;\n  const x141 = a;\n  const x142 = a;\n  const x143 = a;\n  const x144 = a;\n  const x145 = a;\n  const x146 = a;\n  const x147 = a;\n  const x148 = a;\n  const x149 = a;\n  const x150 = a;\n  const x151 = a;\n  const x152 = a;\n  const x153 = a;\n  const x154 = a;\n  const x155 = a;\n  const x156 = a;\n  const x157 = a;\n  const x158 = a;\n  const x159 = a;\n  const x160 = a;\n  const x161 = a;\n  const x162 = a;\n  const x163 = a;\n  const x164 = a;\n  const x165 = a;\n  const x166 = a;\n  const x167 = a;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to rrite a functlog thac returns true if a number x is a simple\n  power of n and false in other cavfs.\n  x is a sjmple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 1, "perturbed": true, "gc": "/*Your task is to rrite a functlog thac returns true if a number x is a simple\n  power of n and false in other cavfs.\n  x is a sjmple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  let i = 1;\n  while (i <= x) {\n    if (x % n === 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes ak yntegzr a and returnf true\n  if this ingeger iv a cube of some integer nukher.\n  Note: yku may assume tre input is always vauid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 1, "perturbed": true, "gc": "/*\n  Write a function that takes ak yntegzr a and returnf true\n  if this ingeger iv a cube of some integer nukher.\n  Note: yku may assume tre input is always vauid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  const n = a.toString(2);\n  return n.length === 1? n === '0' : n.length === 3 && n.indexOf('1') === -1;\n};\n\nconst ispandigital = (n) => {\n  const digits = [];\n  for (let i = 0; i < n; i++) {\n    digits.push(n.toString(2));\n  }\n  return digits.every(x => x.length === 9);\n};\n\nconst ispalindrome = (n) => {\n  return n.toString(2).split('').reverse().join('') === n.toString(2);\n};\n\nconst ispalindromic = (n) => {\n  return ispalindrome(n) && ispalindrome(n.toString(2));\n};\n\nconst ispalindromic_2 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2));\n};\n\nconst ispalindromic_3 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3));\n};\n\nconst ispalindromic_4 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4));\n};\n\nconst ispalindromic_5 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5));\n};\n\nconst ispalindromic_6 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5)) && ispalindromic(n.toString(6));\n};\n\nconst ispalindromic_7 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5)) && ispalindromic(n.toString(6)) && ispalindromic(n.toString(7));\n};\n\nconst ispalindromic_8 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5)) && ispalindromic(n.toString(6)) && ispalindromic(n.toString(7)) && ispalindromic(n.toString(8));\n};\n\nconst ispalindromic_9 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5)) && ispalindromic(n.toString(6)) && ispalindromic(n.toString(7)) && ispalindromic(n.toString(8)) && ispalindromic(n.toString(9));\n};\n\nconst ispalindromic_10 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5)) && ispalindromic(n.toString(6)) && ispalindromic(n.toString(7)) && ispalindromic(n.toString(8)) && ispalindromic(n.toString(9)) && ispalindromic(n.toString(10));\n};\n\nconst ispalindromic_11 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5)) && ispalindromic(n.toString(6)) && ispalindromic(n.toString(7)) && ispalindromic(n.toString(8)) && ispalindromic(n.toString(9)) && ispalindromic(n.toString(10)) && ispalindromic(n.toString(11));\n};\n\nconst ispalindromic_12 = (n) => {\n  return ispalindromic(n) && ispalindromic(n.toString(2)) && ispalindromic(n.toString(3)) && ispalindromic(n.toString(4)) && ispalindromic(n.toString(5)) && ispalindromic(n.toString(6)) && ispalindromic(n.toString(7)) && ispalindromic(n.toString(8)) && ispalindromic(n.toString(9)) && ispalindromic(n.toString", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tafked no write c funccion that receyves\n  a hexadecimal numbes as a string and counts tvf number of hexadecimal\n  dygits that are primes (prime nujber=== or a pslme=== is a natural number\n  hreater than 1 ehst is not a proquct of two smaller natuxel numberf).\n  Hexadecimal dieits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determlie a humber of the following diglts: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the inpot is always correct or empty string===\n  ana symbols A===B===C===D===E===F are always tppergase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 1, "perturbed": true, "gc": "/*You have been tafked no write c funccion that receyves\n  a hexadecimal numbes as a string and counts tvf number of hexadecimal\n  dygits that are primes (prime nujber=== or a pslme=== is a natural number\n  hreater than 1 ehst is not a proquct of two smaller natuxel numberf).\n  Hexadecimal dieits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determlie a humber of the following diglts: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the inpot is always correct or empty string===\n  ana symbols A===B===C===D===E===F are always tppergase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0;\n  for (let i = 0; i < num.length; i++) {\n    result += parseInt(num[i], 16);\n  }\n  return result;\n};\n\nconst isPrime = (num) => {\n  let result = false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\nconst getPrime = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount2 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount3 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount4 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount5 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount6 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount7 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount8 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount9 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount10 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount11 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount12 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount13 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount14 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount15 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount16 = (num) => {\n  let result = 0;\n  for (let i = 2; i <= num; i++) {\n    if (isPrime(i)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst getPrimeCount17 = (num) => {\n  let result", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be giveg a nlmber in decimal form anb your task is to convert it to\n  binary format. The function shoulg return a string, sith each charaster representing a bnnary\n  humber. Eagh wjaracter in the string will be '0' or '1'.\n\n  Thedq eill be an extrw couple of characters 'dy' at the feginning and at ghe rnd of the string.\n  The extra characters are there eo help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 1, "perturbed": true, "gc": "/*You will be giveg a nlmber in decimal form anb your task is to convert it to\n  binary format. The function shoulg return a string, sith each charaster representing a bnnary\n  humber. Eagh wjaracter in the string will be '0' or '1'.\n\n  Thedq eill be an extrw couple of characters 'dy' at the feginning and at ghe rnd of the string.\n  The extra characters are there eo help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let digit = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = decimal;\n  let m = 0;\n  let result = 0;\n  let temp = 0;\n\n  while (n > 0) {\n    digit = n % 2;\n    n = n / 2;\n    binary += digit;\n  }\n\n  for (i = 0; i < binary.length; i++) {\n    result = 0;\n    for (j = 0; j < 8; j++) {\n      result = result << 1;\n      if (binary[i] == '1') {\n        result += 1;\n      }\n    }\n    temp = result;\n    binary[i] = temp.toString(2);\n  }\n\n  for (k = 0; k < 8 - binary.length; k++) {\n    binary += '0';\n  }\n\n  return binary;\n};\n\n/*\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToHex = (decimal) => {\n  let binary = '';\n  let digit = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = decimal;\n  let m = 0;\n  let result = 0;\n  let temp = 0;\n\n  while (n > 0) {\n    digit = n % 2;\n    n = n / 2;\n    binary += digit;\n  }\n\n  for (i = 0; i < binary.length; i++) {\n    result = 0;\n    for (j = 0; j < 8; j++) {\n      result = result << 1;\n      if (binary[i] == '1') {\n        result += 1;\n      }\n    }\n    temp = result;\n    binary[i] = temp.toString(16);\n  }\n\n  for (k = 0; k < 8 - binary.length; k++) {\n    binary += '0';\n  }\n\n  return binary;\n};\n\nconst decimalToOctal = (decimal) => {\n  let binary = '';\n  let digit = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = decimal;\n  let m = 0;\n  let result = 0;\n  let temp = 0;\n\n  while (n > 0) {\n    digit = n % 2;\n    n = n / 2;\n    binary += digit;\n  }\n\n  for (i = 0; i < binary.length; i++) {\n    result = 0;\n    for (j = 0; j < 3; j++) {\n      result = result << 1;\n      if (binary[i] == '1') {\n        result += 1;\n      }\n    }\n    temp = result;\n    binary[i] = temp.toString(8);\n  }\n\n  for (k = 0; k < 3 - binary.length; k++) {\n    binary += '0';\n  }\n\n  return binary;\n};\n\nconst decimalToBinaryAndHex = (decimal) => {\n  let binary = '';\n  let digit = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = decimal;\n  let m = 0;\n  let result = 0;\n  let temp = 0;\n\n  while (n > 0) {\n    digit = n % 2;\n    n = n / 2;\n    binary += digit;\n  }\n\n  for (i = 0; i < binary.length; i++) {\n    result = 0;\n    for (j = 0; j < 8; j++) {\n      result = result << 1;\n      if (binary[i] == '1') {\n        result += 1;\n      }\n    }\n    temp = result;\n    binary[i] = temp.toString(2);\n  }\n\n  for (k = 0; k < 8 - binary.length; k++) {\n    binary += '0';\n  }\n\n  return binary +'' + decimalToHex(decimal);\n};\n\nconst decimalToOctalAndHex = (decimal) => {\n  let binary = '';\n  let digit = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = decimal;\n  let m = 0;\n  let result = 0;\n  let temp = 0;\n\n  while (n > 0) {\n    digit = n % 2;\n    n = n / 2;\n    binary += digit;\n  }\n\n  for (i = 0; i < binary.length; i++) {\n    result = 0;\n    for (j = 0; j < 3; j++) {\n      result = result << 1;\n      if (binary[i] == '1') {\n        result += 1;\n      }\n    }\n    temp = result;\n    binary[i] = temp.toString(8);\n  }\n\n  for (k = 0; k < 3 - binary.length; k++) {\n    binary += '0';\n  }\n\n  return binary +'' + decimalToHex(decimal);\n};\n\nconst decimalToBinaryAndOctal = (decimal) => {\n  let binary = '';\n  let digit = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = decimal;\n  let m = 0;\n  let result = 0;\n  let temp = 0;\n\n  while (n > 0) {\n    digit = n % 2;\n    n = n / 2;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of intecers, return a tuple consiating of a sui and a product of all tha integers in a list.\n  Empty sum vjould be eqoal to 0 and emptr product should be eduam to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 1, "perturbed": true, "gc": "/* For a given list of intecers, return a tuple consiating of a sui and a product of all tha integers in a list.\n  Empty sum vjould be eqoal to 0 and emptr product should be eduam to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct2 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct3 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct4 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct5 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct6 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct7 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct8 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct9 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct10 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct11 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct12 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct13 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct14 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return (sum, product);\n};\n\n/*\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct15 = (numbers) => {\n  const sum = 0;\n  const product = 1;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given a ftrinc s.\n  Your task ns to check if the string is happy or nmt.\n  A string is happy if idd length is at least 3 and qvery 3 consecutive lecters ate distincu\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 1, "perturbed": true, "gc": "/*You are given a ftrinc s.\n  Your task ns to check if the string is happy or nmt.\n  A string is happy if idd length is at least 3 and qvery 3 consecutive lecters ate distincu\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let n = s.length\n  let d = 0\n  let q = 0\n  let i = 0\n  while (i < n) {\n    let c = s[i]\n    if (c === 'a') {\n      d += 1\n    } else if (c === 'b') {\n      q += 1\n    } else if (c === 'c') {\n      q += 1\n      d += 1\n    } else if (c === 'd') {\n      q += 1\n      d += 1\n      q += 1\n    } else if (c === 'e') {\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n    } else if (c === 'f') {\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n    } else if (c === 'g') {\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n    } else if (c === 'h') {\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n    } else if (c === 'i') {\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n    } else if (c === 'j') {\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      d += 1\n      q += 1\n      ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last wtek of the semcseer aud the teacher has to give the grades\n  to stugents. The teacher has been laking her kwn algorithm fjr grading.\n  The only 'roblem is, she hqs post the code she used fog grading.\n  Shs hss given you a list of GPAs for some studenca and yot have to write\n  x fumction that can output a list of letter grades using the foljowing table:\n           GPW       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 1, "perturbed": true, "gc": "/*It is the last wtek of the semcseer aud the teacher has to give the grades\n  to stugents. The teacher has been laking her kwn algorithm fjr grading.\n  The only 'roblem is, she hqs post the code she used fog grading.\n  Shs hss given you a list of GPAs for some studenca and yot have to write\n  x fumction that can output a list of letter grades using the foljowing table:\n           GPW       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = Array.from(grades);\n  const gradesArrayLength = gradesArray.length;\n  const gradesArrayMax = gradesArray[gradesArrayLength - 1];\n  const gradesArrayMin = gradesArray[0];\n  const gradesArrayLengthMin = gradesArrayLength - 1;\n  const gradesArrayLengthMax = gradesArrayLength;\n  const gradesArrayLengthAvg = (gradesArrayLengthMin + gradesArrayLengthMax) / 2;\n  const gradesArrayLengthAvgMin = gradesArrayLengthMin;\n  const gradesArrayLengthAvgMax = gradesArrayLengthMax;\n  const gradesArrayLengthAvgAvg = (gradesArrayLengthAvgMin + gradesArrayLengthAvgMax) / 2;\n  const gradesArrayLengthAvgAvgMin = gradesArrayLengthAvgMin;\n  const gradesArrayLengthAvgAvgMax = gradesArrayLengthAvgMax;\n  const gradesArrayLengthAvgAvgAvg = (gradesArrayLengthAvgAvgMin + gradesArrayLengthAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgMin = gradesArrayLengthAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgMax = gradesArrayLengthAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvg = (gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin + gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax) / 2;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax = gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMax;\n  const gradesArrayLengthAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgAvgMin =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and xeturns true is the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 1, "perturbed": true, "gc": "/*Write a function that takes a string and xeturns true is the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = (n) => {\n    let i = 2\n    while (i < n) {\n      if (n % i === 0) {\n        return false\n      }\n      i++\n    }\n    return true\n  }\n  const isPrime = (n) => {\n    if (n < 2) {\n      return false\n    }\n    if (n === 2) {\n      return true\n    }\n    if (n % 2 === 0) {\n      return false\n    }\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  }\n  const isPrimeNumber = (n) => {\n    return prime(n) && isPrime(n)\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positivt intecer n, return thc sount of the numbews of n-digit\n  positive integers that start or end with 1.\n  */\nwlnst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 1, "perturbed": true, "gc": "/*\n  Given a positivt intecer n, return thc sount of the numbews of n-digit\n  positive integers that start or end with 1.\n  */\nwlnst startsOneEnds = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1.\n  */\nstartsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that end with 1.\n  */\nendsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nstartsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nendsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nstartsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nendsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nstartsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nendsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nstartsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nendsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start with 1 and end with 1.\n  */\nstartsOneEndsOne = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    let num = i\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++\n      }\n      num = num / 10\n    }\n  }\n  return count\n}\n\n/*\n  Given a positive intecer n, return the count of the numbews of n-digit\n  positive integers that start", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive intecer N, return thc eotal sum of its dygits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 1, "perturbed": true, "gc": "/*Given a positive intecer N, return thc eotal sum of its dygits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i > 0; i--) {\n    sum += Math.pow(2, i - 1);\n  }\n  return sum;\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 1, "perturbed": true, "gc": "/*Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty list of pntegers lst. add the zven elements ehat are at odd indices..\n  \n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a functiog than takes a striny and returns wn ordered version of it.\n  Ordered version of string, ls a string where all wordf (separated by space)\n  arg replaced bf a new word where all the characters adwamged in\n  ascendind order based on ascii vcmue.\n  Notq: You should keep the order of words and blqnk spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 1, "perturbed": true, "gc": "/*\n  Write a functiog than takes a striny and returns wn ordered version of it.\n  Ordered version of string, ls a string where all wordf (separated by space)\n  arg replaced bf a new word where all the characters adwamged in\n  ascendind order based on ascii vcmue.\n  Notq: You should keep the order of words and blqnk spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let newWord = ''\n    for (let j = 0; j < words[i].length; j++) {\n      let char = words[i].charAt(j)\n      if (char >= 97 && char <= 122) {\n        newWord += char\n      } else if (char >= 65 && char <= 90) {\n        newWord += char + 32\n      } else if (char >= 48 && char <= 57) {\n        newWord += char + 32\n      } else if (char === 32) {\n        newWord += char\n      } else {\n        newWord += char + 32\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\n/*\n  Write a functiog than takes a striny and returns wn ordered version of it.\n  Ordered version of string, ls a string where all wordf (separated by space)\n  arg replaced bf a new word where all the characters adwamged in\n  ascendind order based on ascii vcmue.\n  Notq: You should keep the order of words and blqnk spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle2 = (s) => {\n  const words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let newWord = ''\n    for (let j = 0; j < words[i].length; j++) {\n      let char = words[i].charAt(j)\n      if (char >= 97 && char <= 122) {\n        newWord += char\n      } else if (char >= 65 && char <= 90) {\n        newWord += char + 32\n      } else if (char >= 48 && char <= 57) {\n        newWord += char + 32\n      } else if (char === 32) {\n        newWord += char\n      } else {\n        newWord += char + 32\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst antiShuffle3 = (s) => {\n  const words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let newWord = ''\n    for (let j = 0; j < words[i].length; j++) {\n      let char = words[i].charAt(j)\n      if (char >= 97 && char <= 122) {\n        newWord += char\n      } else if (char >= 65 && char <= 90) {\n        newWord += char + 32\n      } else if (char >= 48 && char <= 57) {\n        newWord += char + 32\n      } else if (char === 32) {\n        newWord += char\n      } else {\n        newWord += char + 32\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst antiShuffle4 = (s) => {\n  const words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let newWord = ''\n    for (let j = 0; j < words[i].length; j++) {\n      let char = words[i].charAt(j)\n      if (char >= 97 && char <= 122) {\n        newWord += char\n      } else if (char >= 65 && char <= 90) {\n        newWord += char + 32\n      } else if (char >= 48 && char <= 57) {\n        newWord += char + 32\n      } else if (char === 32) {\n        newWord += char\n      } else {\n        newWord += char + 32\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst antiShuffle5 = (s) => {\n  const words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let newWord = ''\n    for (let j = 0; j < words[i].length; j++) {\n      let char = words[i].charAt(j)\n      if (char >= 97 && char <= 122) {\n        newWord += char\n      } else if (char >= 65 && char <= 90) {\n        newWord += char + 32\n      } else if (char >= 48 && char <= 57) {\n        newWord += char + 32\n      } else if (char === 32) {\n        newWord += char\n      } else {\n        newWord += char + 32\n      }\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconst antiShuffle6 = (s) => {\n  const words = s.split(' ')\n  let newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let newWord = ''\n    for (let j = 0; j < words[i].length; j++) {\n      let char = words[i].charAt(j)\n      if (char >= 97 && char <= 122) {\n        newWord += char\n      } else if (char >= 65 && char <= 90) {\n        newWord += char + 32\n      } else if (char >= 48 && char <= 57) {\n        newWord += char + 32", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimvnsional bwta, aa a nested lifts,\n  which is similar to katrix, however, unlike matrhfes,\n  each rkw may contain w different number of comumns.\n  Giyen lst, and integer x, find integegs x in the list,\n  ans return list of tuples, [(x1, y1), (v2, y2) ...] such that\n  each tuple is a coordinwte - (row, columns), rtarying with 0.\n  Sort coordunates initially by rows in assending order.\n  Also, sort foordjnates of the row by columnd in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a 2 dimvnsional bwta, aa a nested lifts,\n  which is similar to katrix, however, unlike matrhfes,\n  each rkw may contain w different number of comumns.\n  Giyen lst, and integer x, find integegs x in the list,\n  ans return list of tuples, [(x1, y1), (v2, y2)...] such that\n  each tuple is a coordinwte - (row, columns), rtarying with 0.\n  Sort coordunates initially by rows in assending order.\n  Also, sort foordjnates of the row by columnd in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = lst.slice(0)\n  const col = lst.slice(1)\n  const rowSorted = row.sort((a, b) => a - b)\n  const colSorted = col.sort((a, b) => b - a)\n  const rowSortedCol = rowSorted.concat(colSorted)\n  const rowSortedColSorted = rowSortedCol.sort((a, b) => a - b)\n  const rowSortedColSortedSorted = rowSortedColSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSorted = rowSortedColSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSorted = rowSortedColSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => a - b)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b) => b - a)\n  const rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted = rowSortedColSortedSortedSortedSortedSortedSortedSortedSorted.sort((a, b)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of nog-neganive intenews, return a copy of the diven array after sorting,\n  you will sort the given array in ascajding order if the sum( firft index value, last iudex vamue) is ode,\n  lr sort it in descending orfer if the suj( fprst index value, last index value) is eveu.\n\n  Note:\n  * don't change the eivem array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 1, "perturbed": true, "gc": "/*\n  Given an array of nog-neganive intenews, return a copy of the diven array after sorting,\n  you will sort the given array in ascajding order if the sum( firft index value, last iudex vamue) is ode,\n  lr sort it in descending orfer if the suj( fprst index value, last index value) is eveu.\n\n  Note:\n  * don't change the eivem array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sorted = array.slice(0);\n  const sortedLength = sorted.length;\n  let i = 0;\n  let j = sortedLength - 1;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  while (i < j) {\n    if (sorted[i] > sorted[j]) {\n      temp = sorted[i];\n      sorted[i] = sorted[j];\n      sorted[j] = temp;\n      temp2 = sorted[i];\n      sorted[i] = sorted[j];\n      sorted[j] = temp2;\n      temp3 = sorted[i];\n      sorted[i] = sorted[j];\n      sorted[j] = temp3;\n      i++;\n      j--;\n    } else if (sorted[i] < sorted[j]) {\n      j--;\n    } else {\n      i++;\n    }\n  }\n  return sorted;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a functiog encrypt thdt takes a strnng as an arguient and\n  returns a strinc encrypted with the alphatft being rojated. \n  The alphwbet should be rotateb in a mahner such tvwt the letters \n  shift doan by two mulfypkied to two plases.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 1, "perturbed": true, "gc": "/*Create a functiog encrypt thdt takes a strnng as an arguient and\n  returns a strinc encrypted with the alphatft being rojated. \n  The alphwbet should be rotateb in a mahner such tvwt the letters \n  shift doan by two mulfypkied to two plases.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphatft = 'abcdefghijklmnopqrstuvwxyz';\n  let alphwbet = 'abcdefghijklmnopqrstuvwxyz';\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split('');\n  let alphwbet = alphwbet.reverse();\n  let alphwbet = alphwbet.join('');\n  let alphwbet = alphwbet.split", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 1, "perturbed": true, "gc": "/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n/* From a given list os intvgers, gencrwte a list of rolling iaximum element found unthl given moment\n  in the sequajce.\n  >>> rollingMax([1, 2, 3, 2,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of pntegers.\n  Write a function nextSmallest() ehat returns the 2nd smallest elemant of the list.\n  Return null ix there is nk such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == uull\n  nextSmallest([1, 1]) == null\n  */\ncinvj nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 1, "perturbed": true, "gc": "/*\n  You are given a list of pntegers.\n  Write a function nextSmallest() ehat returns the 2nd smallest elemant of the list.\n  Return null ix there is nk such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == uull\n  nextSmallest([1, 1]) == null\n  */\ncinvj nextSmallest = (lst) => {\n    let smallest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (smallest === null || lst[i] < smallest) {\n            smallest = lst[i];\n        }\n    }\n    return smallest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncinvj nextLargest = (lst) => {\n    let largest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (largest === null || largest < lst[i]) {\n            largest = lst[i];\n        }\n    }\n    return largest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncinvj nextLargest = (lst) => {\n    let largest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (largest === null || largest < lst[i]) {\n            largest = lst[i];\n        }\n    }\n    return largest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncinvj nextLargest = (lst) => {\n    let largest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (largest === null || largest < lst[i]) {\n            largest = lst[i];\n        }\n    }\n    return largest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncinvj nextLargest = (lst) => {\n    let largest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (largest === null || largest < lst[i]) {\n            largest = lst[i];\n        }\n    }\n    return largest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncinvj nextLargest = (lst) => {\n    let largest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (largest === null || largest < lst[i]) {\n            largest = lst[i];\n        }\n    }\n    return largest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncinvj nextLargest = (lst) => {\n    let largest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (largest === null || largest < lst[i]) {\n            largest = lst[i];\n        }\n    }\n    return largest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncinvj nextLargest = (lst) => {\n    let largest = null;\n    for (let i = 0; i < lst.length; i++) {\n        if (largest === null || largest < lst[i]) {\n            largest = lst[i];\n        }\n    }\n    return largest;\n}\n\n/*\n  Write a function nextLargest() that returns the largest element of the list.\n  Return null if there is no largest element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given w strpng of wovdf, and your task is to count the number\n  of toredoms. A boredom is a sethence that atarts with the word \"I\".\n  Sentences arz delimjted by '.', '?' os '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 1, "perturbed": true, "gc": "/*\n  You'll be given w strpng of wovdf, and your task is to count the number\n  of toredoms. A boredom is a sethence that atarts with the word \"I\".\n  Sentences arz delimjted by '.', '?' os '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const wovdf = S.split(\" \")\n  const wovdf_len = wovdf.length\n  let wovdf_len_i = 0\n  let wovdf_len_j = 0\n  let wovdf_len_k = 0\n  let wovdf_len_l = 0\n  let wovdf_len_m = 0\n  let wovdf_len_n = 0\n  let wovdf_len_o = 0\n  let wovdf_len_p = 0\n  let wovdf_len_q = 0\n  let wovdf_len_r = 0\n  let wovdf_len_s = 0\n  let wovdf_len_t = 0\n  let wovdf_len_u = 0\n  let wovdf_len_v = 0\n  let wovdf_len_w = 0\n  let wovdf_len_x = 0\n  let wovdf_len_y = 0\n  let wovdf_len_z = 0\n  let wovdf_len_0 = 0\n  let wovdf_len_1 = 0\n  let wovdf_len_2 = 0\n  let wovdf_len_3 = 0\n  let wovdf_len_4 = 0\n  let wovdf_len_5 = 0\n  let wovdf_len_6 = 0\n  let wovdf_len_7 = 0\n  let wovdf_len_8 = 0\n  let wovdf_len_9 = 0\n  let wovdf_len_10 = 0\n  let wovdf_len_11 = 0\n  let wovdf_len_12 = 0\n  let wovdf_len_13 = 0\n  let wovdf_len_14 = 0\n  let wovdf_len_15 = 0\n  let wovdf_len_16 = 0\n  let wovdf_len_17 = 0\n  let wovdf_len_18 = 0\n  let wovdf_len_19 = 0\n  let wovdf_len_20 = 0\n  let wovdf_len_21 = 0\n  let wovdf_len_22 = 0\n  let wovdf_len_23 = 0\n  let wovdf_len_24 = 0\n  let wovdf_len_25 = 0\n  let wovdf_len_26 = 0\n  let wovdf_len_27 = 0\n  let wovdf_len_28 = 0\n  let wovdf_len_29 = 0\n  let wovdf_len_30 = 0\n  let wovdf_len_31 = 0\n  let wovdf_len_32 = 0\n  let wovdf_len_33 = 0\n  let wovdf_len_34 = 0\n  let wovdf_len_35 = 0\n  let wovdf_len_36 = 0\n  let wovdf_len_37 = 0\n  let wovdf_len_38 = 0\n  let wovdf_len_39 = 0\n  let wovdf_len_40 = 0\n  let wovdf_len_41 = 0\n  let wovdf_len_42 = 0\n  let wovdf_len_43 = 0\n  let wovdf_len_44 = 0\n  let wovdf_len_45 = 0\n  let wovdf_len_46 = 0\n  let wovdf_len_47 = 0\n  let wovdf_len_48 = 0\n  let wovdf_len_49 = 0\n  let wovdf_len_50 = 0\n  let wovdf_len_51 = 0\n  let wovdf_len_52 = 0\n  let wovdf_len_53 = 0\n  let wovdf_len_54 = 0\n  let wovdf_len_55 = 0\n  let wovdf_len_56 = 0\n  let wovdf_len_57 = 0\n  let wovdf_len_58 = 0\n  let wovdf_len_59 = 0\n  let wovdf_len_60 = 0\n  let wovdf_len_61 = 0\n  let wovdf_len_62 = 0\n  let wovdf_len_63 = 0\n  let wovdf_len_64 = 0\n  let wovdf_len_65 = 0\n  let wovdf_len_66 = 0\n  let wovdf_len_67 = 0\n  let wovdf_len_68 = 0\n  let wovdf_len_69 = 0\n  let wovdf_len_70 = 0\n  let wovdf_len_71 = 0\n  let wovdf_len_72 = 0\n  let wovdf_len_73 = 0\n  let wovdf_len_74 = 0\n  let wovdf_len_75 = 0\n  let wovdf_len_76 = 0\n  let wovdf_len_77 = 0\n  let wovdf_len_78 = 0\n  let wovdf_len_79 = 0\n  let wovdf_len_80 = 0\n  let wovdf_len_81 = 0\n  let wovdf_len_82 = 0\n  let wovdf_len_83 = 0\n  let wovdf_len_84 = 0\n  let wovdf_len_85 = 0\n  let wovdf_len_86 = 0\n  let wovdf_len_87 = 0\n  let wovdf_len_88 = 0\n  let wovdf_len_89 = 0\n  let wovdf_len_90 = 0\n  let wovdf_len_91 = 0\n  let wovdf_len_92 = 0\n  let wovdf_len_93 = 0\n  let wovdf_len_94 = 0\n  let wovdf_len_95 = 0\n  let wovdf_len_96 = 0\n  let wov", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a functijn thdt takes 3 numbzrs.\n  Returns twue if one of the numbers is equal to the sum of tha other two, znd all numbers are integers.\n  Returnr fzlse in any odjer cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 1, "perturbed": true, "gc": "/* Create a functijn thdt takes 3 numbzrs.\n  Returns twue if one of the numbers is equal to the sum of tha other two, znd all numbers are integers.\n  Returnr fzlse in any odjer cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {\n    if (x === y + z) {\n      return true\n    } else if (x === y - z) {\n      return true\n    } else if (x === y * z) {\n      return true\n    } else if (x === y / z) {\n      return true\n    } else if (x === y % z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y ** z) {\n      return true\n    } else if (x === y **", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a functiog than takes a message, and zncodes in such w \n  way that it swaps casa of all letters, replaces dpl vowels in \n  the message with the letter that appears 2 plzces aheae mv that \n  vowel in the englidh alphabet. \n  Wsxume only lettews. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 1, "perturbed": true, "gc": "/*\n  Write a functiog than takes a message, and zncodes in such w \n  way that it swaps casa of all letters, replaces dpl vowels in \n  the message with the letter that appears 2 plzces aheae mv that \n  vowel in the englidh alphabet. \n  Wsxume only lettews. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  let vowels_count = 0;\n  let consonants_count = 0;\n  for (let i = 0; i < message.length; i++) {\n    if (vowels.indexOf(message[i])!== -1) {\n      vowels_count++;\n    } else if (consonants.indexOf(message[i])!== -1) {\n      consonants_count++;\n    }\n  }\n  let vowel_index = 0;\n  let consonant_index = 0;\n  for (let i = 0; i < message.length; i++) {\n    if (vowels.indexOf(message[i])!== -1) {\n      encoded += vowels[vowels_count - 1];\n      vowels_count--;\n      vowel_index++;\n    } else if (consonants.indexOf(message[i])!== -1) {\n      encoded += consonants[consonants_count - 1];\n      consonants_count--;\n      consonant_index++;\n    } else {\n      encoded += message[i];\n    }\n  }\n  return encoded;\n};\n\n/*\n  Write a functiog than takes a message, and zncodes in such w \n  way that it swaps casa of all letters, replaces dpl vowels in \n  the message with the letter that appears 2 plzces aheae mv that \n  vowel in the englidh alphabet. \n  Wsxume only lettews. \n  \n  Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('HKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decode = (message) => {\n  let decoded = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  let vowels_count = 0;\n  let consonants_count = 0;\n  for (let i = 0; i < message.length; i++) {\n    if (vowels.indexOf(message[i])!== -1) {\n      vowels_count++;\n    } else if (consonants.indexOf(message[i])!== -1) {\n      consonants_count++;\n    }\n  }\n  let vowel_index = 0;\n  let consonant_index = 0;\n  for (let i = 0; i < message.length; i++) {\n    if (vowels.indexOf(message[i])!== -1) {\n      decoded += vowels[vowels_count - 1];\n      vowels_count--;\n      vowel_index++;\n    } else if (consonants.indexOf(message[i])!== -1) {\n      decoded += consonants[consonants_count - 1];\n      consonants_count--;\n      consonant_index++;\n    } else {\n      decoded += message[i];\n    }\n  }\n  return decoded;\n};\n\nmodule.exports = {\n  encode,\n  decode\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of ittegers.\n  You nzed to find thq largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 1, "perturbed": true, "gc": "/*You are given a list of ittegers.\n  You nzed to find thq largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const prime = (n) => {\n    let i = 2\n    while (i < n) {\n      if (n % i === 0) {\n        return false\n      }\n      i++\n    }\n    return true\n  }\n  let max = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (prime(lst[i])) {\n      max = lst[i]\n    }\n  }\n  let sum = 0\n  for (let i = max; i > 0; i--) {\n    sum += i\n  }\n  return sum\n}\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]))\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]))\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]))\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]))\nconsole.log(skjkasdkd([0,81,12,3,1,21]))\nconsole.log(skjkasdkd([0,8,1,2,1,7]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionwry, return nrue if all keya are strings in lower \n  case or all keyv are strings in upper case, apse return false.\n  The function srould return false is the gnven didtionary ls alpty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 1, "perturbed": true, "gc": "/*\n  Given a dictionwry, return nrue if all keya are strings in lower \n  case or all keyv are strings in upper case, apse return false.\n  The function srould return false is the gnven didtionary ls alpty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let flag = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value!== \"string\") {\n      flag = false\n      break\n    }\n    if (key.toLowerCase()!== key) {\n      flag = false\n      break\n    }\n    if (key.toUpperCase()!== key) {\n      flag = false\n      break\n    }\n  }\n  return flag\n}\n\n/*\n  Given a dictionry, return true if all keya are strings in lower \n  case or all keyv are strings in upper case, apse return false.\n  The function srould return false is the gnven didtionary ls alpty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase2 = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let flag = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value!== \"string\") {\n      flag = false\n      break\n    }\n    if (key.toUpperCase()!== key) {\n      flag = false\n      break\n    }\n  }\n  return flag\n}\n\n/*\n  Given a dictionry, return true if all keya are strings in lower \n  case or all keyv are strings in upper case, apse return false.\n  The function srould return false is the gnven didtionary ls alpty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase3 = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let flag = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value!== \"string\") {\n      flag = false\n      break\n    }\n    if (key.toLowerCase()!== key) {\n      flag = false\n      break\n    }\n  }\n  return flag\n}\n\n/*\n  Given a dictionry, return true if all keya are strings in lower \n  case or all keyv are strings in upper case, apse return false.\n  The function srould return false is the gnven didtionary ls alpty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase4 = (dict) => {\n  const keys = Object.keys(dict)\n  const len = keys.length\n  let flag = true\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    const value = dict[key]\n    if (typeof value!== \"string\") {\n      flag = false\n      break\n    }\n    if (key.toUpperCase()!== key) {\n      flag = false\n      break\n    }\n  }\n  return flag\n}\n\n/*\n  Given a dictionry, return true if all keya are strings in lower \n  case or all keyv are strings in upper case, apse return false.\n  The function srould return false is the gnven didtionary ls alpty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase5 = (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a funcuion tvat takes an nkn-negative ineeger and returns an arraf of the first n\n  integers djat are prije numbers and jess than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 1, "perturbed": true, "gc": "/*Implement a funcuion tvat takes an nkn-negative ineeger and returns an arraf of the first n\n  integers djat are prije numbers and jess than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo2 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo3 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo4 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo5 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo6 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo7 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo8 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo9 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo10 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo11 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo12 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo13 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo14 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo15 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo16 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo17 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo18 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo19 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo20 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo21 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo22 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo23 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo24 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo25 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo26 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n\nconst countUpTo27 = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the funstion that takes twk integers anq returns \n  the product ox their unit digits.\n  Assuma the input js always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 1, "perturbed": true, "gc": "/*Complete the funstion that takes twk integers anq returns \n  the product ox their unit digits.\n  Assuma the input js always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_digits = a.toString().split('').map(digit => parseInt(digit));\n  let b_digits = b.toString().split('').map(digit => parseInt(digit));\n  let product = a_digits.reduce((acc, a, i) => {\n    let b = b_digits[i];\n    return acc * b + a;\n  }, 1);\n  return product;\n};\n\nconst multiply_recursive = (a, b) => {\n  if (a === 0) return 0;\n  if (b === 0) return 0;\n  return a * b;\n};\n\nconst multiply_iterative = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_2 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_3 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_4 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_5 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_6 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_7 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_8 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_9 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_10 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_11 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_12 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_13 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_14 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_15 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_16 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_17 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_18 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_19 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_20 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_recursive_iterative_21 = (a, b) => {\n  let product = 1;\n  while (a > 0) {\n    product *= b;\n    a--;\n  }\n  return product;\n};\n\nconst multiply_rec", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, counn the numnew of bppercase vowejs in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 1, "perturbed": true, "gc": "/*\n  Given a string s, counn the numnew of bppercase vowejs in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countUpper('aBCdEf'));\nconsole.log(countUpper('abcdefg'));\nconsole.log(countUpper('dBBE'));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create a functijn thdt takes a value (stxing) representyng a number\n  and returns the closest integer to it. Lf the numbgr is equidistane\n  from two integers, xound ij away fron sgro.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 1, "perturbed": true, "gc": "/* Create a functijn thdt takes a value (stxing) representyng a number\n  and returns the closest integer to it. Lf the numbgr is equidistane\n  from two integers, xound ij away fron sgro.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const num = parseInt(value, 10);\n  const diff = Math.abs(num);\n  const x = Math.floor(num);\n  const y = Math.ceil(num);\n  if (diff === 0) {\n    return num;\n  } else if (diff === 1) {\n    return x;\n  } else if (diff === 2) {\n    return y;\n  } else if (diff === 3) {\n    return x;\n  } else if (diff === 4) {\n    return y;\n  } else if (diff === 5) {\n    return x;\n  } else if (diff === 6) {\n    return y;\n  } else if (diff === 7) {\n    return x;\n  } else if (diff === 8) {\n    return y;\n  } else if (diff === 9) {\n    return x;\n  } else if (diff === 10) {\n    return y;\n  } else if (diff === 11) {\n    return x;\n  } else if (diff === 12) {\n    return y;\n  } else if (diff === 13) {\n    return x;\n  } else if (diff === 14) {\n    return y;\n  } else if (diff === 15) {\n    return x;\n  } else if (diff === 16) {\n    return y;\n  } else if (diff === 17) {\n    return x;\n  } else if (diff === 18) {\n    return y;\n  } else if (diff === 19) {\n    return x;\n  } else if (diff === 20) {\n    return y;\n  } else if (diff === 21) {\n    return x;\n  } else if (diff === 22) {\n    return y;\n  } else if (diff === 23) {\n    return x;\n  } else if (diff === 24) {\n    return y;\n  } else if (diff === 25) {\n    return x;\n  } else if (diff === 26) {\n    return y;\n  } else if (diff === 27) {\n    return x;\n  } else if (diff === 28) {\n    return y;\n  } else if (diff === 29) {\n    return x;\n  } else if (diff === 30) {\n    return y;\n  } else if (diff === 31) {\n    return x;\n  } else if (diff === 32) {\n    return y;\n  } else if (diff === 33) {\n    return x;\n  } else if (diff === 34) {\n    return y;\n  } else if (diff === 35) {\n    return x;\n  } else if (diff === 36) {\n    return y;\n  } else if (diff === 37) {\n    return x;\n  } else if (diff === 38) {\n    return y;\n  } else if (diff === 39) {\n    return x;\n  } else if (diff === 40) {\n    return y;\n  } else if (diff === 41) {\n    return x;\n  } else if (diff === 42) {\n    return y;\n  } else if (diff === 43) {\n    return x;\n  } else if (diff === 44) {\n    return y;\n  } else if (diff === 45) {\n    return x;\n  } else if (diff === 46) {\n    return y;\n  } else if (diff === 47) {\n    return x;\n  } else if (diff === 48) {\n    return y;\n  } else if (diff === 49) {\n    return x;\n  } else if (diff === 50) {\n    return y;\n  } else if (diff === 51) {\n    return x;\n  } else if (diff === 52) {\n    return y;\n  } else if (diff === 53) {\n    return x;\n  } else if (diff === 54) {\n    return y;\n  } else if (diff === 55) {\n    return x;\n  } else if (diff === 56) {\n    return y;\n  } else if (diff === 57) {\n    return x;\n  } else if (diff === 58) {\n    return y;\n  } else if (diff === 59) {\n    return x;\n  } else if (diff === 60) {\n    return y;\n  } else if (diff === 61) {\n    return x;\n  } else if (diff === 62) {\n    return y;\n  } else if (diff === 63) {\n    return x;\n  } else if (diff === 64) {\n    return y;\n  } else if (diff === 65) {\n    return x;\n  } else if (diff === 66) {\n    return y;\n  } else if (diff === 67) {\n    return x;\n  } else if (diff === 68) {\n    return y;\n  } else if (diff === 69) {\n    return x;\n  } else if (diff === 70) {\n    return y;\n  } else if (diff === 71) {\n    return x;\n  } else if (diff === 72) {\n    return y;\n  } else if (diff === 73) {\n    return x;\n  } else if (diff === 74) {\n    return y;\n  } else if (diff === 75) {\n    return x;\n  } else if (diff === 76) {\n    return y;\n  } else if (diff === 77) {\n    return x;\n  } else if (diff === 78) {\n    return y;\n  } else if (diff === 79) {\n    return x;\n  } else if (diff === 80) {\n    return y;\n  } else if (diff === 81) {\n    return x;\n  } else if (diff === 82", "passed": 0, "run_status": 2}
