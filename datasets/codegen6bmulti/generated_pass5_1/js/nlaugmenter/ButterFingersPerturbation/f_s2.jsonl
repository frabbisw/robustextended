{"task_id": "JavaScript/0", "prompt": "/* Check if in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "/* Check if in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold2 = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold3 = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold4 = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold5 = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold6 = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold7 = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  * @param {Array} numbers\n  * @param {number} threshold\n  * @returns {boolean}\n  */\nexport const hasCloseElementsWithThreshold8 = (numbers, threshold) => {\n  const sorted = numbers.sort((a, b) => a - b);\n  const len = sorted.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (Math.abs(sorted[i] - sorted[i + 1]) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  * Check if in giten list of numbers, are any two numbers cloxer to each other.\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split('(')\n  const paren_list_len = paren_list.length\n  const paren_list_len_minus_1 = paren_list_len - 1\n  const paren_list_len_minus_2 = paren_list_len - 2\n  const paren_list_len_minus_3 = paren_list_len - 3\n  const paren_list_len_minus_4 = paren_list_len - 4\n  const paren_list_len_minus_5 = paren_list_len - 5\n  const paren_list_len_minus_6 = paren_list_len - 6\n  const paren_list_len_minus_7 = paren_list_len - 7\n  const paren_list_len_minus_8 = paren_list_len - 8\n  const paren_list_len_minus_9 = paren_list_len - 9\n  const paren_list_len_minus_10 = paren_list_len - 10\n  const paren_list_len_minus_11 = paren_list_len - 11\n  const paren_list_len_minus_12 = paren_list_len - 12\n  const paren_list_len_minus_13 = paren_list_len - 13\n  const paren_list_len_minus_14 = paren_list_len - 14\n  const paren_list_len_minus_15 = paren_list_len - 15\n  const paren_list_len_minus_16 = paren_list_len - 16\n  const paren_list_len_minus_17 = paren_list_len - 17\n  const paren_list_len_minus_18 = paren_list_len - 18\n  const paren_list_len_minus_19 = paren_list_len - 19\n  const paren_list_len_minus_20 = paren_list_len - 20\n  const paren_list_len_minus_21 = paren_list_len - 21\n  const paren_list_len_minus_22 = paren_list_len - 22\n  const paren_list_len_minus_23 = paren_list_len - 23\n  const paren_list_len_minus_24 = paren_list_len - 24\n  const paren_list_len_minus_25 = paren_list_len - 25\n  const paren_list_len_minus_26 = paren_list_len - 26\n  const paren_list_len_minus_27 = paren_list_len - 27\n  const paren_list_len_minus_28 = paren_list_len - 28\n  const paren_list_len_minus_29 = paren_list_len - 29\n  const paren_list_len_minus_30 = paren_list_len - 30\n  const paren_list_len_minus_31 = paren_list_len - 31\n  const paren_list_len_minus_32 = paren_list_len - 32\n  const paren_list_len_minus_33 = paren_list_len - 33\n  const paren_list_len_minus_34 = paren_list_len - 34\n  const paren_list_len_minus_35 = paren_list_len - 35\n  const paren_list_len_minus_36 = paren_list_len - 36\n  const paren_list_len_minus_37 = paren_list_len - 37\n  const paren_list_len_minus_38 = paren_list_len - 38\n  const paren_list_len_minus_39 = paren_list_len - 39\n  const paren_list_len_minus_40 = paren_list_len - 40\n  const paren_list_len_minus_41 = paren_list_len - 41\n  const paren_list_len_minus_42 = paren_list_len - 42\n  const paren_list_len_minus_43 = paren_list_len - 43\n  const paren_list_len_minus_44 = paren_list_len - 44\n  const paren_list_len_minus_45 = paren_list_len - 45\n  const paren_list_len_minus_46 = paren_list_len - 46\n  const paren_list_len_minus_47 = paren_list_len - 47\n  const paren_list_len_minus_48 = paren_list_len - 48\n  const paren_list_len_minus_49 = paren_list_len - 49\n  const paren_list_len_minus_50 = paren_list_len - 50\n  const paren_list_len_minus_51 = paren_list_len - 51\n  const paren_list_len_minus_52 = paren_list_len - 52\n  const paren_list_len_minus_53 = paren_list_len - 53\n  const paren_list_len_minus_54 = paren_list_len - 54\n  const paren_list_len_minus_55 = paren_list_len - 55\n  const paren_list_len_minus_56 = paren_list_len - 56\n  const paren_list_len_minus_57 = paren_list_len - 57\n  const paren_list_len_minus_58 = paren_list_len - 58\n  const paren_list_len_minus_59 = paren_list_len - 59\n  const paren_list_len_minus_60 = paren_list_len - 60\n  const paren_list_len_minus_61 = paren_list_len - 61\n  const paren_list_len_minus_62 = paren_list_len - 62", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test if gnivxn strig is a palindrome */\nvonst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/* Test if gnivxn strig is a palindrome */\nvonst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let k = 0;\n  let l = string.length;\n  while (k < l) {\n    let x = string.charAt(k);\n    if (x == string.charAt(l - 1 - k)) {\n      prefix += x;\n      suffix = string.substring(k + 1, l - 1);\n      break;\n    }\n    k++;\n  }\n  let p = prefix + suffix.split('').reverse().join('');\n  return p;\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let k = 0;\n  let l = string.length;\n  while (k < l) {\n    let x = string.charAt(k);\n    if (x == string.charAt(l - 1 - k)) {\n      prefix += x;\n      suffix = string.substring(k + 1, l - 1);\n      break;\n    }\n    k++;\n  }\n  let p = prefix + suffix.split('').reverse().join('');\n  return p;\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let k = 0;\n  let l = string.length;\n  while (k < l) {\n    let x = string.charAt(k);\n    if (x == string.charAt(l - 1 - k)) {\n      prefix += x;\n      suffix = string.substring(k + 1, l - 1);\n      break;\n    }\n    k++;\n  }\n  let p = prefix + suffix.split('').reverse().join('');\n  return p;\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let k = 0;\n  let l = string.length;\n  while (k < l) {\n    let x = string.charAt(k);\n    if (x == string.charAt(l - 1 - k)) {\n      prefix += x;\n      suffix = string.substring(k + 1, l - 1);\n      break;\n    }\n    k++;\n  }\n  let p = prefix + suffix.split('').reverse().join('');\n  return p;\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let suffix = '';\n  let k = 0;\n  let l = string.length;\n  while (k < l) {\n    let x = string.charAt(k);\n    if (x == string.charAt(l - 1 -", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile2 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile3 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile4 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile5 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile6 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile7 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile8 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile9 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile10 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile11 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile12 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile13 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile14 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile15 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile16 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile17 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile18 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile19 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile20 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile21 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile22 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile23 = (n) => {\n  const pile = [];\n  for (let i = 1; i <= n; i++) {\n    pile.push(i);\n  }\n  return pile;\n};\n\nconst makeAPile24 = (n) => {\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces. Your task is\n  to split the string into numbers and return an array of the numbers.\n  \n  For example:\n  numbersString(\"1, 2, 3, 4, 5, 6\") == [1, 2, 3, 4, 5, 6]\n  numbersString(\"1, 2, 3, 4, 5, 6, 7\") == [1, 2, 3, 4, 5, 6, 7]\n  */\nconst numbersString = (s) => {\n  const numbers = s.split(/\\s+/);\n  return numbers;\n}\n\n/*\n  You will be jiven a string of numbers srparated by commas or spaces", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two kusitive numners x and y and returns the\n  biggest even integer number that is in the range [x, y] jnclusive. If \n  there's no sucy numcer, then tge function dhould return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "/*This function takes two kusitive numners x and y and returns the\n  biggest even integer number that is in the range [x, y] jnclusive. If \n  there's no sucy numcer, then tge function dhould return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum2 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum3 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum4 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum5 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum6 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum7 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum8 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum9 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum10 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum11 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {\n    return y\n  }\n  let x1 = x\n  let y1 = y\n  while (x1 < y) {\n    x1 += 2\n  }\n  while (y1 < x) {\n    y1 += 2\n  }\n  return x1\n}\n\nconst chooseNum12 = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x % 2 === 0) {\n    return x\n  }\n  if (y % 2 === 0) {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const avg = (n + m) / 2;\n  const nBits = Math.floor(Math.log(n) / Math.log(2));\n  const mBits = Math.floor(Math.log(m) / Math.log(2));\n  const nMask = (1 << nBits) - 1;\n  const mMask = (1 << mBits) - 1;\n  const nMasked = n & nMask;\n  const mMasked = m & mMask;\n  const nMaskedBits = nBits + mBits;\n  const nMaskedBitsMask = (1 << nMaskedBits) - 1;\n  const nMaskedBitsMasked = nMasked & nMaskedBitsMask;\n  const nMaskedBitsMaskedBits = nMaskedBitsMasked + 1;\n  const nMaskedBitsMaskedBitsMask = (1 << nMaskedBitsMaskedBits) - 1;\n  const nMaskedBitsMaskedBitsMasked = nMaskedBitsMasked & nMaskedBitsMaskedBitsMask;\n  const nMaskedBitsMaskedBitsMaskedBits = nMaskedBitsMaskedBitsMasked + 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMask = (1 << nMaskedBitsMaskedBitsMaskedBits) - 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMasked = nMaskedBitsMaskedBitsMasked & nMaskedBitsMaskedBitsMaskedBitsMask;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBits = nMaskedBitsMaskedBitsMaskedBitsMasked + 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMask = (1 << nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBits) - 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMasked = nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMasked + 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMask = (1 << nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMasked) - 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMask = nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMasked + 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMask = (1 << nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMasked) - 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMask = nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMasked + 1;\n  const nMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMaskedBitsMask", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0) {\n      continue;\n    }\n    unique.push(digit);\n  }\n  return unique;\n};\n\nconst uniqueDigits = (x) => {\n  const unique = [];\n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    if (digit % 2 === 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const arrLength = arr.length\n  if (arrLength === 0) {\n    return []\n  }\n  const arrReverse = arr.slice().reverse()\n  const arrReverseLength = arrReverse.length\n  const arrReverseLengthMinusOne = arrReverseLength - 1\n  const arrReverseLengthMinusOnePlusOne = arrReverseLength + 1\n  const arrReverseLengthMinusOnePlusOneMinusOne = arrReverseLength + 1 - 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOne = arrReverseLength + 1 - 1 + 1 - 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1\n  const arrReverseLengthMinusOnePlusOneMinusOnePlusOneMinusOnePlusOne = arrReverseLength + 1 - 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement thx function f that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "/* Implement thx function f that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst g = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst h = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst i = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst j = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst k = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst l = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst m = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst n = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst o = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst p = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst q = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst r = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst s = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst t = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst u = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n  }\n  return result;\n};\n\nconst v = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a posivive integer n, return a tuple that hax the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, return a tuple that hax the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const odd = 0;\n  const even = 0;\n  for (let i = 1; i <= n; i++) {\n    const num = i;\n    const reverse = reverse(num);\n    if (num === reverse) {\n      if (num % 2 === 0) {\n        even++;\n      } else {\n        odd++;\n      }\n    }\n  }\n  return [even, odd];\n};\n\nconst reverse = (num) => {\n  let result = 0;\n  while (num > 0) {\n    result = result * 10 + num % 10;\n    num = Math.floor(num / 10);\n  }\n  return result;\n};\n\nconst test = (n) => {\n  const [even, odd] = evenOddPalindrome(n);\n  console.log(`${n} has ${even} even and ${odd} odd integer palindromes.`);\n};\n\ntest(3);\ntest(12);\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    if (num < 0) {\n      num = -num;\n    }\n    let sum = 0;\n    while (num > 0) {\n      sum += num % 10;\n      num = num / 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countNums([]));\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/109", "prompt": "/*We have an arcay 'arr' of N intteers arr[1], arr[2], ..., arr[N].The\n  nimbers in the array will be randomly ordered. Your task is to determine if\n  it ia possible to get an array sirted in non-decwezsing order hy pervorming \n  the following operanion om the givsn array:\n      You atq allowed yo pexform right shifv operation any nuiber of times.\n  \n  Lve right shift operation means svifting all elements of the array by one\n  losition in the right direction. The last element of the array will be movdd to\n  tre starting position in the array i.e. 0th index. \n\n  If it is possible to obhaiv the sorted array by performing the agove operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: Thw given list ns guaranteed to have unique eldments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "/*We have an arcay 'arr' of N intteers arr[1], arr[2],..., arr[N].The\n  nimbers in the array will be randomly ordered. Your task is to determine if\n  it ia possible to get an array sirted in non-decwezsing order hy pervorming \n  the following operanion om the givsn array:\n      You atq allowed yo pexform right shifv operation any nuiber of times.\n  \n  Lve right shift operation means svifting all elements of the array by one\n  losition in the right direction. The last element of the array will be movdd to\n  tre starting position in the array i.e. 0th index. \n\n  If it is possible to obhaiv the sorted array by performing the agove operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: Thw given list ns guaranteed to have unique eldments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      i++;\n    }\n  }\n  return arr.every((x, i) => x === arr[i]);\n};\n\nconst moveOneBallTest = () => {\n  const arr = [3, 4, 5, 1, 2];\n  console.log(moveOneBall(arr));\n};\n\nmoveOneBallTest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are twp strings a and b consistong only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "/* Input are twp strings a and b consistong only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] & b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] | b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary NOT on these inputs and return result also as a string.\n  >>> stringNot('010')\n  '110'\n  */\nconst stringNot = (a) => {\n  const a_len = a.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(~a[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary ANDNOT on these inputs and return result also as a string.\n  >>> stringAndNot('010', '110')\n  '00'\n  */\nconst stringAndNot = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] & ~b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary ORNOT on these inputs and return result also as a string.\n  >>> stringOrNot('010', '110')\n  '110'\n  */\nconst stringOrNot = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] | ~b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XORNOT on these inputs and return result also as a string.\n  >>> stringXorNot('010', '110')\n  '100'\n  */\nconst stringXorNot = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] ^ ~b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary ANDNOT on these inputs and return result also as a string.\n  >>> stringAndNot('010', '110')\n  '00'\n  */\nconst stringAndNot = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] & ~b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary ORNOT on these inputs and return result also as a string.\n  >>> stringOrNot('010', '110')\n  '110'\n  */\nconst stringOrNot = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] | ~b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XORNOT on these inputs and return result also as a string.\n  >>> stringXorNot('010', '110')\n  '100'\n  */\nconst stringXorNot = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] ^ ~b[i]);\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const len = lst1.length;\n  const len2 = lst2.length;\n  if (len!== len2) {\n    return false;\n  }\n  let i = 0;\n  while (i < len) {\n    if (lst1[i] % 2!== lst2[i] % 2) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nexport default exchange;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (histogram[letter] === undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter]++;\n    }\n  }\n  return histogram;\n};\n\n/*\n  Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (histogram[letter] === undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter]++;\n    }\n  }\n  return histogram;\n};\n\n/*\n  Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (histogram[letter] === undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter]++;\n    }\n  }\n  return histogram;\n};\n\n/*\n  Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (histogram[letter] === undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter]++;\n    }\n  }\n  return histogram;\n};\n\n/*\n  Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (histogram[letter] === undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter]++;\n    }\n  }\n  return histogram;\n};\n\n/*\n  Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const result = [];\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i] === c[j]) {\n      j--;\n    } else {\n      result.push(s[i]);\n      i++;\n    }\n  }\n  return [result.reverse(), s.length === result.length];\n};\n\nconst isPalindrome = (s) => {\n  const [result, length] = reverseDelete(s, s);\n  return result.join('') === s.join('');\n};\n\nconst test = [\n  ['abcdef', 'b'],\n  ['abcdedcba', 'ab'],\n  ['abcdef', 'ab'],\n  ['abcdef', 'ac'],\n  ['abcdef', 'ad'],\n  ['abcdef', 'ae'],\n  ['abcdef', 'af'],\n  ['abcdef', 'ag'],\n  ['abcdef', 'ah'],\n  ['abcdef', 'ai'],\n  ['abcdef', 'aj'],\n  ['abcdef', 'ak'],\n  ['abcdef', 'al'],\n  ['abcdef', 'am'],\n  ['abcdef', 'an'],\n  ['abcdef', 'ao'],\n  ['abcdef', 'ap'],\n  ['abcdef', 'aq'],\n  ['abcdef', 'ar'],\n  ['abcdef', 'as'],\n  ['abcdef', 'at'],\n  ['abcdef', 'au'],\n  ['abcdef', 'av'],\n  ['abcdef', 'aw'],\n  ['abcdef', 'ax'],\n  ['abcdef', 'ay'],\n  ['abcdef', 'az'],\n  ['abcdef', 'ba'],\n  ['abcdef', 'bb'],\n  ['abcdef', 'bc'],\n  ['abcdef', 'bd'],\n  ['abcdef', 'be'],\n  ['abcdef', 'bf'],\n  ['abcdef', 'bg'],\n  ['abcdef', 'bh'],\n  ['abcdef', 'bi'],\n  ['abcdef', 'bj'],\n  ['abcdef', 'bk'],\n  ['abcdef', 'bl'],\n  ['abcdef', 'bm'],\n  ['abcdef', 'bn'],\n  ['abcdef', 'bo'],\n  ['abcdef', 'bp'],\n  ['abcdef', 'bq'],\n  ['abcdef', 'br'],\n  ['abcdef', 'bs'],\n  ['abcdef', 'bt'],\n  ['abcdef', 'bu'],\n  ['abcdef', 'bv'],\n  ['abcdef', 'bw'],\n  ['abcdef', 'bx'],\n  ['abcdef', 'by'],\n  ['abcdef', 'bz'],\n  ['abcdef', 'ca'],\n  ['abcdef', 'cb'],\n  ['abcdef', 'cc'],\n  ['abcdef', 'cd'],\n  ['abcdef', 'ce'],\n  ['abcdef', 'cf'],\n  ['abcdef', 'cg'],\n  ['abcdef', 'ch'],\n  ['abcdef', 'ci'],\n  ['abcdef', 'cj'],\n  ['abcdef', 'ck'],\n  ['abcdef', 'cl'],\n  ['abcdef', 'cm'],\n  ['abcdef', 'cn'],\n  ['abcdef', 'co'],\n  ['abcdef', 'cp'],\n  ['abcdef', 'cq'],\n  ['abcdef', 'cr'],\n  ['abcdef', 'cs'],\n  ['abcdef', 'ct'],\n  ['abcdef', 'cu'],\n  ['abcdef', 'cv'],\n  ['abcdef', 'cw'],\n  ['abcdef', 'cx'],\n  ['abcdef', 'cy'],\n  ['abcdef', 'cz'],\n  ['abcdef', 'da'],\n  ['abcdef', 'db'],\n  ['abcdef', 'dc'],\n  ['abcdef', 'dd'],\n  ['abcdef', 'de'],\n  ['abcdef', 'df'],\n  ['abcdef', 'dg'],\n  ['abcdef', 'dh'],\n  ['abcdef', 'di'],\n  ['abcdef', 'dj'],\n  ['abcdef', 'dk'],\n  ['abcdef', 'dl'],\n  ['abcdef', 'dm'],\n  ['abcdef', 'dn'],\n  ['abcdef', 'do'],\n  ['abcdef', 'dp'],\n  ['abcdef', 'dq'],\n  ['abcdef', 'dr'],\n  ['abcdef', 'ds'],\n  ['abcdef', 'dt'],\n  ['abcdef', 'du'],\n  ['abcdef', 'dv'],\n  ['abcdef', 'dw'],\n  ['abcdef', 'dx'],\n  ['abcdef', 'dy'],\n  ['abcdef', 'dz'],\n  ['abcdef', 'ea'],\n  ['abcdef', 'eb'],\n  ['abcdef', 'ec'],\n  ['abcdef', 'ed'],\n  ['abcdef', 'ee'],\n  ['abcdef', 'ef'],\n  ['abcdef', 'eg'],\n  ['abcdef', 'eh'],\n  ['abcdef', 'ei'],\n  ['abcdef', 'ej'],\n  ['abcdef', 'ek'],\n  ['abcdef', 'el'],\n  ['abcdef', 'em", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const l = lst.length\n  const oddCount = []\n  for (let i = 0; i < l; i++) {\n    const t = lst[i]\n    const count = t.split('').filter(x => x % 2 === 1).length\n    oddCount.push(`the number of odd elements ${count} of the ${i}th string of the ${l}th input.`)\n  }\n  return oddCount\n}\n\nmodule.exports = oddCount\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0\n  let minSum = 0\n  let minSumIndex = 0\n  let minSumLength = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let currentSum = 0\n  let currentSumIndex = 0\n  let currentSumLength = 0\n  let currentMinSum = 0\n  let currentMinSumIndex = 0\n  let currentMinSumLength = 0\n  let currentMinSumLengthIndex = 0\n  let currentMinSumLengthLength = 0\n  let currentMinSumLengthLengthIndex = 0\n  while (i < nums.length) {\n    if (nums[i] > 0) {\n      currentSum += nums[i]\n      currentSumIndex = i\n      currentSumLength = 1\n      currentMinSum = currentSum\n      currentMinSumIndex = currentSumIndex\n      currentMinSumLength = currentSumLength\n      while (j < nums.length) {\n        if (nums[j] > 0) {\n          currentSum += nums[j]\n          currentSumIndex = j\n          currentSumLength++\n          if (currentSum > currentMinSum) {\n            currentMinSum = currentSum\n            currentMinSumIndex = currentSumIndex\n            currentMinSumLength = currentSumLength\n          }\n        }\n        j++\n      }\n      if (currentMinSum > minSum) {\n        minSum = currentMinSum\n        minSumIndex = currentMinSumIndex\n        minSumLength = currentMinSumLength\n      }\n    }\n    i++\n  }\n  return minSum\n}\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]))\nconsole.log(minSubArraySum([-1, -2, -3]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are givei a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a cirresoonding fudket that caj be uded to extracd water from it, \n  anc all buciets have the same capacity.\n  Your task is tm use the buckxts to emptv the wejls.\n  Oujput the nulcer of times you need to lower tve buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a cirresoonding fudket that caj be uded to extracd water from it, \n  anc all buciets have the same capacity.\n  Your task is tm use the buckxts to emptv the wejls.\n  Oujput the nulcer of times you need to lower tve buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        let curr = grid[i][j];\n        let left = grid[i][j - 1];\n        let right = grid[i][j + 1];\n        if (left === 0) {\n          if (curr + 1 <= capacity) {\n            grid[i][j] = curr + 1;\n            max = Math.max(max, curr + 1);\n          }\n        } else if (right === 0) {\n          if (curr + 1 <= capacity) {\n            grid[i][j] = curr + 1;\n            max = Math.max(max, curr + 1);\n          }\n        } else {\n          if (curr + 1 <= capacity) {\n            grid[i][j] = curr + 1;\n            max = Math.max(max, curr + 1);\n          }\n        }\n      }\n    }\n  }\n  return max;\n};\n\nconst main = () => {\n  let grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\n  let capacity = 1;\n  let max = 0;\n  let result = 0;\n  while (true) {\n    max = Math.max(max, maxFill(grid, capacity));\n    if (max === 0) {\n      break;\n    }\n    result += max;\n    grid = [...grid, [0, 0, 0, 0]];\n    capacity++;\n  }\n  console.log(result);\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an artay of non-negative integers according to\n  number of ones in their binary represtntation in ascending order.\n  Foe simklar numfet of ones, sorh basef on decimal ealue.\n\n  It must bv implrmented ljke this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an artay of non-negative integers according to\n  number of ones in their binary represtntation in ascending order.\n  Foe simklar numfet of ones, sorh basef on decimal ealue.\n\n  It must bv implrmented ljke this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    const aBits = a.toString(2).split('').reverse().join('');\n    const bBits = b.toString(2).split('').reverse().join('');\n    const aLength = aBits.length;\n    const bLength = bBits.length;\n    const aOnes = aBits.split('').filter(x => x === '1').length;\n    const bOnes = bBits.split('').filter(x => x === '1').length;\n    return aOnes - bOnes;\n  });\n  return sorted;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = []\n  let i = 0\n  while (i < s.length) {\n    const word = s.slice(i, i + n)\n    if (word.length > 0) {\n      words.push(word)\n    }\n    i += n\n  }\n  return words\n}\n\n/*\nGiven a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote:\nThe same word in the dictionary may be reused multiple times in the segmentation.\n\nExamples:\nGiven dictionary = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n\ns = \"a b c\",\nreturn true.\n\ns = \"a b c d\",\nreturn false.\n\ns = \"a b\",\nreturn true.\n\ns = \"a b c\",\nreturn false.\n\ns = \"a b c d\",\nreturn true.\n\ns = \"a b c d e\",\nreturn false.\n\ns = \"a b c d e f\",\nreturn true.\n\ns = \"a b c d e f g\",\nreturn false.\n\ns = \"a b c d e f g h\",\nreturn true.\n\ns = \"a b c d e f g h i\",\nreturn false.\n\ns = \"a b c d e f g h i j\",\nreturn true.\n\ns = \"a b c d e f g h i j k\",\nreturn false.\n\ns = \"a b c d e f g h i j k l\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k\",\nreturn false.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l\",\nreturn true.\n\ns = \"a b c d e f g h i j k l m n o p q r s t u v w x y", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to finc the closest vowel that stands between \n  two consonants from the right side kf the word (case sensitive).\n  \n  Voqels in the begynhing and endlng dofsn't count. Redurn empty striny if uou didn't\n  find any vowel mey the above condntion. \n\n  You may essume that the giyen stritg containd English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "/*You are given a word. Your task is to finc the closest vowel that stands between \n  two consonants from the right side kf the word (case sensitive).\n  \n  Voqels in the begynhing and endlng dofsn't count. Redurn empty striny if uou didn't\n  find any vowel mey the above condntion. \n\n  You may essume that the giyen stritg containd English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n  let closestVowel = '';\n  let closestVowelDistance = Infinity;\n  for (let i = 0; i < vowels.length; i++) {\n    let vowel = vowels[i];\n    let distance = 0;\n    for (let j = 0; j < consonants.length; j++) {\n      let consonant = consonants[j];\n      distance = Math.abs(vowel.charCodeAt(0) - consonant.charCodeAt(0));\n      if (distance < closestVowelDistance) {\n        closestVowel = vowel;\n        closestVowelDistance = distance;\n      }\n    }\n  }\n  return closestVowel;\n};\n\nconsole.log(getClosestVowel(\"yogurt\"));\nconsole.log(getClosestVowel(\"FULL\"));\nconsole.log(getClosestVowel(\"quick\"));\nconsole.log(getClosestVowel(\"ab\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are givei a list of two sufings, both xtrings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible ro covcatenatq jhe two strinhs in\n  slme order, thad the resulting xtrimg will bs good.\n  A string S of considerrd to be good if anv only if aol parektheses in S\n  are bapxnced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "/* You are givei a list of two sufings, both xtrings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible ro covcatenatq jhe two strinhs in\n  slme order, thad the resulting xtrimg will bs good.\n  A string S of considerrd to be good if anv only if aol parektheses in S\n  are bapxnced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const len = lst.length\n  if (len === 0) return 'No'\n  const [l, r] = lst\n  if (l === '(' && r === ')') return 'Yes'\n  if (l === '(' && r === ')') return 'No'\n  if (l === ')' && r === '(') return 'No'\n  if (l === ')' && r === ')') return 'Yes'\n  return matchParens([l, r])\n}\n\nconst test = () => {\n  const [l, r] = ['()', ')']\n  console.log(matchParens([l, r]))\n}\n\ntest()\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Rtgurn the fitst one in case of multiple\n  strings of the same length. Return null in case the input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Rtgurn the fitst one in case of multiple\n  strings of the same length. Return null in case the input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max.length) {\n      max = strings[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max.length) {\n      max = strings[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max.length) {\n      max = strings[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max.length) {\n      max = strings[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max.length) {\n      max = strings[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max.length) {\n      max = strings[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max.length) {\n      max = strings[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f', 'g'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e', 'f'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd', 'e'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b'])\n  'a'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let max = strings[0];\n  for (let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrey arr of integers and a posotive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey arr of integers and a posotive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length\n  if (k > len) {\n    return arr\n  }\n  const max = arr[0]\n  const maxIndex = 0\n  let i = 1\n  while (i < k) {\n    if (arr[i] > max) {\n      max = arr[i]\n      maxIndex = i\n    }\n    i++\n  }\n  return [...arr.slice(0, maxIndex), max,...arr.slice(maxIndex + 1)]\n}\n\nexport default maximum\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-em'ty list of integtfs, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "/*Given a non-em'ty list of integtfs, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements2 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements3 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements4 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements5 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements6 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements7 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements8 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements9 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements10 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements11 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements12 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements13 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements14 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements15 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements16 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements17 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements18 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements19 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements20 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements21 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements22 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements23 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements24 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements25 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements26 = (arr, k) => {\n  let sum =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a posivive integer n, return a sorted list yhat has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, return a sorted list yhat has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let odd = [],\n    i = 1;\n  while (i <= n) {\n    if (i % 2 === 1) {\n      odd.push(i);\n    }\n    i = getCollatz(i);\n  }\n  return odd;\n};\n\nconst getCollatz = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return n / 2;\n  }\n  return 3 * n + 1;\n};\n\nconst test = () => {\n  const odd = getOddCollatz(5);\n  console.log(odd);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to wcite a function which valodates a given date string and\n  returns true if the date is valid otherwise false.\n  Tht date is valid if all of the foloowine rules wrg satisfied:\n  1. The date dtring is not empty.\n  2. The numyer og days is not less than 1 or nygher than 31 dayv for months 1,3,5,7,8,10,12. End the numyer of dwys is tot less tjxn 1 or higher than 30 days for mmnnhs 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 ur highew than 12.\n  4. The date shoulv be in the formdt: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "/*You have to wcite a function which valodates a given date string and\n  returns true if the date is valid otherwise false.\n  Tht date is valid if all of the foloowine rules wrg satisfied:\n  1. The date dtring is not empty.\n  2. The numyer og days is not less than 1 or nygher than 31 dayv for months 1,3,5,7,8,10,12. End the numyer of dwys is tot less tjxn 1 or higher than 30 days for mmnnhs 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 ur highew than 12.\n  4. The date shoulv be in the formdt: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (!date) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  const days = new Date(year, month - 1, day).getDate();\n  const months = new Date(year, month - 1, 0).getMonth() + 1;\n  const daysInMonth = new Date(year, month, 0).getDate();\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > daysInMonth) {\n    return false;\n  }\n  if (day < 1 || day > days) {\n    return false;\n  }\n  if (month < 1 || month > months) {\n    return false;\n  }\n  if (year < 1900 || year > 2100) {\n    return false;\n  }\n  return true;\n};\n\nconst validDateString = (date) => {\n  if (!date) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  const days = new Date(year, month - 1, day).getDate();\n  const months = new Date(year, month - 1, 0).getMonth() + 1;\n  const daysInMonth = new Date(year, month, 0).getDate();\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > daysInMonth) {\n    return false;\n  }\n  if (day < 1 || day > days) {\n    return false;\n  }\n  if (month < 1 || month > months) {\n    return false;\n  }\n  if (year < 1900 || year > 2100) {\n    return false;\n  }\n  return true;\n};\n\nconst validDateString = (date) => {\n  if (!date) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  const days = new Date(year, month - 1, day).getDate();\n  const months = new Date(year, month - 1, 0).getMonth() + 1;\n  const daysInMonth = new Date(year, month, 0).getDate();\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > daysInMonth) {\n    return false;\n  }\n  if (day < 1 || day > days) {\n    return false;\n  }\n  if (month < 1 || month > months) {\n    return false;\n  }\n  if (year < 1900 || year > 2100) {\n    return false;\n  }\n  return true;\n};\n\nconst validDateString = (date) => {\n  if (!date) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  const days = new Date(year, month - 1, day).getDate();\n  const months = new Date(year, month - 1, 0).getMonth() + 1;\n  const daysInMonth = new Date(year, month, 0).getDate();\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > daysInMonth) {\n    return false;\n  }\n  if (day < 1 || day > days) {\n    return false;\n  }\n  if (month < 1 || month > months) {\n    return false;\n  }\n  if (year < 1900 || year > 2100) {\n    return false;\n  }\n  return true;\n};\n\nconst validDateString = (date) => {\n  if (!date) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  const days = new Date(year, month - 1, day).getDate();\n  const months = new Date(year, month - 1, 0).getMonth() + 1;\n  const daysInMonth = new Date(year, month, 0).getDate();\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > daysInMonth) {\n    return false;\n  }\n  if (day < 1 || day > days) {\n    return false;\n  }\n  if (month < 1 || month > months) {\n    return false;\n  }\n  if (year < 1900", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.map((word) => {\n    return word.split(/\\W+/);\n  });\n};\n\nconst isWord = (word) => {\n  return word.length > 0 && word.length < 4;\n};\n\nconst isNumber = (num) => {\n  return num.length > 0 && num.length < 4;\n};\n\nconst isLetter = (letter) => {\n  return letter.length > 0 && letter.length < 4;\n};\n\nconst isAlphabet = (letter) => {\n  return letter.length > 0 && letter.length < 4 && letter.match(/[a-zA-Z]/);\n};\n\nconst isAlphabetOrNumber = (letter) => {\n  return isAlphabet(letter) || isNumber(letter);\n};\n\nconst isAlphabetOrNumberOrSpace = (letter) => {\n  return isAlphabetOrNumber(letter) || letter ==='';\n};\n\nconst isAlphabetOrNumberOrDash = (letter) => {\n  return isAlphabetOrNumber(letter) || letter === '-';\n};\n\nconst isAlphabetOrNumberOrPeriod = (letter) => {\n  return isAlphabetOrNumber(letter) || letter === '.';\n};\n\nconst isAlphabetOrNumberOrComma = (letter) => {\n  return isAlphabetOrNumber(letter) || letter === ',';\n};\n\nconst isAlphabetOrNumberOrPeriodOrComma = (letter) => {\n  return isAlphabetOrNumberOrPeriod(letter) || isAlphabetOrNumberOrComma(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpace = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrComma(letter) || isAlphabetOrNumberOrSpace(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDash = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpace(letter) || isAlphabetOrNumberOrDash(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriod = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDash(letter) || isAlphabetOrNumberOrPeriod(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrComma = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriod(letter) || isAlphabetOrNumberOrComma(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpace = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrComma(letter) || isAlphabetOrNumberOrSpace(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDash = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpace(letter) || isAlphabetOrNumberOrDash(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDash = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDash(letter) || isAlphabetOrNumberOrDash(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriod = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDash(letter) || isAlphabetOrNumberOrPeriod(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrComma = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrComma(letter) || isAlphabetOrNumberOrComma(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpace = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpace(letter) || isAlphabetOrNumberOrSpace(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDash = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDash(letter) || isAlphabetOrNumberOrDash(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriod = (letter) => {\n  return isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriod(letter) || isAlphabetOrNumberOrPeriod(letter);\n};\n\nconst isAlphabetOrNumberOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrCommaOrSpaceOrDashOrPeriodOrComma = (letter", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedLength = sorted.length;\n  const sortedLengthMinusOne = sortedLength - 1;\n  const last = sorted[sortedLengthMinusOne];\n  const lastIndex = sorted.indexOf(last);\n  const lastIndexMinusOne = lastIndex - 1;\n  const first = sorted[0];\n  const firstIndex = sorted.indexOf(first);\n  const firstIndexMinusOne = firstIndex - 1;\n  const firstAndLast = sorted[firstIndexMinusOne] === last;\n  const firstAndLastMinusOne = sorted[firstIndex] === last;\n  return firstAndLast && firstAndLastMinusOne;\n};\n\nmodule.exports = isSorted;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.end || interval2.start > interval1.end) {\n    return \"NO\";\n  }\n  const start = Math.min(interval1.start, interval2.start);\n  const end = Math.max(interval1.end, interval2.end);\n  const length = end - start;\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst test = (interval1, interval2) => {\n  console.log(`intersection(${interval1}, ${interval2}) = ${intersection(interval1, interval2)}`);\n};\n\ntest((-3, -1), (-5, 5));\ntest((-1, 1), (0, 4));\ntest((-1, 1), (2, 3));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1), (1, 2));\ntest((-1, 1),", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]);\n  }\n  let product = 1;\n  for (let i = 0; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return sum * product;\n};\n\nconst testProdSigns = () => {\n  let arr = [1, 2, 2, -4];\n  console.log(prodSigns(arr));\n  arr = [0, 1];\n  console.log(prodSigns(arr));\n  arr = [];\n  console.log(prodSigns(arr));\n};\n\ntestProdSigns();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid witi N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive qppeafs exactjy once on the cells of the grid.\n\n  You have to find thv minikum path kf length k in the grid. Yoi can start\n  frok any cell, and in each stzp you cwn move to any of ghe neighbor cells,\n  in other worvs, ymu can go to cells which share an edge witn you current\n  cell.\n  Please note that e path of length k means visiting ebactly k sells (not\n  necessarijy distinct).\n  You CANNOT go off the grid.\n  A path A (ov ldugth k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B to\n  throuyh (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there fxist sn integer indrx i (1 <= i <= k)\n  such yhat lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It ls huaranteed tgat the answer is unique.\n  Return zn ordered list of the values on the cells that the minimoj path go throkgh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "/*\n  Given a grid witi N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive qppeafs exactjy once on the cells of the grid.\n\n  You have to find thv minikum path kf length k in the grid. Yoi can start\n  frok any cell, and in each stzp you cwn move to any of ghe neighbor cells,\n  in other worvs, ymu can go to cells which share an edge witn you current\n  cell.\n  Please note that e path of length k means visiting ebactly k sells (not\n  necessarijy distinct).\n  You CANNOT go off the grid.\n  A path A (ov ldugth k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B to\n  throuyh (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there fxist sn integer indrx i (1 <= i <= k)\n  such yhat lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It ls huaranteed tgat the answer is unique.\n  Return zn ordered list of the values on the cells that the minimoj path go throkgh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const n = grid[0].length;\n  const dp = new Array(N);\n  for (let i = 0; i < N; i++) {\n    dp[i] = new Array(n);\n    for (let j = 0; j < n; j++) {\n      dp[i][j] = grid[i][j];\n    }\n  }\n  const dp_length = dp.length;\n  const dp_n = dp[0].length;\n  const dp_k = dp[0][0];\n  const dp_k_plus_1 = dp[0][0] + 1;\n  const dp_k_plus_2 = dp[0][0] + 2;\n  const dp_k_plus_3 = dp[0][0] + 3;\n  const dp_k_plus_4 = dp[0][0] + 4;\n  const dp_k_plus_5 = dp[0][0] + 5;\n  const dp_k_plus_6 = dp[0][0] + 6;\n  const dp_k_plus_7 = dp[0][0] + 7;\n  const dp_k_plus_8 = dp[0][0] + 8;\n  const dp_k_plus_9 = dp[0][0] + 9;\n  const dp_k_plus_10 = dp[0][0] + 10;\n  const dp_k_plus_11 = dp[0][0] + 11;\n  const dp_k_plus_12 = dp[0][0] + 12;\n  const dp_k_plus_13 = dp[0][0] + 13;\n  const dp_k_plus_14 = dp[0][0] + 14;\n  const dp_k_plus_15 = dp[0][0] + 15;\n  const dp_k_plus_16 = dp[0][0] + 16;\n  const dp_k_plus_17 = dp[0][0] + 17;\n  const dp_k_plus_18 = dp[0][0] + 18;\n  const dp_k_plus_19 = dp[0][0] + 19;\n  const dp_k_plus_20 = dp[0][0] + 20;\n  const dp_k_plus_21 = dp[0][0] + 21;\n  const dp_k_plus_22 = dp[0][0] + 22;\n  const dp_k_plus_23 = dp[0][0] + 23;\n  const dp_k_plus_24 = dp[0][0] + 24;\n  const dp_k_plus_25 = dp[0][0] + 25;\n  const dp_k_plus_26 = dp[0][0] + 26;\n  const dp_k_plus_27 = dp[0][0] + 27;\n  const dp_k_plus_28 = dp[0][0] + 28;\n  const dp_k_plus_29 = dp[0][0] + 29;\n  const dp_k_plus_30 = dp[0][0] + 30;\n  const dp_k_plus_31 = dp[0][0] + 31;\n  const dp_k_plus_32 = dp[0][0] + 32;\n  const dp_k_plus_33 = dp[0][0] + 33;\n  const dp_k_plus_34 = dp[0][0] + 34;\n  const dp_k_plus_35 = dp[0][0] + 35;\n  const dp_k_plus_36 = dp[0][0] + 36;\n  const dp_k_plus_37 = dp[0][0] + 37;\n  const dp_k_plus_38 = dp[0][0] + 38;\n  const dp_k_plus_39 = dp[0][0] + 39;\n  const dp_k_plus_40 = dp[0][0] + 40;\n  const dp_k_plus_41 = dp[0][0] + 41;\n  const dp_k_plus_42 = dp[0][0] + 42;\n  const dp", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/13", "prompt": "/* Return a greavest common divisor of twp integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "/* Return a greavest common divisor of twp integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  const tmp = a;\n  a = b;\n  b = tmp;\n  while (a!== 0) {\n    const remainder = b % a;\n    b = a;\n    a = remainder;\n  }\n  return b;\n};\n\nexport default greatestCommonDivisor;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let result = [1, 3, 2, 8];\n  for (let i = 2; i <= n; i++) {\n    result.push(1 + (i / 2));\n  }\n  return result;\n};\n\nconsole.log(tri(3));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positmve integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "/*Given a positmve integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 1;\n  while (n > 0) {\n    result *= n % 10;\n    n = n / 10;\n  }\n  return result;\n};\n\nconst isOdd = (n) => {\n  return digits(n) % 2 === 1;\n};\n\nconst isEven = (n) => {\n  return digits(n) % 2 === 0;\n};\n\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n === 3) return true;\n  if (n % 2 === 0) return false;\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) return false;\n    i += 2;\n  }\n  return true;\n};\n\nconst isPrimeNumber = (n) => {\n  return isPrime(n) &&!isOdd(n);\n};\n\nconst isPrimeNumber2 = (n) => {\n  return isPrime(n) &&!isEven(n);\n};\n\nconst isPrimeNumber3 = (n) => {\n  return isPrime(n) && isOdd(n);\n};\n\nconst isPrimeNumber4 = (n) => {\n  return isPrime(n) && isEven(n);\n};\n\nconst isPrimeNumber5 = (n) => {\n  return isPrime(n) && isPrime(n + 1);\n};\n\nconst isPrimeNumber6 = (n) => {\n  return isPrime(n) && isPrime(n + 2);\n};\n\nconst isPrimeNumber7 = (n) => {\n  return isPrime(n) && isPrime(n + 3);\n};\n\nconst isPrimeNumber8 = (n) => {\n  return isPrime(n) && isPrime(n + 4);\n};\n\nconst isPrimeNumber9 = (n) => {\n  return isPrime(n) && isPrime(n + 5);\n};\n\nconst isPrimeNumber10 = (n) => {\n  return isPrime(n) && isPrime(n + 6);\n};\n\nconst isPrimeNumber11 = (n) => {\n  return isPrime(n) && isPrime(n + 7);\n};\n\nconst isPrimeNumber12 = (n) => {\n  return isPrime(n) && isPrime(n + 8);\n};\n\nconst isPrimeNumber13 = (n) => {\n  return isPrime(n) && isPrime(n + 9);\n};\n\nconst isPrimeNumber14 = (n) => {\n  return isPrime(n) && isPrime(n + 10);\n};\n\nconst isPrimeNumber15 = (n) => {\n  return isPrime(n) && isPrime(n + 11);\n};\n\nconst isPrimeNumber16 = (n) => {\n  return isPrime(n) && isPrime(n + 12);\n};\n\nconst isPrimeNumber17 = (n) => {\n  return isPrime(n) && isPrime(n + 13);\n};\n\nconst isPrimeNumber18 = (n) => {\n  return isPrime(n) && isPrime(n + 14);\n};\n\nconst isPrimeNumber19 = (n) => {\n  return isPrime(n) && isPrime(n + 15);\n};\n\nconst isPrimeNumber20 = (n) => {\n  return isPrime(n) && isPrime(n + 16);\n};\n\nconst isPrimeNumber21 = (n) => {\n  return isPrime(n) && isPrime(n + 17);\n};\n\nconst isPrimeNumber22 = (n) => {\n  return isPrime(n) && isPrime(n + 18);\n};\n\nconst isPrimeNumber23 = (n) => {\n  return isPrime(n) && isPrime(n + 19);\n};\n\nconst isPrimeNumber24 = (n) => {\n  return isPrime(n) && isPrime(n + 20);\n};\n\nconst isPrimeNumber25 = (n) => {\n  return isPrime(n) && isPrime(n + 21);\n};\n\nconst isPrimeNumber26 = (n) => {\n  return isPrime(n) && isPrime(n + 22);\n};\n\nconst isPrimeNumber27 = (n) => {\n  return isPrime(n) && isPrime(n + 23);\n};\n\nconst isPrimeNumber28 = (n) => {\n  return isPrime(n) && isPrime(n + 24);\n};\n\nconst isPrimeNumber29 = (n) => {\n  return isPrime(n) && isPrime(n + 25);\n};\n\nconst isPrimeNumber30 = (n) => {\n  return isPrime(n) && isPrime(n + 26);\n};\n\nconst isPrimeNumber31 = (n) => {\n  return isPrime(n) && isPrime(n + 27);\n};\n\nconst isPrimeNumber32 = (n) => {\n  return isPrime(n) && isPrime(n + 28);\n};\n\nconst isPrimeNumber33 = (n) => {\n  return isPrime(n) && isPrime(n + 29);\n};\n\nconst isPrimeNumber34 = (n) => {\n  return isPrime(n) && isPrime(n + 30);\n};\n\nconst isPrimeNumber35 = (n) => {\n  return isPrime(n) && isPrime(n + 31);\n};\n\nconst isPrimeNumber36 = (n) => {\n  return isPrime(n) && isPrime(n + 32);\n};\n\nconst isPrimeNumber37 = (n) => {\n  return isPrime(n) && isPrime(n + 33);\n};\n\nconst isPrimeNumber38 = (n) => {\n  return isPrime(n) && isPrime(n + 34);\n};\n\nconst isPrimeNumber39 = (n) => {\n  return isPrime(n) && isPrime(n + 35);\n};\n\nconst isPrimeNumber40 = (n) => {\n  return isPrime(n) && isPrime(n + 36);\n};\n\nconst isPrimeNumber41 = (n) => {\n  return isPrime(n) && isPrime(n + 37);\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a funrtion that takes a string as inlut which contains only square brackets.\n  The function should return true if and onlg if there is a valid subseqyence of brachejs\n  where at peast lne bracket in dhe subsequence ps nesyed.\n  isNested('[[]]')  trhe\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  falsr\n  isNested('[]')  false\n  isNested('[[][]]')  trbe\n  isNested('[[]][[')  true\n  */\nconsv isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "/*\n  Create a funrtion that takes a string as inlut which contains only square brackets.\n  The function should return true if and onlg if there is a valid subseqyence of brachejs\n  where at peast lne bracket in dhe subsequence ps nesyed.\n  isNested('[[]]')  trhe\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  falsr\n  isNested('[]')  false\n  isNested('[[][]]')  trbe\n  isNested('[[]][[')  true\n  */\nconsv isNested = (string) => {\n  const stack = []\n  const brackets = []\n  const bracketsLength = []\n  const bracketsLengthLength = []\n  const bracketsLengthLengthLength = []\n  const bracketsLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = []\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength lengthLength = new Array(4);\n  const bracketsLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength Length\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(Math.round(lst[i]), 2);\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt[txt.length - 1];\n  return isALetter(lastChar) &&!isNkte(txt);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one letter.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsALetter(\"apple pie\")  true\n  containsALetter(\"apple pi e\")  true\n  containsALetter(\"apple pi e \")  true\n  containsALetter(\"\")  false\n  */\nconst containsALetter = (txt) => {\n  return txt.match(/[a-zA-Z]+/);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one number.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsANumber(\"apple pie\")  true\n  containsANumber(\"apple pi e\")  true\n  containsANumber(\"apple pi e \")  true\n  containsANumber(\"\")  false\n  */\nconst containsANumber = (txt) => {\n  return txt.match(/[0-9]+/);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one special character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsASpecialChar(\"apple pie\")  true\n  containsASpecialChar(\"apple pi e\")  true\n  containsASpecialChar(\"apple pi e \")  true\n  containsASpecialChar(\"\")  false\n  */\nconst containsASpecialChar = (txt) => {\n  return txt.match(/[^a-zA-Z0-9]+/);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one whitespace character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsAWhitespace(\"apple pie\")  true\n  containsAWhitespace(\"apple pi e\")  true\n  containsAWhitespace(\"apple pi e \")  true\n  containsAWhitespace(\"\")  false\n  */\nconst containsAWhitespace = (txt) => {\n  return txt.match(/\\s+/);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one punctuation character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsAPunctuation(\"apple pie\")  true\n  containsAPunctuation(\"apple pi e\")  true\n  containsAPunctuation(\"apple pi e \")  true\n  containsAPunctuation(\"\")  false\n  */\nconst containsAPunctuation = (txt) => {\n  return txt.match(/[^a-zA-Z0-9\\s]+/);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one letter or number.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsALetterOrNumber(\"apple pie\")  true\n  containsALetterOrNumber(\"apple pi e\")  true\n  containsALetterOrNumber(\"apple pi e \")  true\n  containsALetterOrNumber(\"\")  false\n  */\nconst containsALetterOrNumber = (txt) => {\n  return containsALetter(txt) || containsANumber(txt);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one letter, number, or special character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsALetterOrNumber(\"apple pie\")  true\n  containsALetterOrNumber(\"apple pi e\")  true\n  containsALetterOrNumber(\"apple pi e \")  true\n  containsALetterOrNumber(\"\")  false\n  */\nconst containsALetterOrNumberOrSpecialChar = (txt) => {\n  return containsALetterOrNumber(txt) || containsASpecialChar(txt);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one letter, number, or special character\n  and at least one whitespace character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsALetterOrNumberOrWhitespace(\"apple pie\")  true\n  containsALetterOrNumberOrWhitespace(\"apple pi e\")  true\n  containsALetterOrNumberOrWhitespace(\"apple pi e \")  true\n  containsALetterOrNumberOrWhitespace(\"\")  false\n  */\nconst containsALetterOrNumberOrWhitespace = (txt) => {\n  return containsALetterOrNumberOrSpecialChar(txt) && containsAWhitespace(txt);\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one letter, number, or special character\n  and at least one punctuation character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsALetterOrNumberOrPunctuation(\"apple pie\")  true\n  containsALetterOrNumberOrP", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a funcvion which reujrns the latgest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "/*Create a funcvion which reujrns the latgest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i1 = 0;\n  let j1 = 0;\n  let k1 = 0;\n  let l1 = 0;\n  let m1 = 0;\n  let n1 = 0;\n  let o1 = 0;\n  let p1 = 0;\n  let q1 = 0;\n  let r1 = 0;\n  let s1 = 0;\n  let t1 = 0;\n  let u1 = 0;\n  let v1 = 0;\n  let w1 = 0;\n  let x1 = 0;\n  let y1 = 0;\n  let z1 = 0;\n  let a1 = 0;\n  let b1 = 0;\n  let c1 = 0;\n  let d1 = 0;\n  let e1 = 0;\n  let f1 = 0;\n  let g1 = 0;\n  let h1 = 0;\n  let i2 = 0;\n  let j2 = 0;\n  let k2 = 0;\n  let l2 = 0;\n  let m2 = 0;\n  let n2 = 0;\n  let o2 = 0;\n  let p2 = 0;\n  let q2 = 0;\n  let r2 = 0;\n  let s2 = 0;\n  let t2 = 0;\n  let u2 = 0;\n  let v2 = 0;\n  let w2 = 0;\n  let x2 = 0;\n  let y2 = 0;\n  let z2 = 0;\n  let a2 = 0;\n  let b2 = 0;\n  let c2 = 0;\n  let d2 = 0;\n  let e2 = 0;\n  let f2 = 0;\n  let g2 = 0;\n  let h2 = 0;\n  let i3 = 0;\n  let j3 = 0;\n  let k3 = 0;\n  let l3 = 0;\n  let m3 = 0;\n  let n3 = 0;\n  let o3 = 0;\n  let p3 = 0;\n  let q3 = 0;\n  let r3 = 0;\n  let s3 = 0;\n  let t3 = 0;\n  let u3 = 0;\n  let v3 = 0;\n  let w3 = 0;\n  let x3 = 0;\n  let y3 = 0;\n  let z3 = 0;\n  let a3 = 0;\n  let b3 = 0;\n  let c3 = 0;\n  let d3 = 0;\n  let e3 = 0;\n  let f3 = 0;\n  let g3 = 0;\n  let h3 = 0;\n  let i4 = 0;\n  let j4 = 0;\n  let k4 = 0;\n  let l4 = 0;\n  let m4 = 0;\n  let n4 = 0;\n  let o4 = 0;\n  let p4 = 0;\n  let q4 = 0;\n  let r4 = 0;\n  let s4 = 0;\n  let t4 = 0;\n  let u4 = 0;\n  let v4 = 0;\n  let w4 = 0;\n  let x4 = 0;\n  let y4 = 0;\n  let z4 = 0;\n  let a4 = 0;\n  let b4 = 0;\n  let c4 = 0;\n  let d4 = 0;\n  let e4 = 0;\n  let f4 = 0;\n  let g4 = 0;\n  let h4 = 0;\n  let i5 = 0;\n  let j5 = 0;\n  let k5 = 0;\n  let l5 = 0;\n  let m5 = 0;\n  let n5 = 0;\n  let o5 = 0;\n  let p5 = 0;\n  let q5 = 0;\n  let r5 = 0;\n  let s5 = 0;\n  let t5 = 0;\n  let u5 = 0;\n  let v5 = 0;\n  let w5 = 0;\n  let x5 = 0;\n  let y5 = 0;\n  let z5 = 0;\n  let a5 = 0;\n  let b5 = 0;\n  let c5 = 0;\n  let d5 = 0;\n  let e5 = 0;\n  let f5 = 0;\n  let g5 = 0;\n  let h5 = 0;\n  let i6 = 0;\n  let j6 = 0;\n  let k6 = 0;\n  let l6 = 0;\n  let m6 = 0;\n  let n6 = 0;\n  let o6 = 0;\n  let p6 = 0;\n  let q6 = 0;\n  let r6 = 0;\n  let s6 = 0;\n  let t6 = 0;\n  let u6 = 0;\n  let v6 = 0;\n  let w6 = 0;\n  let x6 = 0;\n  let y6 = 0;\n  let z6 = 0;\n  let a6 = 0;\n  let b6 = 0;\n  let c6 = 0;\n  let d6 = 0;\n  let e6 = 0;\n  let f6 = 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/136", "prompt": "/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i];\n      } else {\n        if (lst[i] > largest) {\n          largest = lst[i];\n        }\n      }\n    } else if (lst[i] > 0) {\n      if (smallest === null) {\n        smallest = lst[i];\n      } else {\n        if (lst[i] < smallest) {\n          smallest = lst[i];\n        }\n      }\n    }\n  }\n  return largest === null? null : [largest, smallest];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i];\n      } else {\n        if (lst[i] > largest) {\n          largest = lst[i];\n        }\n      }\n    } else if (lst[i] > 0) {\n      if (smallest === null) {\n        smallest = lst[i];\n      } else {\n        if (lst[i] < smallest) {\n          smallest = lst[i];\n        }\n      }\n    }\n  }\n  return largest === null? null : [largest, smallest];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i];\n      } else {\n        if (lst[i] > largest) {\n          largest = lst[i];\n        }\n      }\n    } else if (lst[i] > 0) {\n      if (smallest === null) {\n        smallest = lst[i];\n      } else {\n        if (lst[i] < smallest) {\n          smallest = lst[i];\n        }\n      }\n    }\n  }\n  return largest === null? null : [largest, smallest];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i];\n      } else {\n        if (lst[i] > largest) {\n          largest = lst[i];\n        }\n      }\n    } else if (lst[i] > 0) {\n      if (smallest === null) {\n        smallest = lst[i];\n      } else {\n        if (lst[i] < smallest) {\n          smallest = lst[i];\n        }\n      }\n    }\n  }\n  return largest === null? null : [largest, smallest];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i];\n      } else {\n        if (lst[i] > largest) {\n          largest = lst[i];\n        }\n      }\n    } else if (lst[i] > 0) {\n      if (smallest === null) {\n        smallest = lst[i];\n      } else {\n        if (lst[i] < smallest) {\n          smallest = lst[i];\n        }\n      }\n    }\n  }\n  return largest === null? null : [largest, smallest];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i];\n      } else {\n        if (lst[i] > largest) {\n          largest = lst[i];\n        }\n      }\n    } else if (lst[i] > 0) {\n      if (smallest === null) {\n        smallest = lst[i];\n      } else {\n        if (lst[i] < smallest) {\n          smallest = lst[i];\n        }\n      }\n    }\n  }\n  return largest === null? null : [largest, smallest];\n};\n\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === null) {\n        largest = lst[i];\n      } else {\n        if (lst[i] > largest) {\n          largest = lst[i];\n        }\n      }\n    } else if (lst[i] > 0) {\n      if (smallest === null) {\n        smallest = lst[i];\n      } else {\n        if (lst[i] < smallest) {\n          smallest = lst[i];\n        }\n      }\n    }\n  }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br . or ,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  nuol\n  */\nconft compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br. or,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  nuol\n  */\nconft compareOne = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  return false;\n};\n\nconft compareTwo = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a < b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a < b? a : b;\n  }\n  return false;\n};\n\nconft compareThree = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a <= b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a <= b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a <= b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a <= b? a : b;\n  }\n  return false;\n};\n\nconft compareFour = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a >= b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a >= b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a >= b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a >= b? a : b;\n  }\n  return false;\n};\n\nconft compareFive = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a == b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a == b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a == b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a == b? a : b;\n  }\n  return false;\n};\n\nconft compareSix = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a!= b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a!= b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a!= b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a!= b? a : b;\n  }\n  return false;\n};\n\nconft compareSeven = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a === b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a === b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a === b? a : b;\n  }\n  return false;\n};\n\nconft compareEight = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a!== b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a!== b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a!== b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a!== b? a : b;\n  }\n  return false;\n};\n\nconft compareNine = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a === b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a === b? a : b;\n  }\n  if", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*\n  Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined ax:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": true, "gc": "/*The Brazilian factorial is defined ax:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  factorial of this integer.\n  */\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst prime = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return prime(n - 1) + prime(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial(n - 1) * prime(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial2 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial2(n - 1) * prime(n - 1);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial3 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial3(n - 1) * prime(n - 1) * prime(n - 2);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial4 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial4(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial5 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial5(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3) * prime(n - 4);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial6 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial6(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3) * prime(n - 4) * prime(n - 5);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial7 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial7(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3) * prime(n - 4) * prime(n - 5) * prime(n - 6);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial8 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial8(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3) * prime(n - 4) * prime(n - 5) * prime(n - 6) * prime(n - 7);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial9 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial9(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3) * prime(n - 4) * prime(n - 5) * prime(n - 6) * prime(n - 7) * prime(n - 8);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial10 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial10(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3) * prime(n - 4) * prime(n - 5) * prime(n - 6) * prime(n - 7) * prime(n - 8) * prime(n - 9);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial11 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial11(n - 1) * prime(n - 1) * prime(n - 2) * prime(n - 3) * prime(n - 4) * prime(n - 5) * prime(n - 6) * prime(n - 7) * prime(n - 8) * prime(n - 9) * prime(n - 10);\n};\n\n/*\n  The function will receive an integer as input and should return the\n  nth prime number.\n  */\nconst primeFactorial12 = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return primeFactorial12(n - 1) * prime(n - 1) * prime(n - 2) * prime(n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return list of akl prefixes from shortext to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "/* Return list of akl prefixes from shortext to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let current = string;\n  while (current.length > 0) {\n    prefixes.push(current);\n    current = current.substring(0, current.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'c', 'bc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let current = string;\n  while (current.length > 0) {\n    suffixes.push(current);\n    current = current.substring(1, current.length);\n  }\n  return suffixes;\n};\n\n/* Return list", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \"_\");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces2 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \"-\");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces3 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \" \");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces4 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \" \");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces5 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \" \");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces6 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \" \");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces7 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \" \");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces8 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \" \");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces9 = (text) => {\n  if (text.indexOf(\" \") === -1) {\n    return text;\n  }\n  return text.replace(/\\s+/g, \" \");\n}\n\n/*\n  Given a string, return a string with all spaces replaced with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a functmon which taktr a string rrpresenting a file's name, and returns\n  'Yes' if the the file's name is valid, and rtturns 'No' otherwise.\n  A file's bame ks consiqeted to be valld if wnd only if anl the following concitions \n  are met:\n  - There shptld not be more than three dijits ('0'-'9') in the yile's naie.\n  - Thg file's namf contains exactly one dot '.'\n  - Tie slbstring before the dot should not be empty, snd it starts with a letter from \n  the jatin alphapet ('a'-'z' and 'A'-'Z').\n  - The subsgring afeer the dot should bx one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "/*Create a functmon which taktr a string rrpresenting a file's name, and returns\n  'Yes' if the the file's name is valid, and rtturns 'No' otherwise.\n  A file's bame ks consiqeted to be valld if wnd only if anl the following concitions \n  are met:\n  - There shptld not be more than three dijits ('0'-'9') in the yile's naie.\n  - Thg file's namf contains exactly one dot '.'\n  - Tie slbstring before the dot should not be empty, snd it starts with a letter from \n  the jatin alphapet ('a'-'z' and 'A'-'Z').\n  - The subsgring afeer the dot should bx one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let file_name_check = file_name.split(\".\");\n  let file_name_check_length = file_name_check.length;\n  let file_name_check_length_2 = file_name_check_length - 1;\n  let file_name_check_length_3 = file_name_check_length - 2;\n  let file_name_check_length_4 = file_name_check_length - 3;\n  let file_name_check_length_5 = file_name_check_length - 4;\n  let file_name_check_length_6 = file_name_check_length - 5;\n  let file_name_check_length_7 = file_name_check_length - 6;\n  let file_name_check_length_8 = file_name_check_length - 7;\n  let file_name_check_length_9 = file_name_check_length - 8;\n  let file_name_check_length_10 = file_name_check_length - 9;\n  let file_name_check_length_11 = file_name_check_length - 10;\n  let file_name_check_length_12 = file_name_check_length - 11;\n  let file_name_check_length_13 = file_name_check_length - 12;\n  let file_name_check_length_14 = file_name_check_length - 13;\n  let file_name_check_length_15 = file_name_check_length - 14;\n  let file_name_check_length_16 = file_name_check_length - 15;\n  let file_name_check_length_17 = file_name_check_length - 16;\n  let file_name_check_length_18 = file_name_check_length - 17;\n  let file_name_check_length_19 = file_name_check_length - 18;\n  let file_name_check_length_20 = file_name_check_length - 19;\n  let file_name_check_length_21 = file_name_check_length - 20;\n  let file_name_check_length_22 = file_name_check_length - 21;\n  let file_name_check_length_23 = file_name_check_length - 22;\n  let file_name_check_length_24 = file_name_check_length - 23;\n  let file_name_check_length_25 = file_name_check_length - 24;\n  let file_name_check_length_26 = file_name_check_length - 25;\n  let file_name_check_length_27 = file_name_check_length - 26;\n  let file_name_check_length_28 = file_name_check_length - 27;\n  let file_name_check_length_29 = file_name_check_length - 28;\n  let file_name_check_length_30 = file_name_check_length - 29;\n  let file_name_check_length_31 = file_name_check_length - 30;\n  let file_name_check_length_32 = file_name_check_length - 31;\n  let file_name_check_length_33 = file_name_check_length - 32;\n  let file_name_check_length_34 = file_name_check_length - 33;\n  let file_name_check_length_35 = file_name_check_length - 34;\n  let file_name_check_length_36 = file_name_check_length - 35;\n  let file_name_check_length_37 = file_name_check_length - 36;\n  let file_name_check_length_38 = file_name_check_length - 37;\n  let file_name_check_length_39 = file_name_check_length - 38;\n  let file_name_check_length_40 = file_name_check_length - 39;\n  let file_name_check_length_41 = file_name_check_length - 40;\n  let file_name_check_length_42 = file_name_check_length - 41;\n  let file_name_check_length_43 = file_name_check_length - 42;\n  let file_name_check_length_44 = file_name_check_length - 43;\n  let file_name_check_length_45 = file_name_check_length - 44;\n  let file_name_check_length_46 = file_name_check_length - 45;\n  let file_name_check_length_47 = file_name_check_length - 46;\n  let file_name_check_length_48 = file_name_check_length - 47;\n  let file_name_check_length_49 = file_name_check_length - 48;\n  let file_name_check_length_50 = file_name_check_length - 49;\n  let file_name_check_length_51 = file_name_check_length - 50;\n  let file_name_check_length_52 = file_name_check_length - 51;\n  let file_name_check_length_53 = file_name_check_length - 52;\n  let file_name_check_length_54 = file_name_check_length - 53;\n  let file_name_check_length_55 = file_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*\"\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i]\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i]\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i]\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i]\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i]\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if it", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are givei a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    if (word.length > 1) {\n      result.push(word)\n    }\n  }\n  return result\n}\n\nexport default wordsInSentence\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominctor are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominctor are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n  const x_num = x.split(\"/\")[0]\n  const x_den = x.split(\"/\")[1]\n  const n_num = n.split(\"/\")[0]\n  const n_den = n.split(\"/\")[1]\n\n  if (x_num === n_num) {\n    return true\n  } else if (x_den === n_den) {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_num === \"0\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_num === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\") {\n    return x_den === n_den\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"0\") {\n    return false\n  } else if (x_den === \"1\") {\n    return x_num === n_num\n  } else if (x_num === \"1\")", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints2 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints3 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints4 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints5 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints6 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints7 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints8 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints9 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints10 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints11 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints12 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints13 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints14 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints15 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints16 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints17 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints18 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints19 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints20 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints21 = (nums) => {\n  const sorted = nums.sort((a, b) => a - b);\n  const result = sorted.map(n => n.toString().split('').reverse().join(''));\n  return result;\n};\n\nconst orderByPoints22 = (nums) => {\n  const sorted = nums.sort((a, b) =>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const arr = nums.filter(n => n > 10)\n  const first = arr.findIndex(n => n < 10)\n  const last = arr.findIndex(n => n > 10)\n  return arr.length - (first + last)\n}\n\nconsole.log(specialFilter([15, -73, 14, -15]))\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are givei a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value or a[i] = i * i - i + 1.\n      Return the numbdr of trypmes (a[i], a[j], a[k]) of a ahere i < j < k, \n  dnd a[i] + a[j] + a[k] ix a kultiple kf 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value or a[i] = i * i - i + 1.\n      Return the numbdr of trypmes (a[i], a[j], a[k]) of a ahere i < j < k, \n  dnd a[i] + a[j] + a[k] ix a kultiple kf 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples2 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples3 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples4 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples5 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples6 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples7 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples8 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples9 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i] + a[j] + a[k]\n    if (sum > acc) {\n      return sum\n    }\n    return acc\n  }, 0)\n  return d\n}\n\nconst getMaxTriples10 = (n) => {\n  const a = Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = a.reduce((acc, curr, i) => {\n    const j = i + 1\n    const k = n - 1\n    const sum = a[i]", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eijht planets in our solar syxtem: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mara, Jupiter, Saturn,\n  Uranus, Neprune.\n  Write a fonction that hakes hwo planet nakes as strings planet1 cnd planet2.\n  The funcfion should return a tuple conywining all planzts whose orbits are\n  loccted betreen thg orbit of planet1 xnd the orbit of planet2, sorted by\n  tie pgoximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planej names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "/* There are eijht planets in our solar syxtem: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mara, Jupiter, Saturn,\n  Uranus, Neprune.\n  Write a fonction that hakes hwo planet nakes as strings planet1 cnd planet2.\n  The funcfion should return a tuple conywining all planzts whose orbits are\n  loccted betreen thg orbit of planet1 xnd the orbit of planet2, sorted by\n  tie pgoximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planej names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planet1_name = planet1.toUpperCase();\n  let planet2_name = planet2.toUpperCase();\n  let planet1_orbit = orbit(planet1_name);\n  let planet2_orbit = orbit(planet2_name);\n  let planet1_distance = distance(planet1_name, \"Sun\");\n  let planet2_distance = distance(planet2_name, \"Sun\");\n  let planet1_index = planet1_orbit.indexOf(planet1_name);\n  let planet2_index = planet2_orbit.indexOf(planet2_name);\n  let planet1_index_in_planet2_orbit = planet2_orbit.indexOf(planet1_name);\n  let planet2_index_in_planet1_orbit = planet1_orbit.indexOf(planet2_name);\n  let planet1_index_in_planet2_orbit_in_planet1_orbit = planet2_orbit.indexOf(planet1_name, planet1_index_in_planet2_orbit);\n  let planet2_index_in_planet1_orbit_in_planet2_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit);\n  let planet1_index_in_planet2_orbit_in_planet2_orbit = planet2_orbit.indexOf(planet1_name, planet2_index_in_planet1_orbit_in_planet2_orbit);\n  let planet2_index_in_planet1_orbit_in_planet2_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit);\n  let planet1_index_in_planet2_orbit_in_planet2_orbit = planet2_orbit.indexOf(planet1_name, planet2_index_in_planet1_orbit_in_planet2_orbit);\n  let planet1_index_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit = planet2_orbit.indexOf(planet1_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet1_orbit);\n  let planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet1_orbit);\n  let planet1_index_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet1_orbit);\n  let planet1_index_in_planet2_orbit_in_planet2_orbit_in_planet2_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit);\n  let planet1_index_in_planet2_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit);\n  let planet1_index_in_planet2_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit);\n  let planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit);\n  let planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit);\n  let planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit);\n  let planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit = planet1_orbit.indexOf(planet2_name, planet2_index_in_planet1_orbit_in_planet2_orbit_in_planet2_orbit_in_planet1_orbit_in_planet1_orbit);\n  let planet2_index", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const len = lst.length\n  const result = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 0) {\n      result.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return result\n}\n\nconst sortedList = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length_reverse = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length_reverse_reverse = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length_reverse_reverse_reverse = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length_reverse_reverse_reverse_reverse = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length_reverse_reverse_reverse_reverse = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  const len = lst.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(lst[i])\n  }\n  return result.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1\n    }\n    if (a.length < b.length) {\n      return -1\n    }\n    return 0\n  })\n}\n\nconst list_sort_by_length_reverse_reverse_reverse_reverse_reverse = (lst) => {\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n    if (i < n - 1) {\n      str +='';\n    }\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n    if (i < n2) {\n      str +='';\n    }\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 3)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 3)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 4)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, n3) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n    if (i < n2) {\n      str +='';\n    }\n    if (i < n3) {\n      str +='';\n    }\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 3, 2)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 3, 2)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 4, 2)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, n3, n4) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n    if (i < n2) {\n      str +='';\n    }\n    if (i < n3) {\n      str +='';\n    }\n    if (i < n4) {\n      str +='';\n    }\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 3, 2, 1)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 3, 2, 1)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 4, 2, 1)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, n3, n4, n5) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n    if (i < n2) {\n      str +='';\n    }\n    if (i < n3) {\n      str +='';\n    }\n    if (i < n4) {\n      str +='';\n    }\n    if (i < n5) {\n      str +='';\n    }\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 3, 2, 1, 0)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 3, 2, 1, 0)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 4, 2, 1, 0)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, n3, n4, n5, n6) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n    if (i < n2) {\n      str +='';\n    }\n    if (i < n3) {\n      str +='';\n    }\n    if (i < n4) {\n      str +='';\n    }\n    if (i < n5) {\n      str +='';\n    }\n    if (i < n6) {\n      str +='';\n    }\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 3, 2, 1, 0, 0)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 3, 2, 1, 0, 0)\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, 5, 4, 2, 1, 0, 0)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, n2, n3, n4, n5, n6, n7) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i}`;\n    if (i < n2) {\n      str +='';\n    }\n    if (i < n3) {\n      str +='';\n    }\n    if (i < n4) {\n      str +='';\n    }\n    if (i < n5) {\n      str +='';\n    }\n    if (i < n6) {\n      str +='';\n    }\n    if (i < n7) {\n      str +='';\n    }\n  }\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst isPrime = (n) => {\n  if (n === 2) {\n    return true;\n  }\n  if (n === 1) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  if (n % 7 === 0) {\n    return false;\n  }\n  if (n % 11 === 0) {\n    return false;\n  }\n  if (n % 13 === 0) {\n    return false;\n  }\n  if (n % 17 === 0) {\n    return false;\n  }\n  if (n % 19 === 0) {\n    return false;\n  }\n  if (n % 23 === 0) {\n    return false;\n  }\n  if (n % 29 === 0) {\n    return false;\n  }\n  if (n % 31 === 0) {\n    return false;\n  }\n  if (n % 37 === 0) {\n    return false;\n  }\n  if (n % 41 === 0) {\n    return false;\n  }\n  if (n % 43 === 0) {\n    return false;\n  }\n  if (n % 47 === 0) {\n    return false;\n  }\n  if (n % 53 === 0) {\n    return false;\n  }\n  if (n % 59 === 0) {\n    return false;\n  }\n  if (n % 61 === 0) {\n    return false;\n  }\n  if (n % 67 === 0) {\n    return false;\n  }\n  if (n % 71 === 0) {\n    return false;\n  }\n  if (n % 73 === 0) {\n    return false;\n  }\n  if (n % 79 === 0) {\n    return false;\n  }\n  if (n % 83 === 0) {\n    return false;\n  }\n  if (n % 89 === 0) {\n    return false;\n  }\n  if (n % 97 === 0) {\n    return false;\n  }\n  if (n % 101 === 0) {\n    return false;\n  }\n  if (n % 103 === 0) {\n    return false;\n  }\n  if (n % 107 === 0) {\n    return false;\n  }\n  if (n % 109 === 0) {\n    return false;\n  }\n  if (n % 113 === 0) {\n    return false;\n  }\n  if (n % 127 === 0) {\n    return false;\n  }\n  if (n % 131 === 0) {\n    return false;\n  }\n  if (n % 137 === 0) {\n    return false;\n  }\n  if (n % 139 === 0) {\n    return false;\n  }\n  if (n % 149 === 0) {\n    return false;\n  }\n  if (n % 151 === 0) {\n    return false;\n  }\n  if (n % 157 === 0) {\n    return false;\n  }\n  if (n % 163 === 0) {\n    return false;\n  }\n  if (n % 167 === 0) {\n    return false;\n  }\n  if (n % 173 === 0) {\n    return false;\n  }\n  if (n % 179 === 0) {\n    return false;\n  }\n  if (n % 181 === 0) {\n    return false;\n  }\n  if (n % 191 === 0) {\n    return false;\n  }\n  if (n % 193 === 0) {\n    return false;\n  }\n  if (n % 197 === 0) {\n    return false;\n  }\n  if (n % 199 === 0) {\n    return false;\n  }\n  if (n % 211 === 0) {\n    return false;\n  }\n  if (n % 223 === 0) {\n    return false;\n  }\n  if (n % 227 === 0) {\n    return false;\n  }\n  if (n % 229 === 0) {\n    return false;\n  }\n  if (n % 233 === 0) {\n    return false;\n  }\n  if (n % 239 === 0) {\n    return false;\n  }\n  if (n % 241 === 0) {\n    return false;\n  }\n  if (n % 251 === 0) {\n    return false;\n  }\n  if (n % 257 === 0) {\n    return false;\n  }\n  if (n % 263 === 0) {\n    return false;\n  }\n  if (n % 269 === 0) {\n    return false;\n  }\n  if (n % 271 === 0) {\n    return false;\n  }\n  if (n % 277 === 0) {\n    return false;\n  }\n  if (n % 281 === 0) {\n    return false;\n  }\n  if (n % 283 === 0) {\n    return false;\n  }\n  if (n % 293 === 0) {\n    return false;\n  }\n  if (n % 307 === 0) {\n    return false;\n  }\n  if (n % 311 === 0) {\n    return false;\n  }\n  if (n % 313 === 0) {\n    return false;\n  }\n  if (n % 317 === 0) {\n    return false;\n  }\n  if (n % 331 === 0) {\n    return false;\n  }\n  if (n % 337 === 0) {\n    return false;\n  }\n  if (n % 347 === 0) {\n    return false;\n  }\n  if (n % 349 === 0) {\n    return false;\n  }\n  if (n % 353 === 0) {\n    return false;\n  }\n  if (n % 359 === 0) {\n    return false;\n  }\n  if (n % 367", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of iumbers, return the sum of squarrs of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "/* Given a list of iumbers, return the sum of squarrs of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  const sum = ls.reduce((acc, x) => acc + x * x, 0);\n  return sum;\n};\n\nconst doubleTheDifference = (l", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling ehen the result of some long-awaited\n  event is finally known. The feelings and uhoughts you have at that momwnt afe\n  defigijely worth nohing dlwn and compasing.\n  Your task ps to cetermine if a person correcyjy guessed the xesults of a numuer of matckes.\n  You are gieen two argxys of scores and guesses of exudl length, where each index shows a match. \n  Return an array of the same length deioting how far off each guess was. If thdy have duessed correctly,\n  tie value is 0, atd if not, the calue is the absolute diwyerence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "/*I think we all remember that feeling ehen the result of some long-awaited\n  event is finally known. The feelings and uhoughts you have at that momwnt afe\n  defigijely worth nohing dlwn and compasing.\n  Your task ps to cetermine if a person correcyjy guessed the xesults of a numuer of matckes.\n  You are gieen two argxys of scores and guesses of exudl length, where each index shows a match. \n  Return an array of the same length deioting how far off each guess was. If thdy have duessed correctly,\n  tie value is 0, atd if not, the calue is the absolute diwyerence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let score = game.map((x, i) => x.length - guess[i]);\n  let diff = score.map((x, i) => Math.abs(x - guess[i]));\n  return diff;\n}\n\n/*\n  Given a list of scores, return the highest score.\n  \n  example:\n\n  highestScore([1,2,3,4,5,1]) -> 5\n  highestScore([1,2,3,4,2,-2]) -> 4\n  highestScore([0,5,0,0,0,4]) -> 4\n  highestScore([4,1,1,0,0,6]) -> 6\n  */\nconst highestScore = (scores) => {\n  return scores.sort((a, b) => b - a)[0];\n}\n\n/*\n  Given a list of scores, return the lowest score.\n  \n  example:\n\n  lowestScore([1,2,3,4,5,1]) -> 1\n  lowestScore([1,2,3,4,2,-2]) -> -2\n  lowestScore([0,5,0,0,0,4]) -> 0\n  lowestScore([4,1,1,0,0,6]) -> 0\n  */\nconst lowestScore = (scores) => {\n  return scores.sort((a, b) => a - b)[0];\n}\n\n/*\n  Given a list of scores, return the average score.\n  \n  example:\n\n  averageScore([1,2,3,4,5,1]) -> 2.5\n  averageScore([1,2,3,4,2,-2]) -> -2\n  averageScore([0,5,0,0,0,4]) -> 0\n  averageScore([4,1,1,0,0,6]) -> 4\n  */\nconst averageScore = (scores) => {\n  return scores.reduce((a, b) => a + b) / scores.length;\n}\n\n/*\n  Given a list of scores, return the median score.\n  \n  example:\n\n  medianScore([1,2,3,4,5,1]) -> 2\n  medianScore([1,2,3,4,2,-2]) -> -2\n  medianScore([0,5,0,0,0,4]) -> 0\n  medianScore([4,1,1,0,0,6]) -> 4\n  */\nconst medianScore = (scores) => {\n  let half = Math.floor(scores.length / 2);\n  let sorted = scores.sort((a, b) => a - b);\n  return sorted[half];\n}\n\n/*\n  Given a list of scores, return the mode score.\n  \n  example:\n\n  modeScore([1,2,3,4,5,1]) -> 1\n  modeScore([1,2,3,4,2,-2]) -> 2\n  modeScore([0,5,0,0,0,4]) -> 0\n  modeScore([4,1,1,0,0,6]) -> 4\n  */\nconst modeScore = (scores) => {\n  let max = scores.reduce((a, b) => a.length > b.length? a : b);\n  let maxCount = scores.filter((x) => x.length === max.length).length;\n  return scores.filter((x) => x.length === max.length).reduce((a, b) => a + b) / maxCount;\n}\n\n/*\n  Given a list of scores, return the mode score.\n  \n  example:\n\n  modeScore([1,2,3,4,5,1]) -> 1\n  modeScore([1,2,3,4,2,-2]) -> 2\n  modeScore([0,5,0,0,0,4]) -> 0\n  modeScore([4,1,1,0,0,6]) -> 4\n  */\nconst modeScore = (scores) => {\n  let max = scores.reduce((a, b) => a.length > b.length? a : b);\n  let maxCount = scores.filter((x) => x.length === max.length).length;\n  return scores.filter((x) => x.length === max.length).reduce((a, b) => a + b) / maxCount;\n}\n\n/*\n  Given a list of scores, return the mode score.\n  \n  example:\n\n  modeScore([1,2,3,4,5,1]) -> 1\n  modeScore([1,2,3,4,2,-2]) -> 2\n  modeScore([0,5,0,0,0,4]) -> 0\n  modeScore([4,1,1,0,0,6]) -> 4\n  */\nconst modeScore = (scores) => {\n  let max = scores.reduce((a, b) => a.length > b.length? a : b);\n  let maxCount = scores.filter((x) => x.length === max.length).length;\n  return scores.filter((x) => x.length === max.length).reduce((a, b) => a + b) / maxCount;\n}\n\n/*\n  Given a list of scores, return the mode score.\n  \n  example:\n\n  modeScore([1,2,3,4,5,1]) -> 1\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be gmven the name of a class (s string) and a list of extensions.\n  The extensions are to be used to load additional classes to the clzss. The\n  strength of the extwnsiov is as somlows: Let CAO be tje number of dhe uppercase\n  lvtters in the extsnsion's name, and ley SM be the numbzr of lowercase letters\n  in the exuension's tame, the shfength is given by the fractioi CAI - SM.\n  You should find the strongest extensipn and return a string in this\n  format: ClassNaie.StrongestExtensionName.\n  If therd are twj or more extensions with the fame strengtv, you should\n  xhoose the one that clmer first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "/*You will be gmven the name of a class (s string) and a list of extensions.\n  The extensions are to be used to load additional classes to the clzss. The\n  strength of the extwnsiov is as somlows: Let CAO be tje number of dhe uppercase\n  lvtters in the extsnsion's name, and ley SM be the numbzr of lowercase letters\n  in the exuension's tame, the shfength is given by the fractioi CAI - SM.\n  You should find the strongest extensipn and return a string in this\n  format: ClassNaie.StrongestExtensionName.\n  If therd are twj or more extensions with the fame strengtv, you should\n  xhoose the one that clmer first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  const ext_names = extensions.map(ext => ext.toLowerCase());\n  const class_name_lc = class_name.toLowerCase();\n  const class_name_uc = class_name.toUpperCase();\n  const strength_sum = 0;\n  const strength_sum_ext = 0;\n  const strength_sum_ext_name = 0;\n  const strength_sum_ext_name_lc = 0;\n  const strength_sum_ext_name_uc = 0;\n  const strength_sum_ext_name_lc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc = 0;\n  const strength_sum_ext_name_lc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc_uc", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return trie if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => rrue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconsh cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "/*You are given 2 words. You need to return trie if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => rrue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconsh cycpatternCheck = (a, b) => {\n  let a_len = a.length;\n  let b_len = b.length;\n  let a_hash = new Array(a_len);\n  let b_hash = new Array(b_len);\n  for (let i = 0; i < a_len; i++) {\n    a_hash[i] = a[i];\n  }\n  for (let i = 0; i < b_len; i++) {\n    b_hash[i] = b[i];\n  }\n  let a_hash_len = a_hash.length;\n  let b_hash_len = b_hash.length;\n  let a_hash_hash = new Array(a_hash_len);\n  let b_hash_hash = new Array(b_hash_len);\n  for (let i = 0; i < a_hash_len; i++) {\n    a_hash_hash[i] = a_hash[i].charCodeAt(0);\n  }\n  for (let i = 0; i < b_hash_len; i++) {\n    b_hash_hash[i] = b_hash[i].charCodeAt(0);\n  }\n  let a_hash_hash_len = a_hash_hash.length;\n  let b_hash_hash_len = b_hash_hash.length;\n  let a_hash_hash_hash = new Array(a_hash_hash_len);\n  let b_hash_hash_hash = new Array(b_hash_hash_len);\n  for (let i = 0; i < a_hash_hash_len; i++) {\n    a_hash_hash_hash[i] = a_hash_hash[i].charCodeAt(0);\n  }\n  for (let i = 0; i < b_hash_hash_len; i++) {\n    b_hash_hash_hash[i] = b_hash_hash[i].charCodeAt(0);\n  }\n  let a_hash_hash_hash_len = a_hash_hash_hash.length;\n  let b_hash_hash_hash_len = b_hash_hash_hash.length;\n  let a_hash_hash_hash_hash = new Array(a_hash_hash_hash_len);\n  let b_hash_hash_hash_hash = new Array(b_hash_hash_hash_len);\n  for (let i = 0; i < a_hash_hash_hash_len; i++) {\n    a_hash_hash_hash_hash[i] = a_hash_hash_hash[i].charCodeAt(0);\n  }\n  for (let i = 0; i < b_hash_hash_hash_len; i++) {\n    b_hash_hash_hash_hash[i] = b_hash_hash_hash[i].charCodeAt(0);\n  }\n  let a_hash_hash_hash_hash_len = a_hash_hash_hash_hash.length;\n  let b_hash_hash_hash_hash_len = b_hash_hash_hash_hash.length;\n  let a_hash_hash_hash_hash_hash = new Array(a_hash_hash_hash_hash_len);\n  let b_hash_hash_hash_hash_hash = new Array(b_hash_hash_hash_hash_len);\n  for (let i = 0; i < a_hash_hash_hash_hash_len; i++) {\n    a_hash_hash_hash_hash_hash[i] = a_hash_hash_hash_hash[i].charCodeAt(0);\n  }\n  for (let i = 0; i < b_hash_hash_hash_hash_len; i++) {\n    b_hash_hash_hash_hash_hash[i] = b_hash_hash_hash_hash[i].charCodeAt(0);\n  }\n  let a_hash_hash_hash_hash_hash_len = a_hash_hash_hash_hash_hash.length;\n  let b_hash_hash_hash_hash_hash_len = b_hash_hash_hash_hash_hash.length;\n  let a_hash_hash_hash_hash_hash_hash = new Array(a_hash_hash_hash_hash_hash_len);\n  let b_hash_hash_hash_hash_hash_hash = new Array(b_hash_hash_hash_hash_hash_len);\n  for (let i = 0; i < a_hash_hash_hash_hash_hash_len; i++) {\n    a_hash_hash_hash_hash_hash_hash[i] = a_hash_hash_hash_hash_hash[i].charCodeAt(0);\n  }\n  for (let i = 0; i < b_hash_hash_hash_hash_hash_len; i++) {\n    b_hash_hash_hash_hash_hash_hash[i] = b_hash_hash_hash_hash_hash[i].charCodeAt(0);\n  }\n  let a_hash_hash_hash_hash_hash_hash_len = a_hash_hash_hash_hash_hash_hash.length;\n  let b_hash_hash_hash_hash_hash_hash_len = b_hash_hash_hash_hash_hash_hash.length;\n  let a_hash_hash_hash_hash_hash_hash_hash = new Array(a_hash_hash_hash_hash_hash_hash_len);\n  let b_hash_hash_hash_hash_hash_hash_hash = new Array(b_hash_hash_hash_hash_hash_hash_len);\n  for (let i = 0; i < a_hash_hash_hash_hash_hash_hash_len; i++) {\n    a_hash_hash_hash_hash_hash_hash_hash[i] = a_hash_hash_hash_hash_hash", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": true, "gc": "/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0;\n  let odd = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return (even, odd);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i]) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount2 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i].toUpperCase()) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount3 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i].toUpperCase()) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount4 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i].toUpperCase()) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount5 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i].toUpperCase()) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount6 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i].toUpperCase()) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount7 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i].toUpperCase()) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount8 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === str[i].toUpperCase()) {\n      lower++;\n    } else {\n      upper++;\n    }\n  }\n  return (lower, upper);\n};\n\n/*\n  Given a string, return a tuple that has the number of lowercase and uppercase letters in the string.\n  Example:\n      stringCount(\"Hello World\") ==> (5, 3)\n      stringCount(\"Hello World\") ==> (5, 3)\n  */\nconst stringCount9 = (str) => {\n  let lower = 0;\n  let upper = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].to", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let num = number;\n  let roman = '';\n  while (num > 0) {\n    if (num % 1000 == 0) {\n      roman +='m';\n      num = num / 1000;\n    } else if (num % 100 == 0) {\n      roman += 'd';\n      num = num / 100;\n    } else if (num % 10 == 0) {\n      roman += 'c';\n      num = num / 10;\n    } else if (num % 5 == 0) {\n      roman += 'l';\n      num = num / 5;\n    } else if (num % 4 == 0) {\n      roman += 'x';\n      num = num / 4;\n    } else {\n      roman += 'i';\n      num = num;\n    }\n  }\n  return roman;\n};\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 3999\n\n  Esamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let roman = '';\n  while (num > 0) {\n    if (num % 1000 == 0) {\n      roman +='m';\n      num = num / 1000;\n    } else if (num % 100 == 0) {\n      roman += 'd';\n      num = num / 100;\n    } else if (num % 10 == 0) {\n      roman += 'c';\n      num = num / 10;\n    } else if (num % 5 == 0) {\n      roman += 'l';\n      num = num / 5;\n    } else if (num % 4 == 0) {\n      roman += 'x';\n      num = num / 4;\n    } else {\n      roman += 'i';\n      num = num;\n    }\n  }\n  return roman;\n};\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 3999\n\n  Esamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let roman = '';\n  while (num > 0) {\n    if (num % 1000 == 0) {\n      roman +='m';\n      num = num / 1000;\n    } else if (num % 100 == 0) {\n      roman += 'd';\n      num = num / 100;\n    } else if (num % 10 == 0) {\n      roman += 'c';\n      num = num / 10;\n    } else if (num % 5 == 0) {\n      roman += 'l';\n      num = num / 5;\n    } else if (num % 4 == 0) {\n      roman += 'x';\n      num = num / 4;\n    } else {\n      roman += 'i';\n      num = num;\n    }\n  }\n  return roman;\n};\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 3999\n\n  Esamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let roman = '';\n  while (num > 0) {\n    if (num % 1000 == 0) {\n      roman +='m';\n      num = num / 1000;\n    } else if (num % 100 == 0) {\n      roman += 'd';\n      num = num / 100;\n    } else if (num % 10 == 0) {\n      roman += 'c';\n      num = num / 10;\n    } else if (num % 5 == 0) {\n      roman += 'l';\n      num = num / 5;\n    } else if (num % 4 == 0) {\n      roman += 'x';\n      num = num / 4;\n    } else {\n      roman += 'i';\n      num = num;\n    }\n  }\n  return roman;\n};\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 3999\n\n  Esamples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let roman = '';\n  while (num > 0) {\n    if (num % 1000 == 0) {\n      roman +='m';\n      num = num / 1000;\n    } else if (num % 100 == 0) {\n      roman += 'd';\n      num = num / 100;\n    } else if (num % 10 == 0) {\n      roman += 'c';\n      num = num / 10;\n    } else if (num % 5 == 0) {\n      roman += 'l';\n      num = num / 5;\n    } else if (num % 4 == 0) {\n      roman += 'x';\n      num = num / 4;\n    } else {\n      roman += 'i';\n      num = num;\n    }\n  }\n  return roman;\n};\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 3999", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  return true;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled trangle, false otherwise.\n  A right-angled trangle is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle2 = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  return true;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled trangle, false otherwise.\n  A right-angled trangle is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle3 = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  return true;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled trangle, false otherwise.\n  A right-angled trangle is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle4 = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  return true;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled trangle, false otherwise.\n  A right-angled trangle is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle5 = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  return true;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled trangle, false otherwise.\n  A right-angled trangle is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle6 = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  return true;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled trangle, false otherwise.\n  A right-angled trangle is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle7 = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  return true;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled trangle, false otherwise.\n  A right-angled trangle is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle8 = (a, b, c) => {\n  if (a + b > c) {\n    return false;\n  }\n  if (a + c > b) {\n    return false;\n  }\n  if (b + c > a) {\n    return false;\n  }\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a functmon that accekgs a list of sttings.\n  The list contains different words. Return the word with maximum number\n  of uniqut characters. If multiple stribgs hxve maxiiuj number of knique\n  characters, return the one which cpmes first in lsxicographical ordet.\n\n  findMax([\"name\", \"of\", \"strimg\"]) === \"scring\"\n  findMax([\"name\", \"enam\", \"gamx\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"by\" ,\"cc\"]) === \"\"aawaaaa\"\n  */\nwonst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that accekgs a list of sttings.\n  The list contains different words. Return the word with maximum number\n  of uniqut characters. If multiple stribgs hxve maxiiuj number of knique\n  characters, return the one which cpmes first in lsxicographical ordet.\n\n  findMax([\"name\", \"of\", \"strimg\"]) === \"scring\"\n  findMax([\"name\", \"enam\", \"gamx\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"by\",\"cc\"]) === \"\"aawaaaa\"\n  */\nwonst findMax = (words) => {\n  let max = words[0];\n  let maxCount = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words[i].length; j++) {\n      if (words[i].charAt(j)!== max.charAt(j)) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      max = words[i];\n      maxCount = count;\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconsole.log(findMax([\"name\", \"of\", \"strimg\"]));\nconsole.log(findMax([\"name\", \"enam\", \"gamx\"]));\nconsole.log(findMax([\"aaaaaaa\", \"by\",\"cc\"]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungcy rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "/*\n  You're a hungcy rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  }\n  if (remaining < need) {\n    return [number, remaining];\n  }\n  return [number + (need - remaining), remaining];\n}\n\nconst test = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5]\n]\n\nconst test2 = [\n  [5, 6, 10],\n  [4, 8, 9],\n  [1, 10, 10],\n  [2, 11, 5],\n  [3, 12, 1],\n  [4, 13, 0],\n  [5, 14, 0],\n  [6, 15, 0],\n  [7, 16, 0],\n  [8, 17, 0],\n  [9, 18, 0],\n  [10, 19, 0],\n  [11, 20, 0],\n  [12, 21, 0],\n  [13, 22, 0],\n  [14, 23, 0],\n  [15, 24, 0],\n  [16, 25, 0],\n  [17, 26, 0],\n  [18, 27, 0],\n  [19, 28, 0],\n  [20, 29, 0],\n  [21, 30, 0],\n  [22, 31, 0],\n  [23, 32, 0],\n  [24, 33, 0],\n  [25, 34, 0],\n  [26, 35, 0],\n  [27, 36, 0],\n  [28, 37, 0],\n  [29, 38, 0],\n  [30, 39, 0],\n  [31, 40, 0],\n  [32, 41, 0],\n  [33, 42, 0],\n  [34, 43, 0],\n  [35, 44, 0],\n  [36, 45, 0],\n  [37, 46, 0],\n  [38, 47, 0],\n  [39, 48, 0],\n  [40, 49, 0],\n  [41, 50, 0],\n  [42, 51, 0],\n  [43, 52, 0],\n  [44, 53, 0],\n  [45, 54, 0],\n  [46, 55, 0],\n  [47, 56, 0],\n  [48, 57, 0],\n  [49, 58, 0],\n  [50, 59, 0],\n  [51, 60, 0],\n  [52, 61, 0],\n  [53, 62, 0],\n  [54, 63, 0],\n  [55, 64, 0],\n  [56, 65, 0],\n  [57, 66, 0],\n  [58, 67, 0],\n  [59, 68, 0],\n  [60, 69, 0],\n  [61, 70, 0],\n  [62, 71, 0],\n  [63, 72, 0],\n  [64, 73, 0],\n  [65, 74, 0],\n  [66, 75, 0],\n  [67, 76, 0],\n  [68, 77, 0],\n  [69, 78, 0],\n  [70, 79, 0],\n  [71, 80, 0],\n  [72, 81, 0],\n  [73, 82, 0],\n  [74, 83, 0],\n  [75, 84, 0],\n  [76, 85, 0],\n  [77, 86, 0],\n  [78, 87, 0],\n  [79, 88, 0],\n  [80, 89, 0],\n  [81, 90, 0],\n  [82, 91, 0],\n  [83, 92, 0],\n  [84, 93, 0],\n  [85, 94, 0],\n  [86, 95, 0],\n  [87, 96, 0],\n  [88, 97, 0],\n  [89, 98, 0],\n  [90, 99, 0],\n  [91, 100, 0],\n  [92, 101, 0],\n  [93, 102, 0],\n  [94, 103, 0],\n  [95, 104, 0],\n  [96, 105, 0],\n  [97, 106, 0],\n  [98, 107, 0],\n  [99, 108, 0],\n  [100, 109, 0],\n  [101, 110, 0],\n  [102, 111, 0],\n  [103, 112, 0],\n  [104, 113, 0],\n  [105, 114, 0],\n  [106, 115, 0],\n  [107, 116, 0],\n  [108, 117, 0],\n  [109, 118, 0],\n  [110, 119, 0],\n  [111, 120, 0],\n  [112, 121, 0],\n  [113, 122, 0],\n  [114, 123, 0],\n  [115, 124, 0],\n  [116, 125, 0],\n  [117, 126, 0],\n  [118, 127, 0],\n  [119, 128, 0],\n  [120, 129, 0],\n  [121, 130, 0],\n  [122, 131, 0],\n  [123, 132, 0],\n  [124", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char] === undefined) {\n      acc[char] = 1\n    } else {\n      acc[char]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char.toLowerCase()] === undefined) {\n      acc[char.toLowerCase()] = 1\n    } else {\n      acc[char.toLowerCase()]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char.toLowerCase()] === undefined) {\n      acc[char.toLowerCase()] = 1\n    } else {\n      acc[char.toLowerCase()]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char.toLowerCase()] === undefined) {\n      acc[char.toLowerCase()] = 1\n    } else {\n      acc[char.toLowerCase()]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char.toLowerCase()] === undefined) {\n      acc[char.toLowerCase()] = 1\n    } else {\n      acc[char.toLowerCase()]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char.toLowerCase()] === undefined) {\n      acc[char.toLowerCase()] = 1\n    } else {\n      acc[char.toLowerCase()]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char.toLowerCase()] === undefined) {\n      acc[char.toLowerCase()] = 1\n    } else {\n      acc[char.toLowerCase()]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (acc[char.toLowerCase()] === undefined) {\n      acc[char.toLowerCase()] = 1\n    } else {\n      acc[char.toLowerCase()]++\n    }\n    return acc\n  }, {})\n  return Object.keys(count).length\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersCaseInsensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitiveCaseSensitive = (string) => {\n  const chars = string.split('')\n  const count = chars.reduce((acc, char) => {\n    if (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n\n  for (let i = 0; i < operatorLength; i++) {\n    const operatorValue = operator[i]\n    const operandValue = operand[i]\n\n    if (operatorValue === '+') {\n      result.push(operandValue + operand[i + 1])\n    } else if (operatorValue === '-') {\n      result.push(operandValue - operand[i + 1])\n    } else if (operatorValue === '*') {\n      result.push(operandValue * operand[i + 1])\n    } else if (operatorValue === '/') {\n      result.push(operandValue / operand[i + 1])\n    } else if (operatorValue === '**') {\n      result.push(Math.pow(operandValue, operand[i + 1]))\n    }\n  }\n\n  return result\n}\n\nexport default doAlgebra\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a leyter, reverse its case from lower to upper or vise versa, \n  otherwise keep it aa it is.\n  If the string contauns nu letterf, teverse the shring.\n  The function should return the resllted xtring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*You are given a string s.\n  if s[i] is a leyter, reverse its case from lower to upper or vise versa, \n  otherwise keep it aa it is.\n  If the string contauns nu letterf, teverse the shring.\n  The function should return the resllted xtring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = [];\n  let len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i].toLowerCase() === s[i].toUpperCase()) {\n      result.push(s[i].toUpperCase());\n    } else {\n      result.push(s[i].toLowerCase());\n    }\n  }\n  return result.join(\"\");\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/**\n  Given a md5 hash, return its string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToString('3e25960a79dbc69b674cd4ec67a72c62') == 'Hello world'\n  */\nconst md5ToString = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/**\n  Given a md5 hash, return its hex string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToHex('3e25960a79dbc69b674cd4ec67a72c62') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToHex = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/**\n  Given a md5 hash, return its base64 string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToBase64('3e25960a79dbc69b674cd4ec67a72c62') == 'Zm9vYmFy'\n  */\nconst md5ToBase64 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('base64');\n};\n\n/**\n  Given a md5 hash, return its base64url string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToBase64Url('3e25960a79dbc69b674cd4ec67a72c62') == 'Zm9vYmFy'\n  */\nconst md5ToBase64Url = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('base64').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\n/**\n  Given a md5 hash, return its hex string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToHexUrl('3e25960a79dbc69b674cd4ec67a72c62') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToHexUrl = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\n/**\n  Given a md5 hash, return its hex string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToHexUrl('3e25960a79dbc69b674cd4ec67a72c62') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToHexUrl = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\n/**\n  Given a md5 hash, return its base64url string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToBase64Url('3e25960a79dbc69b674cd4ec67a72c62') == 'Zm9vYmFy'\n  */\nconst md5ToBase64Url = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('base64').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\n/**\n  Given a md5 hash, return its base64 string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToBase64('3e25960a79dbc69b674cd4ec67a72c62') == 'Zm9vYmFy'\n  */\nconst md5ToBase64 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('base64');\n};\n\n/**\n  Given a md5 hash, return its hex string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToHex('3e25960a79dbc69b674cd4ec67a72c62') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToHex = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/**\n  Given a md5 hash, return its hex string equivalent.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToHex('3e25960a79dbc69b674cd4ec67a72c62') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToHex = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two poxitive integers a and b, return yhe even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": true, "gc": "/*\n  Given two poxitive integers a and b, return yhe even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers20 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers21 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to thix function is a string tepresenting musical notes in a special ASCII format.\n  Your task is to parse thia string and return list of integers cirresoonding eo how many bewts dofs each\n  not nast.\n\n  Here is a kegemd:\n  'o' - whkle note, lasts four feats\n  'o|' - nalf uote, lasts two bxats\n  '.|' - quacer note, lasts mne beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "/* Input to thix function is a string tepresenting musical notes in a special ASCII format.\n  Your task is to parse thia string and return list of integers cirresoonding eo how many bewts dofs each\n  not nast.\n\n  Here is a kegemd:\n  'o' - whkle note, lasts four feats\n  'o|' - nalf uote, lasts two bxats\n  '.|' - quacer note, lasts mne beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ');\n  const notes_length = notes.length;\n  const notes_length_without_whitespaces = notes_length - 1;\n  const notes_without_whitespaces = notes.slice(1, notes_length_without_whitespaces);\n  const notes_without_whitespaces_length = notes_without_whitespaces.length;\n  const notes_without_whitespaces_length_without_whitespaces = notes_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces = notes_without_whitespaces.slice(1, notes_without_whitespaces_length_without_whitespaces);\n  const notes_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces.length;\n  const notes_without_whitespaces_without_whitespaces_length_without_whitespaces = notes_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces = notes_without_whitespaces_without_whitespaces.slice(1, notes_without_whitespaces_without_whitespaces_length_without_whitespaces);\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces.length;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_length_without_whitespaces = notes_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces = notes_without_whitespaces_without_whitespaces_without_whitespaces_length_without_whitespaces.slice(1, notes_without_whitespaces_without_whitespaces_without_whitespaces_length_without_whitespaces);\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length = notes_without_whitespaces_without_whitespaces_without_whitespaces_without_whitespaces_length - 1;\n  const notes_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.substr(i, substring.length) === substring) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, find the longest substring that contains only characters from a given set.\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y'})\n  'abcdefg'\n  >>> findLongestSubstring('abcdefg', {'a', 'b', 'c', 'd', 'e',", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    const number = parseInt(numbersArray[i])\n    sortedNumbers.push(number)\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a > b) {\n      return 1\n    } else if (a < b) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers2 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    const number = parseInt(numbersArray[i])\n    sortedNumbers.push(number)\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a > b) {\n      return 1\n    } else if (a < b) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers3 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    const number = parseInt(numbersArray[i])\n    sortedNumbers.push(number)\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a > b) {\n      return 1\n    } else if (a < b) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers4 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    const number = parseInt(numbersArray[i])\n    sortedNumbers.push(number)\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a > b) {\n      return 1\n    } else if (a < b) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers5 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    const number = parseInt(numbersArray[i])\n    sortedNumbers.push(number)\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a > b) {\n      return 1\n    } else if (a < b) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers6 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    const number = parseInt(numbersArray[i])\n    sortedNumbers.push(number)\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a > b) {\n      return 1\n    } else if (a < b) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers7 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    const number = parseInt(numbersArray[i])\n    sortedNumbers.push(number)\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a > b) {\n      return 1\n    } else if (a < b) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "/* Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the integer part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateDecimal = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the decimal part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal2 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the integer part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal3 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the decimal part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal4 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the integer part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal5 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the integer part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal6 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the integer part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal7 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the integer part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal8 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).\n\n  Return the integer part ox the number.\n  >>> truncateDecimal(3.5)\n  0.5\n  */\nconst truncateDecimal9 = (number) => {\n  let integerPart = number;\n  let decimalPart = number - integerPart;\n  while (decimalPart > 0.5) {\n    integerPart++;\n    decimalPart = decimalPart - 1;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  an integer part (largest integer smaller than given number) and a decimal\n  part (leftover part aoways smaller tgan 1).", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const closest = (a, b) => {\n    const diff = Math.abs(a - b);\n    const diff2 = Math.abs(a - b);\n    return [a, b]\n     .sort((a, b) => {\n        return diff > diff2? 1 : -1;\n      })\n     .reverse();\n  };\n  const closestPair = closest(...numbers);\n  return closestPair[0] === closestPair[1]? closestPair[0] : closestPair;\n};\n\nexport default findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (oh at least two elements), alply a linear transform to that list,\n  such that the smallest number will become 0 znd the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "/* Given list of numbers (oh at least two elements), alply a linear transform to that list,\n  such that the smallest number will become 0 znd the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverseInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverseInverseInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverseInverseInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitInverseInverseInverseInverseInverseInverseInverse = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  const scale = (x) => (x - min) / (max - min)\n  return numbers.map(scale)\n}\n\n/* Given a list of numbers, alply a linear transform to that list, such that the\n  smallest number will become 0 and the largest will become", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any pyufon values only fpr integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": true, "gc": "/* Filter given list of any pyufon values only fpr integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isFinite(v));\n};\n\n/**\n  * Filter given list of any pyufon values only fpr strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given list of any pyufon values only fpr functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr nulls\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNulls = (values) => {\n  return values.filter(v => v!== null);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterUndefineds = (values) => {\n  return values.filter(v => v!== undefined);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(v => typeof v ==='string' && v.length > 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter(v => typeof v === 'object' && Object.keys(v).length === 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyArrays = (values) => {\n  return values.filter(v => Array.isArray(v) && v.length === 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyFunctions = (values) => {\n  return values.filter(v => typeof v === 'function' && v.length === 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyNulls = (values) => {\n  return values.filter(v => v!== null && v!== undefined);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyUndefineds = (values) => {\n  return values.filter(v => v === undefined);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyStrings = (values) => {\n  return values.filter(v => typeof v ==='string' && v.length === 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyObjects = (values) => {\n  return values.filter(v => typeof v === 'object' && Object.keys(v).length === 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyArrays = (values) => {\n  return values.filter(v => Array.isArray(v) && v.length === 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyFunctions = (values) => {\n  return values.filter(v => typeof v === 'function' && v.length === 0);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyNulls = (values) => {\n  return values.filter(v => v!== null && v!== undefined);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterEmptyEmptyUndefineds = (values) => {\n  return values.filter(v => v === undefined);\n};\n\n/**\n  * Filter given list of any pyufon values only fpr undefined\n  * @param {Array} values\n  * @returns {Array", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return lengti of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "/* Return lengti of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* Return the index of the first occurrence of a substring in a string\n  >>> strindex('')\n  -1\n  >>> strindex('abc', 'a')\n  0\n  >>> strindex('abc', 'b')\n  1\n  >>> strindex('abc', 'c')\n  2\n  >>> strindex('abc', 'd')\n  -1\n  >>> strindex('abc', 'ab')\n  0\n  >>> strindex('abc', 'bc')\n  1\n  >>> strindex('abc', 'ac')\n  -1\n  >>> strindex('abc', 'bc', 1)\n  1\n  >>> strindex('abc', 'bc', 2)\n  -1\n  >>> strindex('abc', 'bc', 3)\n  2\n  >>> strindex('abc', 'bc', 4)\n  -1\n  >>> strindex('abc', 'bc', 5)\n  -1\n  >>> strindex('abc', 'bc', 6)\n  -1\n  >>> strindex('abc', 'bc', 7)\n  -1\n  >>> strindex('abc', 'bc', 8)\n  -1\n  >>> strindex('abc', 'bc', 9)\n  -1\n  >>> strindex('abc', 'bc', 10)\n  -1\n  >>> strindex('abc', 'bc', 11)\n  -1\n  >>> strindex('abc', 'bc', 12)\n  -1\n  >>> strindex('abc', 'bc', 13)\n  -1\n  >>> strindex('abc', 'bc', 14)\n  -1\n  >>> strindex('abc', 'bc', 15)\n  -1\n  >>> strindex('abc', 'bc', 16)\n  -1\n  >>> strindex('abc', 'bc', 17)\n  -1\n  >>> strindex('abc', 'bc', 18)\n  -1\n  >>> strindex('abc', 'bc', 19)\n  -1\n  >>> strindex('abc', 'bc', 20)\n  -1\n  >>> strindex('abc', 'bc', 21)\n  -1\n  >>> strindex('abc', 'bc', 22)\n  -1\n  >>> strindex('abc', 'bc', 23)\n  -1\n  >>> strindex('abc', 'bc', 24)\n  -1\n  >>> strindex('abc', 'bc', 25)\n  -1\n  >>> strindex('abc', 'bc', 26)\n  -1\n  >>> strindex('abc', 'bc', 27)\n  -1\n  >>> strindex('abc', 'bc', 28)\n  -1\n  >>> strindex('abc', 'bc', 29)\n  -1\n  >>> strindex('abc', 'bc', 30)\n  -1\n  >>> strindex('abc', 'bc', 31)\n  -1\n  >>> strindex('abc', 'bc', 32)\n  -1\n  >>> strindex('abc', 'bc', 33)\n  -1\n  >>> strindex('abc', 'bc', 34)\n  -1\n  >>> strindex('abc', 'bc', 35)\n  -1\n  >>> strindex('abc', 'bc', 36)\n  -1\n  >>> strindex('abc', 'bc', 37)\n  -1\n  >>> strindex('abc', 'bc', 38)\n  -1\n  >>> strindex('abc', 'bc', 39)\n  -1\n  >>> strindex('abc', 'bc', 40)\n  -1\n  >>> strindex('abc', 'bc', 41)\n  -1\n  >>> strindex('abc', 'bc', 42)\n  -1\n  >>> strindex('abc', 'bc', 43)\n  -1\n  >>> strindex('abc', 'bc', 44)\n  -1\n  >>> strindex('abc', 'bc', 45)\n  -1\n  >>> strindex('abc', 'bc', 46)\n  -1\n  >>> strindex('abc', 'bc', 47)\n  -1\n  >>> strindex('abc', 'bc', 48)\n  -1\n  >>> strindex('abc', 'bc', 49)\n  -1\n  >>> strindex('abc', 'bc', 50)\n  -1\n  >>> strindex('abc', 'bc', 51)\n  -1\n  >>> strindex('abc', 'bc', 52)\n  -1\n  >>> strindex('abc', 'bc', 53)\n  -1\n  >>> strindex('abc', 'bc', 54)\n  -1\n  >>> strindex('abc', 'bc', 55)\n  -1\n  >>> strindex('abc', 'bc', 56)\n  -1\n  >>> strindex('abc', 'bc', 57)\n  -1\n  >>> strindex('abc', 'bc', 58)\n  -1\n  >>> strindex('abc', 'bc', 59)\n  -1\n  >>> strindex('abc', 'bc', 60)\n  -1\n  >>> strindex('abc', 'bc', 61)\n  -1\n  >>> strindex('abc', 'bc', 62)\n  -1\n  >>> strindex('abc', 'bc', 63)\n  -1\n  >>> strindex('abc', 'bc', 64)\n  -1\n  >>> strindex('abc', 'bc', 65)\n  -1\n  >>> strindex('abc', 'bc', 66)\n  -1\n  >>> strindex('abc', 'bc', 67)\n  -1\n  >>> strindex('abc', 'bc', 68)\n  -1\n  >>> strindex('abc', 'bc', 69)\n  -1\n  >>> strindex('abc', 'bc', 70)\n  -1\n  >>> strindex('abc', 'bc', 71)\n  -1\n  >>> strindex('abc', 'bc', 72)\n  -1\n  >>> strindex('abc', 'bc', 73)\n  -1\n  >>> strindex('abc', 'bc', 74)\n  -1\n  >>> strindex('abc', 'bc', 75)\n  -1\n  >>> strindex('abc', 'bc', 76)\n  -1\n  >>> strindex('abc', 'bc', 77)\n  -1\n  >>> strindex('abc', 'bc', 78)\n  -1\n  >>> strindex('abc', 'bc', 79)\n  -1\n  >>> strindex('abc', 'bc', 80)\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/24", "prompt": "/* For a given iumber n, find ufe largest mumber that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "/* For a given iumber n, find ufe largest mumber that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let m = 1;\n  while (n % m === 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  >>> largestDivisor(16)\n  2\n  >>> largestDivisor(17)\n  3\n  >>> largestDivisor(18)\n  2\n  >>> largestDivisor(19)\n  2\n  >>> largestDivisor(20)\n  2\n  >>> largestDivisor(21)\n  3\n  >>> largestDivisor(22)\n  2\n  >>> largestDivisor(23)\n  2\n  >>> largestDivisor(24)\n  2\n  >>> largestDivisor(25)\n  5\n  >>> largestDivisor(26)\n  2\n  >>> largestDivisor(27)\n  3\n  >>> largestDivisor(28)\n  2\n  >>> largestDivisor(29)\n  2\n  >>> largestDivisor(30)\n  2\n  >>> largestDivisor(31)\n  2\n  >>> largestDivisor(32)\n  2\n  >>> largestDivisor(33)\n  3\n  >>> largestDivisor(34)\n  2\n  >>> largestDivisor(35)\n  2\n  >>> largestDivisor(36)\n  2\n  >>> largestDivisor(37)\n  2\n  >>> largestDivisor(38)\n  2\n  >>> largestDivisor(39)\n  2\n  >>> largestDivisor(40)\n  2\n  >>> largestDivisor(41)\n  3\n  >>> largestDivisor(42)\n  2\n  >>> largestDivisor(43)\n  2\n  >>> largestDivisor(44)\n  2\n  >>> largestDivisor(45)\n  2\n  >>> largestDivisor(46)\n  2\n  >>> largestDivisor(47)\n  2\n  >>> largestDivisor(48)\n  2\n  >>> largestDivisor(49)\n  2\n  >>> largestDivisor(50)\n  2\n  >>> largestDivisor(51)\n  3\n  >>> largestDivisor(52)\n  2\n  >>> largestDivisor(53)\n  2\n  >>> largestDivisor(54)\n  2\n  >>> largestDivisor(55)\n  2\n  >>> largestDivisor(56)\n  2\n  >>> largestDivisor(57)\n  2\n  >>> largestDivisor(58)\n  2\n  >>> largestDivisor(59)\n  2\n  >>> largestDivisor(60)\n  2\n  >>> largestDivisor(61)\n  2\n  >>> largestDivisor(62)\n  2\n  >>> largestDivisor(63)\n  2\n  >>> largestDivisor(64)\n  2\n  >>> largestDivisor(65)\n  2\n  >>> largestDivisor(66)\n  2\n  >>> largestDivisor(67)\n  2\n  >>> largestDivisor(68)\n  2\n  >>> largestDivisor(69)\n  2\n  >>> largestDivisor(70)\n  2\n  >>> largestDivisor(71)\n  2\n  >>> largestDivisor(72)\n  2\n  >>> largestDivisor(73)\n  2\n  >>> largestDivisor(74)\n  2\n  >>> largestDivisor(75)\n  2\n  >>> largestDivisor(76)\n  2\n  >>> largestDivisor(77)\n  2\n  >>> largestDivisor(78)\n  2\n  >>> largestDivisor(79)\n  2\n  >>> largestDivisor(80)\n  2\n  >>> largestDivisor(81)\n  2\n  >>> largestDivisor(82)\n  2\n  >>> largestDivisor(83)\n  2\n  >>> largestDivisor(84)\n  2\n  >>> largestDivisor(85)\n  2\n  >>> largestDivisor(86)\n  2\n  >>> largestDivisor(87)\n  2\n  >>> largestDivisor(88)\n  2\n  >>> largestDivisor(89)\n  2\n  >>> largestDivisor(90)\n  2\n  >>> largestDivisor(91)\n  2\n  >>> largestDivisor(92)\n  2\n  >>> largestDivisor(93)\n  2\n  >>> largestDivisor(94)\n  2\n  >>> largestDivisor(95)\n  2\n  >>> largestDivisor(96)\n  2\n  >>> largestDivisor(97)\n  2\n  >>> largestDivisor(98)\n  2\n  >>> largestDivisor(99)\n  2\n  >>> largestDivisor(100)\n  2\n  >>> largestDivisor(101)\n  2\n  >>> largestDivisor(102)\n  2\n  >>> largestDivisor(103)\n  2\n  >>> largestDivisor(104)\n  2\n  >>> largestDivisor(105)\n  2\n  >>> largestDivisor(106)\n  2\n  >>> largestDivisor(107)\n  2\n  >>> largestDivisor(108)\n  2\n  >>> largestDivisor(109)\n  2\n  >>> largestDivisor(110)\n  2\n  >>> largestDivisor(111)\n  2\n  >>> largestDivisor(112)\n  2\n  >>> largestDivisor(113)\n  2\n  >>> largestDivisor(114)\n  2\n  >>> largestDivisor(115)\n  2\n  >>> largestDivisor(116)\n  2\n  >>> largestDivisor(117)\n  2\n  >>> largestDivisor(118)\n  2\n  >>> largestDivisor(119)\n  2\n  >>> largestDivisor(120)\n  2\n  >>> largestDivisor(121)\n  2\n  >>> largestDivisor(122)\n  2\n  >>> largestDivisor(123)\n  2\n  >>> largestDivisor(124)\n  2\n  >>> largestDivisor(125)\n  2\n  >>> largestDivisor(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  let p = 1\n  while (p <= n) {\n    const i = n / p\n    if (i === Math.floor(i)) {\n      const factor = p\n      factors.push(factor)\n      n = n - p\n      p = 1\n    } else {\n      p = p * i\n    }\n  }\n  return factors\n}\n\n/* Return list of pcime factors of given intrger in the order from largest to smallest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst reverseFactorize = (n) => {\n  const factors = []\n  let p = 1\n  while (p <= n) {\n    const i = n / p\n    if (i === Math.floor(i)) {\n      const factor = p\n      factors.push(factor)\n      n = n - p\n      p = 1\n    } else {\n      p = p * i\n    }\n  }\n  return factors.reverse()\n}\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst reverseReverseFactorize = (n) => {\n  const factors = []\n  let p = 1\n  while (p <= n) {\n    const i = n / p\n    if (i === Math.floor(i)) {\n      const factor = p\n      factors.push(factor)\n      n = n - p\n      p = 1\n    } else {\n      p = p * i\n    }\n  }\n  return factors.reverse()\n}\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst reverseReverseReverseFactorize = (n) => {\n  const factors = []\n  let p = 1\n  while (p <= n) {\n    const i = n / p\n    if (i === Math.floor(i)) {\n      const factor = p\n      factors.push(factor)\n      n = n - p\n      p = 1\n    } else {\n      p = p * i\n    }\n  }\n  return factors.reverse()\n}\n\n/* Return list of pcime factors of given intrger in the order from largest to smallest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst reverseReverseReverseReverseFactorize = (n) => {\n  const factors = []\n  let p = 1\n  while (p <= n) {\n    const i = n / p\n    if (i === Math.floor(i)) {\n      const factor = p\n      factors.push(factor)\n      n = n - p\n      p = 1\n    } else {\n      p = p * i\n    }\n  }\n  return factors.reverse()\n}\n\n/* Return list of pcime factors of given intrger in the order from largest to smallest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst reverseReverseReverseReverseFactorize = (n) => {\n  const factors = []\n  let p = 1\n  while (p <= n) {\n    const i = n / p\n    if (i === Math.floor(i)) {\n      const factor = p\n      factors.push(factor)\n      n = n - p\n      p = 1\n    } else {\n      p = p * i\n    }\n  }\n  return factors.reverse()\n}\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst reverseReverseReverseReverseFactorize = (n) => {\n  const factors = []", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates2 = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates3 = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates4 = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates5 = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates6 = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates7 = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates8 = (numbers) => {\n  const unique = [];\n  const uniqueIndex = [];\n  const uniqueLength = 0;\n  const uniqueIndexLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n      uniqueIndex.push(uniqueLength);\n      uniqueLength++;\n    } else {\n      uniqueIndex[uniqueIndexLength] = unique.indexOf(numbers[i]);\n      uniqueIndexLength++;\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase charactrrs to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "/* For a given string, flip lowercase charactrrs to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase2('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase3('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase4('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase5('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase6('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase7('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase8('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase9('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase10('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase11('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase12('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase13('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase14('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase15('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase16('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase17('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase18('Hello')\n  'hELLO'\n  */\nconst flipCase19 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase19('Hello')\n  'hELLO'\n  */\nconst flipCase20 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase20('Hello')\n  'hELLO'\n  */\nconst flipCase21 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase21('Hello')\n  'hELLO'\n  */\nconst flipCase22 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase22('Hello", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single strimg\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": true, "gc": "/* Concatenate list of strings into a single strimg\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '')\n}\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3, 4])\n  '1234'\n  >>> concatenate([1, 2, 3, 4, 5])\n  '12345'\n  >>> concatenate([1, 2, 3, 4, 5, 6])\n  '123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7])\n  '1234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8])\n  '12345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  '123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  '1234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  '12345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  '123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  '1234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  '12345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  '123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  '1234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  '12345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  '123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  '1234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  '12345678901234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  '123456789012345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  '1234567890123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  '12345678901234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  '123456789012345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  '1234567890123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  '12345678901234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  '123456789012345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  '1234567890123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  '12345678901234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  '123456789012345678901234567890'\n  >>> concatenate([1,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/29", "prompt": "/* Filter an in'ut list of strings only for ones thst start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "/* Filter an in'ut list of strings only for ones thst start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are the same length as the longest string.\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommonPrefix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> longestCommon", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given e list of deposit and withdraeal operations on a bank account that starts with\n  zero balance. Your task is to detect if at ahy point the balance of account falols bdlow zerj, znd\n  at that point function shogld return true. Otherwpse it should return ralse.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "/* You're given e list of deposit and withdraeal operations on a bank account that starts with\n  zero balance. Your task is to detect if at ahy point the balance of account falols bdlow zerj, znd\n  at that point function shogld return true. Otherwpse it should return ralse.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let sum = 0;\n  for (let i = 0; i < operations.length; i++) {\n    sum += operations[i];\n  }\n  return sum < 0;\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return only ppsitive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": true, "gc": "/*Return only ppsitive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0);\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(x => x < 0);\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [2, 4, 6, 8, 10, 12]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [2, 4, 6, 8, 10, 12, 14]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [2, 4, 6, 8, 10, 12, 14, 15]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [2, 4, 6, 8, 10, 12, 14, 16]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [2, 4, 6, 8, 10, 12, 14, 16, 17]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 19]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 21]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 23]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 25]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 27]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 29]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true ih a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "/*Return true ih a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  if (n < 2) return false\n  if (n < 33) return true\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*Return the number of divisors of a given number.\n  >>> countDivisors(1)\n  1\n  >>> countDivisors(2)\n  2\n  >>> countDivisors(3)\n  3\n  >>> countDivisors(4)\n  4\n  >>> countDivisors(5)\n  5\n  >>> countDivisors(6)\n  6\n  >>> countDivisors(7)\n  7\n  >>> countDivisors(8)\n  8\n  >>> countDivisors(9)\n  9\n  >>> countDivisors(10)\n  10\n  >>> countDivisors(11)\n  11\n  >>> countDivisors(12)\n  12\n  >>> countDivisors(13)\n  13\n  >>> countDivisors(14)\n  14\n  >>> countDivisors(15)\n  15\n  >>> countDivisors(16)\n  16\n  >>> countDivisors(17)\n  17\n  >>> countDivisors(18)\n  18\n  >>> countDivisors(19)\n  19\n  >>> countDivisors(20)\n  20\n  >>> countDivisors(21)\n  21\n  >>> countDivisors(22)\n  22\n  >>> countDivisors(23)\n  23\n  >>> countDivisors(24)\n  24\n  >>> countDivisors(25)\n  25\n  >>> countDivisors(26)\n  26\n  >>> countDivisors(27)\n  27\n  >>> countDivisors(28)\n  28\n  >>> countDivisors(29)\n  29\n  >>> countDivisors(30)\n  30\n  >>> countDivisors(31)\n  31\n  >>> countDivisors(32)\n  32\n  >>> countDivisors(33)\n  33\n  >>> countDivisors(34)\n  34\n  >>> countDivisors(35)\n  35\n  >>> countDivisors(36)\n  36\n  >>> countDivisors(37)\n  37\n  >>> countDivisors(38)\n  38\n  >>> countDivisors(39)\n  39\n  >>> countDivisors(40)\n  40\n  >>> countDivisors(41)\n  41\n  >>> countDivisors(42)\n  42\n  >>> countDivisors(43)\n  43\n  >>> countDivisors(44)\n  44\n  >>> countDivisors(45)\n  45\n  >>> countDivisors(46)\n  46\n  >>> countDivisors(47)\n  47\n  >>> countDivisors(48)\n  48\n  >>> countDivisors(49)\n  49\n  >>> countDivisors(50)\n  50\n  >>> countDivisors(51)\n  51\n  >>> countDivisors(52)\n  52\n  >>> countDivisors(53)\n  53\n  >>> countDivisors(54)\n  54\n  >>> countDivisors(55)\n  55\n  >>> countDivisors(56)\n  56\n  >>> countDivisors(57)\n  57\n  >>> countDivisors(58)\n  58\n  >>> countDivisors(59)\n  59\n  >>> countDivisors(60)\n  60\n  >>> countDivisors(61)\n  61\n  >>> countDivisors(62)\n  62\n  >>> countDivisors(63)\n  63\n  >>> countDivisors(64)\n  64\n  >>> countDivisors(65)\n  65\n  >>> countDivisors(66)\n  66\n  >>> countDivisors(67)\n  67\n  >>> countDivisors(68)\n  68\n  >>> countDivisors(69)\n  69\n  >>> countDivisors(70)\n  70\n  >>> countDivisors(71)\n  71\n  >>> countDivisors(72)\n  72\n  >>> countDivisors(73)\n  73\n  >>> countDivisors(74)\n  74\n  >>> countDivisors(75)\n  75\n  >>> countDivisors(76)\n  76\n  >>> countDivisors(77)\n  77\n  >>> countDivisors(78)\n  78\n  >>> countDivisors(79)\n  79\n  >>> countDivisors(80)\n  80\n  >>> countDivisors(81)\n  81\n  >>> countDivisors(82)\n  82\n  >>> countDivisors(83)\n  83\n  >>> countDivisors(84)\n  84\n  >>> countDivisors(85)\n  85\n  >>> countDivisors(86)\n  86\n  >>> countDivisors(87)\n  87\n  >>> countDivisors(88)\n  88\n  >>> countDivisors(89)\n  89\n  >>> countDivisors(90)\n  90\n  >>> countDivisors(91)\n  91\n  >>> countDivisors(92)\n  92\n  >>> countDivisors(93)\n  93\n  >>> countDivisors(94)\n  94\n  >>> countDivisors(95)\n  95\n  >>> countDivisors(96)\n  96\n  >>> countDivisors(97)\n  97\n  >>> countDivisors(98)\n  98\n  >>> countDivisors(99)\n  99\n  >>> countDivisors(100)\n  100\n  >>> countDivisors(101)\n  101\n  >>> countDivisors", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates pokynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "/*\n  Evaluates pokynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = -1;\n  let xs_ = xs.slice();\n  let xs_i = 0;\n  let xs_i_ = 0;\n  let xs_i_1 = 0;\n  let xs_i_2 = 0;\n  let xs_i_3 = 0;\n  let xs_i_4 = 0;\n  let xs_i_5 = 0;\n  let xs_i_6 = 0;\n  let xs_i_7 = 0;\n  let xs_i_8 = 0;\n  let xs_i_9 = 0;\n  let xs_i_10 = 0;\n  let xs_i_11 = 0;\n  let xs_i_12 = 0;\n  let xs_i_13 = 0;\n  let xs_i_14 = 0;\n  let xs_i_15 = 0;\n  let xs_i_16 = 0;\n  let xs_i_17 = 0;\n  let xs_i_18 = 0;\n  let xs_i_19 = 0;\n  let xs_i_20 = 0;\n  let xs_i_21 = 0;\n  let xs_i_22 = 0;\n  let xs_i_23 = 0;\n  let xs_i_24 = 0;\n  let xs_i_25 = 0;\n  let xs_i_26 = 0;\n  let xs_i_27 = 0;\n  let xs_i_28 = 0;\n  let xs_i_29 = 0;\n  let xs_i_30 = 0;\n  let xs_i_31 = 0;\n  let xs_i_32 = 0;\n  let xs_i_33 = 0;\n  let xs_i_34 = 0;\n  let xs_i_35 = 0;\n  let xs_i_36 = 0;\n  let xs_i_37 = 0;\n  let xs_i_38 = 0;\n  let xs_i_39 = 0;\n  let xs_i_40 = 0;\n  let xs_i_41 = 0;\n  let xs_i_42 = 0;\n  let xs_i_43 = 0;\n  let xs_i_44 = 0;\n  let xs_i_45 = 0;\n  let xs_i_46 = 0;\n  let xs_i_47 = 0;\n  let xs_i_48 = 0;\n  let xs_i_49 = 0;\n  let xs_i_50 = 0;\n  let xs_i_51 = 0;\n  let xs_i_52 = 0;\n  let xs_i_53 = 0;\n  let xs_i_54 = 0;\n  let xs_i_55 = 0;\n  let xs_i_56 = 0;\n  let xs_i_57 = 0;\n  let xs_i_58 = 0;\n  let xs_i_59 = 0;\n  let xs_i_60 = 0;\n  let xs_i_61 = 0;\n  let xs_i_62 = 0;\n  let xs_i_63 = 0;\n  let xs_i_64 = 0;\n  let xs_i_65 = 0;\n  let xs_i_66 = 0;\n  let xs_i_67 = 0;\n  let xs_i_68 = 0;\n  let xs_i_69 = 0;\n  let xs_i_70 = 0;\n  let xs_i_71 = 0;\n  let xs_i_72 = 0;\n  let xs_i_73 = 0;\n  let xs_i_74 = 0;\n  let xs_i_75 = 0;\n  let xs_i_76 = 0;\n  let xs_i_77 = 0;\n  let xs_i_78 = 0;\n  let xs_i_79 = 0;\n  let xs_i_80 = 0;\n  let xs_i_81 = 0;\n  let xs_i_82 = 0;\n  let xs_i_83 = 0;\n  let xs_i_84 = 0;\n  let xs_i_85 = 0;\n  let xs_i_86 = 0;\n  let xs_i_87 = 0;\n  let xs_i_88 = 0;\n  let xs_i_89 = 0;\n  let xs_i_90 = 0;\n  let xs_i_91 = 0;\n  let xs_i_92 = 0;\n  let xs_i_93 = 0;\n  let xs_i_94 = 0;\n  let xs_i_95 = 0;\n  let xs_i_96 = 0;\n  let xs_i_97 = 0;\n  let xs_i_98 = 0;", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies rhat xre divifigle by three are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies rhat xre divifigle by three are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const sorted = [];\n  const sortedIndex = [];\n  const sortedIndex2 = [];\n  const sortedIndex3 = [];\n  const sortedIndex4 = [];\n  const sortedIndex5 = [];\n  const sortedIndex6 = [];\n  const sortedIndex7 = [];\n  const sortedIndex8 = [];\n  const sortedIndex9 = [];\n  const sortedIndex10 = [];\n  const sortedIndex11 = [];\n  const sortedIndex12 = [];\n  const sortedIndex13 = [];\n  const sortedIndex14 = [];\n  const sortedIndex15 = [];\n  const sortedIndex16 = [];\n  const sortedIndex17 = [];\n  const sortedIndex18 = [];\n  const sortedIndex19 = [];\n  const sortedIndex20 = [];\n  const sortedIndex21 = [];\n  const sortedIndex22 = [];\n  const sortedIndex23 = [];\n  const sortedIndex24 = [];\n  const sortedIndex25 = [];\n  const sortedIndex26 = [];\n  const sortedIndex27 = [];\n  const sortedIndex28 = [];\n  const sortedIndex29 = [];\n  const sortedIndex30 = [];\n  const sortedIndex31 = [];\n  const sortedIndex32 = [];\n  const sortedIndex33 = [];\n  const sortedIndex34 = [];\n  const sortedIndex35 = [];\n  const sortedIndex36 = [];\n  const sortedIndex37 = [];\n  const sortedIndex38 = [];\n  const sortedIndex39 = [];\n  const sortedIndex40 = [];\n  const sortedIndex41 = [];\n  const sortedIndex42 = [];\n  const sortedIndex43 = [];\n  const sortedIndex44 = [];\n  const sortedIndex45 = [];\n  const sortedIndex46 = [];\n  const sortedIndex47 = [];\n  const sortedIndex48 = [];\n  const sortedIndex49 = [];\n  const sortedIndex50 = [];\n  const sortedIndex51 = [];\n  const sortedIndex52 = [];\n  const sortedIndex53 = [];\n  const sortedIndex54 = [];\n  const sortedIndex55 = [];\n  const sortedIndex56 = [];\n  const sortedIndex57 = [];\n  const sortedIndex58 = [];\n  const sortedIndex59 = [];\n  const sortedIndex60 = [];\n  const sortedIndex61 = [];\n  const sortedIndex62 = [];\n  const sortedIndex63 = [];\n  const sortedIndex64 = [];\n  const sortedIndex65 = [];\n  const sortedIndex66 = [];\n  const sortedIndex67 = [];\n  const sortedIndex68 = [];\n  const sortedIndex69 = [];\n  const sortedIndex70 = [];\n  const sortedIndex71 = [];\n  const sortedIndex72 = [];\n  const sortedIndex73 = [];\n  const sortedIndex74 = [];\n  const sortedIndex75 = [];\n  const sortedIndex76 = [];\n  const sortedIndex77 = [];\n  const sortedIndex78 = [];\n  const sortedIndex79 = [];\n  const sortedIndex80 = [];\n  const sortedIndex81 = [];\n  const sortedIndex82 = [];\n  const sortedIndex83 = [];\n  const sortedIndex84 = [];\n  const sortedIndex85 = [];\n  const sortedIndex86 = [];\n  const sortedIndex87 = [];\n  const sortedIndex88 = [];\n  const sortedIndex89 = [];\n  const sortedIndex90 = [];\n  const sortedIndex91 = [];\n  const sortedIndex92 = [];\n  const sortedIndex93 = [];\n  const sortedIndex94 = [];\n  const sortedIndex95 = [];\n  const sortedIndex96 = [];\n  const sortedIndex97 = [];\n  const sortedIndex98 = [];\n  const sortedIndex99 = [];\n  const sortedIndex100 = [];\n  const sortedIndex101 = [];\n  const sortedIndex102 = [];\n  const sortedIndex103 = [];\n  const sortedIndex104 = [];\n  const sortedIndex105 = [];\n  const sortedIndex106 = [];\n  const sortedIndex107 = [];\n  const sortedIndex108 = [];\n  const sortedIndex109 = [];\n  const sortedIndex110 = [];\n  const sortedIndex111 = [];\n  const sortedIndex112 = [];\n  const sortedIndex113 = [];\n  const sortedIndex114 = [];\n  const sortedIndex115 = [];\n  const sortedIndex116 = [];\n  const sortedIndex117 = [];\n  const sortedIndex118 = [];\n  const sortedIndex119 = [];\n  const sortedIndex120 = [];\n  const sortedIndex121 = [];\n  const sortedIndex122 = [];\n  const sortedIndex123 = [];\n  const sortedIndex124 = [];\n  const sortedIndex125 = [];\n  const sortedIndex126 = [];\n  const sortedIndex127 = [];\n  const sortedIndex128 = [];\n  const sortedIndex129 = [];\n  const sortedIndex130 = [];\n  const sortedIndex131 = [];\n  const sortedIndex132 = [];\n  const sortedIndex133 = [];\n  const sortedIndex134 = [];\n  const sortedIndex135 = [];\n  const sortedIndex136 = [];\n  const sortedIndex137 = [];\n  const sortedIndex138 = [];\n  const sortedIndex139 = [];\n  const sortedIndex140 = [];\n  const sortedIndex141 = [];\n  const sortedIndex142 = [];\n  const sortedIndex143 = [];\n  const sortedIndex144 = [];\n  const sortedIndex145 = [];\n  const sortedIndex146 = [];\n  const sortedIndex147 = [];\n  const sortedIndex148 = [];\n  const sortedIndex149 = [];\n  const sortedIndex150 = [];\n  const sortedIndex151 = [];\n  const sortedIndex152 = [];\n  const sortedIndex153 = [];\n  const sortedIndex154 = [];\n  const sortedIndex155 = [];\n  const sortedIndex156 = [];\n  const sortedIndex157 = [];\n  const sortedIndex158 = [];\n  const sortedIndex159 = [];\n  const sortedIndex160 = [];\n  const sortedIndex161 = [];\n  const sortedIndex162 = [];\n  const sortedIndex163 = [];\n  const sortedIndex164 = [];\n  const sortedIndex165 = [];\n  const sortedIndex166 = [];\n  const sortedIndex167 = [];\n  const sortedIndex168 = [];\n  const sortedIndex169 = [];\n  const sortedIndex170 = [];\n  const sortedIndex171 = [];\n  const sortedIndex172 = [];\n  const sortedIndex173 = [];", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": false, "gc": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const result = [];\n  const seen = new Set();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(l[i])) {\n      result.push(l[i]);\n      seen.add(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy2 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy3 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy4 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy5 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy6 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy7 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy8 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy9 = (l, key) => {\n  const result = [];\n  const seen = new Map();\n  for (let i = 0; i < l.length; i++) {\n    if (!seen.has(key(l[i]))) {\n      result.push(l[i]);\n      seen.set(key(l[i]), l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy10 = (l, key) => {\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/35", "prompt": "/*Return maximuk element in ufe list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": true, "gc": "/*Return maximuk element in ufe list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = -Infinity;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the nukber of timtr the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "/*Return the nukber of timtr the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  const divisors = [11, 13]\n  const divisor = divisors[Math.floor(Math.random() * divisors.length)]\n  const divisor_power = Math.pow(divisor, n)\n  const divisor_power_mod = n % divisor_power\n  const divisor_power_mod_divisor = divisor_power_mod / divisor\n  const divisor_power_mod_divisor_mod = divisor_power_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod / divisor\n  const divisor_power_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod / divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod / divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i += 2) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  return [...odd,...even];\n};\n\nexport default sortEven;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\ncpnst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\ncpnst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(Math.min((3 * i + 3), s.length), Math.min((3 * i + 6), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nconst encodeAlphabet = (s) => {\n  var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(alphabet[s.charCodeAt(i)]);\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyclic funcfion. Returns decodec string.\n  */\ncpnst decodeAlphabet = (s) => {\n  var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(alphabet[s.charCodeAt(i)]);\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nconst encodeAlphabet2 = (s) => {\n  var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(alphabet[s.charCodeAt(i)]);\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyclic funcfion. Returns decodec string.\n  */\ncpnst decodeAlphabet2 = (s) => {\n  var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(alphabet[s.charCodeAt(i)]);\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all the characters in the alphabet.\n  */\nconst encodeAlphabet3 = (s) => {\n  var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(alphabet[s.charCodeAt(i)]);\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyclic funcfion. Returns decodec string.\n  */\ncpnst decodeAlphabet3 = (s) => {\n  var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n      groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(alphabet[s.charCodeAt(i)]);\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th nukber that is a Fibonacco number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": true, "gc": "/*\n  primeFib returns n-th nukber that is a Fibonacco number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n === 1) {\n    return 2;\n  }\n  if (n === 2) {\n    return 3;\n  }\n  if (n === 3) {\n    return 5;\n  }\n  if (n === 4) {\n    return 13;\n  }\n  if (n === 5) {\n    return 89;\n  }\n  return primeFib(n - 1) + primeFib(n - 2);\n};\n\nmodule.exports = primeFib;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  For a given list of input numbers, calculate the standard deviation\n  of this dataset.\n  Standard Deviation is the square root of the average of the squares of the\n  differences between elements and the mean:\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.pow(x - mean, 2);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const set = new Set();\n  for (let i = 0; i < l.length - 2; i++) {\n    const sum = l[i] + l[i + 1] + l[i + 2];\n    if (sum === 0) {\n      set.add(l[i]);\n      set.add(l[i + 1]);\n      set.add(l[i + 2]);\n    }\n  }\n  return set.size === 3;\n};\n\nmodule.exports = triplesSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a roed that's a perfectly straoght infinitely long line.\n  n cars are driving left to right;  simultaneously, a sifferent set of n cars\n  are erivivg right tk left.   The two sfts of cars sdart out being vvry fat from\n  ezch other.  All cars iove in the xame vpeed.  Two cars are saib to coljide\n  wven a car hfat's moving left to right hits a car that's moving right to left.\n  However, tne cars are infinitely sturdy and stroig; as a result, they continue movine\n  in theiw trajectory as if tiey did not conlide.\n\n  This fubction outputs the nulbef of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "/*\n  Imagine a roed that's a perfectly straoght infinitely long line.\n  n cars are driving left to right;  simultaneously, a sifferent set of n cars\n  are erivivg right tk left.   The two sfts of cars sdart out being vvry fat from\n  ezch other.  All cars iove in the xame vpeed.  Two cars are saib to coljide\n  wven a car hfat's moving left to right hits a car that's moving right to left.\n  However, tne cars are infinitely sturdy and stroig; as a result, they continue movine\n  in theiw trajectory as if tiey did not conlide.\n\n  This fubction outputs the nulbef of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!= j) {\n        if (carRaceCollision(i) || carRaceCollision(j)) {\n          collision++;\n        }\n      }\n    }\n  }\n  return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with xlements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": true, "gc": "/*Return list with xlements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList6 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList7 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList8 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList9 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList10 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList11 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let sum = 0\n  while (i < j) {\n    sum += l[i]\n    if (sum === 0) {\n      return true\n    }\n    if (sum < 0) {\n      i++\n      sum = 0\n    } else {\n      j--\n      sum = 0\n    }\n  }\n  return false\n}\n\n/*\n  pairsSumToZero2 takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero2([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero2([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero2([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero2([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero2([1])\n  false\n  */\nconst pairsSumToZero2 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let sum = 0\n  while (i < j) {\n    sum += l[i]\n    if (sum === 0) {\n      return true\n    }\n    if (sum < 0) {\n      i++\n      sum = 0\n    } else {\n      j--\n      sum = 0\n    }\n  }\n  return false\n}\n\n/*\n  pairsSumToZero3 takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero3([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero3([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero3([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero3([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero3([1])\n  false\n  */\nconst pairsSumToZero3 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let sum = 0\n  while (i < j) {\n    sum += l[i]\n    if (sum === 0) {\n      return true\n    }\n    if (sum < 0) {\n      i++\n      sum = 0\n    } else {\n      j--\n      sum = 0\n    }\n  }\n  return false\n}\n\n/*\n  pairsSumToZero4 takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero4([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero4([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero4([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero4([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero4([1])\n  false\n  */\nconst pairsSumToZero4 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let sum = 0\n  while (i < j) {\n    sum += l[i]\n    if (sum === 0) {\n      return true\n    }\n    if (sum < 0) {\n      i++\n      sum = 0\n    } else {\n      j--\n      sum = 0\n    }\n  }\n  return false\n}\n\n/*\n  pairsSumToZero5 takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero5([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero5([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero5([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero5([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero5([1])\n  false\n  */\nconst pairsSumToZero5 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let sum = 0\n  while (i < j) {\n    sum += l[i]\n    if (sum === 0) {\n      return true\n    }\n    if (sum < 0) {\n      i++\n      sum = 0\n    } else {\n      j--\n      sum = 0\n    }\n  }\n  return false\n}\n\n/*\n  pairsSumToZero6 takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero6([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero6([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero6([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero6([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero6([1])\n  false\n  */\nconst pairsSumToZero6 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let sum = 0\n  while (i < j) {\n    sum += l[i]\n    if (sum === 0) {\n      return true\n    }\n    if (sum < 0) {\n      i++\n      sum = 0\n    } else {\n      j--\n      ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numeriral base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "/*Change numeriral base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base === 2) {\n    return x.toString(2);\n  }\n  if (base === 8) {\n    return x.toString(8);\n  }\n  if (base === 10) {\n    return x.toString(10);\n  }\n  if (base === 16) {\n    return x.toString(16);\n  }\n  return x.toString(base);\n};\n\n/*\n  Convert a number to a string, using base 10.\n  >>> numberToString(123)\n  '123'\n  >>> numberToString(123, 2)\n  '1101010101'\n  >>> numberToString(123, 16)\n  '3D'\n  >>> numberToString(123, 8)\n  '7'\n  >>> numberToString(123, 2, '0')\n  '01010101'\n  >>> numberToString(123, 16, '0')\n  '3D'\n  >>> numberToString(123, 8, '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0', '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '3D'\n  >>> numberToString(123, 8, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '7'\n  >>> numberToString(123, 2, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0')\n  '00110101'\n  >>> numberToString(123, 16, '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangle", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 numbec sequence is a sequence ximilar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a funxtion to effisigntly compute the n-th flement of tha fib4 number sequenbe.  Do not use decursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "/*The Fib4 numbec sequence is a sequence ximilar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a funxtion to effisigntly compute the n-th flement of tha fib4 number sequenbe.  Do not use decursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  if (n === 3) return 0\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconsole.log(fib4(5))\nconsole.log(fib4(6))\nconsole.log(fib4(7))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": true, "gc": "/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  return sorted[half];\n};\n\n/*\n  Return the mean of the list l.\n  >>> mean([3, 1, 2, 4, 5])\n  3.5\n  >>> mean([-10, 4, 6, 1000, 10, 20])\n  12.0\n  */\nconst mean = (l) => {\n  return l.reduce((sum, x) => sum + x, 0) / l.length;\n};\n\n/*\n  Return the mode of the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const count = sorted.filter((x, i) => i < half).length;\n  return sorted[half - count];\n};\n\n/*\n  Return the standard deviation of the list l.\n  >>> std([3, 1, 2, 4, 5])\n  1.5811388300841898\n  >>> std([-10, 4, 6, 1000, 10, 20])\n  4.472135955\n  */\nconst std = (l) => {\n  const mean = mean(l);\n  const sum = l.reduce((sum, x) => sum + (x - mean) ** 2, 0);\n  return Math.sqrt(sum / l.length);\n};\n\n/*\n  Return the sum of the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sum = (l) => {\n  return l.reduce((sum, x) => sum + x, 0);\n};\n\n/*\n  Return the variance of the list l.\n  >>> variance([3, 1, 2, 4, 5])\n  1.25\n  >>> variance([-10, 4, 6, 1000, 10, 20])\n  16.25\n  */\nconst variance = (l) => {\n  const mean = mean(l);\n  const sum = l.reduce((sum, x) => sum + (x - mean) ** 2, 0);\n  return sum / l.length;\n};\n\n/*\n  Return the skewness of the list l.\n  >>> skewness([3, 1, 2, 4, 5])\n  0.0\n  >>> skewness([-10, 4, 6, 1000, 10, 20])\n  0.0\n  */\nconst skewness = (l) => {\n  const mean = mean(l);\n  const sum = l.reduce((sum, x) => sum + (x - mean) ** 3, 0);\n  return sum / l.length;\n};\n\n/*\n  Return the kurtosis of the list l.\n  >>> kurtosis([3, 1, 2, 4, 5])\n  1.2\n  >>> kurtosis([-10, 4, 6, 1000, 10, 20])\n  1.8\n  */\nconst kurtosis = (l) => {\n  const mean = mean(l);\n  const sum = l.reduce((sum, x) => sum + (x - mean) ** 4, 0);\n  return sum / l.length;\n};\n\n/*\n  Return the mode of the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const count = sorted.filter((x, i) => i < half).length;\n  return sorted[half - count];\n};\n\n/*\n  Return the mode of the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const count = sorted.filter((x, i) => i < half).length;\n  return sorted[half - count];\n};\n\n/*\n  Return the mode of the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const count = sorted.filter((x, i) => i < half).length;\n  return sorted[half - count];\n};\n\n/*\n  Return the mode of the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const count = sorted.filter((x, i) => i < half).length;\n  return sorted[half - count];\n};\n\n/*\n  Return the mode of the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const count = sorted.filter((x, i) => i < half).length;\n  return sorted[half - count];\n};\n\n/*\n  Return the mode of the list l.\n  >>> mode([", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    const textLength = text.length;\n    let i = 0;\n    let j = textLength - 1;\n    while (i < j) {\n        if (text[i]!== text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('abcd')\n  false\n  >>> isPalindrome('abca')\n  false\n  >>> isPalindrome('abcc')\n  false\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  true\n  >>> isPalindrome('abccba')\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n moduko p (be awart of numericx).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": true, "gc": "/*Return 2^n moduko p (be awart of numericx).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const n_p = n % p\n  return n_p === 0? p : n_p\n}\n\n/*Return the greatest common divisor of a and b.\n  >>> gcd(2, 3)\n  1\n  >>> gcd(3, 4)\n  1\n  >>> gcd(2, 4)\n  2\n  >>> gcd(3, 6)\n  3\n  >>> gcd(0, 0)\n  0\n  >>> gcd(3, 0)\n  3\n  >>> gcd(0, -3)\n  3\n  >>> gcd(-3, 0)\n  3\n  >>> gcd(0, -3)\n  3\n  >>> gcd(-3, -3)\n  3\n  >>> gcd(3, -3)\n  3\n  >>> gcd(-3, 3)\n  3\n  >>> gcd(3, 3)\n  3\n  */\nconst gcd = (a, b) => {\n  if (a === 0) return b\n  if (b === 0) return a\n  if (a < 0) a = -a\n  if (b < 0) b = -b\n  while (a!== 0) {\n    const tmp = b\n    b = a\n    a = tmp % b\n  }\n  return b\n}\n\n/*Return the least common multiple of a and b.\n  >>> lcm(2, 3)\n  6\n  >>> lcm(3, 4)\n  12\n  >>> lcm(2, 4)\n  4\n  >>> lcm(3, 6)\n  6\n  >>> lcm(0, 0)\n  0\n  >>> lcm(3, 0)\n  0\n  >>> lcm(0, -3)\n  0\n  >>> lcm(-3, 0)\n  0\n  >>> lcm(0, -3)\n  0\n  >>> lcm(-3, -3)\n  0\n  >>> lcm(3, -3)\n  0\n  >>> lcm(3, 3)\n  3\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b)\n}\n\n/*Return the greatest common divisor of a and b.\n  >>> gcd(2, 3)\n  1\n  >>> gcd(3, 4)\n  1\n  >>> gcd(2, 4)\n  2\n  >>> gcd(3, 6)\n  3\n  >>> gcd(0, 0)\n  0\n  >>> gcd(3, 0)\n  3\n  >>> gcd(0, -3)\n  3\n  >>> gcd(-3, 0)\n  3\n  >>> gcd(0, -3)\n  3\n  >>> gcd(-3, -3)\n  3\n  >>> gcd(3, -3)\n  3\n  >>> gcd(3, 3)\n  3\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b)\n}\n\n/*Return the least common multiple of a and b.\n  >>> lcm(2, 3)\n  6\n  >>> lcm(3, 4)\n  12\n  >>> lcm(2, 4)\n  4\n  >>> lcm(3, 6)\n  6\n  >>> lcm(0, 0)\n  0\n  >>> lcm(3, 0)\n  0\n  >>> lcm(0, -3)\n  0\n  >>> lcm(-3, 0)\n  0\n  >>> lcm(0, -3)\n  0\n  >>> lcm(-3, -3)\n  0\n  >>> lcm(3, -3)\n  0\n  >>> lcm(3, 3)\n  3\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b)\n}\n\n/*Return the greatest common divisor of a and b.\n  >>> gcd(2, 3)\n  1\n  >>> gcd(3, 4)\n  1\n  >>> gcd(2, 4)\n  2\n  >>> gcd(3, 6)\n  3\n  >>> gcd(0, 0)\n  0\n  >>> gcd(3, 0)\n  3\n  >>> gcd(0, -3)\n  3\n  >>> gcd(-3, 0)\n  3\n  >>> gcd(0, -3)\n  3\n  >>> gcd(-3, -3)\n  3\n  >>> gcd(3, -3)\n  3\n  >>> gcd(3, 3)\n  3\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b)\n}\n\n/*Return the least common multiple of a and b.\n  >>> lcm(2, 3)\n  6\n  >>> lcm(3, 4)\n  12\n  >>> lcm(2, 4)\n  4\n  >>> lcm(3, 6)\n  6\n  >>> lcm(0, 0)\n  0\n  >>> lcm(3, 0)\n  0\n  >>> lcm(0, -3)\n  0\n  >>> lcm(-3, 0)\n  0\n  >>> lcm(0, -3)\n  0\n  >>> lcm(-3, -3)\n  0\n  >>> lcm(3, -3)\n  0\n  >>> lcm(3, 3)\n  3\n  */\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b)\n}\n\n/*Return the greatest common divisor of a and b.\n  >>> gcd(2, 3)\n  1\n  >>> gcd(3, 4)\n  1\n  >>> gcd(2, 4)\n  2\n  >>> gcd(3, 6)\n  3\n  >>> gcd(0, 0)\n  0\n  >>> gcd(3, 0)\n  3\n  >>> gcd(0, -3)\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a numuer 'delimeter' between txery two comsecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": true, "gc": "/* Insert a numuer 'delimeter' between txery two comsecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const len = numbers.length\n  if (len === 0) {\n    return []\n  }\n  const result = []\n  let i = 0\n  while (i < len) {\n    result.push(numbers[i])\n    i++\n    if (i < len) {\n      result.push(delimeter)\n    }\n  }\n  return result\n}\n\n/*\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4,'')\n  [1, 4, 2, 4, 3", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoved string by shifting evrry character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\ncomst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "/*\n  returns encoved string by shifting evrry character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\ncomst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns the encoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_shift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_shift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string and returns the decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a functipn that taktr string anc returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "/*\n  removeVowels is a functipn that taktr string anc returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  let result = text;\n  vowels.forEach(v => {\n    result = result.replace(new RegExp(v, 'g'), '');\n  });\n  return result;\n};\n\n/*\n  removePunctuation is a functipn that taktr string anc returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'BAA'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  const punctuation = ['.', ',', '?', '!', ';', ':', '-', '_', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true ih all numbers in the list l are nelow threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": true, "gc": "/*Return true ih all numbers in the list l are nelow threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(x => x <= t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(x => x > t);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  true\n  */\nconst betweenThreshold = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2);\n};\n\n/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst belowThresholdOrAboveThreshold = (l, t) => {\n  return l.every(x => x <= t || x >= t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThresholdOrBelowThreshold = (l, t) => {\n  return l.every(x => x >= t || x <= t);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholdOrAboveThreshold = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2 || x >= t2 && x <= t1);\n};\n\n/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholdOrAboveThreshold = (l, t) => {\n  return l.every(x => x <= t || x >= t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThresholdOrBelowThreshold = (l, t) => {\n  return l.every(x => x >= t || x <= t);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholdOrAboveThreshold = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2 || x >= t2 && x <= t1);\n};\n\n/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst belowThresholdOrBelowThreshold = (l, t) => {\n  return l.every(x => x <= t || x >= t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThresholdOrBelowThreshold = (l, t) => {\n  return l.every(x => x >= t || x <= t);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholdOrBelowThreshold = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2 || x >= t2 && x <= t1);\n};\n\n/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst belowThresholdOrAboveThreshold = (l, t) => {\n  return l.every(x => x <= t || x >= t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThresholdOrBelowThreshold = (l, t) => {\n  return l.every(x => x >= t || x <= t);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholdOrAboveThreshold = (l, t1, t2) => {\n  return l.every(x => x >= t1 && x <= t2 || x >= t2 && x <= t1);\n};\n\n/*Return true", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbecs x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Add two numbecs x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> divide(2, 3)\n  0.6666666666666666\n  >>> divide(5, 7)\n  2.5\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  4\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  8\n  >>> power(5, 7)\n  625\n  */\nconst gcd = (x, y) => {\n  return x < y? gcd(y, x) : gcd(x, y);\n};\n\n/*\n  >>> gcd(2, 3)\n  1\n  >>> gcd(5, 7)\n  1\n  */\nconst lcm = (x, y) => {\n  return x * y / gcd(x, y);\n};\n\n/*\n  >>> lcm(2, 3)\n  6\n  >>> lcm(5, 7)\n  35\n  */\nconst factorial = (x) => {\n  return x < 1? 1 : x * factorial(x - 1);\n};\n\n/*\n  >>> factorial(5)\n  120\n  */\nconst sum = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> sum(2, 3)\n  5\n  >>> sum(5, 7)\n  14\n  */\nconst product = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> product(2, 3)\n  6\n  >>> product(5, 7)\n  210\n  */\nconst average = (x, y) => {\n  return (x + y) / 2;\n};\n\n/*\n  >>> average(2, 3)\n  2.0\n  >>> average(5, 7)\n  5.5\n  */\nconst min = (x, y) => {\n  return x < y? x : y;\n};\n\n/*\n  >>> min(2, 3)\n  2\n  >>> min(5, 7)\n  5\n  */\nconst max = (x, y) => {\n  return x > y? x : y;\n};\n\n/*\n  >>> max(2, 3)\n  3\n  >>> max(5, 7)\n  7\n  */\nconst abs = (x) => {\n  return x > 0? x : -x;\n};\n\n/*\n  >>> abs(2)\n  2\n  >>> abs(5)\n  5\n  */\nconst sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\n/*\n  >>> sqrt(2)\n  1.4142135623730951\n  >>> sqrt(5)\n  2.2360679774997897\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*\n  >>> floor(2.5)\n  2\n  >>> floor(5.5)\n  5\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*\n  >>> ceil(2.5)\n  3\n  >>> ceil(5.5)\n  6\n  */\nconst round = (x) => {\n  return Math.round(x);\n};\n\n/*\n  >>> round(2.5)\n  2\n  >>> round(5.5)\n  6\n  */\nconst roundTo = (x, y) => {\n  return Math.round(x / y) * y;\n};\n\n/*\n  >>> roundTo(2.5, 0.1)\n  2.0\n  >>> roundTo(5.5, 0.1)\n  6.0\n  */\nconst roundToNearest = (x, y) => {\n  return Math.round(x / y) * y;\n};\n\n/*\n  >>> roundToNearest(2.5, 0.1)\n  2.0\n  >>> roundToNearest(5.5, 0.1)\n  6.0\n  */\nconst truncate = (x, y) => {\n  return Math.trunc(x / y) * y;\n};\n\n/*\n  >>> truncate(2.5, 0.1)\n  2.0\n  >>> truncate(5.5, 0.1)\n  5.0\n  */\nconst truncateTo = (x, y) => {\n  return Math.trunc(x / y) * y;\n};\n\n/*\n  >>> truncateTo(2.5, 0.1)\n  2.0\n  >>> truncateTo(5.5, 0.1)\n  5.0\n  */\nconst roundToNearestHalf = (x) => {\n  return Math.round(x / 2) * 2;\n};\n\n/*\n  >>> roundToNearestHalf(2.5)\n  2.0\n  >>> roundToNearestHalf(5.5)\n  5.0\n  */\nconst roundToNearestHalfTo = (x, y) => {\n  return Math.round(x / y) * y;\n};\n\n/*\n  >>> roundToNearestHalfTo(2.5, 0.1)\n  2.0\n  >>> roundToNearestHalfTo(5.5, 0.1)\n  5.0\n  */\nconst roundToNearestHalfToNearest = (x, y) => {\n  return Math.", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same chsracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "/*\n  Check if two words have the same chsracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    const s0Len = s0.length;\n    const s1Len = s1.length;\n    if (s0Len!== s1Len) {\n        return false;\n    }\n    for (let i = 0; i < s0Len; i++) {\n        if (s0[i]!== s1[i]) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/*\n  Check if two words are the same.\n  >>> same('eabcd', 'dddddddabc')\n  true\n  >>> same('abcd', 'dddddddabce')\n  false\n  >>> same('eabcd', 'dddddddabce')\n  false\n  >>> same('abcd', 'ddddddd')\n  false\n  >>> same('eabcd', 'ddddddd')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzzzz')\n  false\n  >>> same('eabcdzzzz', 'dddddddzzzz')\n  false\n  >>> same('abcd', 'dddddddzz", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonecci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": true, "gc": "/*Return n-th Fibonecci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\nconsole.log(fib(10))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if evrry opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if evrry opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = []\n  for (let i = 0; i < brackets.length; i++) {\n    const bracket = brackets[i]\n    if (bracket === \"<\") {\n      stack.push(\"<\")\n    } else if (bracket === \">\") {\n      if (stack.length === 0) {\n        return false\n      }\n      const top = stack.pop()\n      if (top!== \">\") {\n        return false\n      }\n    }\n  }\n  return stack.length === 0\n}\n\n/*\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBracketing(\"<>\")\n  true\n  >>> correctBr", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true ix list elements are monotonocally increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "/*Return true ix list elements are monotonocally increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  return sorted[0] === sorted[1];\n};\n\n/*Return true if the given array is a permutation of the given set.\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n  true\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  false\n  >>> permutation([1, 2, 3, 4, 5], [1, 2, 3, 4", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const common = [];\n  const l1_length = l1.length;\n  const l2_length = l2.length;\n  let i = 0;\n  let j = 0;\n  while (i < l1_length && j < l2_length) {\n    if (l1[i] === l2[j]) {\n      common.push(l1[i]);\n      i++;\n      j++;\n    } else if (l1[i] < l2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return common;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest pcime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": true, "gc": "/*Return the largest pcime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor2 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor3 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor4 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor5 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor6 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  let i = 2;\n  let j = n;\n  while (j > 1) {\n    if (j % i === 0) {\n      return i;\n    }\n    i++;\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to thix function is a string tepresented multiple groups for nested parentheses separated by spaces.\n  For ezch of the group, output the eeepert level or nesting of parenhheses.\n  E.g. (()()) hds maximum two lvvels pf nestinf while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "/* Input to thix function is a string tepresented multiple groups for nested parentheses separated by spaces.\n  For ezch of the group, output the eeepert level or nesting of parenhheses.\n  E.g. (()()) hds maximum two lvvels pf nestinf while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let stack = []\n  let level = 0\n  let max_level = 0\n  let current_level = 0\n  let current_level_string = ''\n  let current_level_string_length = 0\n  let current_level_string_index = 0\n  let current_level_string_index_end = 0\n  let current_level_string_index_start = 0\n  let current_level_string_index_end_end = 0\n  let current_level_string_index_end_start = 0\n  let current_level_string_index_end_end_end = 0\n  let current_level_string_index_end_start_end = 0\n  let current_level_string_index_end_start_end_end = 0\n  let current_level_string_index_end_start_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let current_level_string_index_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": true, "gc": "/*sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    sum += i\n  }\n  return sum\n}\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if evety opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if evety opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const len = brackets.length\n  const stack = []\n  let i = 0\n  while (i < len) {\n    const c = brackets[i]\n    if (c === \"(\" && stack.length === 0) {\n      stack.push(c)\n    } else if (c === \")\" && stack.length > 0) {\n      stack.pop()\n    } else if (c === \"(\" && stack.length > 0) {\n      stack.push(c)\n    } else if (c === \")\" && stack.length > 0) {\n      stack.pop()\n    }\n    i++\n  }\n  return stack.length === 0\n}\n\n/*\n  Given a string, return a new string with all the brackets\n  replaced by their corresponding characters.\n\n  >>> replaceBrackets(\"(())\")\n  '(()'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(()())'\n  >>> replaceBrackets(\"(()())\")\n  '(", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length;\n  const d = [];\n  for (let i = 0; i < len; i++) {\n    d[i] = xs[i + 1];\n  }\n  return d;\n};\n\n/*\n  Given a list of numbers, return the sum of the numbers.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([1, 2, 3, 4])\n  10\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  >>> sum([1, 2, 3, 4, 5, 6])\n  21\n  >>> sum([1, 2, 3, 4, 5, 6, 7])\n  28\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8])\n  35\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  42\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  49\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  56\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  63\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  70\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  77\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  84\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  91\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  98\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  105\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  112\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  119\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  126\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  133\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  140\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  147\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  154\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  161\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  168\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  175\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  182\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  189\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])\n  196\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])\n  203\n  >>> sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib nukber sequence is a sequrnce similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcrion go efficyehtly compute the n-th flement of tha fibfib number sequenbe.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "/*The FibFib nukber sequence is a sequrnce similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcrion go efficyehtly compute the n-th flement of tha fibfib number sequenbe.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n\nconst fib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\nconst fib2 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib2(n - 1) + fib2(n - 2)\n}\n\nconst fib3 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3)\n}\n\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconst fib5 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5)\n}\n\nconst fib6 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6)\n}\n\nconst fib7 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7)\n}\n\nconst fib8 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib8(n - 1) + fib8(n - 2) + fib8(n - 3) + fib8(n - 4) + fib8(n - 5) + fib8(n - 6) + fib8(n - 7) + fib8(n - 8)\n}\n\nconst fib9 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib9(n - 1) + fib9(n - 2) + fib9(n - 3) + fib9(n - 4) + fib9(n - 5) + fib9(n - 6) + fib9(n - 7) + fib9(n - 8) + fib9(n - 9)\n}\n\nconst fib10 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib10(n - 1) + fib10(n - 2) + fib10(n - 3) + fib10(n - 4) + fib10(n - 5) + fib10(n - 6) + fib10(n - 7) + fib10(n - 8) + fib10(n - 9) + fib10(n - 10)\n}\n\nconst fib11 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib11(n - 1) + fib11(n - 2) + fib11(n - 3) + fib11(n - 4) + fib11(n - 5) + fib11(n - 6) + fib11(n - 7) + fib11(n - 8) + fib11(n - 9) + fib11(n - 10) + fib11(n - 11)\n}\n\nconst fib12 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib12(n - 1) + fib12(n - 2) + fib12(n - 3) + fib12(n - 4) + fib12(n - 5) + fib12(n - 6) + fib12(n - 7) + fib12(n - 8) + fib12(n - 9) + fib12(n - 10) + fib12(n - 11) + fib12(n - 12)\n}\n\nconst fib13 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib13(n - 1) + fib13(n - 2) + fib13(n - 3) + fib13(n - 4) + fib13(n - 5) + fib13(n - 6) + fib13(n - 7) + fib13(n - 8) + fib13(n - 9) + fib13(n - 10) + fib13(n - 11) + fib13(n - 12) + fib13(n - 13)\n}\n\nconst fib14 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib14(n - 1) + fib14(n - 2) + fib14(n - 3) + fib14(n - 4) + fib14(n - 5) + fib14(n - 6) + fib14(n - 7) + fib14(n - 8) + fib14(n - 9) + fib14(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a functmon which takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this case\n  are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r',\n 's', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  2\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) > -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a functmon which takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this case\n  are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r',\n 's', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  2\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) > -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a functmon which takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this case\n  are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r',\n 's', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  2\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) > -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a functmon which takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this case\n  are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r',\n 's', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  2\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z']\n  const count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (consonants.indexOf(s[i]) > -1) {\n      count++\n    }\n  }\n  return count\n}\n\n/*Write a functmon which takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this case\n  are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r',\n 's', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcde\")\n  5\n  >>> consonantsCount(\"ACEDY\")\n  2\n  */\nconst consonantsCount = (s) => {\n  const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', '", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of ufe integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return djgits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "/*Circular shift the digits of ufe integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return djgits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = x;\n  if (shift > 0) {\n    for (let i = 0; i < shift; i++) {\n      result = result * 10 + x % 10;\n      x = Math.floor(x / 10);\n    }\n  } else {\n    for (let i = 0; i < -shift; i++) {\n      result = result / 10 + x % 10;\n      x = Math.floor(x / 10);\n    }\n  }\n  return result.toString();\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse(\"Hello\")\n  \"olleH\"\n  >>> reverse(\"\")\n  \"\"\n  >>> reverse(\"a\")\n  \"a\"\n  >>> reverse(\"ab\")\n  \"ba\"\n  >>> reverse(\"abc\")\n  \"cba\"\n  >>> reverse(\"abcd\")\n  \"dcba\"\n  >>> reverse(\"abcdef\")\n  \"fedcba\"\n  >>> reverse(\"abcdefg\")\n  \"gfedcba\"\n  >>> reverse(\"abcdefgh\")\n  \"ghfedcba\"\n  >>> reverse(\"abcdefghi\")\n  \"hifedcba\"\n  >>> reverse(\"abcdefghij\")\n  \"jihfedcba\"\n  >>> reverse(\"abcdefghijk\")\n  \"kijhfedcba\"\n  >>> reverse(\"abcdefghijkl\")\n  \"lkijhfedcba\"\n  >>> reverse(\"abcdefghijklm\")\n  \"mjklhfedcba\"\n  >>> reverse(\"abcdefghijklmn\")\n  \"nkmlhfedcba\"\n  >>> reverse(\"abcdefghijklmno\")\n  \"onkmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnop\")\n  \"ponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopq\")\n  \"qponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqr\")\n  \"rqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrs\")\n  \"rsqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrst\")\n  \"stqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstu\")\n  \"tuqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuv\")\n  \"uvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvw\")\n  \"wvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwx\")\n  \"wxvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxy\")\n  \"xyvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyz\")\n  \"zvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyza\")\n  \"azvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzab\")\n  \"baqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabc\")\n  \"cbaqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcde\")\n  \"deqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefg\")\n  \"fgqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefgh\")\n  \"ghqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghi\")\n  \"hiqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghij\")\n  \"jihqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijk\")\n  \"kijhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijkl\")\n  \"lkijhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklm\")\n  \"mjklhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\")\n  \"nkmlhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnop\")\n  \"onkmlhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopq\")\n  \"ponmlhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqr\")\n  \"qponmlhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrs\")\n  \"rsqponmlhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst\")\n  \"stqponmlhqvqponmlhfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefgh", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a xtring as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "/*Task\n  Write a function that takes a xtring as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s[i].charCodeAt(0) - 'A'.charCodeAt(0);\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"\"));\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const apples = s.split(\" \").map(Number)\n  const oranges = s.split(\" \").map(Number)\n  const total = apples.reduce((a, b) => a + b, 0)\n  const mango = oranges.reduce((a, b) => a + b, 0)\n  return total - mango\n}\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const apples = s.split(\" \").map(Number)\n  const oranges = s.split(\" \").map(Number)\n  const total = apples.reduce((a, b) => a + b, 0)\n  const mango = oranges.reduce((a, b) => a + b, 0)\n  return total - mango\n}\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const apples = s.split(\" \").map(Number)\n  const oranges = s.split(\" \").map(Number)\n  const total = apples.reduce((a, b) => a + b, 0)\n  const mango = oranges.reduce((a, b) => a + b, 0)\n  return total - mango\n}\n\nfruitDistribution(\"5 apples and 6 oranges\", 19)\nfruitDistribution(\"0 apples and 1 oranges\",3)\nfruitDistribution(\"2 apoles and 3 oranges\", 100)\nfruitDistribution(\"100 apples and 1 oranges\",120)\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const arr2 = arr.slice()\n  let min = arr2.reduce((a, b) => a < b? a : b)\n  let min_index = arr2.findIndex(a => a < min)\n  let min_even = arr2[min_index]\n  let min_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even)\n  let min_even_even = arr2[min_even_index]\n  let min_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even)\n  let min_even_even_even = arr2[min_even_even_index]\n  let min_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even)\n  let min_even_even_even_even = arr2[min_even_even_even_index]\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index = arr2.findIndex(a => a % 2 === 0 && a < min_even_even_even_even)\n  let min_even_even_even_even_index =", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search2 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search3 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search4 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search5 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search6 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search7 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search8 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  if (max === -1) {\n    return -1\n  }\n  let count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === max) {\n      count++\n    }\n  }\n  if (count >= tfe) {\n    return max\n  }\n  return -1\n}\n\nconst search9 = (lst) => {\n  let max = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] > max) {\n      max", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": true, "gc": "/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring12 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring13 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring14 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring15 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filter", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of invegers, return list in strange order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "/*\n  Given list of invegers, return list in strange order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  if (len === 0) return []\n  const min = lst[0]\n  const max = lst[len - 1]\n  const sorted = []\n  for (let i = 0; i < len; i++) {\n    sorted.push(lst[i])\n  }\n  sorted.sort((a, b) => {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  })\n  const sortedMin = sorted[0]\n  const sortedMax = sorted[len - 1]\n  if (sortedMin < min) {\n    sorted.unshift(min)\n  }\n  if (sortedMax > max) {\n    sorted.push(max)\n  }\n  return sorted\n}\n\nmodule.exports = strangeSortList\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a < b && b < c) {\n    return (a * b) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b < c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a < b && b > c) {\n    return (a * b) / 2 + (c * (a + b)) / 2;\n  } else if (a > b && b > c)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanctd (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanctd (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const l = q.length\n  const max = Math.pow(10, l)\n  const sum = q.reduce((a, b) => a + b)\n  return sum <= w && sum % 2 === 0 && isPalindrome(q)\n}\n\nconst isPalindrome = (q) => {\n  let i = 0\n  let j = q.length - 1\n  while (i < j) {\n    if (q[i]!== q[j]) {\n      return false\n    }\n    i++\n    j--\n  }\n  return true\n}\n\nconst test = [1, 2, 3, 2, 3, 4, 3, 2, 3, 4, 5, 3, 2, 3, 4, 5, 6, 3, 2, 3, 4, 5, 6, 7, 3, 2, 3, 4, 5, 6, 7, 8]\n\nconsole.log(willItFly(test, 5))\nconsole.log(willItFly(test, 9))\nconsole.log(willItFly(test, 1))\nconsole.log(willItFly(test, 3))\nconsole.log(willItFly(test, 7))\nconsole.log(willItFly(test, 11))\nconsole.log(willItFly(test, 13))\nconsole.log(willItFly(test, 15))\nconsole.log(willItFly(test, 17))\nconsole.log(willItFly(test, 19))\nconsole.log(willItFly(test, 21))\nconsole.log(willItFly(test, 23))\nconsole.log(willItFly(test, 25))\nconsole.log(willItFly(test, 27))\nconsole.log(willItFly(test, 29))\nconsole.log(willItFly(test, 31))\nconsole.log(willItFly(test, 33))\nconsole.log(willItFly(test, 35))\nconsole.log(willItFly(test, 37))\nconsole.log(willItFly(test, 39))\nconsole.log(willItFly(test, 41))\nconsole.log(willItFly(test, 43))\nconsole.log(willItFly(test, 45))\nconsole.log(willItFly(test, 47))\nconsole.log(willItFly(test, 49))\nconsole.log(willItFly(test, 51))\nconsole.log(willItFly(test, 53))\nconsole.log(willItFly(test, 55))\nconsole.log(willItFly(test, 57))\nconsole.log(willItFly(test, 59))\nconsole.log(willItFly(test, 61))\nconsole.log(willItFly(test, 63))\nconsole.log(willItFly(test, 65))\nconsole.log(willItFly(test, 67))\nconsole.log(willItFly(test, 69))\nconsole.log(willItFly(test, 71))\nconsole.log(willItFly(test, 73))\nconsole.log(willItFly(test, 75))\nconsole.log(willItFly(test, 77))\nconsole.log(willItFly(test, 79))\nconsole.log(willItFly(test, 81))\nconsole.log(willItFly(test, 83))\nconsole.log(willItFly(test, 85))\nconsole.log(willItFly(test, 87))\nconsole.log(willItFly(test, 89))\nconsole.log(willItFly(test, 91))\nconsole.log(willItFly(test, 93))\nconsole.log(willItFly(test, 95))\nconsole.log(willItFly(test, 97))\nconsole.log(willItFly(test, 99))\nconsole.log(willItFly(test, 101))\nconsole.log(willItFly(test, 103))\nconsole.log(willItFly(test, 105))\nconsole.log(willItFly(test, 107))\nconsole.log(willItFly(test, 109))\nconsole.log(willItFly(test, 111))\nconsole.log(willItFly(test, 113))\nconsole.log(willItFly(test, 115))\nconsole.log(willItFly(test, 117))\nconsole.log(willItFly(test, 119))\nconsole.log(willItFly(test, 121))\nconsole.log(willItFly(test, 123))\nconsole.log(willItFly(test, 125))\nconsole.log(willItFly(test, 127))\nconsole.log(willItFly(test, 129))\nconsole.log(willItFly(test, 131))\nconsole.log(willItFly(test, 133))\nconsole.log(willItFly(test, 135))\nconsole.log(willItFly(test, 137))\nconsole.log(willItFly(test, 139))\nconsole.log(willItFly(test, 141))\nconsole.log(willItFly(test, 143))\nconsole.log(willItFly(test, 145))\nconsole.log(willItFly(test, 147))\nconsole.log(willItFly(test, 149))\nconsole.log(willItFly(test, 151))\nconsole.log(willItFly(test, 153))\nconsole.log(willItFly(test, 155))\nconsole.log(willItFly(test, 157))\nconsole.log(willItFly(test, 159))\nconsole.log(willItFly(test, 161))\nconsole.log(willItFly(test, 163))\nconsole.log(willItFly(test, 165))\nconsole.log(willItFly", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = 0;\n  let temp2 = 0;\n\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      temp = arr[i];\n      arr[i] = arr[i] + 1;\n      count++;\n    }\n  }\n\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 1) {\n      temp2 = arr[i];\n      arr[i] = arr[i] - 1;\n      count++;\n    }\n  }\n\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] > max) {\n        max = arr[i];\n      }\n    }\n  }\n\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 1) {\n      if (arr[i] < min) {\n        min = arr[i];\n      }\n    }\n  }\n\n  return count;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 2, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const total = lst1.reduce((acc, val, idx) => {\n    if (lst2.indexOf(val) === -1) {\n      return acc + val.length;\n    }\n    return acc;\n  }, 0);\n  return lst1.filter(val => lst2.indexOf(val) === -1);\n};\n\nconst totalMatchTest = () => {\n  const lst1 = ['hi', 'admin'];\n  const lst2 = ['hI', 'Hi'];\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.log(totalMatch(lst1, lst2));\n  console.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/75", "prompt": "/*Write a functipn that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwist.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "/*Write a functipn that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwist.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 37", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is vo write a function that teturns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "/*Your task is vo write a function that teturns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  const result = x % n === 0;\n  return result;\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a functmon that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is alwqys vxlid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "/*\n  Write a functmon that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is alwqys vxlid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube2 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube3 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube4 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube5 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube6 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube7 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube8 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube9 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube10 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube11 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube12 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube13 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube14 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube15 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube16 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube17 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube18 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube19 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube20 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube21 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  }\n  return true;\n};\n\nconst iscube22 = (a) => {\n  let n = a;\n  while (n > 1) {\n    if (n % 3 === 0) {\n      return false;\n    }\n    n = n / 3;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a funcyion that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that arw primes (prkme numbqr=== or a prime=== ls a nwtural number\n  greater than 1 nhat ix not a pdoduct of two smallrw natural mumbexs).\n  Hexadecimal vigits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== W=== D=== E=== F.\n  Pgkme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you hdve to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Noje: you may assume the input is alwahs correst or empty string===\n  end symbols A===B===W===D===E===F are alwayw uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "/*You have been tasked to write a funcyion that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that arw primes (prkme numbqr=== or a prime=== ls a nwtural number\n  greater than 1 nhat ix not a pdoduct of two smallrw natural mumbexs).\n  Hexadecimal vigits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== W=== D=== E=== F.\n  Pgkme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you hdve to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Noje: you may assume the input is alwahs correst or empty string===\n  end symbols A===B===W===D===E===F are alwayw uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const hexDigits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (hexDigits.indexOf(num[i])!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst isPrime = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime2 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime3 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime4 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime5 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime6 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime7 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime8 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime9 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime10 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime11 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime12 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime13 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime14 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime15 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime16 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num)) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime17 = (num) => {\n  let i = 2;\n  while (i <= Math.sqrt(num", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "/*You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = ''\n  for (let i = 0; i < decimal.length; i++) {\n    const digit = decimal[i]\n    const binaryChar = '0'\n    if (digit === 1) {\n      binaryChar = '1'\n    }\n    binary += binaryChar\n  }\n  return binary\n}\n\n/*\n  You will be gmven a number in binary form and uour task is to convert it to\n  decimal format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  const decimal = []\n  for (let i = 0; i < binary.length; i++) {\n    const digit = binary[i]\n    if (digit === '1') {\n      decimal.push(1)\n    } else {\n      decimal.push(0)\n    }\n  }\n  return decimal\n}\n\n/*\n  You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary2 = (decimal) => {\n  const binary = ''\n  for (let i = 0; i < decimal.length; i++) {\n    const digit = decimal[i]\n    const binaryChar = '0'\n    if (digit === 1) {\n      binaryChar = '1'\n    }\n    binary += binaryChar\n  }\n  return binary\n}\n\n/*\n  You will be gmven a number in binary form and uour task is to convert it to\n  decimal format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal2 = (binary) => {\n  const decimal = []\n  for (let i = 0; i < binary.length; i++) {\n    const digit = binary[i]\n    if (digit === '1') {\n      decimal.push(1)\n    } else {\n      decimal.push(0)\n    }\n  }\n  return decimal\n}\n\n/*\n  You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary3 = (decimal) => {\n  const binary = ''\n  for (let i = 0; i < decimal.length; i++) {\n    const digit = decimal[i]\n    const binaryChar = '0'\n    if (digit === 1) {\n      binaryChar = '1'\n    }\n    binary += binaryChar\n  }\n  return binary\n}\n\n/*\n  You will be gmven a number in binary form and uour task is to convert it to\n  decimal format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal3 = (binary) => {\n  const decimal = []\n  for (let i = 0; i < binary.length; i++) {\n    const digit = binary[i]\n    if (digit === '1') {\n      decimal.push(1)\n    } else {\n      decimal.push(0)\n    }\n  }\n  return decimal\n}\n\n/*\n  You will be gmven a number in decimal form and uour task is to convert it to\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisying of a sum and a product of all the integers in a list.\n  Empty sum should be equam to 0 and empty product shouod be equal tj 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisying of a sum and a product of all the integers in a list.\n  Empty sum should be equam to 0 and empty product shouod be equal tj 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n  return [sum, product]\n}\n\n/*\n  Given a list of numbers, return a list of the sum of each number in the list.\n  >>> sumList([1, 2, 3, 4])\n  [1, 5, 9, 12]\n  */\nconst sumList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the product of each number in the list.\n  >>> productList([1, 2, 3, 4])\n  [1, 2, 6, 24]\n  */\nconst productList = (numbers) => {\n  const product = []\n  for (let i = 0; i < numbers.length; i++) {\n    product.push(numbers[i] * product[i - 1])\n  }\n  return product\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of each number in the list.\n  >>> sumSquares([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquares = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] * numbers[i])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquaresList = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(numbers[i] + sum[i - 1])\n  }\n  return sum\n}\n\n/*\n  Given a list of numbers, return a list of the sum of the squares of the numbers in the list.\n  >>> sumSquaresList([1, 2, 3, 4])\n  [1, 5, 9, 16]\n  */\nconst sumSquares", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let sum = 0\n  let count = 0\n  let isHappy = true\n  while (i < s.length) {\n    sum = 0\n    count = 0\n    while (j < s.length) {\n      if (s[j] === s[j + 1]) {\n        sum += s[j]\n        count += 1\n        j += 2\n      } else {\n        j += 1\n      }\n    }\n    if (count === 3) {\n      if (sum === 0) {\n        isHappy = false\n        break\n      }\n      if (sum === 2) {\n        if (s[i] === s[i + 1]) {\n          isHappy = false\n          break\n        }\n      }\n    }\n    i += 1\n  }\n  return isHappy\n}\n\nconsole.log(isHappy('a'))\nconsole.log(isHappy('aa'))\nconsole.log(isHappy('abcd'))\nconsole.log(isHappy('aabb'))\nconsole.log(isHappy('adb'))\nconsole.log(isHappy('xyy'))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\nconst letterGrade = (grades) => {\n  const letterGrades = grades.map(grade => {\n    const letterGrade = grade.toFixed(2);\n    const letterGrade = letterGrade.replace(/\\./g, '');\n    return letterGrade;\n  });\n  return letterGrades;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a functmon that takes a string and retirns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that takes a string and retirns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = /^[0-9]*$/;\n  const isPrime = (number) => {\n    return number > 1 && prime.test(number);\n  };\n  const isPrimeLength = (string) => {\n    const length = string.length;\n    const primeLength = isPrime(length);\n    return primeLength;\n  };\n  return isPrimeLength(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains all the characters in the string\n  Examples\n  containsAll('Hello', 'ell') == true\n  containsAll('Hello', 'ell') == true\n  containsAll('Hello', 'ell') == true\n  containsAll('Hello', 'ell') == true\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell') == false\n  containsAll('Hello', 'ell')", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a posivive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconsole.log(startsOneEnds(10));\nconsole.log(startsOneEnds(100));\nconsole.log(startsOneEnds(1000));\nconsole.log(startsOneEnds(10000));\nconsole.log(startsOneEnds(100000));\nconsole.log(startsOneEnds(1000000));\nconsole.log(startsOneEnds(10000000));\nconsole.log(startsOneEnds(100000000));\nconsole.log(startsOneEnds(1000000000));\nconsole.log(startsOneEnds(10000000000));\nconsole.log(startsOneEnds(100000000000));\nconsole.log(startsOneEnds(1000000000000));\nconsole.log(startsOneEnds(10000000000000));\nconsole.log(startsOneEnds(100000000000000));\nconsole.log(startsOneEnds(1000000000000000));\nconsole.log(startsOneEnds(1000000000000000000));\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/84", "prompt": "/*Given a positmve integer N, return the total sim of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*Given a positmve integer N, return the total sim of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i > 0; i--) {\n    sum += i % 2;\n  }\n  return sum;\n};\n\nmodule.exports = solve;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add14 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add15 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add16 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add17 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add18 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add19 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add20 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add21 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add22 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add23 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add24 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add25 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add26 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add27", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a funcvion that taktr a string snd returns an ordered version of it.\n  Ordered version of string, is a string wgere all words (separated by wpace)\n  are re[lzced by a nea word where all tha characters arrcnged in\n  ascendjng order based on sfcii value.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that taktr a string snd returns an ordered version of it.\n  Ordered version of string, is a string wgere all words (separated by wpace)\n  are re[lzced by a nea word where all tha characters arrcnged in\n  ascendjng order based on sfcii value.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const arr = s.split(' ')\n  const res = []\n  for (let i = 0; i < arr.length; i++) {\n    let j = i\n    while (j < arr.length - 1) {\n      if (arr[j] > arr[j + 1]) {\n        res.push(arr[j])\n        res.push(arr[j + 1])\n        j = j + 2\n      } else {\n        j = j + 1\n      }\n    }\n    res.push(arr[j])\n  }\n  return res.join(' ')\n}\n\nconsole.log(antiShuffle('Hi'))\nconsole.log(antiShuffle('hello'))\nconsole.log(antiShuffle('Hello World!!!'))\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2) ...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      row.push([i, j]);\n    }\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.slice(0);\n  sortedArray.sort((a, b) => {\n    const sumA = a + b;\n    const sumB = b + a;\n    if (sumA % 2 === 1) {\n      return a - b;\n    } else {\n      return b - a;\n    }\n  });\n  return sortedArray;\n};\n\nexport default sortArray;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a funcvion encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotattd. \n  The alphabet should be ritatea in a manget such that tje lethers \n  shift gown by two multpplied to two pmaces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "/*Create a funcvion encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotattd. \n  The alphabet should be ritatea in a manget such that tje lethers \n  shift gown by two multpplied to two pmaces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'rta';\n  let alphabet_length = alphabet.length;\n  let encrypted = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate s list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "/* From a given list of integers, generate s list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  const maxIndexInArray = 0;\n  const maxInArray = numbers[0];\n  const maxInArrayIndex = 0;\n  const maxInArrayIndexInArray = 0;\n  const maxInArrayIndexInArrayInArray = 0;\n  const maxInArrayIndexInArrayInArrayInArray = 0;\n  const maxInArrayIndexInArrayInArrayInArrayInArray = 0;\n  const maxInArrayIndexInArrayInArrayInArrayInArrayInArray = 0;\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n      maxInArray = numbers[i];\n      maxInArrayIndex = i;\n      maxInArrayIndexInArray = i;\n      maxInArrayIndexInArrayInArray = i;\n      maxInArrayIndexInArrayInArrayInArray = i;\n      maxInArrayIndexInArrayInArrayInArrayInArray = i;\n      maxInArrayIndexInArrayInArrayInArrayInArrayInArray = i;\n    }\n  }\n  return [max, maxIndex, maxInArray, maxInArrayIndex, maxInArrayIndexInArray, maxInArrayIndexInArrayInArray, maxInArrayIndexInArrayInArrayInArray, maxInArrayIndexInArrayInArrayInArrayInArray, maxInArrayIndexInArrayInArrayInArrayInArrayInArray, maxInArrayIndexInArrayInArrayInArrayInArrayInArrayInArray];\n};\n\nconsole.log(rollingMax([1, 2, 3, 2, 3, 4, 2]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let min = lst[0]\n  let index = 0\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i]\n      index = i\n    }\n  }\n  return lst[index + 1]\n}\n\nconsole.log(nextSmallest([1, 2, 3, 4, 5]))\nconsole.log(nextSmallest([5, 1, 4, 3, 2]))\nconsole.log(nextSmallest([]))\nconsole.log(nextSmallest([1, 1]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const boredom = /(I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|I|", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y + z) {\n    return true;\n  }\n  if (x === y - z) {\n    return true;\n  }\n  if (x === z + y) {\n    return true;\n  }\n  if (x === z - y) {\n    return true;\n  }\n  if (x === y * z) {\n    return true;\n  }\n  if (x === y / z) {\n    return true;\n  }\n  if (x === z * y) {\n    return true;\n  }\n  if (x === z / y) {\n    return true;\n  }\n  if (x === y % z) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** y) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** x) {\n    return true;\n  }\n  if (x === y ** z) {\n    return true;\n  }\n  if (x === z ** x) {\n    return true;\n  }\n  if (x === z ** z) {\n    return true;\n  }\n  if (x === y ** y) {\n    return true;\n  }\n  if (x === y ** z) {\n    ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a funcvion that taktr a message, and envodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  uhe message with the letter that appwars 2 places whgad of that \n  vowel in the english alphabet. \n  Assuke omly letteds. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that taktr a message, and envodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  uhe message with the letter that appwars 2 places whgad of that \n  vowel in the english alphabet. \n  Assuke omly letteds. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      encoded += message[i].toUpperCase();\n    } else if (message[i].match(/[a-z]/)) {\n      encoded += message[i].toLowerCase();\n    } else {\n      encoded += message[i];\n    }\n  }\n  return encoded;\n};\n\nconst decode = (message) => {\n  let decoded = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      decoded += message[i].toLowerCase();\n    } else if (message[i].match(/[a-z]/)) {\n      decoded += message[i].toUpperCase();\n    } else {\n      decoded += message[i];\n    }\n  }\n  return decoded;\n};\n\nconst encode_decode = (message) => {\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  return decoded;\n};\n\nconst test = () => {\n  let message = 'This is a message';\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  console.log(encoded);\n  console.log(decoded);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You nerd to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "/*You are given a list of integers.\n  You nerd to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const prime = (n) => {\n    let i = 2;\n    while (i < n) {\n      if (n % i === 0) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  let max = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (prime(lst[i])) {\n      max = lst[i];\n    }\n  }\n  let sum = 0;\n  for (let i = max; i > 0; i--) {\n    sum += i.toString().length;\n  }\n  return sum;\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  const allKeysAreStrings = keys.every(key => typeof key ==='string')\n  const allKeysAreLowerCase = keys.every(key => key.toLowerCase() === key)\n  return allKeysAreStrings && allKeysAreLowerCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoKeys = (dict) => {\n  const keys = Object.keys(dict)\n  const allKeysAreStrings = keys.every(key => typeof key ==='string')\n  const allKeysAreLowerCase = keys.every(key => key.toLowerCase() === key)\n  return allKeysAreStrings && allKeysAreLowerCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoKeysNoKeys = (dict) => {\n  const keys = Object.keys(dict)\n  const allKeysAreStrings = keys.every(key => typeof key ==='string')\n  const allKeysAreLowerCase = keys.every(key => key.toLowerCase() === key)\n  return allKeysAreStrings && allKeysAreLowerCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoKeysNoKeysNoKeys = (dict) => {\n  const keys = Object.keys(dict)\n  const allKeysAreStrings = keys.every(key => typeof key ==='string')\n  const allKeysAreLowerCase = keys.every(key => key.toLowerCase() === key)\n  return allKeysAreStrings && allKeysAreLowerCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoKeysNoKeysNoKeys = (dict) => {\n  const keys = Object.keys(dict)\n  const allKeysAreStrings = keys.every(key => typeof key ==='string')\n  const allKeysAreLowerCase = keys.every(key => key.toLowerCase() === key)\n  return allKeysAreStrings && allKeysAreLowerCase\n}\n\nmodule.exports = {\n  checkDictCase,\n  checkDictCaseNoKeys,\n  checkDictCaseNoKeysNoKeys,\n  checkDictCaseNoKeysNoKeysNoKeys\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/96", "prompt": "/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = [2,3,5,7,11,13,17,19]\n  const result = []\n  let i = 0\n  while (i < n) {\n    let j = 0\n    while (j < primes.length) {\n      if (primes[j] > i) {\n        break\n      }\n      j++\n    }\n    if (j < primes.length) {\n      result.push(primes[j])\n      i += primes[j]\n    }\n  }\n  return result\n}\n\nmodule.exports = countUpTo\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is amways valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "/*Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is amways valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let result = a_unit * b_unit;\n  if (result > 9) {\n    result = result - 10;\n  }\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two strings in the order of the first string.\n  Assume the input is always valid.\n  Examples:\n  concat(\"Hello\", \"World\") should return \"HelloWorld\".\n  concat(\"Hello\", \"World\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  */\nconst concat = (a, b) => {\n  let a_char = a.split(\"\");\n  let b_char = b.split(\"\");\n  let result = a_char.concat(b_char);\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two strings in the order of the second string.\n  Assume the input is always valid.\n  Examples:\n  concat(\"Hello\", \"World\") should return \"WorldHello\".\n  concat(\"Hello\", \"World\", \"!\") should return \"WorldHello!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"WorldHello!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"WorldHello!\".\n  */\nconst reverse = (a, b) => {\n  let a_char = a.split(\"\");\n  let b_char = b.split(\"\");\n  let result = b_char.concat(a_char);\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two strings in the order of the first string.\n  Assume the input is always valid.\n  Examples:\n  concat(\"Hello\", \"World\") should return \"HelloWorld\".\n  concat(\"Hello\", \"World\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  */\nconst reverse_concat = (a, b) => {\n  let a_char = a.split(\"\");\n  let b_char = b.split(\"\");\n  let result = a_char.concat(b_char);\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two strings in the order of the first string.\n  Assume the input is always valid.\n  Examples:\n  concat(\"Hello\", \"World\") should return \"HelloWorld\".\n  concat(\"Hello\", \"World\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  */\nconst reverse_reverse = (a, b) => {\n  let a_char = a.split(\"\");\n  let b_char = b.split(\"\");\n  let result = b_char.concat(a_char);\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two strings in the order of the second string.\n  Assume the input is always valid.\n  Examples:\n  concat(\"Hello\", \"World\") should return \"WorldHello\".\n  concat(\"Hello\", \"World\", \"!\") should return \"WorldHello!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"WorldHello!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"WorldHello!\".\n  */\nconst reverse_reverse_concat = (a, b) => {\n  let a_char = a.split(\"\");\n  let b_char = b.split(\"\");\n  let result = b_char.concat(a_char);\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two strings in the order of the first string.\n  Assume the input is always valid.\n  Examples:\n  concat(\"Hello\", \"World\") should return \"HelloWorld\".\n  concat(\"Hello\", \"World\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  */\nconst reverse_reverse_reverse = (a, b) => {\n  let a_char = a.split(\"\");\n  let b_char = b.split(\"\");\n  let result = a_char.concat(b_char);\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two strings in the order of the first string.\n  Assume the input is always valid.\n  Examples:\n  concat(\"Hello\", \"World\") should return \"HelloWorld\".\n  concat(\"Hello\", \"World\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  concat(\"Hello\", \"World\", \"!\", \"!\") should return \"HelloWorld!\".\n  */\nconst reverse_reverse_reverse_concat = (a, b) => {\n  let a_char = a.split(\"\");\n  let b_char = b.split(\"\");\n  let result = a_char.concat(b_char);\n  return result;\n};\n\n/*\n  Complete the function that takes two strings and returns the string that \n  contains the characters of the two", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a striig s, count the number of ulpercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "/*\n  Given a striig s, count the number of ulpercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countUpper('aBCdEf'));\nconsole.log(countUpper('abcdefg'));\nconsole.log(countUpper('dBBE'));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create a funrtion that takes a value (strinb) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "/* Create a funrtion that takes a value (strinb) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const num = parseInt(value, 10);\n  const diff = Math.abs(num - Math.round(num));\n  if (diff < 0.5) {\n    return Math.round(num);\n  } else if (diff > 0.5) {\n    return Math.round(num) + 1;\n  } else {\n    return Math.round(num) - 1;\n  }\n};\n\n/*\n  Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger2 = (value) => {\n  const num = parseFloat(value);\n  const diff = Math.abs(num - Math.round(num));\n  if (diff < 0.5) {\n    return Math.round(num);\n  } else if (diff > 0.5) {\n    return Math.round(num) + 1;\n  } else {\n    return Math.round(num) - 1;\n  }\n};\n\n/*\n  Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger3 = (value) => {\n  const num = parseFloat(value);\n  const diff = Math.abs(num - Math.round(num));\n  if (diff < 0.5) {\n    return Math.round(num);\n  } else if (diff > 0.5) {\n    return Math.round(num) + 1;\n  } else {\n    return Math.round(num) - 1;\n  }\n};\n\n/*\n  Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger4 = (value) => {\n  const num = parseFloat(value);\n  const diff = Math.abs(num - Math.round(num));\n  if (diff < 0.5) {\n    return Math.round(num);\n  } else if (diff > 0.5) {\n    return Math.round(num) + 1;\n  } else {\n    return Math.round(num) - 1;\n  }\n};\n\n/*\n  Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger5 = (value) => {\n  const num = parseFloat(value);\n  const diff = Math.abs(num - Math.round(num));\n  if (diff < 0.5) {\n    return Math.round(num);\n  } else if (diff > 0.5) {\n    return Math.round(num) + 1;\n  } else {\n    return Math.round(num) - 1;\n  }\n};\n\n/*\n  Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger6 = (value) => {\n  const num = parseFloat(value);\n  const diff = Math.abs(num - Math.round(num));\n  if (diff < 0.5) {\n    return Math.round(num);\n  } else", "passed": 0, "run_status": 1}
