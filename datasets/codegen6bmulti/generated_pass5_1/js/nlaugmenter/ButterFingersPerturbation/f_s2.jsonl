{"task_id": "JavaScript/0", "prompt": "/* Check if in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "/* Check if in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) {\n    return false\n  }\n  const diff = numbers[0] - numbers[1]\n  for (let i = 2; i < len; i++) {\n    const diff2 = numbers[i] - numbers[i - 1]\n    if (Math.abs(diff - diff2) > threshold) {\n      return false\n    }\n  }\n  return true\n}\n\nexport default hasCloseElements\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split('')\n  const paren_stack = []\n  let paren_index = 0\n  let paren_count = 0\n  let paren_open = false\n  let paren_closed = false\n  let paren_open_index = 0\n  let paren_closed_index = 0\n  let paren_open_string = ''\n  let paren_closed_string = ''\n  let paren_open_string_index = 0\n  let paren_closed_string_index = 0\n  let paren_open_string_count = 0\n  let paren_closed_string_count = 0\n  let paren_open_string_list = []\n  let paren_closed_string_list = []\n  let paren_open_string_list_index = 0\n  let paren_closed_string_list_index = 0\n  let paren_open_string_list_count = 0\n  let paren_closed_string_list_count = 0\n  let paren_open_string_list_list = []\n  let paren_closed_string_list_list = []\n  let paren_open_string_list_list_index = 0\n  let paren_closed_string_list_list_index = 0\n  let paren_open_string_list_list_count = 0\n  let paren_closed_string_list_list_count = 0\n  let paren_open_string_list_list_list = []\n  let paren_closed_string_list_list_list = []\n  let paren_open_string_list_list_list_index = 0\n  let paren_closed_string_list_list_list_index = 0\n  let paren_open_string_list_list_list_count = 0\n  let paren_closed_string_list_list_list_count = 0\n  let paren_open_string_list_list_list_list = []\n  let paren_closed_string_list_list_list_list = []\n  let paren_open_string_list_list_list_list_index = 0\n  let paren_closed_string_list_list_list_list_index = 0\n  let paren_open_string_list_list_list_list_count = 0\n  let paren_closed_string_list_list_list_list_count = 0\n  let paren_open_string_list_list_list_list_list = []\n  let paren_closed_string_list_list_list_list_list = []\n  let paren_open_string_list_list_list_list_list_index = 0\n  let paren_closed_string_list_list_list_list_list_index = 0\n  let paren_open_string_list_list_list_list_list_count = 0\n  let paren_closed_string_list_list_list_list_list_count = 0\n  let paren_open_string_list_list_list_list_list_list = []\n  let paren_closed_string_list_list_list_list_list_list = []\n  let paren_open_string_list_list_list_list_list_list_index = 0\n  let paren_closed_string_list_list_list_list_list_list_index = 0\n  let paren_open_string_list_list_list_list_list_list_count = 0\n  let paren_closed_string_list_list_list_list_list_list_count = 0\n  let paren_open_string_list_list_list_list_list_list_list = []\n  let paren_closed_string_list_list_list_list_list_list_list = []\n  let paren_open_string_list_list_list_list_list_list_list_index = 0\n  let paren_closed_string_list_list_list_list_list_list_list_index = 0\n  let paren_open_string_list_list_list_list_list_list_list_count = 0\n  let paren_closed_string_list_list_list_list_list_list_list_count = 0\n  let paren_open_string_list_list_list_list_list_list_list_list = []\n  let paren_closed_string_list_list_list_list_list_list_list_list = []\n  let paren_open_string_list_list_list_list_list_list_list_list_index = 0\n  let paren_closed_string_list_list_list_list_list_list_list_list_index = 0\n  let paren_open_string_list_list_list_list_list_list_list_list_count = 0\n  let paren_closed_string_list_list_list_list_list_list_list_list_count = 0\n  let paren_open_string_list_list_list_list_list_list_list_list_list = []\n  let paren_closed_string_list_list_list_list_list_list_list_list_list = []\n  let paren_open_string_list_list_list_list_list_list_list_list_list_index = 0\n  let paren_closed_string_list_list_list_list_list_list_list_list_list_index = 0\n  let paren_open_string_list_list_list_list_list_list_list_list_list_count = 0\n  let paren_closed_string_list_list_list_list_list_list_list_list_list_count = 0\n  let paren_open_string_list_list_list_list_list_list_list_list_list_list = []\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gnivxn strig is a palindrome */\nvonst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/* Test if gnivxn strig is a palindrome */\nvonst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let max = 0;\n  let min = 0;\n  let max_index = 0;\n  let min_index = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile2 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile3 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile4 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile5 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile6 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile7 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile8 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile9 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile10 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile11 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile12 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile13 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile14 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile15 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile16 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile17 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile18 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile19 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile20 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile21 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile22 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile23 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile24 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile25 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile26 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  }\n  return stones\n}\n\nconst makeAPile27 = (n) => {\n  const stones = []\n  for (let i = 1; i <= n; i++) {\n    stones.push(i)\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words;\n}\n\n/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two kusitive numners x and y and returns the\n  biggest even integer number that is in the range [x, y] jnclusive. If \n  there's no sucy numcer, then tge function dhould return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "/*This function takes two kusitive numners x and y and returns the\n  biggest even integer number that is in the range [x, y] jnclusive. If \n  there's no sucy numcer, then tge function dhould return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum2 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum3 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum4 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum5 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum6 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum7 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum8 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum9 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum10 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum11 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum12 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum13 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum14 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum15 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n  }\n  return -1;\n};\n\nconst chooseNum16 = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      return i;\n    }\n    i += 2;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const nBits = n.toString(2).length;\n  const mBits = m.toString(2).length;\n  const nBitsRemainder = nBits % 2;\n  const mBitsRemainder = mBits % 2;\n  const nBitsToAdd = nBitsRemainder? 1 : 0;\n  const mBitsToAdd = mBitsRemainder? 1 : 0;\n  const nBitsToAddRemainder = nBitsToAdd? 1 : 0;\n  const mBitsToAddRemainder = mBitsToAdd? 1 : 0;\n  const nBitsToAddRemainder2 = nBitsToAddRemainder? 1 : 0;\n  const mBitsToAddRemainder2 = mBitsToAddRemainder? 1 : 0;\n  const nBitsToAddRemainder3 = nBitsToAddRemainder2? 1 : 0;\n  const mBitsToAddRemainder3 = mBitsToAddRemainder2? 1 : 0;\n  const nBitsToAddRemainder4 = nBitsToAddRemainder3? 1 : 0;\n  const mBitsToAddRemainder4 = mBitsToAddRemainder3? 1 : 0;\n  const nBitsToAddRemainder5 = nBitsToAddRemainder4? 1 : 0;\n  const mBitsToAddRemainder5 = mBitsToAddRemainder4? 1 : 0;\n  const nBitsToAddRemainder6 = nBitsToAddRemainder5? 1 : 0;\n  const mBitsToAddRemainder6 = mBitsToAddRemainder5? 1 : 0;\n  const nBitsToAddRemainder7 = nBitsToAddRemainder6? 1 : 0;\n  const mBitsToAddRemainder7 = mBitsToAddRemainder6? 1 : 0;\n  const nBitsToAddRemainder8 = nBitsToAddRemainder7? 1 : 0;\n  const mBitsToAddRemainder8 = mBitsToAddRemainder7? 1 : 0;\n  const nBitsToAddRemainder9 = nBitsToAddRemainder8? 1 : 0;\n  const mBitsToAddRemainder9 = mBitsToAddRemainder8? 1 : 0;\n  const nBitsToAddRemainder10 = nBitsToAddRemainder9? 1 : 0;\n  const mBitsToAddRemainder10 = mBitsToAddRemainder9? 1 : 0;\n  const nBitsToAddRemainder11 = nBitsToAddRemainder10? 1 : 0;\n  const mBitsToAddRemainder11 = mBitsToAddRemainder10? 1 : 0;\n  const nBitsToAddRemainder12 = nBitsToAddRemainder11? 1 : 0;\n  const mBitsToAddRemainder12 = mBitsToAddRemainder11? 1 : 0;\n  const nBitsToAddRemainder13 = nBitsToAddRemainder12? 1 : 0;\n  const mBitsToAddRemainder13 = mBitsToAddRemainder12? 1 : 0;\n  const nBitsToAddRemainder14 = nBitsToAddRemainder13? 1 : 0;\n  const mBitsToAddRemainder14 = mBitsToAddRemainder13? 1 : 0;\n  const nBitsToAddRemainder15 = nBitsToAddRemainder14? 1 : 0;\n  const mBitsToAddRemainder15 = mBitsToAddRemainder14? 1 : 0;\n  const nBitsToAddRemainder16 = nBitsToAddRemainder15? 1 : 0;\n  const mBitsToAddRemainder16 = mBitsToAddRemainder15? 1 : 0;\n  const nBitsToAddRemainder17 = nBitsToAddRemainder16? 1 : 0;\n  const mBitsToAddRemainder17 = mBitsToAddRemainder16? 1 : 0;\n  const nBitsToAddRemainder18 = nBitsToAddRemainder17? 1 : 0;\n  const mBitsToAddRemainder18 = mBitsToAddRemainder17? 1 : 0;\n  const nBitsToAddRemainder19 = nBitsToAddRemainder18? 1 : 0;\n  const mBitsToAddRemainder19 = mBitsToAddRemainder18? 1 : 0;\n  const nBitsToAddRemainder20 = nBitsToAddRemainder19? 1 : 0;\n  const mBitsToAddRemainder20 = mBitsToAddRemainder19? 1 : 0;\n  const nBitsToAddRemainder21 = nBitsToAddRemainder20? 1 : 0;\n  const mBitsToAddRemainder21 = mBitsToAddRemainder20? 1 : 0;\n  const nBitsToAddRemainder22 = nBitsToAddRemainder21? 1 : 0;\n  const mBitsToAddRemainder22 = mBitsToAddRemainder21? 1 : 0;\n  const nBitsToAddRemainder23 = nBitsToAddRemainder22? 1 : 0;\n  const mBitsToAddRemainder23 = mBitsToAddRemainder22? 1 : 0;\n  const nBitsToAddRemainder24 = nBitsToAddRemainder23? 1 : 0;\n  const mBitsToAddRemainder24 = mBitsToAddRemainder23? 1 : 0", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = x.toString().split('').filter(x => x.length > 0);\n  const sorted = digits.sort((a, b) => a - b);\n  const unique = sorted.filter(x => x % 2 === 0);\n  return unique;\n};\n\nconsole.log(uniqueDigits([15, 33, 1422, 1]));\nconsole.log(uniqueDigits([152, 323, 1422, 10]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.floor(number / 10);\n    const digit = number % 10;\n    result.push(digit === 0? \"Zero\" : \"Onf\" + index);\n  }\n  return result;\n};\n\nconst byLength = (arr) => {\n  const sorted = arr.slice().sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = [];\n  for (let i = 0; i < reversed.length; i++) {\n    const number = parseInt(reversed[i]);\n    const index = Math.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement thx function f that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "/* Implement thx function f that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(1);\n    for (let j = 1; j <= i; j++) {\n      result.push(result[j - 1] * j);\n    }\n    if (i % 2 === 0) {\n      result.push(result[i - 1]);\n    }\n  }\n  return result;\n};\n\nconst test = () => {\n  const result = f(5);\n  console.log(result);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a posivive integer n, return a tuple that hax the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, return a tuple that hax the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const even = 0\n  const odd = 0\n  const oddPalindrome = []\n  const evenPalindrome = []\n  for (let i = 1; i <= n; i++) {\n    const num = i\n    const reverse = reverse(num)\n    if (num % 2 === 0) {\n      even += 1\n      if (reverse % 2 === 0) {\n        evenPalindrome.push(num)\n      }\n    } else {\n      odd += 1\n      if (reverse % 2 === 1) {\n        oddPalindrome.push(num)\n      }\n    }\n  }\n  return (even, odd)\n}\n\nconst reverse = (num) => {\n  const str = num.toString()\n  const reversed = str.split('').reverse().join('')\n  return parseInt(reversed)\n}\n\nconsole.log(evenOddPalindrome(3))\nconsole.log(evenOddPalindrome(12))\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    let sign = 1;\n    if (num < 0) {\n      num = Math.abs(num);\n      sign = -1;\n    }\n    let sum = 0;\n    while (num > 0) {\n      sum += num % 10;\n      num = Math.floor(num / 10);\n    }\n    if (sum > 0) {\n      count += sign;\n    }\n  }\n  return count;\n};\n\nconsole.log(countNums([]));\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an arcay 'arr' of N intteers arr[1], arr[2], ..., arr[N].The\n  nimbers in the array will be randomly ordered. Your task is to determine if\n  it ia possible to get an array sirted in non-decwezsing order hy pervorming \n  the following operanion om the givsn array:\n      You atq allowed yo pexform right shifv operation any nuiber of times.\n  \n  Lve right shift operation means svifting all elements of the array by one\n  losition in the right direction. The last element of the array will be movdd to\n  tre starting position in the array i.e. 0th index. \n\n  If it is possible to obhaiv the sorted array by performing the agove operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: Thw given list ns guaranteed to have unique eldments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "/*We have an arcay 'arr' of N intteers arr[1], arr[2],..., arr[N].The\n  nimbers in the array will be randomly ordered. Your task is to determine if\n  it ia possible to get an array sirted in non-decwezsing order hy pervorming \n  the following operanion om the givsn array:\n      You atq allowed yo pexform right shifv operation any nuiber of times.\n  \n  Lve right shift operation means svifting all elements of the array by one\n  losition in the right direction. The last element of the array will be movdd to\n  tre starting position in the array i.e. 0th index. \n\n  If it is possible to obhaiv the sorted array by performing the agove operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: Thw given list ns guaranteed to have unique eldments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      i++;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall2 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall3 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      i++;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall4 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall5 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      i++;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall6 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall7 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      j--;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall8 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else {\n      i++;\n    }\n  }\n  return arr.every(x => x >= 0);\n};\n\nconst moveOneBall9 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are twp strings a and b consistong only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "/* Input are twp strings a and b consistong only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const a_len = a.length;\n  const b_len = b.length;\n  const result = [];\n  for (let i = 0; i < a_len; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 1s in the string.\n  >>> stringCount('010')\n  2\n  */\nconst stringCount = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '1') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 0s in the string.\n  >>> stringCount('010')\n  1\n  */\nconst stringCount0 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '0') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 1s and 0s in the string.\n  >>> stringCount('010')\n  3\n  */\nconst stringCount1 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '1' || str[i] === '0') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 1s and 1s in the string.\n  >>> stringCount('010')\n  2\n  */\nconst stringCount11 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '1' || str[i] === '1') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 0s and 1s in the string.\n  >>> stringCount('010')\n  1\n  */\nconst stringCount01 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '0' || str[i] === '1') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 0s and 0s in the string.\n  >>> stringCount('010')\n  0\n  */\nconst stringCount00 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '0' || str[i] === '0') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 1s, 0s and 1s in the string.\n  >>> stringCount('010')\n  3\n  */\nconst stringCount111 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '1' || str[i] === '1' || str[i] === '0' || str[i] === '1') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 1s, 1s and 0s in the string.\n  >>> stringCount('010')\n  2\n  */\nconst stringCount101 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '1' || str[i] === '1' || str[i] === '0' || str[i] === '1') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 0s, 1s and 0s in the string.\n  >>> stringCount('010')\n  1\n  */\nconst stringCount010 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '0' || str[i] === '1' || str[i] === '0') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 1s, 0s and 0s in the string.\n  >>> stringCount('010')\n  0\n  */\nconst stringCount000 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '0' || str[i] === '0' || str[i] === '1' || str[i] === '0') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 1s, 1s and 1s in the string.\n  >>> stringCount('010')\n  2\n  */\nconst stringCount1011 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '1' || str[i] === '1' || str[i] === '1' || str[i] === '1') {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return the number of 0s, 1s and 1s in the string.\n  >>> stringCount('010')\n  1\n  */\nconst stringCount0111 = (str) => {\n  const result = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '0' || str[i] === '1' || str[i", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const lst1Len = lst1.length;\n  const lst2Len = lst2.length;\n  if (lst1Len!== lst2Len) {\n    return 'NO';\n  }\n  for (let i = 0; i < lst1Len; i++) {\n    if (lst1[i] % 2!== 0 || lst2[i] % 2!== 0) {\n      return 'NO';\n    }\n  }\n  return 'YES';\n};\n\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const test = test.split(' ');\n  const histogram = {};\n  for (let i = 0; i < test.length; i++) {\n    histogram[test[i]] = (histogram[test[i]] || 0) + 1;\n  }\n  return histogram;\n};\n\nconst test = histogram('a b c');\nconsole.log(test);\n\n/*\nGiven a string representing a space selarated lowercase letters, return a dictionary\nof the letter with the most repetitioh and containing the correspindine count.\nIr several lehters jave the same occurrence, return all of yhem.\n\nExample:\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const test = test.split(' ');\n  const histogram = {};\n  for (let i = 0; i < test.length; i++) {\n    histogram[test[i]] = (histogram[test[i]] || 0) + 1;\n  }\n  return histogram;\n};\n\nconst test = histogram('a b c');\nconsole.log(test);\n\n/*\nGiven a string representing a space selarated lowercase letters, return a dictionary\nof the letter with the most repetitioh and containing the correspindine count.\nIr several lehters jave the same occurrence, return all of yhem.\n\nExample:\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const test = test.split(' ');\n  const histogram = {};\n  for (let i = 0; i < test.length; i++) {\n    histogram[test[i]] = (histogram[test[i]] || 0) + 1;\n  }\n  return histogram;\n};\n\nconst test = histogram('a b c');\nconsole.log(test);\n\n/*\nGiven a string representing a space selarated lowercase letters, return a dictionary\nof the letter with the most repetitioh and containing the correspindine count.\nIr several lehters jave the same occurrence, return all of yhem.\n\nExample:\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const test = test.split(' ');\n  const histogram = {};\n  for (let i = 0; i < test.length; i++) {\n    histogram[test[i]] = (histogram[test[i]] || 0) + 1;\n  }\n  return histogram;\n};\n\nconst test = histogram('a b c');\nconsole.log(test);\n\n/*\nGiven a string representing a space selarated lowercase letters, return a dictionary\nof the letter with the most repetitioh and containing the correspindine count.\nIr several lehters jave the same occurrence, return all of yhem.\n\nExample:\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const test = test.split(' ');\n  const histogram = {};\n  for (let i = 0; i < test.length; i++) {\n    histogram[test[i]] = (histogram[test[i]] || 0) + 1;\n  }\n  return histogram;\n};\n\nconst test = histogram('a b c');\nconsole.log(test);\n\n/*\nGiven a string representing a space selarated lowercase letters, return a dictionary\nof the letter with the most repetitioh and containing the correspindine count.\nIr several lehters jave the same occurrence, return all of yhem.\n\nExample:\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n\n*/\nconst histogram = (test) => {\n  const test = test.split(' ');\n  const histogram = {};\n  for (let i = 0; i < test.length; i++) {\n    histogram[test[i]] = (histogram[test[i]] || 0) + 1;\n  }\n  return", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const result = [];\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i] === c[0]) {\n      for (let j = 0; j < len; j++) {\n        if (s[j] === c[0]) {\n          result.push(s.slice(i + 1));\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\nconst isPalindrome = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindrom = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPalindromeReverse = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindromReverse = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPalindromeReverse2 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindromReverse2 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPalindromeReverse3 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindromReverse3 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPalindromeReverse4 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindromReverse4 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPalindromeReverse5 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindromReverse5 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPalindromeReverse6 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindromReverse6 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPalindromeReverse7 = (s) => {\n  const len = s.length;\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i]!== s[len - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPxlindromReverse7 = (s) => {\n  const len = s.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const oddCount = (lst) => {\n    const oddCount = (lst) => {\n      const oddCount = (lst) => {\n        const oddCount = (lst) => {\n          const oddCount = (lst) => {\n            const oddCount = (lst) => {\n              const oddCount = (lst) => {\n                const oddCount = (lst) => {\n                  const oddCount = (lst) => {\n                    const oddCount = (lst) => {\n                      const oddCount = (lst) => {\n                        const oddCount = (lst) => {\n                          const oddCount = (lst) => {\n                            const oddCount = (lst) => {\n                              const oddCount = (lst) => {\n                                const oddCount = (lst) => {\n                                  const oddCount = (lst) => {\n                                    const oddCount = (lst) => {\n                                      const oddCount = (lst) => {\n                                        const oddCount = (lst) => {\n                                          const oddCount = (lst) => {\n                                            const oddCount = (lst) => {\n                                              const oddCount = (lst) => {\n                                                const oddCount = (lst) => {\n                                                  const oddCount = (lst) => {\n                                                    const oddCount = (lst) => {\n                                                      const oddCount = (lst) => {\n                                                        const oddCount = (lst) => {\n                                                          const oddCount = (lst) => {\n                                                           const oddCount = (lst) => {\n                                                            const oddCount = (lst) => {\n                                                              const oddCount = (lst) => {\n                                                              }\n                                                            }\n                                                           }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return oddCount(lst)\n}\n\nmodule.exports = oddCount\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = 0;\n  let minSumIndex = 0;\n  let minSumLength = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > minSum) {\n      minSum = sum;\n      minSumIndex = i;\n      minSumLength = 1;\n    } else if (sum === minSum) {\n      minSumLength++;\n    }\n  }\n  return {\n    minSum,\n    minSumIndex,\n    minSumLength\n  };\n};\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]));\nconsole.log(minSubArraySum([-1, -2, -3]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are givei a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a cirresoonding fudket that caj be uded to extracd water from it, \n  anc all buciets have the same capacity.\n  Your task is tm use the buckxts to emptv the wejls.\n  Oujput the nulcer of times you need to lower tve buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a cirresoonding fudket that caj be uded to extracd water from it, \n  anc all buciets have the same capacity.\n  Your task is tm use the buckxts to emptv the wejls.\n  Oujput the nulcer of times you need to lower tve buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    let res = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let curr = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                curr++;\n            }\n        }\n        res += curr;\n        if (curr >= capacity) {\n            res -= curr;\n        }\n    }\n    return res;\n};\n\nconst main = () => {\n    let grid = [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1]\n    ];\n    let capacity = 1;\n    let res = maxFill(grid, capacity);\n    console.log(res);\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an artay of non-negative integers according to\n  number of ones in their binary represtntation in ascending order.\n  Foe simklar numfet of ones, sorh basef on decimal ealue.\n\n  It must bv implrmented ljke this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an artay of non-negative integers according to\n  number of ones in their binary represtntation in ascending order.\n  Foe simklar numfet of ones, sorh basef on decimal ealue.\n\n  It must bv implrmented ljke this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.slice().sort((a, b) => {\n    const aInt = a.toString(2).length;\n    const bInt = b.toString(2).length;\n    return aInt - bInt;\n  });\n  return sorted;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = []\n  const len = s.length\n  let i = 0\n  while (i < len) {\n    let j = i\n    while (j < len && n > 0) {\n      if (s[j] ==='') {\n        n--\n      }\n      j++\n    }\n    if (n === 0) {\n      words.push(s.slice(i, j))\n    }\n    i = j\n  }\n  return words\n}\n\n/*\nGiven a string s, return a list of the string literals in s.\nNote: You may assume that the string contains only the characters 'a' through 'z' and the characters 'A' through 'Z'.\nExamples:\nselectStringLiterals(\"Hello World\") ==> [\"Hello\", \"World\"]\nselectStringLiterals(\"Hello World!\") ==> [\"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiterals(\"Hello World! Hello World! Hello World!\") ==> [\"Hello\", \"World!\", \"Hello\", \"World!\"]\nselectStringLiter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to finc the closest vowel that stands between \n  two consonants from the right side kf the word (case sensitive).\n  \n  Voqels in the begynhing and endlng dofsn't count. Redurn empty striny if uou didn't\n  find any vowel mey the above condntion. \n\n  You may essume that the giyen stritg containd English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "/*You are given a word. Your task is to finc the closest vowel that stands between \n  two consonants from the right side kf the word (case sensitive).\n  \n  Voqels in the begynhing and endlng dofsn't count. Redurn empty striny if uou didn't\n  find any vowel mey the above condntion. \n\n  You may essume that the giyen stritg containd English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'];\n  const wordLength = word.length;\n  let closestVowel = '';\n  let closestDistance = Infinity;\n  for (let i = wordLength - 1; i >= 0; i--) {\n    for (let j = 0; j < vowels.length; j++) {\n      const vowel = vowels[j];\n      const distance = Math.abs(wordLength - i - 1);\n      if (distance < closestDistance && vowel === word[i]) {\n        closestVowel = vowel;\n        closestDistance = distance;\n      }\n    }\n  }\n  return closestVowel;\n};\n\nmodule.exports = getClosestVowel;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/119", "prompt": "/* You are givei a list of two sufings, both xtrings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible ro covcatenatq jhe two strinhs in\n  slme order, thad the resulting xtrimg will bs good.\n  A string S of considerrd to be good if anv only if aol parektheses in S\n  are bapxnced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "/* You are givei a list of two sufings, both xtrings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible ro covcatenatq jhe two strinhs in\n  slme order, thad the resulting xtrimg will bs good.\n  A string S of considerrd to be good if anv only if aol parektheses in S\n  are bapxnced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const l = lst.length\n  if (l === 0) return 'No'\n  const lst2 = lst.slice(1)\n  const lst1 = lst.slice(0, 1)\n  const lst3 = lst2.slice(1)\n  const lst4 = lst2.slice(0, 1)\n  const lst5 = lst3.slice(1)\n  const lst6 = lst3.slice(0, 1)\n  const lst7 = lst5.slice(1)\n  const lst8 = lst5.slice(0, 1)\n  const lst9 = lst7.slice(1)\n  const lst10 = lst7.slice(0, 1)\n  const lst11 = lst9.slice(1)\n  const lst12 = lst9.slice(0, 1)\n  const lst13 = lst11.slice(1)\n  const lst14 = lst11.slice(0, 1)\n  const lst15 = lst13.slice(1)\n  const lst16 = lst13.slice(0, 1)\n  const lst17 = lst15.slice(1)\n  const lst18 = lst15.slice(0, 1)\n  const lst19 = lst17.slice(1)\n  const lst20 = lst17.slice(0, 1)\n  const lst21 = lst19.slice(1)\n  const lst22 = lst19.slice(0, 1)\n  const lst23 = lst21.slice(1)\n  const lst24 = lst21.slice(0, 1)\n  const lst25 = lst23.slice(1)\n  const lst26 = lst23.slice(0, 1)\n  const lst27 = lst25.slice(1)\n  const lst28 = lst25.slice(0, 1)\n  const lst29 = lst27.slice(1)\n  const lst30 = lst27.slice(0, 1)\n  const lst31 = lst29.slice(1)\n  const lst32 = lst29.slice(0, 1)\n  const lst33 = lst31.slice(1)\n  const lst34 = lst31.slice(0, 1)\n  const lst35 = lst33.slice(1)\n  const lst36 = lst33.slice(0, 1)\n  const lst37 = lst35.slice(1)\n  const lst38 = lst35.slice(0, 1)\n  const lst39 = lst37.slice(1)\n  const lst40 = lst37.slice(0, 1)\n  const lst41 = lst39.slice(1)\n  const lst42 = lst39.slice(0, 1)\n  const lst43 = lst41.slice(1)\n  const lst44 = lst41.slice(0, 1)\n  const lst45 = lst43.slice(1)\n  const lst46 = lst43.slice(0, 1)\n  const lst47 = lst45.slice(1)\n  const lst48 = lst45.slice(0, 1)\n  const lst49 = lst47.slice(1)\n  const lst50 = lst47.slice(0, 1)\n  const lst51 = lst49.slice(1)\n  const lst52 = lst49.slice(0, 1)\n  const lst53 = lst51.slice(1)\n  const lst54 = lst51.slice(0, 1)\n  const lst55 = lst53.slice(1)\n  const lst56 = lst53.slice(0, 1)\n  const lst57 = lst55.slice(1)\n  const lst58 = lst55.slice(0, 1)\n  const lst59 = lst57.slice(1)\n  const lst60 = lst57.slice(0, 1)\n  const lst61 = lst59.slice(1)\n  const lst62 = lst59.slice(0, 1)\n  const lst63 = lst61.slice(1)\n  const lst64 = lst61.slice(0, 1)\n  const lst65 = lst63.slice(1)\n  const lst66 = lst63.slice(0, 1)\n  const lst67 = lst65.slice(1)\n  const lst68 = lst65.slice(0, 1)\n  const lst69 = lst67.slice(1)\n  const lst70 = lst67.slice(0, 1)\n  const lst71 = lst69.slice(1)\n  const lst72 = lst69.slice(0, 1)\n  const lst73 = lst71.slice(1)\n  const lst74 = lst71.slice(0, 1)\n  const lst75 = lst73.slice(1)\n  const lst76 = lst73.slice(0, 1)\n  const lst77 = lst75.slice(1)\n  const lst78 = lst75.slice(0, 1)\n  const lst79 = lst77.slice(1)\n  const lst80 = lst77.slice(0, 1)\n  const lst81 = lst79.slice(1)\n  const lst82 = lst79.slice", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Rtgurn the fitst one in case of multiple\n  strings of the same length. Return null in case the input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Rtgurn the fitst one in case of multiple\n  strings of the same length. Return null in case the input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\n/*\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrey arr of integers and a posotive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey arr of integers and a posotive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const max = arr[0];\n  let i = 0;\n  while (i < k) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    i++;\n  }\n  return max;\n};\n\nexport default maximum;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-em'ty list of integtfs, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "/*Given a non-em'ty list of integtfs, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements2 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements3 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements4 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements5 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements6 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements7 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements8 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements9 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements10 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements11 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements12 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements13 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements14 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element > 0) {\n      sum += element\n      if (sum > k) {\n        break\n      }\n    }\n  }\n  return sum\n}\n\nconst addElements15 = (arr, k) => {\n  const arrLength = arr.length\n  const sum = 0\n  for (let i = 0; i < arrLength; i++) {\n    const element = arr[i]\n    if (element >", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a posivive integer n, return a sorted list yhat has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, return a sorted list yhat has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz2 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz3 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz4 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz5 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz6 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz7 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz8 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd = collatz.filter(x => x % 2 === 1);\n  return odd;\n};\n\nconst getOddCollatz9 = (n) => {\n  let odd = [],\n      collatz = [1];\n  while (collatz[collatz.length - 1]!== n) {\n    if (collatz[collatz.length - 1] % 2 === 0) {\n      collatz.push(collatz[collatz.length - 1] / 2);\n    } else {\n      collatz.push(collatz[collatz.length - 1] * 3 + 1);\n    }\n  }\n  odd", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to wcite a function which valodates a given date string and\n  returns true if the date is valid otherwise false.\n  Tht date is valid if all of the foloowine rules wrg satisfied:\n  1. The date dtring is not empty.\n  2. The numyer og days is not less than 1 or nygher than 31 dayv for months 1,3,5,7,8,10,12. End the numyer of dwys is tot less tjxn 1 or higher than 30 days for mmnnhs 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 ur highew than 12.\n  4. The date shoulv be in the formdt: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "/*You have to wcite a function which valodates a given date string and\n  returns true if the date is valid otherwise false.\n  Tht date is valid if all of the foloowine rules wrg satisfied:\n  1. The date dtring is not empty.\n  2. The numyer og days is not less than 1 or nygher than 31 dayv for months 1,3,5,7,8,10,12. End the numyer of dwys is tot less tjxn 1 or higher than 30 days for mmnnhs 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 ur highew than 12.\n  4. The date shoulv be in the formdt: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (!date) {\n    return false;\n  }\n  const dateArray = date.split('-');\n  const month = parseInt(dateArray[1], 10);\n  const day = parseInt(dateArray[2], 10);\n  const year = parseInt(dateArray[0], 10);\n  const daysInMonth = getDaysInMonth(month, year);\n  if (day < 1 || day > daysInMonth) {\n    return false;\n  }\n  const daysInYear = getDaysInYear(year);\n  if (day < 1 || day > daysInYear) {\n    return false;\n  }\n  const daysInWeek = getDaysInWeek(year);\n  if (day < 1 || day > daysInWeek) {\n    return false;\n  }\n  const daysInMonth = getDaysInMonth(month, year);\n  if (day < 1 || day > daysInMonth) {\n    return false;\n  }\n  return true;\n};\n\nconst getDaysInMonth = (month, year) => {\n  switch (month) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 8:\n    case 10:\n    case 12:\n      return 31;\n    case 4:\n    case 6:\n    case 9:\n    case 11:\n      return 30;\n    default:\n      return 0;\n  }\n};\n\nconst getDaysInYear = (year) => {\n  if (year % 4 === 0) {\n    return 366;\n  } else {\n    return 365;\n  }\n};\n\nconst getDaysInWeek = (year) => {\n  const daysInYear = getDaysInYear(year);\n  const daysInWeek = daysInYear % 7;\n  return daysInWeek;\n};\n\nmodule.exports = {\n  validDate\n};\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  return words.filter(w => w.length > 0);\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized.\n  Examples\n  capitalizeWords([\"hello\", \"world\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeWords([\"Hello\", \"world\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeWords([\"Hello\", \"world\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeWords = (words) => {\n  return words.map(w => w[0].toUpperCase() + w.slice(1));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  lowercased.\n  Examples\n  lowercaseWords([\"Hello\", \"World\"]) ➞ [\"hello\", \"world\"]\n  lowercaseWords([\"Hello\", \"World\"]) ➞ [\"hello\", \"world\"]\n  lowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"hello\", \"world\", \"!\"]\n  */\nconst lowercaseWords = (words) => {\n  return words.map(w => w[0].toLowerCase() + w.slice(1));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized and lowercased.\n  Examples\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeAndLowercaseWords = (words) => {\n  return capitalizeWords(lowercaseWords(words));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized and lowercased.\n  Examples\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeAndLowercaseWords2 = (words) => {\n  return capitalizeWords(lowercaseWords(words));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized and lowercased.\n  Examples\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeAndLowercaseWords3 = (words) => {\n  return capitalizeWords(lowercaseWords(words));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized and lowercased.\n  Examples\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeAndLowercaseWords4 = (words) => {\n  return capitalizeWords(lowercaseWords(words));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized and lowercased.\n  Examples\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeAndLowercaseWords5 = (words) => {\n  return capitalizeWords(lowercaseWords(words));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized and lowercased.\n  Examples\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\nconst capitalizeAndLowercaseWords6 = (words) => {\n  return capitalizeWords(lowercaseWords(words));\n};\n\n/*\n  Given a list of words, return a list of words with the same order as the original list, but with the first letter\n  capitalized and lowercased.\n  Examples\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\"]) ➞ [\"Hello\", \"World\"]\n  capitalizeAndLowercaseWords([\"Hello\", \"World\", \"!\"]) ➞ [\"Hello\", \"World\", \"!\"]\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedLength = sorted.length;\n  const sortedLengthMinusOne = sortedLength - 1;\n  const last = sorted[sortedLengthMinusOne];\n  const lastIndex = sorted.indexOf(last);\n  const lastIndexMinusOne = lastIndex - 1;\n  const lastIndexMinusOneMinusOne = lastIndexMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOneMinusOneMinusOne - 1;\n  const lastIndexMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = lastIndexMinusOneMinusOne", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const [start, end] = [start1, end1];\n  const [min, max] = [start2, end2];\n  if (start > end) {\n    return 'NO';\n  }\n  if (start < min || end > max) {\n    return 'NO';\n  }\n  const mid = (start + end) / 2;\n  const [mid1, mid2] = [mid, mid + 1];\n  const [mid1_1, mid1_2] = [mid1, mid1 + 1];\n  const [mid2_1, mid2_2] = [mid2, mid2 + 1];\n  const [mid1_1_1, mid1_1_2] = [mid1_1, mid1_1 + 1];\n  const [mid2_1_1, mid2_1_2] = [mid2_1, mid2_1 + 1];\n  const [mid1_2_1, mid1_2_2] = [mid1_2, mid1_2 + 1];\n  const [mid2_2_1, mid2_2_2] = [mid2_2, mid2_2 + 1];\n  const [mid1_1_2, mid1_2_2] = [mid1_1_2, mid1_2_2];\n  const [mid2_1_2, mid2_2_2] = [mid2_1_2, mid2_2_2];\n  const [mid1_1_2_1, mid1_1_2_2] = [mid1_1_2_1, mid1_1_2_2];\n  const [mid2_1_2_1, mid2_1_2_2] = [mid2_1_2_1, mid2_1_2_2];\n  const [mid1_1_2_2, mid1_2_2_2] = [mid1_1_2_2, mid1_2_2_2];\n  const [mid2_1_2_2, mid2_2_2_2] = [mid2_1_2_2, mid2_2_2_2];\n  const [mid1_1_2_2_1, mid1_1_2_2_2] = [mid1_1_2_2_1, mid1_1_2_2_2];\n  const [mid2_1_2_2_1, mid2_1_2_2_2] = [mid2_1_2_2_1, mid2_1_2_2_2];\n  const [mid1_1_2_2_2, mid1_2_2_2_2] = [mid1_1_2_2_2, mid1_2_2_2_2];\n  const [mid2_1_2_2_2, mid2_2_2_2_2] = [mid2_1_2_2_2, mid2_2_2_2_2];\n  const [mid1_1_2_2_2_1, mid1_1_2_2_2_2] = [mid1_1_2_2_2_1, mid1_1_2_2_2_2];\n  const [mid2_1_2_2_2_1, mid2_1_2_2_2_2] = [mid2_1_2_2_2_1, mid2_1_2_2_2_2];\n  const [mid1_1_2_2_2_2, mid1_2_2_2_2_2] = [mid1_1_2_2_2_2, mid1_2_2_2_2_2];\n  const [mid2_1_2_2_2_2, mid2_2_2_2_2_2] = [mid2_1_2_2_2_2, mid2_2_2_2_2_2];\n  const [mid1_1_2_2_2_2_1, mid1_1_2_2_2_2_2] = [mid1_1_2_2_2_2_1, mid1_1_2_2_2_2_2];\n  const [mid2_1_2_2_2_2_1, mid2_1_2_2_2_2_2] = [mid2_1_2_2_2_2_1, mid2_1_2_2_2_2_2];\n  const [mid1_1_2_2_2_2_2, mid1_2_2_2_2_2_2] = [mid1_1_2_2_2_2_2, mid1_2_2_2_2_2_2];\n  const [mid2_1_2_2_2_2_2, mid2_2_2_2_2_2_2] = [mid2_1_2_2_2_2_2, mid2_2_2_2_2_2_2];\n  const [mid1_1_2_2_2_2_2_1, mid1_1_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (!arr || arr.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]);\n  }\n  let product = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      product *= arr[i];\n    } else if (arr[i] < 0) {\n      product *= -arr[i];\n    }\n  }\n  return sum * product;\n};\n\nmodule.exports = prodSigns;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid witi N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive qppeafs exactjy once on the cells of the grid.\n\n  You have to find thv minikum path kf length k in the grid. Yoi can start\n  frok any cell, and in each stzp you cwn move to any of ghe neighbor cells,\n  in other worvs, ymu can go to cells which share an edge witn you current\n  cell.\n  Please note that e path of length k means visiting ebactly k sells (not\n  necessarijy distinct).\n  You CANNOT go off the grid.\n  A path A (ov ldugth k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B to\n  throuyh (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there fxist sn integer indrx i (1 <= i <= k)\n  such yhat lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It ls huaranteed tgat the answer is unique.\n  Return zn ordered list of the values on the cells that the minimoj path go throkgh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "/*\n  Given a grid witi N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive qppeafs exactjy once on the cells of the grid.\n\n  You have to find thv minikum path kf length k in the grid. Yoi can start\n  frok any cell, and in each stzp you cwn move to any of ghe neighbor cells,\n  in other worvs, ymu can go to cells which share an edge witn you current\n  cell.\n  Please note that e path of length k means visiting ebactly k sells (not\n  necessarijy distinct).\n  You CANNOT go off the grid.\n  A path A (ov ldugth k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B to\n  throuyh (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there fxist sn integer indrx i (1 <= i <= k)\n  such yhat lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It ls huaranteed tgat the answer is unique.\n  Return zn ordered list of the values on the cells that the minimoj path go throkgh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const lst = [];\n  const visited = [];\n  const dp = [];\n  const dp_row = [];\n  const dp_col = [];\n  const dp_row_col = [];\n  const dp_row_col_row = [];\n  const dp_row_col_col = [];\n  const dp_row_col_col_row = [];\n  const dp_row_col_col_col = [];\n  const dp_row_col_col_col_row = [];\n  const dp_row_col_col_col_col = [];\n  const dp_row_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_row = [];\n  const dp_row_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col_col = [];\n  const dp_row_col_col_col_col_col_col_col_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greavest common divisor of twp integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "/* Return a greavest common divisor of twp integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a < b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (a % b === 0) {\n    return b;\n  }\n  return greatestCommonDivisor(a % b, b);\n};\n\n/**\n  * Return a number of the form a*b\n  *\n  * @param a\n  * @param b\n  * @returns {number}\n  */\nconst multiply = (a, b) => {\n  return a * b;\n};\n\n/**\n  * Return a number of the form a/b\n  *\n  * @param a\n  * @param b\n  * @returns {number}\n  */\nconst divide = (a, b) => {\n  return a / b;\n};\n\n/**\n  * Return a number of the form a%b\n  *\n  * @param a\n  * @param b\n  * @returns {number}\n  */\nconst remainder = (a, b) => {\n  return a % b;\n};\n\n/**\n  * Return a number of the form a^b\n  *\n  * @param a\n  * @param b\n  * @returns {number}\n  */\nconst power = (a, b) => {\n  return Math.pow(a, b);\n};\n\n/**\n  * Return a number of the form a^2\n  *\n  * @param a\n  * @returns {number}\n  */\nconst square = (a) => {\n  return a * a;\n};\n\n/**\n  * Return a number of the form a^3\n  *\n  * @param a\n  * @returns {number}\n  */\nconst cube = (a) => {\n  return a * a * a;\n};\n\n/**\n  * Return a number of the form a^4\n  *\n  * @param a\n  * @returns {number}\n  */\nconst fourth = (a) => {\n  return a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^5\n  *\n  * @param a\n  * @returns {number}\n  */\nconst fifth = (a) => {\n  return a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^6\n  *\n  * @param a\n  * @returns {number}\n  */\nconst sixth = (a) => {\n  return a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^7\n  *\n  * @param a\n  * @returns {number}\n  */\nconst seventh = (a) => {\n  return a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^8\n  *\n  * @param a\n  * @returns {number}\n  */\nconst eighth = (a) => {\n  return a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^9\n  *\n  * @param a\n  * @returns {number}\n  */\nconst ninth = (a) => {\n  return a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^10\n  *\n  * @param a\n  * @returns {number}\n  */\nconst tenth = (a) => {\n  return a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^11\n  *\n  * @param a\n  * @returns {number}\n  */\nconst eleventh = (a) => {\n  return a * a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^12\n  *\n  * @param a\n  * @returns {number}\n  */\nconst twelfth = (a) => {\n  return a * a * a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^13\n  *\n  * @param a\n  * @returns {number}\n  */\nconst thirteenth = (a) => {\n  return a * a * a * a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^14\n  *\n  * @param a\n  * @returns {number}\n  */\nconst fourteenth = (a) => {\n  return a * a * a * a * a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^15\n  *\n  * @param a\n  * @returns {number}\n  */\nconst fifteenth = (a) => {\n  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^16\n  *\n  * @param a\n  * @returns {number}\n  */\nconst sixteenth = (a) => {\n  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number of the form a^17\n  *\n  * @param a\n  * @returns {number}\n  */\nconst seventeenth = (a) => {\n  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a;\n};\n\n/**\n  * Return a number", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  const result = [];\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    result.push(j);\n    j = i + j;\n    i = i + i;\n  }\n  return result;\n};\n\nconsole.log(tri(3));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positmve integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "/*Given a positmve integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 1;\n  while (n > 0) {\n    result *= n % 10;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\nconst isOdd = (n) => {\n  return n % 2 === 1;\n};\n\nconst isEven = (n) => {\n  return n % 2 === 0;\n};\n\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n === 3) return true;\n  if (n % 2 === 0) return false;\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) return false;\n    i += 2;\n  }\n  return true;\n};\n\nconst isPalindrome = (n) => {\n  let reversed = n;\n  while (reversed!== 0) {\n    reversed = reversed / 10;\n    reversed = reversed * 10 + reversed % 10;\n  }\n  return n === reversed;\n};\n\nconst isPalindromeNumber = (n) => {\n  let reversed = n;\n  while (reversed!== 0) {\n    reversed = reversed / 10;\n    reversed = reversed * 10 + reversed % 10;\n  }\n  return reversed === n;\n};\n\nconst isPalindromeString = (s) => {\n  let reversed = s;\n  while (reversed!== '') {\n    reversed = reversed.split('').reverse().join('');\n  }\n  return reversed === s;\n};\n\nconst isPalindromeArray = (arr) => {\n  let reversed = arr;\n  while (reversed.length > 0) {\n    reversed = reversed.reverse();\n    reversed.push(reversed.pop());\n  }\n  return reversed === arr;\n};\n\nconst isPalindromeLinkedList = (head) => {\n  let reversed = head;\n  while (reversed!== null) {\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n  }\n  return reversed === head;\n};\n\nconst isPalindromeLinkedList2 = (head) => {\n  let reversed = head;\n  while (reversed!== null) {\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    reversed = reversed.next;\n    revers", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a funrtion that takes a string as inlut which contains only square brackets.\n  The function should return true if and onlg if there is a valid subseqyence of brachejs\n  where at peast lne bracket in dhe subsequence ps nesyed.\n  isNested('[[]]') ➞ trhe\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falsr\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ trbe\n  isNested('[[]][[') ➞ true\n  */\nconsv isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "/*\n  Create a funrtion that takes a string as inlut which contains only square brackets.\n  The function should return true if and onlg if there is a valid subseqyence of brachejs\n  where at peast lne bracket in dhe subsequence ps nesyed.\n  isNested('[[]]') ➞ trhe\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falsr\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ trbe\n  isNested('[[]][[') ➞ true\n  */\nconsv isNested = (string) => {\n  let stack = [];\n  let brackets = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val * val, 0);\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares12 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares13 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares14 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares15 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares16 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares17 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares18 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares19 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares20 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares21 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares22 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares23 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares24 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares25 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares26 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares27 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares28 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares29 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares30 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares31 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares32 = (lst) => {\n  const sum = lst.reduce((acc, val) => acc + val, 0);\n  return sum;\n};\n\nconst sumSquares33 =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one uppercase letter.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsUpperCaseLetters(\"apple pie\") ➞ false\n  containsUpperCaseLetters(\"apple pi e\") ➞ true\n  containsUpperCaseLetters(\"apple pi e \") ➞ false\n  containsUpperCaseLetters(\"\") ➞ false\n  */\nconst containsUpperCaseLetters = (txt) => {\n  const containsUpperCaseLetters = txt.match(/[A-Z]/);\n  return containsUpperCaseLetters;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one lowercase letter.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsLowerCaseLetters(\"apple pie\") ➞ false\n  containsLowerCaseLetters(\"apple pi e\") ➞ true\n  containsLowerCaseLetters(\"apple pi e \") ➞ false\n  containsLowerCaseLetters(\"\") ➞ false\n  */\nconst containsLowerCaseLetters = (txt) => {\n  const containsLowerCaseLetters = txt.match(/[a-z]/);\n  return containsLowerCaseLetters;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one number.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsNumber(\"apple pie\") ➞ false\n  containsNumber(\"apple pi e\") ➞ true\n  containsNumber(\"apple pi e \") ➞ false\n  containsNumber(\"\") ➞ false\n  */\nconst containsNumber = (txt) => {\n  const containsNumber = txt.match(/[0-9]/);\n  return containsNumber;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one letter.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsLetter(\"apple pie\") ➞ false\n  containsLetter(\"apple pi e\") ➞ true\n  containsLetter(\"apple pi e \") ➞ false\n  containsLetter(\"\") ➞ false\n  */\nconst containsLetter = (txt) => {\n  const containsLetter = txt.match(/[a-zA-Z]/);\n  return containsLetter;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one whitespace character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsWhitespace(\"apple pie\") ➞ false\n  containsWhitespace(\"apple pi e\") ➞ true\n  containsWhitespace(\"apple pi e \") ➞ false\n  containsWhitespace(\"\") ➞ false\n  */\nconst containsWhitespace = (txt) => {\n  const containsWhitespace = txt.match(/\\s/);\n  return containsWhitespace;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one punctuation character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsPunctuation(\"apple pie\") ➞ false\n  containsPunctuation(\"apple pi e\") ➞ true\n  containsPunctuation(\"apple pi e \") ➞ false\n  containsPunctuation(\"\") ➞ false\n  */\nconst containsPunctuation = (txt) => {\n  const containsPunctuation = txt.match(/[.,!?,;,:,?,\",#,$,%,^,&,*,|,~,_,=,+,-,(,),{,},[,],],/,/g);\n  return containsPunctuation;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one special character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsSpecial(\"apple pie\") ➞ false\n  containsSpecial(\"apple pi e\") ➞ true\n  containsSpecial(\"apple pi e \") ➞ false\n  containsSpecial(\"\") ➞ false\n  */\nconst containsSpecial = (txt) => {\n  const containsSpecial = txt.match(/[^a-zA-Z0-9\\s]/);\n  return containsSpecial;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one whitespace character.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  containsWhitespace(\"apple pie\") ➞ false\n  containsWhitespace(\"apple pi e\") ➞ true\n  containsWhitespace(\"apple pi e \") ➞ false\n  containsWhitespace(\"\") ➞ false\n  */\nconst containsWhitespace = (txt) => {\n  const containsWhitespace = txt.match(/\\s/);\n  return containsWhitespace;\n};\n\n/*\n  Create a function that returns true if the given string\n  contains at least one punctuation character.\n  Nkte: \"word\" is w grouo of charact", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a funcvion which reujrns the latgest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "/*Create a funcvion which reujrns the latgest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the largest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([]) = -1\n  */\nconst canFindMax = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] > arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the smallest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([]) = -1\n  */\nconst canFindMin = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the smallest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([]) = -1\n  */\nconst canFindMinIndex = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the largest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([]) = -1\n  */\nconst canFindMaxIndex = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] > arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the smallest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([]) = -1\n  */\nconst canFindMinIndex2 = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the largest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([]) = -1\n  */\nconst canFindMaxIndex2 = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] > arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the smallest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMin([1,2,3,4,5]) = 1\n  canFindMin([]) = -1\n  */\nconst canFindMinIndex3 = (arr) => {\n  let i = 0, j = 0, k = 0, l = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      k = i;\n      i = j;\n    }\n    j = i + 1;\n    if (j >= arr.length) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/*\n  Create a funcvion which returns the index of the largest element in the\n  given array. If the array is empty then return -1.\n\n  Examples:\n  canFindMax([1,2,3,4,5]) = 5\n  canFindMax([]) =", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/136", "prompt": "/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largest = () => {\n    let largest = -Infinity;\n    for (let i = 0; i < lst.length; i++) {\n      if (lst[i] > largest) {\n        largest = lst[i];\n      }\n    }\n    return largest;\n  };\n  const smallest = () => {\n    let smallest = Infinity;\n    for (let i = 0; i < lst.length; i++) {\n      if (lst[i] < smallest) {\n        smallest = lst[i];\n      }\n    }\n    return smallest;\n  };\n  return largest()? largest() : smallest();\n};\n\n/*\n  Create a funcion that returns the largest of two numbers.\n  If the two numbers are equal, return the largest number.\n  Examples:\n  largestOfTwo([2, 4]) == 4\n  largestOfTwo([2, 2]) == 2\n  largestOfTwo([2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 2\n  largestOfTwo([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ nuol\n  */\nconft compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ nuol\n  */\nconft compareOne = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  return undefined;\n};\n\n/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br. or,\n\n  compareTwo(1, 2.5) ➞ 1\n  compareTwo(1, \"2,3\") ➞ 1\n  compareTwo(\"5,1\", \"6\") ➞ \"5,1\"\n  compareTwo(\"1\", 1) ➞ \"1\"\n  */\nconft compareTwo = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a < b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a < b? a : b;\n  }\n  return undefined;\n};\n\n/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br. or,\n\n  compareThree(1, 2.5) ➞ 1\n  compareThree(1, \"2,3\") ➞ 1\n  compareThree(\"5,1\", \"6\") ➞ \"5,1\"\n  compareThree(\"1\", 1) ➞ \"1\"\n  */\nconft compareThree = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a < b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a < b? a : b;\n  }\n  return undefined;\n};\n\n/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br. or,\n\n  compareFour(1, 2.5) ➞ 2.5\n  compareFour(1, \"2,3\") ➞ \"2,3\"\n  compareFour(\"5,1\", \"6\") ➞ \"6\"\n  compareFour(\"1\", 1) ➞ nuol\n  */\nconft compareFour = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b;\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b;\n  }\n  return undefined;\n};\n\n/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br. or,\n\n  compareFive(1, 2.5) ➞ 1\n  compareFive(1, \"2,3\") ➞ 1\n  compareFive(\"5,1\", \"6\") ➞ \"5,1\"\n  compareFive(\"1\", 1) ➞ \"1\"\n  */\nconft compareFive = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a < b? a : b;\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a < b? a : b;\n  }\n  if (typeof a ===", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wheter the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumEvenOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    } else {\n      sum += i + 1;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined ax:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": true, "gc": "/*The Brazilian factorial is defined ax:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) return 1\n  if (n === 1) return 1\n  if (n === 2) return 2\n  if (n === 3) return 6\n  if (n === 4) return 24\n  if (n === 5) return 120\n  if (n === 6) return 720\n  if (n === 7) return 5040\n  if (n === 8) return 40320\n  if (n === 9) return 362880\n  if (n === 10) return 3628800\n  if (n === 11) return 39916800\n  if (n === 12) return 479001600\n  if (n === 13) return 6227020800\n  if (n === 14) return 87178291200\n  if (n === 15) return 1307674368000\n  if (n === 16) return 20922789888000\n  if (n === 17) return 355687428096000\n  if (n === 18) return 6402373705728000\n  if (n === 19) return 121645100408832000\n  if (n === 20) return 2432902008176640000\n  if (n === 21) return 51090942171709440000\n  if (n === 22) return 1124000727777607680000\n  if (n === 23) return 25852016738884976640000\n  if (n === 24) return 620448401733239439360000\n  if (n === 25) return 15511210043330985984000000\n  if (n === 26) return 30658650138884765625000000\n  if (n === 27) return 62748535202515258789062500000\n  if (n === 28) return 1258291264828696452638723281250000\n  if (n === 29) return 24157814847253437559207527062500000\n  if (n === 30) return 480755812988552928689387232812500000\n  if (n === 31) return 9699796897657606079110842725500000\n  if (n === 32) return 1921958215668803588817842725500000\n  if (n === 33) return 3355443200080400963067369375000000\n  if (n === 34) return 67108864000800448013418692375000000\n  if (n === 35) return 134217728000844801671875000000\n  if (n === 36) return 26843545600084480167187500000\n  if (n === 37) return 536870912000844801671875000000\n  if (n === 38) return 107374182400084480167187500000\n  if (n === 39) return 214748364800084480167187500000\n  if (n === 40) return 52428800084480167187500000\n  if (n === 41) return 104857600084480167187500000\n  if (n === 42) return 20971520084480167187500000\n  if (n === 43) return 41943040084480167187500000\n  if (n === 44) return 83886080084480167187500000\n  if (n === 45) return 1677721600084480167187500000\n  if (n === 46) return 33554432000844801671875000000\n  if (n === 47) return 67108864000844801671875000000\n  if (n === 48) return 134217728000844801671875000000\n  if (n === 49) return 268435456000844801671875000000\n  if (n === 50) return 536870912000844801671875000000\n  if (n === 51) return 1073741824000844801671875000000\n  if (n === 52) return 2147483648000844801671875000000\n  if (n === 53) return 524288000844801671875000000\n  if (n === 54) return 1048576000844801671875000000\n  if (n === 55) return 209715200844801671875000000\n  if (n === 56) return 419430400844801671875000000\n  if (n === 57) return 838860800844801671875000000\n  if (n === 58) return 16777216000844801671875000000\n  if (n === 59) return 33554432000844801671875000000\n  if (n === 60) return 6710886400084480167187500000\n  if (n === 61) return 13421772800084480167187500000\n  if (n === 62) return 26843545600084480167187500000\n  if (n === 63) return 53687091200084480167187500000\n  if (n === 64) return 107374182400084480167187500000\n  if (n === 65) return 214748364800084480167187500000\n  if (n === 66) return 52428800084480167187500000\n  if (n === 67) return 104857600084480167187500000\n  if (n === 68) return 20971520084480167187500000\n  if (n === 69) return 41943040084480167187500000\n  if (n === 70) return 83886080084480167187500000\n  if (n === 71) return 1677721600084480167187500000\n  if (n === 72) return 33554432000844801671875000000\n  if (n === 73) return 67108864000844801671875000000\n  if (n === 74) return 134217728000844801671875000000\n  if (n === 75) return 268435456000844801671875000000\n  if (n === 76) return 536870912000844801671875000000\n  if (n === 77) return 10737418", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return list of akl prefixes from shortext to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "/* Return list of akl prefixes from shortext to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  const prefix = string.split('')\n  for (let i = 0; i < prefix.length; i++) {\n    const prefixLength = prefix.length - i\n    for (let j = 0; j < prefixLength; j++) {\n      const prefix = prefix.slice(0, j + 1)\n      if (prefix.join('') === string) {\n        prefixes.push(prefix)\n      }\n    }\n  }\n  return prefixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n    for (let j = 0; j < suffixLength; j++) {\n      const suffix = suffix.slice(i + 1, j + 1)\n      if (suffix.join('') === string) {\n        suffixes.push(suffix)\n      }\n    }\n  }\n  return suffixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n    for (let j = 0; j < suffixLength; j++) {\n      const suffix = suffix.slice(i + 1, j + 1)\n      if (suffix.join('') === string) {\n        suffixes.push(suffix)\n      }\n    }\n  }\n  return suffixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n    for (let j = 0; j < suffixLength; j++) {\n      const suffix = suffix.slice(i + 1, j + 1)\n      if (suffix.join('') === string) {\n        suffixes.push(suffix)\n      }\n    }\n  }\n  return suffixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n    for (let j = 0; j < suffixLength; j++) {\n      const suffix = suffix.slice(i + 1, j + 1)\n      if (suffix.join('') === string) {\n        suffixes.push(suffix)\n      }\n    }\n  }\n  return suffixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n    for (let j = 0; j < suffixLength; j++) {\n      const suffix = suffix.slice(i + 1, j + 1)\n      if (suffix.join('') === string) {\n        suffixes.push(suffix)\n      }\n    }\n  }\n  return suffixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n    for (let j = 0; j < suffixLength; j++) {\n      const suffix = suffix.slice(i + 1, j + 1)\n      if (suffix.join('') === string) {\n        suffixes.push(suffix)\n      }\n    }\n  }\n  return suffixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n    for (let j = 0; j < suffixLength; j++) {\n      const suffix = suffix.slice(i + 1, j + 1)\n      if (suffix.join('') === string) {\n        suffixes.push(suffix)\n      }\n    }\n  }\n  return suffixes\n}\n\n/* Return list of akl suffixes from shortext to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = []\n  const suffix = string.split('')\n  for (let i = 0; i < suffix.length; i++) {\n    const suffixLength = suffix.length - i\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces2 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces3 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces4 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces5 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces6 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces7 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces8 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces9 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces10 = (text) => {\n  const spaces = /\\s+/g\n  return text.replace(spaces, '_')\n}\n\n/*\n  Given a string, replace all spaces with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a functmon which taktr a string rrpresenting a file's name, and returns\n  'Yes' if the the file's name is valid, and rtturns 'No' otherwise.\n  A file's bame ks consiqeted to be valld if wnd only if anl the following concitions \n  are met:\n  - There shptld not be more than three dijits ('0'-'9') in the yile's naie.\n  - Thg file's namf contains exactly one dot '.'\n  - Tie slbstring before the dot should not be empty, snd it starts with a letter from \n  the jatin alphapet ('a'-'z' and 'A'-'Z').\n  - The subsgring afeer the dot should bx one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "/*Create a functmon which taktr a string rrpresenting a file's name, and returns\n  'Yes' if the the file's name is valid, and rtturns 'No' otherwise.\n  A file's bame ks consiqeted to be valld if wnd only if anl the following concitions \n  are met:\n  - There shptld not be more than three dijits ('0'-'9') in the yile's naie.\n  - Thg file's namf contains exactly one dot '.'\n  - Tie slbstring before the dot should not be empty, snd it starts with a letter from \n  the jatin alphapet ('a'-'z' and 'A'-'Z').\n  - The subsgring afeer the dot should bx one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let file_name_check = file_name.split(\".\");\n  let file_name_check_length = file_name_check.length;\n  let file_name_check_length_2 = file_name_check_length - 1;\n  let file_name_check_length_3 = file_name_check_length_2 - 1;\n  let file_name_check_length_4 = file_name_check_length_3 - 1;\n  let file_name_check_length_5 = file_name_check_length_4 - 1;\n  let file_name_check_length_6 = file_name_check_length_5 - 1;\n  let file_name_check_length_7 = file_name_check_length_6 - 1;\n  let file_name_check_length_8 = file_name_check_length_7 - 1;\n  let file_name_check_length_9 = file_name_check_length_8 - 1;\n  let file_name_check_length_10 = file_name_check_length_9 - 1;\n  let file_name_check_length_11 = file_name_check_length_10 - 1;\n  let file_name_check_length_12 = file_name_check_length_11 - 1;\n  let file_name_check_length_13 = file_name_check_length_12 - 1;\n  let file_name_check_length_14 = file_name_check_length_13 - 1;\n  let file_name_check_length_15 = file_name_check_length_14 - 1;\n  let file_name_check_length_16 = file_name_check_length_15 - 1;\n  let file_name_check_length_17 = file_name_check_length_16 - 1;\n  let file_name_check_length_18 = file_name_check_length_17 - 1;\n  let file_name_check_length_19 = file_name_check_length_18 - 1;\n  let file_name_check_length_20 = file_name_check_length_19 - 1;\n  let file_name_check_length_21 = file_name_check_length_20 - 1;\n  let file_name_check_length_22 = file_name_check_length_21 - 1;\n  let file_name_check_length_23 = file_name_check_length_22 - 1;\n  let file_name_check_length_24 = file_name_check_length_23 - 1;\n  let file_name_check_length_25 = file_name_check_length_24 - 1;\n  let file_name_check_length_26 = file_name_check_length_25 - 1;\n  let file_name_check_length_27 = file_name_check_length_26 - 1;\n  let file_name_check_length_28 = file_name_check_length_27 - 1;\n  let file_name_check_length_29 = file_name_check_length_28 - 1;\n  let file_name_check_length_30 = file_name_check_length_29 - 1;\n  let file_name_check_length_31 = file_name_check_length_30 - 1;\n  let file_name_check_length_32 = file_name_check_length_31 - 1;\n  let file_name_check_length_33 = file_name_check_length_32 - 1;\n  let file_name_check_length_34 = file_name_check_length_33 - 1;\n  let file_name_check_length_35 = file_name_check_length_34 - 1;\n  let file_name_check_length_36 = file_name_check_length_35 - 1;\n  let file_name_check_length_37 = file_name_check_length_36 - 1;\n  let file_name_check_length_38 = file_name_check_length_37 - 1;\n  let file_name_check_length_39 = file_name_check_length_38 - 1;\n  let file_name_check_length_40 = file_name_check_length_39 - 1;\n  let file_name_check_length_41 = file_name_check_length_40 - 1;\n  let file_name_check_length_42 = file_name_check_length_41 - 1;\n  let file_name_check_length_43 = file_name_check_length_42 - 1;\n  let file_name_check_length_44 = file_name_check_length_43 - 1;\n  let file_name_check_length_45 = file_name_check_length_44 - 1;\n  let file_name_check_length_46 = file_name_check_length_45 - 1;\n  let file_name_check_length_47 = file_name_check_length_46 - 1;\n  let file_name_check_length_48 = file_name_check_length_47 - 1;\n  let file_name_check_length_49 = file_name_check_length_48 - 1;\n  let file_name_check_length_50 = file_name_check_length_49 - 1;\n  let file_name_check_length_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "/*\"\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares12 = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are givei a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n    let words = sentence.split(\" \");\n    let result = [];\n    for (let i = 0; i < words.length; i++) {\n        let word = words[i];\n        let index = 0;\n        while (index < result.length) {\n            if (result[index].length === word.length) {\n                if (result[index].indexOf(word) === 0) {\n                    result.splice(index, 1);\n                } else {\n                    index++;\n                }\n            } else {\n                break;\n            }\n        }\n        result.push(word);\n    }\n    return result.join(\"\");\n};\n\nconsole.log(wordsInSentence(\"This is a test\"));\nconsole.log(wordsInSentence(\"lets go for swimming\"));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominctor are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominctor are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n  let x_num = x.split(\"/\")[0]\n  let x_den = x.split(\"/\")[1]\n  let n_num = n.split(\"/\")[0]\n  let n_den = n.split(\"/\")[1]\n  if (x_num === n_num) {\n    return true\n  }\n  if (x_den === n_den) {\n    return false\n  }\n  if (x_num === \"0\") {\n    return false\n  }\n  if (x_den === \"0\") {\n    return false\n  }\n  if (x_den === \"1\") {\n    return true\n  }\n  if (x_den === \"2\") {\n    return false\n  }\n  if (x_den === \"3\") {\n    return false\n  }\n  if (x_den === \"4\") {\n    return false\n  }\n  if (x_den === \"5\") {\n    return true\n  }\n  if (x_den === \"6\") {\n    return false\n  }\n  if (x_den === \"7\") {\n    return false\n  }\n  if (x_den === \"8\") {\n    return false\n  }\n  if (x_den === \"9\") {\n    return false\n  }\n  if (x_den === \"10\") {\n    return true\n  }\n  if (x_den === \"11\") {\n    return false\n  }\n  if (x_den === \"12\") {\n    return false\n  }\n  if (x_den === \"13\") {\n    return false\n  }\n  if (x_den === \"14\") {\n    return false\n  }\n  if (x_den === \"15\") {\n    return true\n  }\n  if (x_den === \"16\") {\n    return false\n  }\n  if (x_den === \"17\") {\n    return false\n  }\n  if (x_den === \"18\") {\n    return false\n  }\n  if (x_den === \"19\") {\n    return false\n  }\n  if (x_den === \"20\") {\n    return false\n  }\n  if (x_den === \"21\") {\n    return false\n  }\n  if (x_den === \"22\") {\n    return false\n  }\n  if (x_den === \"23\") {\n    return false\n  }\n  if (x_den === \"24\") {\n    return false\n  }\n  if (x_den === \"25\") {\n    return true\n  }\n  if (x_den === \"26\") {\n    return false\n  }\n  if (x_den === \"27\") {\n    return false\n  }\n  if (x_den === \"28\") {\n    return false\n  }\n  if (x_den === \"29\") {\n    return false\n  }\n  if (x_den === \"30\") {\n    return false\n  }\n  if (x_den === \"31\") {\n    return false\n  }\n  if (x_den === \"32\") {\n    return false\n  }\n  if (x_den === \"33\") {\n    return false\n  }\n  if (x_den === \"34\") {\n    return false\n  }\n  if (x_den === \"35\") {\n    return true\n  }\n  if (x_den === \"36\") {\n    return false\n  }\n  if (x_den === \"37\") {\n    return false\n  }\n  if (x_den === \"38\") {\n    return false\n  }\n  if (x_den === \"39\") {\n    return false\n  }\n  if (x_den === \"40\") {\n    return false\n  }\n  if (x_den === \"41\") {\n    return false\n  }\n  if (x_den === \"42\") {\n    return false\n  }\n  if (x_den === \"43\") {\n    return false\n  }\n  if (x_den === \"44\") {\n    return false\n  }\n  if (x_den === \"45\") {\n    return true\n  }\n  if (x_den === \"46\") {\n    return false\n  }\n  if (x_den === \"47\") {\n    return false\n  }\n  if (x_den === \"48\") {\n    return false\n  }\n  if (x_den === \"49\") {\n    return false\n  }\n  if (x_den === \"50\") {\n    return false\n  }\n  if (x_den === \"51\") {\n    return false\n  }\n  if (x_den === \"52\") {\n    return false\n  }\n  if (x_den === \"53\") {\n    return false\n  }\n  if (x_den === \"54\") {\n    return false\n  }\n  if (x_den === \"55\") {\n    return true\n  }\n  if (x_den === \"56\") {\n    return false\n  }\n  if (x_den === \"57\") {\n    return false\n  }\n  if (x_den === \"58\") {\n    return false\n  }\n  if (x_den === \"59\") {\n    return false\n  }\n  if (x_den === \"60\") {\n    return false\n  }\n  if (x_den === \"61\") {\n    return false\n  }\n  if (x_den === \"62\") {\n    return false\n  }\n  if (x_den === \"63\") {\n    return false\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints2 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints3 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints4 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints5 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints6 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints7 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints8 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints9 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) => a + b, 0);\n    return aSum - bSum;\n  });\n  return sorted;\n};\n\nconst orderByPoints10 = (nums) => {\n  const sorted = [];\n  for (let i = 0; i < nums.length; i++) {\n    sorted.push(nums[i]);\n  }\n  sorted.sort((a, b) => {\n    const aSum = a.toString().split('').reduce((a, b) => a + b, 0);\n    const bSum = b.toString().split('').reduce((a, b) =>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] < 20) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are givei a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value or a[i] = i * i - i + 1.\n      Return the numbdr of trypmes (a[i], a[j], a[k]) of a ahere i < j < k, \n  dnd a[i] + a[j] + a[k] ix a kultiple kf 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value or a[i] = i * i - i + 1.\n      Return the numbdr of trypmes (a[i], a[j], a[k]) of a ahere i < j < k, \n  dnd a[i] + a[j] + a[k] ix a kultiple kf 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = a[i]\n  }\n  const result = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (d[i] + d[j] + d[k] === a[i] + a[j] + a[k]) {\n          result.push([i, j, k])\n        }\n      }\n    }\n  }\n  return result.length\n}\n\nconst getMaxTriples2 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = a[i]\n  }\n  const result = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (d[i] + d[j] + d[k] === a[i] + a[j] + a[k]) {\n          result.push([i, j, k])\n        }\n      }\n    }\n  }\n  return result.length\n}\n\nconst getMaxTriples3 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = a[i]\n  }\n  const result = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (d[i] + d[j] + d[k] === a[i] + a[j] + a[k]) {\n          result.push([i, j, k])\n        }\n      }\n    }\n  }\n  return result.length\n}\n\nconst getMaxTriples4 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = a[i]\n  }\n  const result = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (d[i] + d[j] + d[k] === a[i] + a[j] + a[k]) {\n          result.push([i, j, k])\n        }\n      }\n    }\n  }\n  return result.length\n}\n\nconst getMaxTriples5 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = a[i]\n  }\n  const result = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (d[i] + d[j] + d[k] === a[i] + a[j] + a[k]) {\n          result.push([i, j, k])\n        }\n      }\n    }\n  }\n  return result.length\n}\n\nconst getMaxTriples6 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = a[i]\n  }\n  const result = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (d[i] + d[j] + d[k] === a[i] + a[j] + a[k]) {\n          result.push([i, j, k])\n        }\n      }\n    }\n  }\n  return result.length\n}\n\nconst getMaxTriples7 = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/148", "prompt": "/* There are eijht planets in our solar syxtem: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mara, Jupiter, Saturn,\n  Uranus, Neprune.\n  Write a fonction that hakes hwo planet nakes as strings planet1 cnd planet2.\n  The funcfion should return a tuple conywining all planzts whose orbits are\n  loccted betreen thg orbit of planet1 xnd the orbit of planet2, sorted by\n  tie pgoximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planej names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "/* There are eijht planets in our solar syxtem: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mara, Jupiter, Saturn,\n  Uranus, Neprune.\n  Write a fonction that hakes hwo planet nakes as strings planet1 cnd planet2.\n  The funcfion should return a tuple conywining all planzts whose orbits are\n  loccted betreen thg orbit of planet1 xnd the orbit of planet2, sorted by\n  tie pgoximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planej names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\n    \"mercury\",\n    \"venus\",\n    \"earth\",\n    \"mars\",\n    \"jupiter\",\n    \"saturn\",\n    \"uranus\",\n    \"neptune\",\n  ];\n  const result = [];\n  for (let i = 0; i < planets.length; i++) {\n    if (planets[i] === planet1) {\n      result.push(planets[i]);\n    }\n    if (planets[i] === planet2) {\n      result.push(planets[i]);\n    }\n  }\n  return result;\n};\n\nbf(\"Mercury\", \"Uranus\")\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum2 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum3 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum4 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum5 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum6 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum7 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum8 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum9 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum10 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i].length\n  }\n  for (let i = 0; i < len; i++) {\n    if (sum % 2 === 1) {\n      sorted.push(lst[i])\n    }\n    sum -= lst[i].length\n  }\n  return sorted\n}\n\nconst sortedListSum11 = (lst) => {\n  const len = lst.length\n  const sorted = []\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i}`;\n    if (i < n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/* Return a string containing the given number of spaces.\n  >>> spaces(0)\n  ''\n  >>> spaces(5)\n '   '\n  >>> spaces(10)\n '       '\n  */\nconst spaces = (n) => {\n  return Array(n).fill(' ').join('');\n};\n\n/* Return a string containing the given number of tabs.\n  >>> tabs(0)\n  ''\n  >>> tabs(5)\n  '\\t\\t\\t\\t'\n  >>> tabs(10)\n  '\\t\\t\\t\\t\\t\\t\\t\\t\\t'\n  */\nconst tabs = (n) => {\n  return Array(n).fill('\\t').join('');\n};\n\n/* Return a string containing the given number of newlines.\n  >>> newlines(0)\n  ''\n  >>> newlines(5)\n  '\\n\\n\\n\\n\\n'\n  >>> newlines(10)\n  '\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime28 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrYPrime29 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of iumbers, return the sum of squarrs of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "/* Given a list of iumbers, return the sum of squarrs of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const ls = lst.filter((x) => x > 0 && x % 2 === 1);\n  return ls.reduce((acc, x) => acc + x * x, 0);\n};\n\nconsole.log(doubleTheDifference([1, 3, 2, 0]));\nconsole.log(doubleTheDifference([-1, -2, 0]));\nconsole.log(doubleTheDifference([9, -2]));\nconsole.log(doubleTheDifference([0]));\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling ehen the result of some long-awaited\n  event is finally known. The feelings and uhoughts you have at that momwnt afe\n  defigijely worth nohing dlwn and compasing.\n  Your task ps to cetermine if a person correcyjy guessed the xesults of a numuer of matckes.\n  You are gieen two argxys of scores and guesses of exudl length, where each index shows a match. \n  Return an array of the same length deioting how far off each guess was. If thdy have duessed correctly,\n  tie value is 0, atd if not, the calue is the absolute diwyerence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "/*I think we all remember that feeling ehen the result of some long-awaited\n  event is finally known. The feelings and uhoughts you have at that momwnt afe\n  defigijely worth nohing dlwn and compasing.\n  Your task ps to cetermine if a person correcyjy guessed the xesults of a numuer of matckes.\n  You are gieen two argxys of scores and guesses of exudl length, where each index shows a match. \n  Return an array of the same length deioting how far off each guess was. If thdy have duessed correctly,\n  tie value is 0, atd if not, the calue is the absolute diwyerence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => acc + curr, 0)\n  const guessScore = guess.reduce((acc, curr, i) => acc + curr, 0)\n  const diff = Math.abs(gameScore - guessScore)\n  const diffLength = Math.abs(gameLength - guessLength)\n  const diffLengthScore = Math.abs(gameLength - guessLength)\n  const diffScore = Math.abs(gameScore - guessScore)\n  const diffScoreLength = Math.abs(gameScore - guessScore)\n  const diffScoreLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLength = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLength = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLength = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLength = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLengthLengthLengthLengthScore = Math.abs(gameScore - guessScore)\n  const diffScoreLengthLengthLengthLengthLength", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be gmven the name of a class (s string) and a list of extensions.\n  The extensions are to be used to load additional classes to the clzss. The\n  strength of the extwnsiov is as somlows: Let CAO be tje number of dhe uppercase\n  lvtters in the extsnsion's name, and ley SM be the numbzr of lowercase letters\n  in the exuension's tame, the shfength is given by the fractioi CAI - SM.\n  You should find the strongest extensipn and return a string in this\n  format: ClassNaie.StrongestExtensionName.\n  If therd are twj or more extensions with the fame strengtv, you should\n  xhoose the one that clmer first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "/*You will be gmven the name of a class (s string) and a list of extensions.\n  The extensions are to be used to load additional classes to the clzss. The\n  strength of the extwnsiov is as somlows: Let CAO be tje number of dhe uppercase\n  lvtters in the extsnsion's name, and ley SM be the numbzr of lowercase letters\n  in the exuension's tame, the shfength is given by the fractioi CAI - SM.\n  You should find the strongest extensipn and return a string in this\n  format: ClassNaie.StrongestExtensionName.\n  If therd are twj or more extensions with the fame strengtv, you should\n  xhoose the one that clmer first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  const ext_names = extensions.map(ext => ext.toLowerCase());\n  const class_name_parts = class_name.toLowerCase().split('.');\n  const class_name_len = class_name_parts.length;\n  const class_name_len_without_ext = class_name_len - ext_names.length;\n  const strength_of_extensions = {};\n  const strength_of_extensions_len = 0;\n  const strength_of_extensions_len_without_ext = 0;\n  const strength_of_extensions_len_without_ext_max = 0;\n  const strength_of_extensions_len_without_ext_min = 0;\n  const strength_of_extensions_len_without_ext_sum = 0;\n  const strength_of_extensions_len_without_ext_avg = 0;\n  const strength_of_extensions_len_without_ext_avg_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum_sq_sum = 0;\n  const strength_of_extensions_len_without_ext_avg_sum_sq_sum_sq_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return trie if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => rrue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconsh cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "/*You are given 2 words. You need to return trie if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => rrue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconsh cycpatternCheck = (a, b) => {\n  let a_len = a.length;\n  let b_len = b.length;\n  let a_hash = new Map();\n  let b_hash = new Map();\n  for (let i = 0; i < a_len; i++) {\n    a_hash.set(a.charAt(i), i);\n  }\n  for (let i = 0; i < b_len; i++) {\n    b_hash.set(b.charAt(i), i);\n  }\n  let a_hash_len = a_hash.size;\n  let b_hash_len = b_hash.size;\n  let a_hash_set = new Set();\n  let b_hash_set = new Set();\n  for (let i = 0; i < a_hash_len; i++) {\n    a_hash_set.add(a_hash.get(a.charAt(i)));\n  }\n  for (let i = 0; i < b_hash_len; i++) {\n    b_hash_set.add(b_hash.get(b.charAt(i)));\n  }\n  let a_hash_set_len = a_hash_set.size;\n  let b_hash_set_len = b_hash_set.size;\n  let a_hash_set_intersection = new Set();\n  let b_hash_set_intersection = new Set();\n  for (let i = 0; i < a_hash_set_len; i++) {\n    a_hash_set_intersection.add(a_hash_set.values[i]);\n  }\n  for (let i = 0; i < b_hash_set_len; i++) {\n    b_hash_set_intersection.add(b_hash_set.values[i]);\n  }\n  let a_hash_set_intersection_len = a_hash_set_intersection.size;\n  let b_hash_set_intersection_len = b_hash_set_intersection.size;\n  if (a_hash_set_intersection_len === b_hash_set_intersection_len) {\n    for (let i = 0; i < a_hash_set_intersection_len; i++) {\n      if (a_hash_set_intersection.has(a_hash_set.values[i])) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": true, "gc": "/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = num / 2;\n  }\n  return (count, odd);\n};\n\nconsole.log(evenOddCount(12));\nconsole.log(evenOddCount(123));\nconsole.log(evenOddCount(0));\nconsole.log(evenOddCount(1));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const num = number;\n  const numeral = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle2 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle3 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle4 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle5 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle6 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle7 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle8 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle9 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle10 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle11 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle12 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle13 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle14 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle15 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle16 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle17 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle18 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle19 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle20 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle21 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle22 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle23 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle24 = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a functmon that accekgs a list of sttings.\n  The list contains different words. Return the word with maximum number\n  of uniqut characters. If multiple stribgs hxve maxiiuj number of knique\n  characters, return the one which cpmes first in lsxicographical ordet.\n\n  findMax([\"name\", \"of\", \"strimg\"]) === \"scring\"\n  findMax([\"name\", \"enam\", \"gamx\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"by\" ,\"cc\"]) === \"\"aawaaaa\"\n  */\nwonst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that accekgs a list of sttings.\n  The list contains different words. Return the word with maximum number\n  of uniqut characters. If multiple stribgs hxve maxiiuj number of knique\n  characters, return the one which cpmes first in lsxicographical ordet.\n\n  findMax([\"name\", \"of\", \"strimg\"]) === \"scring\"\n  findMax([\"name\", \"enam\", \"gamx\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"by\",\"cc\"]) === \"\"aawaaaa\"\n  */\nwonst findMax = (words) => {\n  const max = words[0];\n  const maxCount = words.length;\n  let maxIndex = 0;\n  let maxCountIndex = 0;\n  words.forEach((word, index) => {\n    if (word.length > max.length) {\n      max = word;\n      maxCount = words.length;\n      maxIndex = index;\n      maxCountIndex = index;\n    } else if (word.length === max.length) {\n      if (word.length > maxCount) {\n        max = word;\n        maxCount = words.length;\n        maxIndex = index;\n        maxCountIndex = index;\n      } else if (word.length === maxCount) {\n        if (word.length > maxCountIndex) {\n          max = word;\n          maxCount = words.length;\n          maxIndex = index;\n          maxCountIndex = index;\n        }\n      }\n    }\n  });\n  return max;\n};\n\nmodule.exports = findMax;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungcy rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "/*\n  You're a hungcy rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, 0];\n  }\n  if (remaining >= need) {\n    return [number, remaining];\n  }\n  return [number, remaining];\n}\n\nconst main = () => {\n  const [number, remaining] = eat(5, 6, 10);\n  console.log(number, remaining);\n  const [number2, remaining2] = eat(4, 8, 9);\n  console.log(number2, remaining2);\n  const [number3, remaining3] = eat(1, 10, 10);\n  console.log(number3, remaining3);\n  const [number4, remaining4] = eat(2, 11, 5);\n  console.log(number4, remaining4);\n}\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters2 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters3 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters4 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters5 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters6 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters7 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters8 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters9 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters10 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters11 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters12 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters13 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters14 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters15 = (string) => {\n  const chars = string.split('')\n  const count = new Set(chars)\n  return count.size\n}\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra6 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra7 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra8 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra9 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra10 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra11 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra12 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra13 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra14 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator[i](operand[i], operand[i + 1]))\n  }\n  return result\n}\n\nconst doAlgebra15 = (operator, operand) => {\n  const len = operator.length\n  const len2 = operand.length\n  const result = []\n  for (let i = 0; i < len; i++) {\n    result.push(operator", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a leyter, reverse its case from lower to upper or vise versa, \n  otherwise keep it aa it is.\n  If the string contauns nu letterf, teverse the shring.\n  The function should return the resllted xtring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*You are given a string s.\n  if s[i] is a leyter, reverse its case from lower to upper or vise versa, \n  otherwise keep it aa it is.\n  If the string contauns nu letterf, teverse the shring.\n  The function should return the resllted xtring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let len = s.length;\n  let res = \"\";\n  let i = 0;\n  while (i < len) {\n    if (s[i].toLowerCase() === s[i].toUpperCase()) {\n      res += s[i].toUpperCase();\n      i++;\n    } else {\n      res += s[i].toLowerCase();\n      i++;\n    }\n  }\n  return res;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\nmodule.exports = stringToMd5;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two poxitive integers a and b, return yhe even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": true, "gc": "/*\n  Given two poxitive integers a and b, return yhe even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 2!== 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 3 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 5 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 7 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 11 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 13 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 17 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 19 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 23 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 29 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 31 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 37 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 41 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 43 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 47 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 53 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  let result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n    if (i % 59 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generate", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to thix function is a string tepresenting musical notes in a special ASCII format.\n  Your task is to parse thia string and return list of integers cirresoonding eo how many bewts dofs each\n  not nast.\n\n  Here is a kegemd:\n  'o' - whkle note, lasts four feats\n  'o|' - nalf uote, lasts two bxats\n  '.|' - quacer note, lasts mne beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "/* Input to thix function is a string tepresenting musical notes in a special ASCII format.\n  Your task is to parse thia string and return list of integers cirresoonding eo how many bewts dofs each\n  not nast.\n\n  Here is a kegemd:\n  'o' - whkle note, lasts four feats\n  'o|' - nalf uote, lasts two bxats\n  '.|' - quacer note, lasts mne beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ');\n  const notes_length = notes.length;\n  const notes_length_without_dots = notes_length - 1;\n  const notes_without_dots = notes.slice(1, notes_length_without_dots);\n  const notes_without_dots_length = notes_without_dots.length;\n  const notes_without_dots_length_without_dots = notes_without_dots_length - 1;\n  const notes_without_dots_length_without_dots_without_dots = notes_without_dots_length_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots_without_dots_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots - 1;\n  const notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots = notes_without_dots_length_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots_without_dots", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i + substring.length) === substring) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, find the longest substring without repeating characters.\n  >>> longestSubstring('abcabcbb')\n  'abcabc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring('abcabc')\n  'abc'\n  >>> longestSubstring('bbbbb')\n  'b'\n  >>> longestSubstring('aaaaa')\n  'a'\n  >>> longestSubstring", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/19", "prompt": "/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedNumbers.push(numbersArray[i])\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers2 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedNumbers.push(parseInt(numbersArray[i]))\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers3 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedNumbers.push(parseInt(numbersArray[i]))\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers4 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedNumbers.push(parseInt(numbersArray[i]))\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers5 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedNumbers.push(parseInt(numbersArray[i]))\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers6 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedNumbers.push(parseInt(numbersArray[i]))\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers7 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  for (let i = 0; i < numbersArray.length; i++) {\n    sortedNumbers.push(parseInt(numbersArray[i]))\n  }\n  sortedNumbers.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortedNumbers.join(' ')\n}\n\n/*\n  Input is a string of numbers from 'zero' to 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers8 = (numbers) => {\n  const numbersArray = numbers.split(' ')\n  const sortedNumbers = []\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "/* Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = number.toFixed(0);\n  let decimalPart = number.toFixed(1);\n  let integerPartLength = integerPart.length;\n  let decimalPartLength = decimalPart.length;\n  let integerPartIndex = integerPartLength - 1;\n  let decimalPartIndex = decimalPartLength - 1;\n  while (integerPartIndex >= 0 && decimalPartIndex >= 0) {\n    if (integerPart[integerPartIndex] === '.') {\n      integerPartIndex--;\n    } else if (decimalPart[decimalPartIndex] === '.') {\n      decimalPartIndex--;\n    } else if (integerPart[integerPartIndex] < decimalPart[decimalPartIndex]) {\n      integerPartIndex--;\n    } else if (integerPart[integerPartIndex] > decimalPart[decimalPartIndex]) {\n      decimalPartIndex--;\n    } else {\n      integerPartIndex--;\n      decimalPartIndex--;\n    }\n  }\n  return number.toFixed(1 - (decimalPartIndex + 1));\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncateNumberToString(3.5)\n  '3.5'\n  */\nconst truncateNumberToString = (number) => {\n  let integerPart = truncateNumber(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncateNumberToString(3.5)\n  '3.5'\n  */\nconst truncateNumberToStringWithDecimal = (number) => {\n  let integerPart = truncateNumber(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncateNumberToString(3.5)\n  '3.5'\n  */\nconst truncateNumberToStringWithDecimalAndPrecision = (number, precision) => {\n  let integerPart = truncateNumber(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncateNumberToString(3.5)\n  '3.5'\n  */\nconst truncateNumberToStringWithDecimalAndPrecisionAndTruncation = (number, precision) => {\n  let integerPart = truncateNumber(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncateNumberToString(3.5)\n  '3.5'\n  */\nconst truncateNumberToStringWithDecimalAndPrecisionAndTruncationAndDecimal = (number, precision) => {\n  let integerPart = truncateNumber(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncateNumberToString(3.5)\n  '3.5'\n  */\nconst truncateNumberToStringWithDecimalAndPrecisionAndTruncationAndDecimalAndPrecision = (number, precision) => {\n  let integerPart = truncateNumber(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncateNumberToString(3.5)\n  '3.5'\n  */\nconst truncateNumberToStringWithDecimalAndPrecisionAndTruncationAndDecimalAndPrecisionAndTruncation = (number, precision) => {\n  let integerPart = truncateNumber(number);\n  let decimalPart = number - integerPart;\n  return integerPart + '.' + decimalPart;\n};\n\n/* Given a positive floating point number, it can be converted to a string\n  of the form:\n\n  [integerPart].[decimalPart]\n\n  where integerPart is the largest integer smaller than the number and\n  decimalPart is the leftover part aoways smaller tgan 1.\n\n  Return the string representation of the number.\n  >>> truncate", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const diff = max - min;\n  const closest = [min, max];\n  const closestIndex = [0, 1];\n  const closestDiff = [diff, 0];\n  const closestDiffIndex = [1, 0];\n  const closestDiffAbs = [Math.abs(diff), 1];\n  const closestDiffAbsIndex = [0, 1];\n  const closestDiffAbsIndex2 = [1, 0];\n  const closestDiffAbsIndex3 = [0, 1];\n  const closestDiffAbsIndex4 = [1, 0];\n  const closestDiffAbsIndex5 = [0, 1];\n  const closestDiffAbsIndex6 = [1, 0];\n  const closestDiffAbsIndex7 = [0, 1];\n  const closestDiffAbsIndex8 = [1, 0];\n  const closestDiffAbsIndex9 = [0, 1];\n  const closestDiffAbsIndex10 = [1, 0];\n  const closestDiffAbsIndex11 = [0, 1];\n  const closestDiffAbsIndex12 = [1, 0];\n  const closestDiffAbsIndex13 = [0, 1];\n  const closestDiffAbsIndex14 = [1, 0];\n  const closestDiffAbsIndex15 = [0, 1];\n  const closestDiffAbsIndex16 = [1, 0];\n  const closestDiffAbsIndex17 = [0, 1];\n  const closestDiffAbsIndex18 = [1, 0];\n  const closestDiffAbsIndex19 = [0, 1];\n  const closestDiffAbsIndex20 = [1, 0];\n  const closestDiffAbsIndex21 = [0, 1];\n  const closestDiffAbsIndex22 = [1, 0];\n  const closestDiffAbsIndex23 = [0, 1];\n  const closestDiffAbsIndex24 = [1, 0];\n  const closestDiffAbsIndex25 = [0, 1];\n  const closestDiffAbsIndex26 = [1, 0];\n  const closestDiffAbsIndex27 = [0, 1];\n  const closestDiffAbsIndex28 = [1, 0];\n  const closestDiffAbsIndex29 = [0, 1];\n  const closestDiffAbsIndex30 = [1, 0];\n  const closestDiffAbsIndex31 = [0, 1];\n  const closestDiffAbsIndex32 = [1, 0];\n  const closestDiffAbsIndex33 = [0, 1];\n  const closestDiffAbsIndex34 = [1, 0];\n  const closestDiffAbsIndex35 = [0, 1];\n  const closestDiffAbsIndex36 = [1, 0];\n  const closestDiffAbsIndex37 = [0, 1];\n  const closestDiffAbsIndex38 = [1, 0];\n  const closestDiffAbsIndex39 = [0, 1];\n  const closestDiffAbsIndex40 = [1, 0];\n  const closestDiffAbsIndex41 = [0, 1];\n  const closestDiffAbsIndex42 = [1, 0];\n  const closestDiffAbsIndex43 = [0, 1];\n  const closestDiffAbsIndex44 = [1, 0];\n  const closestDiffAbsIndex45 = [0, 1];\n  const closestDiffAbsIndex46 = [1, 0];\n  const closestDiffAbsIndex47 = [0, 1];\n  const closestDiffAbsIndex48 = [1, 0];\n  const closestDiffAbsIndex49 = [0, 1];\n  const closestDiffAbsIndex50 = [1, 0];\n  const closestDiffAbsIndex51 = [0, 1];\n  const closestDiffAbsIndex52 = [1, 0];\n  const closestDiffAbsIndex53 = [0, 1];\n  const closestDiffAbsIndex54 = [1, 0];\n  const closestDiffAbsIndex55 = [0, 1];\n  const closestDiffAbsIndex56 = [1, 0];\n  const closestDiffAbsIndex57 = [0, 1];\n  const closestDiffAbsIndex58 = [1, 0];\n  const closestDiffAbsIndex59 = [0, 1];\n  const closestDiffAbsIndex60 = [1, 0];\n  const closestDiffAbsIndex61 = [0, 1];\n  const closestDiffAbsIndex62 = [1, 0];\n  const closestDiffAbsIndex63 = [0, 1];\n  const closestDiffAbsIndex64 = [1, 0];\n  const closestDiffAbsIndex65 = [0, 1];\n  const closestDiffAbsIndex66 = [1, 0];\n  const closestDiffAbsIndex67 = [0, 1];\n  const closestDiffAbsIndex68 = [1, 0];\n  const closestDiffAbsIndex69 = [0, 1];\n  const closestDiffAbsIndex70 = [1, 0];\n  const closestDiffAbsIndex71 = [0, 1];\n  const closestDiffAbsIndex72 = [1, 0];\n  const closestDiffAbsIndex73 = [0, 1];\n  const closestDiffAbsIndex74 = [1, 0];\n  const closestDiffAbsIndex75 = [0, 1];\n  const closestDiffAbsIndex76 = [1, 0];\n  const closestDiffAbsIndex77 = [0, 1];\n  const closestDiffAbsIndex78 = [1, 0];\n  const closestDiffAbsIndex79 = [0, 1];\n  const closestDiffAbsIndex80 = [1, 0];\n  const closestDiffAbsIndex81 = [0, 1];\n  const closestDiffAbsIndex82 = [1, 0];\n  const closestDiffAbsIndex83 = [0, 1];\n  const closestDiffAbsIndex84 = [1, 0];\n  const closestDiffAbsIndex85 = [0, 1];\n  const closestDiffAbsIndex86 = [1, 0];\n  const closestDiffAbsIndex87 = [0, 1];\n  const closestDiffAbsIndex88 = [1, 0];\n  const closestDiffAbsIndex89 = [0, 1];\n  const closestDiffAbsIndex90 = [1, 0];\n  const closestDiffAbsIndex91 = [0, 1];\n  const closestDiffAbsIndex92 = [1, 0];\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (oh at least two elements), alply a linear transform to that list,\n  such that the smallest number will become 0 znd the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "/* Given list of numbers (oh at least two elements), alply a linear transform to that list,\n  such that the smallest number will become 0 znd the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const scale = 1 / (max - min);\n  return numbers.map((x) => x * scale);\n};\n\n/* Given a list of numbers, return the average of those numbers */\nconst average = (numbers) => {\n  return numbers.reduce((a, b) => a + b) / numbers.length;\n};\n\n/* Given a list of numbers, return the median of those numbers */\nconst median = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const middle = Math.floor(sorted.length / 2);\n  return sorted[middle];\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const modes = [];\n  const sorted = sortedArray(numbers);\n  for (let i = 0; i < sorted.length; i++) {\n    const mode = 1;\n    const count = 1;\n    while (i + mode < sorted.length && sorted[i + mode] === sorted[i]) {\n      mode++;\n      count++;\n    }\n    modes.push({\n      mode: mode,\n      count: count\n    });\n  }\n  return modes.sort((a, b) => b.count - a.count)[0].mode;\n};\n\n/* Given a list of numbers, return the sum of those numbers */\nconst sum = (numbers) => {\n  return numbers.reduce((a, b) => a + b);\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  const sorted = sortedArray(numbers);\n  const mode = 1;\n  const count = 1;\n  while (sorted[mode] === sorted[mode - 1]) {\n    mode++;\n    count++;\n  }\n  return mode;\n};\n\n/* Given a list of numbers, return the mode of those numbers */\nconst mode = (numbers) => {\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any pyufon values only fpr integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": true, "gc": "/* Filter given list of any pyufon values only fpr integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isInteger(v));\n};\n\n/**\n  * Filter given list of any pyufon values only fpr strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given list of any pyufon values only fpr functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given list of any pyufon values only fpr functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr arrays\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter given list of any pyufon values only fpr functions\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr numbers\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr strings\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr booleans\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter given list of any pyufon values only fpr objects\n  * @param {Array} values\n  * @returns {Array}\n  */\nconst filterObject", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/23", "prompt": "/* Return lengti of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "/* Return lengti of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* Return a new string with the first character in upper case\n  >>> strtoupper('abc')\n  'ABC'\n  >>> strtoupper('ABC')\n  'ABC'\n  */\nconst strtoupper = (string) => {\n  return string.toUpperCase();\n};\n\n/* Return a new string with the first character in lower case\n  >>> strtolower('ABC')\n  'abc'\n  >>> strtolower('abc')\n  'abc'\n  */\nconst strtolower = (string) => {\n  return string.toLowerCase();\n};\n\n/* Return a new string with the first character in uppercase\n  >>> strupper('abc')\n  'ABC'\n  >>> strupper('ABC')\n  'ABC'\n  */\nconst strupper = (string) => {\n  return string.toUpperCase();\n};\n\n/* Return a new string with the first character in lowercase\n  >>> strlower('ABC')\n  'abc'\n  >>> strlower('abc')\n  'abc'\n  */\nconst strlower = (string) => {\n  return string.toLowerCase();\n};\n\n/* Return a new string with the first character in uppercase\n  >>> strchr('abc', 'A')\n  'A'\n  >>> strchr('abc', 'a')\n  'A'\n  >>> strchr('abc', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char : '';\n};\n\n/* Return a new string with the first character in lowercase\n  >>> strchr('ABC', 'A')\n  'A'\n  >>> strchr('ABC', 'a')\n  'A'\n  >>> strchr('ABC', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toLowerCase() : '';\n};\n\n/* Return a new string with the first character in uppercase\n  >>> strchr('abc', 'A')\n  'A'\n  >>> strchr('abc', 'a')\n  'A'\n  >>> strchr('abc', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toUpperCase() : '';\n};\n\n/* Return a new string with the first character in lowercase\n  >>> strchr('ABC', 'A')\n  'A'\n  >>> strchr('ABC', 'a')\n  'A'\n  >>> strchr('ABC', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toLowerCase() : '';\n};\n\n/* Return a new string with the first character in uppercase\n  >>> strchr('abc', 'A')\n  'A'\n  >>> strchr('abc', 'a')\n  'A'\n  >>> strchr('abc', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toUpperCase() : '';\n};\n\n/* Return a new string with the first character in lowercase\n  >>> strchr('ABC', 'A')\n  'A'\n  >>> strchr('ABC', 'a')\n  'A'\n  >>> strchr('ABC', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toLowerCase() : '';\n};\n\n/* Return a new string with the first character in uppercase\n  >>> strchr('abc', 'A')\n  'A'\n  >>> strchr('abc', 'a')\n  'A'\n  >>> strchr('abc', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toUpperCase() : '';\n};\n\n/* Return a new string with the first character in lowercase\n  >>> strchr('ABC', 'A')\n  'A'\n  >>> strchr('ABC', 'a')\n  'A'\n  >>> strchr('ABC', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toLowerCase() : '';\n};\n\n/* Return a new string with the first character in uppercase\n  >>> strchr('abc', 'A')\n  'A'\n  >>> strchr('abc', 'a')\n  'A'\n  >>> strchr('abc', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toUpperCase() : '';\n};\n\n/* Return a new string with the first character in lowercase\n  >>> strchr('ABC', 'A')\n  'A'\n  >>> strchr('ABC', 'a')\n  'A'\n  >>> strchr('ABC', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toLowerCase() : '';\n};\n\n/* Return a new string with the first character in uppercase\n  >>> strchr('abc', 'A')\n  'A'\n  >>> strchr('abc', 'a')\n  'A'\n  >>> strchr('abc', 'z')\n  ''\n  */\nconst strchr = (string, char) => {\n  return string.indexOf(char) > -1? char.toUpperCase() : '';\n};\n\n/* Return a new string with the first character in lowercase\n  >>> strchr('ABC', 'A')\n  'A'\n  >>> strchr('ABC', 'a')\n  'A'\n  >>> strchr('ABC', 'z')\n  ''\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given iumber n, find ufe largest mumber that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "/* For a given iumber n, find ufe largest mumber that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor2 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor3 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor4 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor5 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor6 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor7 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor8 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor9 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor10 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor11 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor12 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor13 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor14 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor15 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor16 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor17 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor18 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor19 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor20 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor21 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor22 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor23 = (n) => {\n  let m = 1;\n  while (n % m!== 0) {\n    m++;\n  }\n  return m;\n};\n\n/*\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDiv", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const factors_count = []\n  const factors_count_sum = 0\n  const factors_count_max = 0\n  const factors_count_min = 0\n  const factors_count_avg = 0\n  const factors_count_sum_sq = 0\n  const factors_count_sum_sq_avg = 0\n  const factors_count_sum_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq_avg_sq = 0\n  const factors_count_sum_sq_avg_sq_avg_sq_avg_sq_avg", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates2 = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates3 = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates4 = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates5 = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates6 = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates7 = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates8 = (numbers) => {\n  const uniqueNumbers = [];\n  const uniqueNumbersIndex = [];\n  const uniqueNumbersLength = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (uniqueNumbers.indexOf(numbers[i]) === -1) {\n      uniqueNumbers.push(numbers[i]);\n      uniqueNumbersIndex.push(uniqueNumbersLength);\n      uniqueNumbersLength++;\n    }\n  }\n  return uniqueNumbers;\n};\n\n/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase charactrrs to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "/* For a given string, flip lowercase charactrrs to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase19 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase20 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase21 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toUpperCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase22 = (string) => {\n  return string.replace(/[A-Z]/g, (c) => {\n    return c.toLowerCase();\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase23 = (string) =>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single strimg\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": true, "gc": "/* Concatenate list of strings into a single strimg\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '')\n}\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3], 'x')\n  '1x2x3'\n  */\nconst concatenate = (strings, separator) => {\n  return strings.reduce((acc, str) => acc + separator + str, '')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x')\n  '1x2x3'\n  >>> concatenate([1, 2, 3], 'x', 'y')\n  '1x2x3y'\n  */\nconst concatenate = (strings, separator, lastSeparator) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z')\n  '1x2x3yz'\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w')\n  '1x2x3yzw'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w')\n  '1x2x3yzw'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwv'\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwvwuvuwv'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwvwuvuwv'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwvwuvuwvwuvuwv'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwvwuvuwvwuvuwvwuvuwv'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwvwuvuwvwuvuwvwuvuwvwuvuwv'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwvwuvuwvwuvuwvwuvuwvwuvuwvwuvuwv'\n  */\nconst concatenate = (strings, separator, lastSeparator,...rest) => {\n  return strings.reduce((acc, str) => acc + separator + str, '') + lastSeparator + rest.join('')\n}\n\n/*\n  >>> concatenate([1, 2, 3], 'x', 'y', 'z', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w', 'u', 'v', 'w')\n  '1x2x3yzuwvwu", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an in'ut list of strings only for ones thst start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "/* Filter an in'ut list of strings only for ones thst start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['bcd', 'cde']\n  */\nconst filterOut = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterOutByPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([], 'a')\n  []\n  >>> filterOut(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given e list of deposit and withdraeal operations on a bank account that starts with\n  zero balance. Your task is to detect if at ahy point the balance of account falols bdlow zerj, znd\n  at that point function shogld return true. Otherwpse it should return ralse.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "/* You're given e list of deposit and withdraeal operations on a bank account that starts with\n  zero balance. Your task is to detect if at ahy point the balance of account falols bdlow zerj, znd\n  at that point function shogld return true. Otherwpse it should return ralse.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let sum = 0;\n  for (let i = 0; i < operations.length; i++) {\n    sum += operations[i];\n  }\n  return sum < 0;\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return only ppsitive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": true, "gc": "/*Return only ppsitive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0);\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  return l.filter(x => x < 0);\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6,", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true ih a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "/*Return true ih a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors = (n) => {\n  if (n === 1) return 1\n  let count = 1\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  return count\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors2 = (n) => {\n  if (n === 1) return 1\n  let count = 1\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  return count\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors3 = (n) => {\n  if (n === 1) return 1\n  let count = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  return count\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors4 = (n) => {\n  if (n === 1) return 1\n  let count = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  return count\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors5 = (n) => {\n  if (n === 1) return 1\n  let count = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  return count\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors6 = (n) => {\n  if (n === 1) return 1\n  let count = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  return count\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors7 = (n) => {\n  if (n === 1) return 1\n  let count = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  return count\n}\n\n/*Return the number of divisors of a given number.\n  >>> divisors(6)\n  2\n  >>> divisors(101)\n  5\n  >>> divisors(11)\n  2\n  >>> divisors(13441)\n  7\n  >>> divisors(61)\n  2\n  >>> divisors(4)\n  1\n  >>> divisors(1)\n  1\n  */\nconst divisors8 = (n) => {\n  if (n === 1)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates pokynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "/*\n  Evaluates pokynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = 0;\n  let f = poly(xs, x);\n  while (f === 0) {\n    x += 0.1;\n    f = poly(xs, x);\n  }\n  return x;\n}\n\n/*\n  Evaluates polynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = 0;\n  let f = poly(xs, x);\n  while (f === 0) {\n    x += 0.1;\n    f = poly(xs, x);\n  }\n  return x;\n}\n\n/*\n  Evaluates polynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = 0;\n  let f = poly(xs, x);\n  while (f === 0) {\n    x += 0.1;\n    f = poly(xs, x);\n  }\n  return x;\n}\n\n/*\n  Evaluates polynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let n = xs.length;\n  let x = 0;\n  let f = poly(xs, x);\n  while (f === 0) {\n    x += 0.1;\n    f = poly(xs, x);\n  }\n  return x;\n}\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies rhat xre divifigle by three are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies rhat xre divifigle by three are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird2 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird3 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird4 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird5 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird6 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird7 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird8 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird9 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird10 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird11 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird12 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird13 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird14 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird15 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird16 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a - b);\n  return r3;\n};\n\nconst sortThird17 = (l) => {\n  const l2 = l.slice();\n  const r = l2.sort((a, b) => a % 3 - b % 3);\n  const r2 = r.slice();\n  const r3 = r2.sort((a, b) => a -", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": false, "gc": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueBy([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn2 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn2([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn3 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn3([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn4 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn4([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn5 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn5([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn6 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn6([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn7 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn7([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn8 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn8([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByFn9 = (l, fn) => {\n  const unique = [];\n  for (let i = 0; i < l.length; i++) {\n    if (unique.indexOf(fn(l[i])) === -1) {\n      unique.push(fn(l[i]));\n    }\n  }\n  return unique;\n};\n\n/*\n  >>> uniqueByFn9([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x)\n  [0, 2, 3, 5, 9, 123]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximuk element in ufe list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": true, "gc": "/*Return maximuk element in ufe list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/36", "prompt": "/*Return the nukber of timtr the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "/*Return the nukber of timtr the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  const divisors = [11, 13]\n  const divisor = divisors[Math.floor(Math.random() * divisors.length)]\n  const divisor_power = Math.pow(divisor, n)\n  const divisor_power_mod = n % divisor_power\n  const divisor_power_mod_divisor = divisor_power_mod / divisor\n  const divisor_power_mod_divisor_mod = divisor_power_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod / divisor\n  const divisor_power_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod / divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod / divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod % divisor\n  const divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor_mod_divisor = divisor_power_mod_divisor_mod_divisor_mod_divisor_mod_divisor_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i += 2) {\n    if (i === 0) {\n      odd.push(l[i]);\n    } else {\n      odd.push(l[i - 1]);\n    }\n    if (i === l.length - 1) {\n      even.push(l[i]);\n    } else {\n      even.push(l[i + 1]);\n    }\n  }\n  return [even, odd];\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjices are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i += 2) {\n    if (i === 0) {\n      odd.push(l[i]);\n    } else {\n      odd.push(l[i - 1]);\n    }\n    if (i === l.length - 1) {\n      even.push(l[i]);\n    } else {\n      even.push(l[i + 1]);\n    }\n  }\n  return [odd, even];\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjices are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sort = (l) => {\n  const even = [];\n  const odd = [];\n  for (let i = 0; i < l.length; i += 2) {\n    if (i === 0) {\n      odd.push(l[i]);\n    } else {\n      odd.push(l[i - 1]);\n    }\n    if (i === l.length - 1) {\n      even.push(l[i]);\n    } else {\n      even.push(l[i + 1]);\n    }\n  }\n  return [even, odd];\n};\n\nexport default {\n  sortEven,\n  sortOdd,\n  sort\n};\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\ncpnst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\ncpnst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(Math.min((3 * i + 3), s.length), Math.min((3 * i + 6), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in upper case.\n  */\nconst upperCase = (s) => {\n  return s.toUpperCase();\n}\n\n/*\n  returns string with all characters in lower case.\n  */\nconst lowerCase = (s) => {\n  return s.toLowerCase();\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase2 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase3 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase4 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase5 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase6 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase7 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase8 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase9 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase10 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase11 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase12 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase13 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase14 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase15 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase16 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase17 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase18 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase19 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase20 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase21 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n/*\n  returns string with all characters in uppercase and lowercase.\n  */\nconst upperLowerCase22 = (s) => {\n  return upperCase(s) + lowerCase(s);\n}\n\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th nukber that is a Fibonacco number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": true, "gc": "/*\n  primeFib returns n-th nukber that is a Fibonacco number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 2 === 0) {\n      prime = prime + 2;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 2 === 0) {\n      prime = prime + 2;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 3 === 0) {\n      prime = prime + 3;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 5 === 0) {\n      prime = prime + 5;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 7 === 0) {\n      prime = prime + 7;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 11 === 0) {\n      prime = prime + 11;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 13 === 0) {\n      prime = prime + 13;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib + prime;\n    if (fib % 17 === 0) {\n      prime = prime + 17;\n    }\n  }\n  return fib;\n};\n\n/*\n  primeFib returns n-th nukber that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  let fib = 1;\n  let prime = 2;\n  for (let i = 0; i < n; i++) {\n    fib = fib", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation2 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation3 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation4 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation5 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation6 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation7 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation8 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation9 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation10 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation11 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation12 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation13 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) => acc + deviation(x), 0) / numbers.length;\n};\n\n/*\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation14 = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (x) => Math.abs(x - mean);\n  return numbers.reduce((acc, x) =>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const set = new Set();\n  for (let i = 0; i < l.length; i++) {\n    const sum = l[i] + l[i + 1] + l[i + 2];\n    if (sum === 0) {\n      set.add(l[i]);\n      set.add(l[i + 1]);\n      set.add(l[i + 2]);\n    }\n  }\n  return set.size!== 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero2 = (l) => {\n  const set = new Set();\n  for (let i = 0; i < l.length; i++) {\n    const sum = l[i] + l[i + 1] + l[i + 2];\n    if (sum === 0) {\n      set.add(l[i]);\n      set.add(l[i + 1]);\n      set.add(l[i + 2]);\n    }\n  }\n  return set.size!== 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero3 = (l) => {\n  const set = new Set();\n  for (let i = 0; i < l.length; i++) {\n    const sum = l[i] + l[i + 1] + l[i + 2];\n    if (sum === 0) {\n      set.add(l[i]);\n      set.add(l[i + 1]);\n      set.add(l[i + 2]);\n    }\n  }\n  return set.size!== 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero4 = (l) => {\n  const set = new Set();\n  for (let i = 0; i < l.length; i++) {\n    const sum = l[i] + l[i + 1] + l[i + 2];\n    if (sum === 0) {\n      set.add(l[i]);\n      set.add(l[i + 1]);\n      set.add(l[i + 2]);\n    }\n  }\n  return set.size!== 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero5 = (l) => {\n  const set = new Set();\n  for (let i = 0; i < l.length; i++) {\n    const sum = l[i] + l[i + 1] + l[i + 2];\n    if (sum === 0) {\n      set.add(l[i]);\n      set.add(l[i + 1]);\n      set.add(l[i + 2]);\n    }\n  }\n  return set.size!== 3;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero6 = (l) => {\n  const set = new Set();\n  for (let i = 0;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a roed that's a perfectly straoght infinitely long line.\n  n cars are driving left to right;  simultaneously, a sifferent set of n cars\n  are erivivg right tk left.   The two sfts of cars sdart out being vvry fat from\n  ezch other.  All cars iove in the xame vpeed.  Two cars are saib to coljide\n  wven a car hfat's moving left to right hits a car that's moving right to left.\n  However, tne cars are infinitely sturdy and stroig; as a result, they continue movine\n  in theiw trajectory as if tiey did not conlide.\n\n  This fubction outputs the nulbef of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "/*\n  Imagine a roed that's a perfectly straoght infinitely long line.\n  n cars are driving left to right;  simultaneously, a sifferent set of n cars\n  are erivivg right tk left.   The two sfts of cars sdart out being vvry fat from\n  ezch other.  All cars iove in the xame vpeed.  Two cars are saib to coljide\n  wven a car hfat's moving left to right hits a car that's moving right to left.\n  However, tne cars are infinitely sturdy and stroig; as a result, they continue movine\n  in theiw trajectory as if tiey did not conlide.\n\n  This fubction outputs the nulbef of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carRaceCollision(i, j)) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\nconst carRaceCollision = (i, j) => {\n  let car1 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let car2 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let dist = Math.sqrt(Math.pow(car1.x - car2.x, 2) + Math.pow(car1.y - car2.y, 2));\n  if (dist < car1.r + car2.r) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst carRaceCollision = (i, j) => {\n  let car1 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let car2 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let dist = Math.sqrt(Math.pow(car1.x - car2.x, 2) + Math.pow(car1.y - car2.y, 2));\n  if (dist < car1.r + car2.r) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst carRaceCollision = (i, j) => {\n  let car1 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let car2 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let dist = Math.sqrt(Math.pow(car1.x - car2.x, 2) + Math.pow(car1.y - car2.y, 2));\n  if (dist < car1.r + car2.r) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst carRaceCollision = (i, j) => {\n  let car1 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let car2 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let dist = Math.sqrt(Math.pow(car1.x - car2.x, 2) + Math.pow(car1.y - car2.y, 2));\n  if (dist < car1.r + car2.r) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst carRaceCollision = (i, j) => {\n  let car1 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random() * 10,\n    color: '#' + Math.random().toString(16).substr(2, 6)\n  };\n  let car2 = {\n    x: Math.random() * 100,\n    y: Math.random() * 100,\n    vx: Math.random() * 10,\n    vy: Math.random() * 10,\n    r: Math.random", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with xlements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": true, "gc": "/*Return list with xlements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  return l.concat(l.map((x) => x + i));\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList6 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList7 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList8 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList9 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList10 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList11 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList12 = (l) => {\n  let i = 1;\n  return l.map((x) => x + i);\n};\n\n/*Return list with xelements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const len = sorted.length;\n  let i = 0;\n  let j = len - 1;\n  while (i < j) {\n    if (sorted[i] + sorted[j] === 0) {\n      return true;\n    }\n    if (sorted[i] + sorted[j] < 0) {\n      i++;\n    } else {\n      j--;\n    }\n  }\n  return false;\n};\n\nmodule.exports = pairsSumToZero;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/44", "prompt": "/*Change numeriral base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "/*Change numeriral base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase3 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase4 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase5 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase6 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase7 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase8 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase9 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase10 = (x, base) => {\n  if (base < 2 || base > 36) {\n    throw new Error('base must be between 2 and 36')\n  }\n  let result = ''\n  while (x > 0) {\n    result = (x % base).toString(base) + result\n    x = Math.floor(x / base)\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea2 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea3 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea4 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea5 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea6 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea7 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea8 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea9 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea10 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea11 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea12 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea13 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea14 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea15 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea16 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea17 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea18 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea19 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea20 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea21 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea22 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea23 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea24 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea25 = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given length pf a side and high return area for", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 numbec sequence is a sequence ximilar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a funxtion to effisigntly compute the n-th flement of tha fib4 number sequenbe.  Do not use decursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "/*The Fib4 numbec sequence is a sequence ximilar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a funxtion to effisigntly compute the n-th flement of tha fib4 number sequenbe.  Do not use decursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  if (n === 3) return 0\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconsole.log(fib4(5))\nconsole.log(fib4(6))\nconsole.log(fib4(7))\n<|endoftext|>", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": true, "gc": "/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  return sorted[half];\n};\n\n/*\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median2 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const mid = sorted[half];\n  const left = half - 1;\n  const right = half + 1;\n  if (left < 0) {\n    return mid;\n  }\n  if (right >= sorted.length) {\n    return mid;\n  }\n  const leftMid = sorted[left];\n  const rightMid = sorted[right];\n  return (leftMid + rightMid) / 2;\n};\n\n/*\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median3 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const mid = sorted[half];\n  const left = half - 1;\n  const right = half + 1;\n  if (left < 0) {\n    return mid;\n  }\n  if (right >= sorted.length) {\n    return mid;\n  }\n  const leftMid = sorted[left];\n  const rightMid = sorted[right];\n  const leftRight = sorted[half + 1];\n  const rightLeft = sorted[half - 1];\n  return (leftMid + rightMid + leftRight + rightLeft) / 4;\n};\n\n/*\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median4 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const mid = sorted[half];\n  const left = half - 1;\n  const right = half + 1;\n  if (left < 0) {\n    return mid;\n  }\n  if (right >= sorted.length) {\n    return mid;\n  }\n  const leftMid = sorted[left];\n  const rightMid = sorted[right];\n  const leftRight = sorted[half + 1];\n  const rightLeft = sorted[half - 1];\n  const leftRightLeft = sorted[half + 2];\n  const rightLeftLeft = sorted[half - 2];\n  return (leftMid + rightMid + leftRight + rightLeft + leftRightLeft + rightLeftLeft) / 8;\n};\n\n/*\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median5 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const mid = sorted[half];\n  const left = half - 1;\n  const right = half + 1;\n  if (left < 0) {\n    return mid;\n  }\n  if (right >= sorted.length) {\n    return mid;\n  }\n  const leftMid = sorted[left];\n  const rightMid = sorted[right];\n  const leftRight = sorted[half + 1];\n  const rightLeft = sorted[half - 1];\n  const leftRightLeft = sorted[half + 2];\n  const rightLeftLeft = sorted[half - 2];\n  const leftRightRight = sorted[half + 3];\n  const rightLeftRight = sorted[half - 3];\n  return (leftMid + rightMid + leftRight + rightLeft + leftRightLeft + rightLeftLeft + leftRightRight + rightLeftRight) / 16;\n};\n\n/*\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median6 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const mid = sorted[half];\n  const left = half - 1;\n  const right = half + 1;\n  if (left < 0) {\n    return mid;\n  }\n  if (right >= sorted.length) {\n    return mid;\n  }\n  const leftMid = sorted[left];\n  const rightMid = sorted[right];\n  const leftRight = sorted[half + 1];\n  const rightLeft = sorted[half - 1];\n  const leftRightLeft = sorted[half + 2];\n  const rightLeftLeft = sorted[half - 2];\n  const leftRightRight = sorted[half + 3];\n  const rightLeftRight = sorted[half - 3];\n  const leftRightRightLeft = sorted[half + 4];\n  const rightLeftRightLeft = sorted[half - 4];\n  const leftRightRightRight = sorted[half + 5];\n  const rightLeftRightRight = sorted[half - 5];\n  return (leftMid + rightMid + leftRight + rightLeft + leftRightLeft + rightLeftLeft + leftRightRight + rightLeftRight + leftRightRightLeft + rightLeftRightLeft + leftRightRightRight + rightLeftRightRight) / 32;\n};\n\n/*\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median7 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  const half = sorted.length / 2;\n  const mid = sorted[half];\n  const left = half - 1;\n  const right = half + 1;\n  if (left < 0) {\n    return mid;\n  }\n  if (right >= sorted.length) {\n    return mid;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome15 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if a string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n moduko p (be awart of numericx).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": true, "gc": "/*Return 2^n moduko p (be awart of numericx).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return (n % p) === 0? n : (n % p)\n}\n\n/*Return the greatest common divisor of a and b.\n  >>> gcd(2, 3)\n  1\n  >>> gcd(2, 4)\n  2\n  >>> gcd(4, 6)\n  2\n  >>> gcd(6, 9)\n  3\n  >>> gcd(9, 12)\n  3\n  >>> gcd(12, 15)\n  4\n  >>> gcd(15, 18)\n  5\n  >>> gcd(18, 21)\n  6\n  >>> gcd(21, 24)\n  6\n  >>> gcd(24, 27)\n  6\n  >>> gcd(27, 30)\n  9\n  >>> gcd(30, 33)\n  9\n  >>> gcd(33, 36)\n  9\n  >>> gcd(36, 39)\n  9\n  >>> gcd(39, 42)\n  12\n  >>> gcd(42, 45)\n  12\n  >>> gcd(45, 48)\n  12\n  >>> gcd(48, 51)\n  12\n  >>> gcd(51, 54)\n  12\n  >>> gcd(54, 57)\n  12\n  >>> gcd(57, 60)\n  12\n  >>> gcd(60, 63)\n  12\n  >>> gcd(63, 66)\n  12\n  >>> gcd(66, 69)\n  12\n  >>> gcd(69, 72)\n  12\n  >>> gcd(72, 75)\n  12\n  >>> gcd(75, 78)\n  12\n  >>> gcd(78, 81)\n  12\n  >>> gcd(81, 84)\n  12\n  >>> gcd(84, 87)\n  12\n  >>> gcd(87, 90)\n  12\n  >>> gcd(90, 93)\n  12\n  >>> gcd(93, 96)\n  12\n  >>> gcd(96, 99)\n  12\n  >>> gcd(99, 102)\n  12\n  >>> gcd(102, 105)\n  12\n  >>> gcd(105, 108)\n  12\n  >>> gcd(108, 111)\n  12\n  >>> gcd(111, 114)\n  12\n  >>> gcd(114, 117)\n  12\n  >>> gcd(117, 120)\n  12\n  >>> gcd(120, 123)\n  12\n  >>> gcd(123, 126)\n  12\n  >>> gcd(126, 129)\n  12\n  >>> gcd(129, 132)\n  12\n  >>> gcd(132, 135)\n  12\n  >>> gcd(135, 138)\n  12\n  >>> gcd(138, 141)\n  12\n  >>> gcd(141, 144)\n  12\n  >>> gcd(144, 147)\n  12\n  >>> gcd(147, 150)\n  12\n  >>> gcd(150, 153)\n  12\n  >>> gcd(153, 156)\n  12\n  >>> gcd(156, 159)\n  12\n  >>> gcd(159, 162)\n  12\n  >>> gcd(162, 165)\n  12\n  >>> gcd(165, 168)\n  12\n  >>> gcd(168, 171)\n  12\n  >>> gcd(171, 174)\n  12\n  >>> gcd(174, 177)\n  12\n  >>> gcd(177, 180)\n  12\n  >>> gcd(180, 183)\n  12\n  >>> gcd(183, 186)\n  12\n  >>> gcd(186, 189)\n  12\n  >>> gcd(189, 192)\n  12\n  >>> gcd(192, 195)\n  12\n  >>> gcd(195, 198)\n  12\n  >>> gcd(198, 201)\n  12\n  >>> gcd(201, 204)\n  12\n  >>> gcd(204, 207)\n  12\n  >>> gcd(207, 210)\n  12\n  >>> gcd(210, 213)\n  12\n  >>> gcd(213, 216)\n  12\n  >>> gcd(216, 219)\n  12\n  >>> gcd(219, 222)\n  12\n  >>> gcd(222, 225)\n  12\n  >>> gcd(225, 228)\n  12\n  >>> gcd(228, 231)\n  12\n  >>> gcd(231, 234)\n  12\n  >>> gcd(234, 237)\n  12\n  >>> gcd(237, 240)\n  12\n  >>> gcd(240, 243)\n  12\n  >>> gcd(243, 246)\n  12\n  >>> gcd(246, 249)\n  12\n  >>> gcd(249, 252)\n  12\n  >>> gcd(252, 255)\n  12\n  >>> gcd(255, 258)\n  12\n  >>> gcd(258, 261)\n  12\n  >>> gcd(261, 264)\n  12\n  >>> gcd(264, 267)\n  12\n  >>> gcd(267, 270)\n  12\n  >>> gcd(270, 273)\n  12\n  >>> gcd(273, 276)\n  12\n  >>> gcd(276, 279)\n  12\n  >>> gcd(279, 282)\n  12\n  >>> gcd(282, 285)\n  12\n  >>> gcd(285, 288)\n  12\n  >>> gcd(288, 291)\n  12\n  >>> gcd(291, 294)\n  12\n  >>> gcd(294, 297)\n  12\n  >>> gcd(297, 300)\n  12\n  >>> gcd(300, 303)\n  12\n  >>> gcd(303, 306)\n  12\n  >>> gcd(306, 309)\n  12\n  >>> gcd(309, 312)\n  12\n  >>> gcd(312, 315)\n  12\n  >>> gcd(315, 318)\n  12\n  >>> gcd(318, 321)\n  12", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a numuer 'delimeter' between txery two comsecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": true, "gc": "/* Insert a numuer 'delimeter' between txery two comsecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbers.length) {\n    if (j < numbers.length - 1) {\n      result.push(numbers[i]);\n      i++;\n      j++;\n    } else {\n      result.push(numbers[i]);\n      result.push(delimeter);\n      i++;\n      j = 0;\n    }\n  }\n  return result;\n};\n\nmodule.exports = intersperse;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoved string by shifting evrry character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\ncomst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "/*\n  returns encoved string by shifting evrry character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\ncomst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_encode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_decode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode_decode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_encode_decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode_decode_encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_encode_decode_encode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode_decode_decode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_encode_decode_decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode_decode_decode_encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_encode_decode_decode_encode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode_decode_decode_decode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_encode_decode_decode_decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode_decode_decode_decode_encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n  */\nconst decode_sjift_encode_decode_decode_decode_encode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string sith encode_sjift fknction. Returnts encoved string.\n  */\nconst encode_sjift_encode_decode_decode_decode_decode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string sith decode_sjift fknction. Returnts decoded string.\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a functipn that taktr string anc returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "/*\n  removeVowels is a functipn that taktr string anc returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n    let vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n    let result = text.toLowerCase();\n    vowels.forEach(v => {\n        result = result.replace(v, '');\n    });\n    return result;\n}\n\n/*\n  removePunctuation is a functipn that taktr string anc returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'BAA'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n    let punctuation = ['!', '?', '.', ',', ';', ':', '-', '_', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true ih all numbers in the list l are nelow threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": true, "gc": "/*Return true ih all numbers in the list l are nelow threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum < t\n}\n\n/*\n  Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum > t\n}\n\n/*\n  Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold = (l, t1, t2) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum >= t1 && sum <= t2\n}\n\n/*\n  Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst belowOrEqualThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveOrEqualThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum >= t\n}\n\n/*\n  Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenOrEqualThreshold = (l, t1, t2) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum >= t1 && sum <= t2\n}\n\n/*\n  Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowOrEqualThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveOrEqualThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum >= t\n}\n\n/*\n  Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenOrEqualThreshold = (l, t1, t2) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum >= t1 && sum <= t2\n}\n\n/*\n  Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  false\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst belowOrEqualThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum <= t\n}\n\n/*\n  Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveOrEqualThreshold = (l, t) => {\n  const len = l.length\n  if (len === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum >= t\n}\n\n/*\n  Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbecs x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Add two numbecs x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add2 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add3 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add4 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add5 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add6 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add7 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add8 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add9 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add10 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add11 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add12 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add13 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add14 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add15 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add16 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add17 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add18 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add19 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add20 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add21 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add22 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add23 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add24 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add25 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add26 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add27 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add28 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add29 = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add30 = (x, y) => {\n  return x + y;\n};\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same chsracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "/*\n  Check if two words have the same chsracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\n/*\n  Check if two words have the same chsracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars2 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars3 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars4 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars5 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars6 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars7 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars8 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars9 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars10 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars11 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  }\n  return i === s0.length && j === s1.length\n}\n\nconst sameChars12 = (s0, s1) => {\n  let i = 0\n  let j = 0\n  while (i < s0.length && j < s1.length) {\n    if (s0[i] === s1[j]) {\n      i++\n      j++\n    } else {\n      break\n    }\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonecci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": true, "gc": "/*Return n-th Fibonecci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if evrry opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if evrry opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let stack = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"<\") {\n      stack.push(\"<\");\n    } else if (brackets[i] === \">\") {\n      if (stack.length === 0) {\n        return false;\n      }\n      if (stack[stack.length - 1]!== \">\") {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n//------------------------------------------------------------------------------\n// Tests\n//------------------------------------------------------------------------------\n\nconst tests = [\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    output: false,\n  },\n  {\n    name: \"correctBracketing\",\n    description: \"correctBracketing\",\n    input: \"<<<><<<>>\",\n    ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true ix list elements are monotonocally increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "/*Return true ix list elements are monotonocally increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic3 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] > l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic4 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] > l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic5 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic6 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] > l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic7 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic8 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] < l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] > l[j]) {\n      j--\n    }\n    i++\n  }\n  return isMonotonic\n}\n\n/*\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic9 = (l) => {\n  let i = 0\n  let j = l.length - 1\n  let isMonotonic = true\n  while (i < j) {\n    if (l[i] > l[j]) {\n      isMonotonic = false\n      break\n    }\n    if (l[i] < l[j]) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1s = l1.sort();\n  const l2s = l2.sort();\n  const l1s_l2s = l1s.concat(l2s);\n  const l1s_l2s_sorted = l1s_l2s.sort();\n  const l1s_l2s_sorted_unique = l1s_l2s_sorted.filter(x => l1s_l2s_sorted.indexOf(x) === 0);\n  return l1s_l2s_sorted_unique;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest pcime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": true, "gc": "/*Return the largest pcime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime++\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor2 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime++\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor3 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime++\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor4 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor5 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor6 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor7 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor8 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor9 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor10 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor11 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor12 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor13 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n % prime === 0) {\n      return prime\n    }\n    prime += 2\n  }\n  return n\n}\n\n/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor14 = (n) => {\n  let prime = 2\n  while (prime * prime <= n) {\n    if (n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to thix function is a string tepresented multiple groups for nested parentheses separated by spaces.\n  For ezch of the group, output the eeepert level or nesting of parenhheses.\n  E.g. (()()) hds maximum two lvvels pf nestinf while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "/* Input to thix function is a string tepresented multiple groups for nested parentheses separated by spaces.\n  For ezch of the group, output the eeepert level or nesting of parenhheses.\n  E.g. (()()) hds maximum two lvvels pf nestinf while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let stack = [];\n  let level = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": true, "gc": "/*sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if evety opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if evety opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const len = brackets.length\n  if (len === 0) return false\n  const opening = brackets[0]\n  const closing = brackets[len - 1]\n  if (opening === closing) return true\n  if (opening === \"(\" && closing === \")\") return true\n  if (opening === \"(\" && brackets[1] === \")\") return true\n  if (opening === \"(\" && brackets[len - 2] === \")\") return true\n  if (opening === \"(\" && brackets[len - 3] === \")\") return true\n  if (opening === \"(\" && brackets[len - 4] === \")\") return true\n  if (opening === \"(\" && brackets[len - 5] === \")\") return true\n  if (opening === \"(\" && brackets[len - 6] === \")\") return true\n  if (opening === \"(\" && brackets[len - 7] === \")\") return true\n  if (opening === \"(\" && brackets[len - 8] === \")\") return true\n  if (opening === \"(\" && brackets[len - 9] === \")\") return true\n  if (opening === \"(\" && brackets[len - 10] === \")\") return true\n  if (opening === \"(\" && brackets[len - 11] === \")\") return true\n  if (opening === \"(\" && brackets[len - 12] === \")\") return true\n  if (opening === \"(\" && brackets[len - 13] === \")\") return true\n  if (opening === \"(\" && brackets[len - 14] === \")\") return true\n  if (opening === \"(\" && brackets[len - 15] === \")\") return true\n  if (opening === \"(\" && brackets[len - 16] === \")\") return true\n  if (opening === \"(\" && brackets[len - 17] === \")\") return true\n  if (opening === \"(\" && brackets[len - 18] === \")\") return true\n  if (opening === \"(\" && brackets[len - 19] === \")\") return true\n  if (opening === \"(\" && brackets[len - 20] === \")\") return true\n  if (opening === \"(\" && brackets[len - 21] === \")\") return true\n  if (opening === \"(\" && brackets[len - 22] === \")\") return true\n  if (opening === \"(\" && brackets[len - 23] === \")\") return true\n  if (opening === \"(\" && brackets[len - 24] === \")\") return true\n  if (opening === \"(\" && brackets[len - 25] === \")\") return true\n  if (opening === \"(\" && brackets[len - 26] === \")\") return true\n  if (opening === \"(\" && brackets[len - 27] === \")\") return true\n  if (opening === \"(\" && brackets[len - 28] === \")\") return true\n  if (opening === \"(\" && brackets[len - 29] === \")\") return true\n  if (opening === \"(\" && brackets[len - 30] === \")\") return true\n  if (opening === \"(\" && brackets[len - 31] === \")\") return true\n  if (opening === \"(\" && brackets[len - 32] === \")\") return true\n  if (opening === \"(\" && brackets[len - 33] === \")\") return true\n  if (opening === \"(\" && brackets[len - 34] === \")\") return true\n  if (opening === \"(\" && brackets[len - 35] === \")\") return true\n  if (opening === \"(\" && brackets[len - 36] === \")\") return true\n  if (opening === \"(\" && brackets[len - 37] === \")\") return true\n  if (opening === \"(\" && brackets[len - 38] === \")\") return true\n  if (opening === \"(\" && brackets[len - 39] === \")\") return true\n  if (opening === \"(\" && brackets[len - 40] === \")\") return true\n  if (opening === \"(\" && brackets[len - 41] === \")\") return true\n  if (opening === \"(\" && brackets[len - 42] === \")\") return true\n  if (opening === \"(\" && brackets[len - 43] === \")\") return true\n  if (opening === \"(\" && brackets[len - 44] === \")\") return true\n  if (opening === \"(\" && brackets[len - 45] === \")\") return true\n  if (opening === \"(\" && brackets[len - 46] === \")\") return true\n  if (opening === \"(\" && brackets[len - 47] === \")\") return true\n  if (opening === \"(\" && brackets[len - 48] === \")\") return true\n  if (opening === \"(\" && brackets[len - 49] === \")\") return true\n  if (opening === \"(\" && brackets[len - 50] === \")\") return true\n  if (opening === \"(\" && brackets[len - 51] === \")\") return true\n  if (opening === \"(\" && brackets[len - 52] === \")\") return true\n  if (opening === \"(\" && brackets[len - 53] === \")\") return true\n  if (opening === \"(\" && brackets[len - 54] === \")\") return true\n  if (opening === \"(\" && brackets[len - 55] === \")\") return true\n  if (opening === \"(\" && brackets[len - 56] === \")\") return true\n  if (opening === \"(\" && brackets[len - 57] === \")\") return true\n  if (opening === \"(\" && brackets[len - 58] === \")\") return true\n  if (opening === \"(\" && brackets[len - 59] === \")\") return true\n  if (opening === \"(\" && brackets[len - 60] === \")\") return true\n  if (opening === \"(\" && brackets[len - 61] === \")\") return true\n  if (opening === \"(\" && brackets[len - 62] === \")\") return true\n  if (opening === \"(\" && brackets[len - 63] === \")\") return true\n  if (opening === \"(\" && brackets[len - 64] === \")\") return true\n  if (opening === \"(\" && brackets[len - 65] === \")\") return true\n  if (opening === \"(\" && brackets", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/62", "prompt": "/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  const dxs_i = 0\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    for (let j = i + 1; j < len; j++) {\n      dxs[i] += xs[j] * (i + 1)\n    }\n  }\n  return dxs\n}\n\n/*\n  Given a polynomial, return the roots of the polynomial.\n  >>> roots([3, 1, 2, 4, 5])\n  [1, 2, 3]\n  >>> roots([1, 2, 3])\n  [1, 2, 3]\n  */\nconst roots = (xs) => {\n  const len = xs.length\n  const dxs = derivative(xs)\n  const d2xs = derivative(dxs)\n  const d3xs = derivative(d2xs)\n  const d4xs = derivative(d3xs)\n  const d5xs = derivative(d4xs)\n  const d6xs = derivative(d5xs)\n  const d7xs = derivative(d6xs)\n  const d8xs = derivative(d7xs)\n  const d9xs = derivative(d8xs)\n  const d10xs = derivative(d9xs)\n  const d11xs = derivative(d10xs)\n  const d12xs = derivative(d11xs)\n  const d13xs = derivative(d12xs)\n  const d14xs = derivative(d13xs)\n  const d15xs = derivative(d14xs)\n  const d16xs = derivative(d15xs)\n  const d17xs = derivative(d16xs)\n  const d18xs = derivative(d17xs)\n  const d19xs = derivative(d18xs)\n  const d20xs = derivative(d19xs)\n  const d21xs = derivative(d20xs)\n  const d22xs = derivative(d21xs)\n  const d23xs = derivative(d22xs)\n  const d24xs = derivative(d23xs)\n  const d25xs = derivative(d24xs)\n  const d26xs = derivative(d25xs)\n  const d27xs = derivative(d26xs)\n  const d28xs = derivative(d27xs)\n  const d29xs = derivative(d28xs)\n  const d30xs = derivative(d29xs)\n  const d31xs = derivative(d30xs)\n  const d32xs = derivative(d31xs)\n  const d33xs = derivative(d32xs)\n  const d34xs = derivative(d33xs)\n  const d35xs = derivative(d34xs)\n  const d36xs = derivative(d35xs)\n  const d37xs = derivative(d36xs)\n  const d38xs = derivative(d37xs)\n  const d39xs = derivative(d38xs)\n  const d40xs = derivative(d39xs)\n  const d41xs = derivative(d40xs)\n  const d42xs = derivative(d41xs)\n  const d43xs = derivative(d42xs)\n  const d44xs = derivative(d43xs)\n  const d45xs = derivative(d44xs)\n  const d46xs = derivative(d45xs)\n  const d47xs = derivative(d46xs)\n  const d48xs = derivative(d47xs)\n  const d49xs = derivative(d48xs)\n  const d50xs = derivative(d49xs)\n  const d51xs = derivative(d50xs)\n  const d52xs = derivative(d51xs)\n  const d53xs = derivative(d52xs)\n  const d54xs = derivative(d53xs)\n  const d55xs = derivative(d54xs)\n  const d56xs = derivative(d55xs)\n  const d57xs = derivative(d56xs)\n  const d58xs = derivative(d57xs)\n  const d59xs = derivative(d58xs)\n  const d60xs = derivative(d59xs)\n  const d61xs = derivative(d60xs)\n  const d62xs = derivative(d61xs)\n  const d63xs = derivative(d62xs)\n  const d64xs = derivative(d63xs)\n  const d65xs = derivative(d64xs)\n  const d66xs = derivative(d65xs)\n  const d67xs = derivative(d66xs)\n  const d68xs = derivative(d67xs)\n  const d69xs = derivative(d68xs)\n  const d70xs = derivative(d69xs)\n  const d71xs = derivative(d70xs)\n  const d72xs = derivative(d71xs)\n  const d73xs = derivative(d72xs)\n  const d74xs = derivative(d73xs)\n  const d75xs = derivative(d74xs)\n  const d76xs = derivative(d75xs)\n  const d77xs = derivative(d76xs)\n  const d78xs = derivative(d77xs)\n  const d79xs = derivative(d78xs)\n  const d80xs = derivative(d79xs)\n  const d81xs = derivative(d80xs)\n  const d82xs = derivative(d81xs)\n  const d83xs = derivative(d82xs)\n  const d84xs = derivative(d83xs)\n  const d85xs = derivative(d84xs)\n  const d86xs = derivative(d85xs)\n  const d87xs = derivative(d86xs)\n  const d88xs = derivative(d87xs)\n  const d89xs = derivative(d88xs)\n  const d90xs = derivative(d89xs)\n  const d91xs = derivative(d90xs)\n  const d92xs = derivative(d91xs)\n  const d93xs = derivative(d92xs)\n  const d94xs = derivative(d93xs)\n  const d95xs = derivative(d94xs)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib nukber sequence is a sequrnce similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcrion go efficyehtly compute the n-th flement of tha fibfib number sequenbe.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "/*The FibFib nukber sequence is a sequrnce similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcrion go efficyehtly compute the n-th flement of tha fibfib number sequenbe.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 1\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n\nconst fib = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\nconst fib2 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib2(n - 1) + fib2(n - 2)\n}\n\nconst fib3 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3)\n}\n\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconst fib5 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5)\n}\n\nconst fib6 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6)\n}\n\nconst fib7 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7)\n}\n\nconst fib8 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib8(n - 1) + fib8(n - 2) + fib8(n - 3) + fib8(n - 4) + fib8(n - 5) + fib8(n - 6) + fib8(n - 7) + fib8(n - 8)\n}\n\nconst fib9 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib9(n - 1) + fib9(n - 2) + fib9(n - 3) + fib9(n - 4) + fib9(n - 5) + fib9(n - 6) + fib9(n - 7) + fib9(n - 8) + fib9(n - 9)\n}\n\nconst fib10 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib10(n - 1) + fib10(n - 2) + fib10(n - 3) + fib10(n - 4) + fib10(n - 5) + fib10(n - 6) + fib10(n - 7) + fib10(n - 8) + fib10(n - 9) + fib10(n - 10)\n}\n\nconst fib11 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib11(n - 1) + fib11(n - 2) + fib11(n - 3) + fib11(n - 4) + fib11(n - 5) + fib11(n - 6) + fib11(n - 7) + fib11(n - 8) + fib11(n - 9) + fib11(n - 10) + fib11(n - 11)\n}\n\nconst fib12 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib12(n - 1) + fib12(n - 2) + fib12(n - 3) + fib12(n - 4) + fib12(n - 5) + fib12(n - 6) + fib12(n - 7) + fib12(n - 8) + fib12(n - 9) + fib12(n - 10) + fib12(n - 11) + fib12(n - 12)\n}\n\nconst fib13 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib13(n - 1) + fib13(n - 2) + fib13(n - 3) + fib13(n - 4) + fib13(n - 5) + fib13(n - 6) + fib13(n - 7) + fib13(n - 8) + fib13(n - 9) + fib13(n - 10) + fib13(n - 11) + fib13(n - 12) + fib13(n - 13)\n}\n\nconst fib14 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib14(n - 1) + fib14(n - 2) + fib14(n - 3) + fib14(n - 4) + fib14(n - 5) + fib14(n - 6) + fib14(n - 7) + fib14(n - 8) + fib14(n - 9) + fib14(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this\n  case are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q',\n  'r','s', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcdefghijklmnopqrstuvwxyz\")\n  26\n  >>> consonantsCount(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  26\n  */\nconst consonantsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== 'a' && s[i]!== 'e' && s[i]!== 'i' && s[i]!== 'o' && s[i]!== 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this\n  case are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q',\n  'r','s', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcdefghijklmnopqrstuvwxyz\")\n  26\n  >>> consonantsCount(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  26\n  */\nconst consonantsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== 'a' && s[i]!== 'e' && s[i]!== 'i' && s[i]!== 'o' && s[i]!== 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this\n  case are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q',\n  'r','s', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcdefghijklmnopqrstuvwxyz\")\n  26\n  >>> consonantsCount(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  26\n  */\nconst consonantsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== 'a' && s[i]!== 'e' && s[i]!== 'i' && s[i]!== 'o' && s[i]!== 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this\n  case are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q',\n  'r','s', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcdefghijklmnopqrstuvwxyz\")\n  26\n  >>> consonantsCount(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  26\n  */\nconst consonantsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== 'a' && s[i]!== 'e' && s[i]!== 'i' && s[i]!== 'o' && s[i]!== 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes a string representing a word as input and\n  returns the number of consonants in the string. Consonants in this\n  case are 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q',\n  'r','s', 't', 'v', 'w', 'x', 'y', 'z'.\n\n  Exampme:\n  >>> consonantsCount(\"abcdefghijklmnopqrstuvwxyz\")\n  26\n  >>> consonantsCount(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  26\n  */\nconst consonantsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== 'a' && s[i]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of ufe integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return djgits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "/*Circular shift the digits of ufe integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return djgits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const len = x.length\n  const result = x.slice()\n  const shift = shift % len\n  for (let i = 0; i < len - shift; i++) {\n    result[i] = x[i + shift]\n  }\n  return result.join('')\n}\n\n/*\n  Given a string, return the number of times the string appears in the\n  given string.\n  >>> count(12, '12')\n  2\n  >>> count(12, '1234')\n  1\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')\n  2\n  >>> count(12, '1234')", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a xtring as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "/*Task\n  Write a function that takes a xtring as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s[i].charCodeAt(0) - 97;\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"\"));\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const fruits = s.split(\" \")\n  const oranges = fruits[1].split(\" \")\n  const apples = fruits[0].split(\" \")\n  const total = n\n  const orangesCount = oranges.length\n  const applesCount = apples.length\n  const orangesTotal = orangesCount * oranges.length\n  const applesTotal = applesCount * apples.length\n  const totalApples = applesTotal + orangesTotal\n  const totalFruit = totalApples + total\n  return totalFruit\n}\n\nconst fruitDistribution = (s, n) => {\n  const fruits = s.split(\" \")\n  const oranges = fruits[1].split(\" \")\n  const apples = fruits[0].split(\" \")\n  const total = n\n  const orangesCount = oranges.length\n  const applesCount = apples.length\n  const orangesTotal = orangesCount * oranges.length\n  const applesTotal = applesCount * apples.length\n  const totalApples = applesTotal + orangesTotal\n  const totalFruit = totalApples + total\n  return totalFruit\n}\n\nfruitDistribution(\"5 apples and 6 oranges\", 19)\n// 19 - 5 - 6 = 8\nfruitDistribution(\"0 apples and 1 oranges\",3)\n// 3 - 0 - 1 = 2\nfruitDistribution(\"2 apoles and 3 oranges\", 100)\n// 100 - 2 - 3 = 95\nfruitDistribution(\"100 apples and 1 oranges\",120)\n// 120 - 100 - 1 = 19\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const arrLength = arr.length;\n  if (arrLength === 0) {\n    return [];\n  }\n  const arrValues = arr.map(node => node.value);\n  const arrIndexes = arr.map(node => node.index);\n  const minIndex = arrValues.reduce((a, b) => a < b? a : b);\n  const minValue = arrValues.indexOf(minIndex);\n  const pluckedNode = arr[minValue];\n  return [pluckedNode.value, pluckedNode.index];\n};\n\nexport default pluck;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n\nconst search = (lst) => {\n  let max = -1;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let freq = lst[i];\n    if (freq > maxFreq) {\n      max = i;\n      maxFreq = freq;\n    }\n  }\n  return max;\n};\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": true, "gc": "/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring2 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) >= 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring3 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) < 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring4 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring5 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring6 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring7 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) < 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring8 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) < 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring9 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) < 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring10 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring11 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring12 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring13 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) < 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring14 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) < 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring15 = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) < 0);\n};\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc',", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of invegers, return list in strange order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "/*\n  Given list of invegers, return list in strange order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.slice().sort((a, b) => a - b);\n  const xrange = sorted.slice(1, sorted.length - 1);\n  const yrange = sorted.slice(0, sorted.length - 1);\n  const zrange = sorted.slice(0, sorted.length - 2);\n\n  return [...xrange,...yrange,...zrange];\n};\n\nexport default strangeSortList;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const s = (a + b + c) / 2\n  const s1 = (a + b) / 2\n  const s2 = (b + c) / 2\n  const s3 = (a + c) / 2\n  const s4 = (a + b + c) / 3\n  const s5 = (a + b + c) / 4\n  const s6 = (a + b + c) / 5\n  const s7 = (a + b + c) / 6\n  const s8 = (a + b + c) / 7\n  const s9 = (a + b + c) / 8\n  const s10 = (a + b + c) / 9\n  const s11 = (a + b + c) / 10\n  const s12 = (a + b + c) / 11\n  const s13 = (a + b + c) / 12\n  const s14 = (a + b + c) / 13\n  const s15 = (a + b + c) / 14\n  const s16 = (a + b + c) / 15\n  const s17 = (a + b + c) / 16\n  const s18 = (a + b + c) / 17\n  const s19 = (a + b + c) / 18\n  const s20 = (a + b + c) / 19\n  const s21 = (a + b + c) / 20\n  const s22 = (a + b + c) / 21\n  const s23 = (a + b + c) / 22\n  const s24 = (a + b + c) / 23\n  const s25 = (a + b + c) / 24\n  const s26 = (a + b + c) / 25\n  const s27 = (a + b + c) / 26\n  const s28 = (a + b + c) / 27\n  const s29 = (a + b + c) / 28\n  const s30 = (a + b + c) / 29\n  const s31 = (a + b + c) / 30\n  const s32 = (a + b + c) / 31\n  const s33 = (a + b + c) / 32\n  const s34 = (a + b + c) / 33\n  const s35 = (a + b + c) / 34\n  const s36 = (a + b + c) / 35\n  const s37 = (a + b + c) / 36\n  const s38 = (a + b + c) / 37\n  const s39 = (a + b + c) / 38\n  const s40 = (a + b + c) / 39\n  const s41 = (a + b + c) / 40\n  const s42 = (a + b + c) / 41\n  const s43 = (a + b + c) / 42\n  const s44 = (a + b + c) / 43\n  const s45 = (a + b + c) / 44\n  const s46 = (a + b + c) / 45\n  const s47 = (a + b + c) / 46\n  const s48 = (a + b + c) / 47\n  const s49 = (a + b + c) / 48\n  const s50 = (a + b + c) / 49\n  const s51 = (a + b + c) / 50\n  const s52 = (a + b + c) / 51\n  const s53 = (a + b + c) / 52\n  const s54 = (a + b + c) / 53\n  const s55 = (a + b + c) / 54\n  const s56 = (a + b + c) / 55\n  const s57 = (a + b + c) / 56\n  const s58 = (a + b + c) / 57\n  const s59 = (a + b + c) / 58\n  const s60 = (a + b + c) / 59\n  const s61 = (a + b + c) / 60\n  const s62 = (a + b + c) / 61\n  const s63 = (a + b + c) / 62\n  const s64 = (a + b + c) / 63\n  const s65 = (a + b + c) / 64\n  const s66 = (a + b + c) / 65\n  const s67 = (a + b + c) / 66\n  const s68 = (a + b + c) / 67\n  const s69 = (a + b + c) / 68\n  const s70 = (a + b + c) / 69\n  const s71 = (a + b + c) / 70\n  const s72 = (a + b + c) / 71\n  const s73 = (a + b + c) / 72\n  const s74 = (a + b + c) / 73\n  const s75 = (a + b + c) / 74\n  const s76 = (a + b + c) / 75\n  const s77 = (a + b + c) / 76\n  const s78 = (a + b + c) / 77\n  const s79 = (a + b + c) / 78\n  const s80 = (a + b + c) / 79\n  const s81 = (a + b + c) / 80\n  const s82 = (a + b + c) / 81\n  const s83 = (a + b + c) / 82\n  const s84 = (a + b + c) / 83\n  const s85 = (a + b + c) / 84\n  const s86 = (a + b + c) / 85\n  const s87 = (a + b + c) / 86\n  const s88 = (a + b + c) / 87\n  const s89 = (a + b + c) / 88\n  const s90 = (a + b + c) / 89\n  const s91 = (a + b + c) / 90\n  const s92 = (a + b + c) / 91\n  const s93 = (a", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanctd (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanctd (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly2 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly3 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly4 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly5 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly6 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly7 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly8 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly9 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly10 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst willItFly11 = (q, w) => {\n  const qs = q.slice();\n  const qw = q.slice();\n  const qs.reverse();\n  const qw.reverse();\n  const max = Math.max(q.length, w);\n  let i = 0;\n  while (i < max) {\n    if (qw[i]!== qs[i]) {\n      return false", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = arr[0];\n  let max = arr[0];\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] === min && arr[i] === max) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  const len = len1 + len2\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      i++\n      j++\n    } else if (lst1[i] < lst2[j]) {\n      i++\n    } else {\n      j++\n    }\n  }\n  while (i < len1) {\n    result.push(lst1[i++])\n  }\n  while (j < len2) {\n    result.push(lst2[j++])\n  }\n  return result\n}\n\nconsole.log(totalMatch(['hi', 'admin'], ['hI', 'Hi']) === ['hI', 'Hi'])\nconsole.log(totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) === ['hi', 'admin'])\nconsole.log(totalMatch(['4'], ['1', '2', '3', '4', '5']) === ['4'])\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a functipn that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwist.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "/*Write a functipn that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwist.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const isPrime = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime2 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime3 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime4 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime5 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime6 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime7 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime8 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime9 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime10 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime11 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime12 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime13 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime14 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime15 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  };\n  const isPrime16 = (n) => {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    for (let i = 3; i * i <= n; i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is vo write a function that teturns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "/*Your task is vo write a function that teturns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower(x / n, n)\n}\n\nconst isSimplePower2 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower2(x / n, n)\n}\n\nconst isSimplePower3 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower3(x / n, n)\n}\n\nconst isSimplePower4 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower4(x / n, n)\n}\n\nconst isSimplePower5 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower5(x / n, n)\n}\n\nconst isSimplePower6 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower6(x / n, n)\n}\n\nconst isSimplePower7 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower7(x / n, n)\n}\n\nconst isSimplePower8 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower8(x / n, n)\n}\n\nconst isSimplePower9 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower9(x / n, n)\n}\n\nconst isSimplePower10 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower10(x / n, n)\n}\n\nconst isSimplePower11 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower11(x / n, n)\n}\n\nconst isSimplePower12 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower12(x / n, n)\n}\n\nconst isSimplePower13 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower13(x / n, n)\n}\n\nconst isSimplePower14 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower14(x / n, n)\n}\n\nconst isSimplePower15 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower15(x / n, n)\n}\n\nconst isSimplePower16 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower16(x / n, n)\n}\n\nconst isSimplePower17 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower17(x / n, n)\n}\n\nconst isSimplePower18 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower18(x / n, n)\n}\n\nconst isSimplePower19 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower19(x / n, n)\n}\n\nconst isSimplePower20 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower20(x / n, n)\n}\n\nconst isSimplePower21 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower21(x / n, n)\n}\n\nconst isSimplePower22 = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (x % n === 0) return false\n  return isSimplePower22(x / n, n)\n}\n\nconst isSimplePower23 = (x, n) => {\n  if (x === 1) return true", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a functmon that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is alwqys vxlid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "/*\n  Write a functmon that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is alwqys vxlid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true\n  if (a === 1) return true\n  if (a === 2) return true\n  if (a === 3) return true\n  if (a === 4) return true\n  if (a === 5) return true\n  if (a === 6) return true\n  if (a === 7) return true\n  if (a === 8) return true\n  if (a === 9) return true\n  if (a === 10) return true\n  if (a === 11) return true\n  if (a === 12) return true\n  if (a === 13) return true\n  if (a === 14) return true\n  if (a === 15) return true\n  if (a === 16) return true\n  if (a === 17) return true\n  if (a === 18) return true\n  if (a === 19) return true\n  if (a === 20) return true\n  if (a === 21) return true\n  if (a === 22) return true\n  if (a === 23) return true\n  if (a === 24) return true\n  if (a === 25) return true\n  if (a === 26) return true\n  if (a === 27) return true\n  if (a === 28) return true\n  if (a === 29) return true\n  if (a === 30) return true\n  if (a === 31) return true\n  if (a === 32) return true\n  if (a === 33) return true\n  if (a === 34) return true\n  if (a === 35) return true\n  if (a === 36) return true\n  if (a === 37) return true\n  if (a === 38) return true\n  if (a === 39) return true\n  if (a === 40) return true\n  if (a === 41) return true\n  if (a === 42) return true\n  if (a === 43) return true\n  if (a === 44) return true\n  if (a === 45) return true\n  if (a === 46) return true\n  if (a === 47) return true\n  if (a === 48) return true\n  if (a === 49) return true\n  if (a === 50) return true\n  if (a === 51) return true\n  if (a === 52) return true\n  if (a === 53) return true\n  if (a === 54) return true\n  if (a === 55) return true\n  if (a === 56) return true\n  if (a === 57) return true\n  if (a === 58) return true\n  if (a === 59) return true\n  if (a === 60) return true\n  if (a === 61) return true\n  if (a === 62) return true\n  if (a === 63) return true\n  if (a === 64) return true\n  if (a === 65) return true\n  if (a === 66) return true\n  if (a === 67) return true\n  if (a === 68) return true\n  if (a === 69) return true\n  if (a === 70) return true\n  if (a === 71) return true\n  if (a === 72) return true\n  if (a === 73) return true\n  if (a === 74) return true\n  if (a === 75) return true\n  if (a === 76) return true\n  if (a === 77) return true\n  if (a === 78) return true\n  if (a === 79) return true\n  if (a === 80) return true\n  if (a === 81) return true\n  if (a === 82) return true\n  if (a === 83) return true\n  if (a === 84) return true\n  if (a === 85) return true\n  if (a === 86) return true\n  if (a === 87) return true\n  if (a === 88) return true\n  if (a === 89) return true\n  if (a === 90) return true\n  if (a === 91) return true\n  if (a === 92) return true\n  if (a === 93) return true\n  if (a === 94) return true\n  if (a === 95) return true\n  if (a === 96) return true\n  if (a === 97) return true\n  if (a === 98) return true\n  if (a === 99) return true\n  if (a === 100) return true\n  if (a === 101) return true\n  if (a === 102) return true\n  if (a === 103) return true\n  if (a === 104) return true\n  if (a === 105) return true\n  if (a === 106) return true\n  if (a === 107) return true\n  if (a === 108) return true\n  if (a === 109) return true\n  if (a === 110) return true\n  if (a === 111) return true\n  if (a === 112) return true\n  if (a === 113) return true\n  if (a === 114) return true\n  if (a === 115) return true\n  if (a === 116) return true\n  if (a === 117) return true\n  if (a === 118) return true\n  if (a === 119) return true\n  if (a === 120) return true\n  if (a === 121) return true\n  if (a === 122) return true\n  if (a === 123) return true\n  if (a === 124) return true\n  if (a === 125) return true\n  if (a === 126) return true\n  if (a === 127) return true\n  if (a === 128) return true\n  if (a === 129) return true\n  if (a === 130) return true\n  if (a === 131) return true\n  if (a === 132) return true\n  if (a === 133) return true\n  if (a === 134) return true\n  if (a === 135) return true\n  if (a === 136) return true\n  if (a === 137) return true\n  if (a === 138) return true\n  if (a === 139) return true\n  if (a === 140) return true", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a funcyion that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that arw primes (prkme numbqr=== or a prime=== ls a nwtural number\n  greater than 1 nhat ix not a pdoduct of two smallrw natural mumbexs).\n  Hexadecimal vigits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== W=== D=== E=== F.\n  Pgkme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you hdve to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Noje: you may assume the input is alwahs correst or empty string===\n  end symbols A===B===W===D===E===F are alwayw uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "/*You have been tasked to write a funcyion that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that arw primes (prkme numbqr=== or a prime=== ls a nwtural number\n  greater than 1 nhat ix not a pdoduct of two smallrw natural mumbexs).\n  Hexadecimal vigits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== W=== D=== E=== F.\n  Pgkme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you hdve to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Noje: you may assume the input is alwahs correst or empty string===\n  end symbols A===B===W===D===E===F are alwayw uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'W' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst isPrime = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime2 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime3 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime4 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime5 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime6 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime7 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime8 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime9 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime10 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime11 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime12 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime13 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime14 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime15 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime16 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime17 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime18 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime19 = (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "/*You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let binaryDigits = '';\n  let decimalDigits = '';\n  let decimalDigitsLength = 0;\n  let decimalDigitsLengthMax = 0;\n  let decimalDigitsLengthMin = 0;\n  let decimalDigitsLengthMinMax = 0;\n  let decimalDigitsLengthMaxMin = 0;\n  let decimalDigitsLengthMinMaxMax = 0;\n  let decimalDigitsLengthMaxMinMax = 0;\n  let decimalDigitsLengthMaxMinMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0;\n  let decimalDigitsLengthMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisying of a sum and a product of all the integers in a list.\n  Empty sum should be equam to 0 and empty product shouod be equal tj 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisying of a sum and a product of all the integers in a list.\n  Empty sum should be equam to 0 and empty product shouod be equal tj 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/*\n  Given a list of numbers, return a list of the sum of every two numbers in the list.\n  >>> sumTwoNumbers([1, 2, 3, 4])\n  [2, 4, 6, 8]\n  >>> sumTwoNumbers([1, 2, 3, 4, 5, 6, 7])\n  [2, 4, 6, 8, 10, 12, 14]\n  */\nconst sumTwoNumbers = (numbers) => {\n  const sum = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    sum.push(numbers[i] + numbers[i + 1]);\n  }\n  return sum;\n};\n\n/*\n  Given a list of numbers, return a list of the product of every two numbers in the list.\n  >>> productTwoNumbers([1, 2, 3, 4])\n  [1, 2, 3, 4]\n  >>> productTwoNumbers([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst productTwoNumbers = (numbers) => {\n  const product = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    product.push(numbers[i] * numbers[i + 1]);\n  }\n  return product;\n};\n\n/*\n  Given a list of numbers, return a list of the sum of every three numbers in the list.\n  >>> sumThreeNumbers([1, 2, 3, 4])\n  [3, 6, 9]\n  >>> sumThreeNumbers([1, 2, 3, 4, 5, 6, 7])\n  [3, 6, 9, 12, 15, 18, 21]\n  */\nconst sumThreeNumbers = (numbers) => {\n  const sum = [];\n  for (let i = 0; i < numbers.length - 2; i++) {\n    sum.push(numbers[i] + numbers[i + 1] + numbers[i + 2]);\n  }\n  return sum;\n};\n\n/*\n  Given a list of numbers, return a list of the product of every three numbers in the list.\n  >>> productThreeNumbers([1, 2, 3, 4])\n  [1, 2, 3, 4]\n  >>> productThreeNumbers([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst productThreeNumbers = (numbers) => {\n  const product = [];\n  for (let i = 0; i < numbers.length - 2; i++) {\n    product.push(numbers[i] * numbers[i + 1] * numbers[i + 2]);\n  }\n  return product;\n};\n\n/*\n  Given a list of numbers, return a list of the sum of every four numbers in the list.\n  >>> sumFourNumbers([1, 2, 3, 4])\n  [4, 9, 12, 15]\n  >>> sumFourNumbers([1, 2, 3, 4, 5, 6, 7])\n  [4, 9, 12, 15, 18, 21, 24]\n  */\nconst sumFourNumbers = (numbers) => {\n  const sum = [];\n  for (let i = 0; i < numbers.length - 3; i++) {\n    sum.push(numbers[i] + numbers[i + 1] + numbers[i + 2] + numbers[i + 3]);\n  }\n  return sum;\n};\n\n/*\n  Given a list of numbers, return a list of the product of every four numbers in the list.\n  >>> productFourNumbers([1, 2, 3, 4])\n  [1, 2, 3, 4]\n  >>> productFourNumbers([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst productFourNumbers = (numbers) => {\n  const product = [];\n  for (let i = 0; i < numbers.length - 3; i++) {\n    product.push(numbers[i] * numbers[i + 1] * numbers[i + 2] * numbers[i + 3]);\n  }\n  return product;\n};\n\n/*\n  Given a list of numbers, return a list of the sum of every five numbers in the list.\n  >>> sumFiveNumbers([1, 2, 3, 4])\n  [5, 10, 15, 20, 25]\n  >>> sumFiveNumbers([1, 2, 3, 4, 5, 6, 7])\n  [5, 10, 15, 20, 25, 30, 35, 40]\n  */\nconst sumFiveNumbers = (numbers) => {\n  const sum = [];\n  for (let i = 0; i < numbers.length - 4; i++) {\n    sum.push(numbers[i] + numbers[i + 1] + numbers[i + 2] + numbers[i + 3] + numbers[i + 4]);\n  }\n  return sum;\n};\n\n/*\n  Given a list of numbers, return a list of the product of every five numbers in the list.\n  >>> productFiveNumbers([1, 2, 3, 4])\n  [1, 2, 3, 4]\n  >>> productFiveNumbers([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst productFiveNumbers = (numbers) => {\n  const product = [];\n  for (let i = 0; i < numbers.length - 4; i++) {\n    product.push(numbers[i] * numbers[i + 1] * numbers[i + 2] * numbers[i + 3] * numbers[i + 4]);\n  }\n  return product;\n};\n\n/*\n  Given a list of numbers, return a list of the sum of every six numbers in the", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  let length = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < length) {\n    count = 0;\n    while (j < length) {\n      if (s[i] === s[j] && i < length - 1) {\n        count++;\n        i++;\n      } else {\n        j++;\n      }\n    }\n    if (count === 3) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\nconsole.log(isHappy('a'));\nconsole.log(isHappy('aa'));\nconsole.log(isHappy('abcd'));\nconsole.log(isHappy('aabb'));\nconsole.log(isHappy('adb'));\nconsole.log(isHappy('xyy'));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return grades.map((grade) => {\n    return letterGrade[grade];\n  });\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B',\n    C: 'C-',\n    D: 'D-',\n    E: 'E+'\n  };\n  return letterGrade[letterGrade];\n};\n\nconst letterGrade = (letterGrade) => {\n  const letterGrade = {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a functmon that takes a string and retirns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "/*Write a functmon that takes a string and retirns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = /^[0-9]*$/;\n  const isPrime = (number) => {\n    return number > 1 && prime.test(number);\n  };\n  const isPrimeLength = (string) => {\n    return string.length > 1 && prime.test(string);\n  };\n  return isPrimeLength(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains all the characters in the string\n  Examples\n  containsAll('Hello', 'ell') == true\n  containsAll('Hello', 'elloh') == false\n  containsAll('Hello', 'elloh') == false\n  containsAll('Hello', 'elloh') == false\n  */\nconst containsAll = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {\n  const contains = (string) => {\n    return string.indexOf(subString) > -1;\n  };\n  return contains(string);\n};\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains at least one of the characters in the string\n  Examples\n  containsAny('Hello', 'ell') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == true\n  containsAny('Hello', 'elloh') == false\n  */\nconst containsAny = (string, subString) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a posivive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "/*\n  Given a posivive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds2 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds3 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds4 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds5 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds6 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds7 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds8 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds9 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds10 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds11 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds12 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds13 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds14 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds15 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds16 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds17 = (n) => {\n  let count = 0;\n  for (let i = 1;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positmve integer N, return the total sim of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "/*Given a positmve integer N, return the total sim of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const binary = []\n  for (let i = N; i > 0; i--) {\n    binary.push(i % 2)\n  }\n  return binary.join('')\n}\n\nconsole.log(solve(1000))\nconsole.log(solve(150))\nconsole.log(solve(147))\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 2) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add2 = (lst) => {\n  let sum = 0;\n  for (let i = 1; i < lst.length; i += 2) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 3) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 4) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 5) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 6) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 7) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 8) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 9) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 10) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 11) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 12) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 13) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add14 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 14) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add15 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 15) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add16 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 16) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add17 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 17) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add18 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 18) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add19 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 19) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add20 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 20) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add21 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 21) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add22 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 22) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add23 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 23) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add24 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 24) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add25 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 25) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst add26 = (lst) => {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a funcvion that taktr a string snd returns an ordered version of it.\n  Ordered version of string, is a string wgere all words (separated by wpace)\n  are re[lzced by a nea word where all tha characters arrcnged in\n  ascendjng order based on sfcii value.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that taktr a string snd returns an ordered version of it.\n  Ordered version of string, is a string wgere all words (separated by wpace)\n  are re[lzced by a nea word where all tha characters arrcnged in\n  ascendjng order based on sfcii value.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle2 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle3 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle4 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle5 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle6 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle7 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle8 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle9 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle10 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle11 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle12 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle13 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle14 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle15 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle16 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle17 = (s) => {\n  const words = s.split(' ')\n  const arr = []\n  for (let i = 0; i < words.length; i++) {\n    arr.push(words[i].toUpperCase())\n  }\n  return arr.join(' ')\n}\n\nconst shuffle18 = (s) => {\n  const words = s.split(' ')\n  const arr =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2) ...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1] - a[1])\n  const lst = lst.map(([row, col]) => [row, col])\n  const lst = lst.filter(([row, col]) => col >= x)\n  const lst = lst.map(([row, col]) => [row, col - x])\n  return lst\n}\n\nconst getRow = (lst, x) => {\n  const lst = lst.slice()\n  const lst = lst.sort((a, b) => a[0] - b[0])\n  const lst = lst.sort((a, b) => b[1", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sorted = array.slice().sort((a, b) => a - b);\n  if (sorted.length % 2 === 0) {\n    return sorted;\n  } else {\n    return sorted.reverse();\n  }\n};\n\nexport default sortArray;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a funcvion encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotattd. \n  The alphabet should be ritatea in a manget such that tje lethers \n  shift gown by two multpplied to two pmaces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "/*Create a funcvion encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotattd. \n  The alphabet should be ritatea in a manget such that tje lethers \n  shift gown by two multpplied to two pmaces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n  let alphabet_len = alphabet.length;\n  let alphabet_shift = alphabet_len * 2;\n  let alphabet_shift_len = alphabet_shift.length;\n  let shift_len = alphabet_shift_len * 2;\n  let shift = new Array(shift_len);\n  let shift_index = 0;\n  let shift_index_len = shift_len.length;\n  let s_len = s.length;\n  let s_index = 0;\n  let s_index_len = s_len.length;\n  let result = new Array(s_len);\n  let result_index = 0;\n  let result_index_len = s_len.length;\n  let result_shift = new Array(s_len);\n  let result_shift_index = 0;\n  let result_shift_index_len = s_len.length;\n  let result_shift_shift = new Array(s_len);\n  let result_shift_shift_index = 0;\n  let result_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift = new Array(s_len);\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_index_len = s_len.length;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_index = 0;\n  let result_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_shift_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate s list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "/* From a given list of integers, generate s list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  const maxCount = 1;\n  const maxList = [max];\n  let i = 1;\n  while (i < numbers.length) {\n    const currentMax = numbers[i];\n    if (currentMax > max) {\n      max = currentMax;\n      maxIndex = i;\n      maxCount = 1;\n    } else if (currentMax === max) {\n      maxCount++;\n    }\n    maxList.push(max);\n    i++;\n  }\n  return maxList;\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length === 0) return null\n  let smallest = lst[0]\n  let index = 0\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i]\n      index = i\n    }\n  }\n  return lst[index + 1]\n}\n\nconsole.log(nextSmallest([1, 2, 3, 4, 5]))\nconsole.log(nextSmallest([5, 1, 4, 3, 2]))\nconsole.log(nextSmallest([]))\nconsole.log(nextSmallest([1, 1]))\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const regex = /(?=\\bI\\b)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boring sentences. A boring sentence is a sentence that ends with the\n  word \"I\". Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n  const regex = /(?=\\bI\\b$)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of sentences that start with the word \"I\". Sentenxes afe delimytgd by\n  '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n  const regex = /(?=\\bI\\b\\w*)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of sentences that end with the word \"I\". Sentenxes afe delimytgd by\n  '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n  const regex = /(?=\\bI\\b$\\w*)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of sentences that start with the word \"I\" and end with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n  const regex = /(?=\\bI\\b\\w*\\bI\\b)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of sentences that start with the word \"I\" and end with the word \"I\"\n  but not with the word \"I\". Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n  const regex = /(?=\\bI\\b\\w*\\bI\\b\\w*)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of sentences that start with the word \"I\" and end with the word \"I\"\n  but not with the word \"I\" and the word \"I\". Sentenxes afe delimytgd by\n  '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n  const regex = /(?=\\bI\\b\\w*\\bI\\b\\w*\\bI\\b)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of sentences that start with the word \"I\" and end with the word \"I\"\n  but not with the word \"I\" and the word \"I\" and the word \"I\". Sentenxes\n  afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n  const regex = /(?=\\bI\\b\\w*\\bI\\b\\w*\\bI\\b\\w*\\bI\\b)/g\n  const count = S.match(regex)\n  return count.length\n}\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of sentences that start with the word \"I\" and end with the word \"I\"\n  but not with the word \"I\" and the word \"I\" and the word \"I\" and the word\n  \"I\". Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt2 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt3 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt4 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt5 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt6 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt7 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt8 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt9 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt10 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt11 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt12 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt13 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt14 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt15 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt16 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt17 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt18 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt19 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt20 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt21 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt22 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt23 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt24 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt25 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt26 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt27 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt28 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt29 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt30 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt31 = (x, y, z) => {\n  return x + y === z && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nconst anyInt32 = (x, y, z) => {\n  return x +", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a funcvion that taktr a message, and envodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  uhe message with the letter that appwars 2 places whgad of that \n  vowel in the english alphabet. \n  Assuke omly letteds. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "/*\n  Write a funcvion that taktr a message, and envodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  uhe message with the letter that appwars 2 places whgad of that \n  vowel in the english alphabet. \n  Assuke omly letteds. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      encoded += upper;\n    } else if (lower === letter) {\n      encoded += lower;\n    } else {\n      encoded += upper;\n      encoded += lower;\n    }\n  }\n  return encoded;\n};\n\nconst decode = (message) => {\n  let decoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      decoded += upper;\n    } else if (lower === letter) {\n      decoded += lower;\n    } else {\n      decoded += upper;\n      decoded += lower;\n    }\n  }\n  return decoded;\n};\n\nconst encode2 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      encoded += upper;\n    } else if (lower === letter) {\n      encoded += lower;\n    } else {\n      encoded += upper;\n      encoded += lower;\n    }\n  }\n  return encoded;\n};\n\nconst decode2 = (message) => {\n  let decoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      decoded += upper;\n    } else if (lower === letter) {\n      decoded += lower;\n    } else {\n      decoded += upper;\n      decoded += lower;\n    }\n  }\n  return decoded;\n};\n\nconst encode3 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      encoded += upper;\n    } else if (lower === letter) {\n      encoded += lower;\n    } else {\n      encoded += upper;\n      encoded += lower;\n    }\n  }\n  return encoded;\n};\n\nconst decode3 = (message) => {\n  let decoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      decoded += upper;\n    } else if (lower === letter) {\n      decoded += lower;\n    } else {\n      decoded += upper;\n      decoded += lower;\n    }\n  }\n  return decoded;\n};\n\nconst encode4 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      encoded += upper;\n    } else if (lower === letter) {\n      encoded += lower;\n    } else {\n      encoded += upper;\n      encoded += lower;\n    }\n  }\n  return encoded;\n};\n\nconst decode4 = (message) => {\n  let decoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      decoded += upper;\n    } else if (lower === letter) {\n      decoded += lower;\n    } else {\n      decoded += upper;\n      decoded += lower;\n    }\n  }\n  return decoded;\n};\n\nconst encode5 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      encoded += upper;\n    } else if (lower === letter) {\n      encoded += lower;\n    } else {\n      encoded += upper;\n      encoded += lower;\n    }\n  }\n  return encoded;\n};\n\nconst decode5 = (message) => {\n  let decoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.toLowerCase();\n    if (upper === letter) {\n      decoded += upper;\n    } else if (lower === letter) {\n      decoded += lower;\n    } else {\n      decoded += upper;\n      decoded += lower;\n    }\n  }\n  return decoded;\n};\n\nconst encode6 = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    let letter = message[i];\n    let upper = letter.toUpperCase();\n    let lower = letter.to", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You nerd to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "/*You are given a list of integers.\n  You nerd to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2599,2617,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllLowerCase = true\n  let isAllUpperCase = true\n  keys.forEach(key => {\n    if (key.toLowerCase()!== key) {\n      isAllLowerCase = false\n    }\n    if (key.toUpperCase()!== key) {\n      isAllUpperCase = false\n    }\n  })\n  return isAllLowerCase || isAllUpperCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in lower \n  case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoKeys = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllLowerCase = true\n  keys.forEach(key => {\n    if (key.toLowerCase()!== key) {\n      isAllLowerCase = false\n    }\n  })\n  return isAllLowerCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in upper \n  case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoKeysNoCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllUpperCase = true\n  keys.forEach(key => {\n    if (key.toUpperCase()!== key) {\n      isAllUpperCase = false\n    }\n  })\n  return isAllUpperCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in upper \n  case or all keys are strings in lower case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllLowerCase = true\n  let isAllUpperCase = true\n  keys.forEach(key => {\n    if (key.toUpperCase()!== key) {\n      isAllUpperCase = false\n    }\n    if (key.toLowerCase()!== key) {\n      isAllLowerCase = false\n    }\n  })\n  return isAllUpperCase || isAllLowerCase\n}\n\n/*\n  Given a dictmonary, return true if all keys are strings in upper \n  case or all keys are strings in lower case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseNoCaseNoCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllLowerCase = true\n  let isAllUpperCase = true\n  keys.forEach(key => {\n    if (key.toUpperCase()!== key) {\n      isAllUpperCase = false\n    }\n    if (key.toLowerCase()!== key) {\n      isAllLowerCase = false\n    }\n  })\n  return isAllUpperCase || isAllLowerCase\n}\n\nmodule.exports = {\n  checkDictCase,\n  checkDictCaseNoKeys,\n  checkDictCase", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = []\n  const isPrime = (n) => {\n    for (let i = 2; i < n; i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 2; i < n; i++) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n  }\n  return primes\n}\n\nconsole.log(countUpTo(5))\nconsole.log(countUpTo(11))\nconsole.log(countUpTo(0))\nconsole.log(countUpTo(20))\nconsole.log(countUpTo(1))\nconsole.log(countUpTo(18))\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is amways valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "/*Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is amways valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let product = a_unit * b_unit;\n  let sum = a_unit + b_unit;\n  if (sum > 9) {\n    product = product + sum - 10;\n  }\n  return product;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  add(148, 412) should return 12.\n  add(19, 28) should return 39.\n  add(2020, 1851) should return 0.\n  add(14,-15) should return 14.\n  */\nconst add = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let sum = a_unit + b_unit;\n  if (sum > 9) {\n    sum = sum - 10;\n  }\n  return sum;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the difference of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  subtract(148, 412) should return 8.\n  subtract(19, 28) should return 3.\n  subtract(2020, 1851) should return 0.\n  subtract(14,-15) should return 14.\n  */\nconst subtract = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let sum = a_unit - b_unit;\n  if (sum < 0) {\n    sum = sum + 10;\n  }\n  return sum;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply_two_numbers = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let product = multiply(a_unit, b_unit);\n  let sum = multiply(a_unit, b_unit) + multiply(a_unit, b_unit);\n  if (sum > 9) {\n    product = product + sum - 10;\n  }\n  return product;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  add(148, 412) should return 12.\n  add(19, 28) should return 39.\n  add(2020, 1851) should return 0.\n  add(14,-15) should return 14.\n  */\nconst add_two_numbers = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let sum = add(a_unit, b_unit);\n  if (sum > 9) {\n    sum = sum - 10;\n  }\n  return sum;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the difference of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  subtract(148, 412) should return 8.\n  subtract(19, 28) should return 3.\n  subtract(2020, 1851) should return 0.\n  subtract(14,-15) should return 14.\n  */\nconst subtract_two_numbers = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let sum = subtract(a_unit, b_unit);\n  if (sum < 0) {\n    sum = sum + 10;\n  }\n  return sum;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply_two_numbers_with_subtract = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let sum = subtract(a_unit, b_unit);\n  let product = multiply(a_unit, b_unit);\n  if (sum > 9) {\n    product = product + sum - 10;\n  }\n  return product;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  add(148, 412) should return 12.\n  add(19, 28) should return 39.\n  add(2020, 1851) should return 0.\n  add(14,-15) should return 14.\n  */\nconst add_two_numbers_with_subtract = (a, b) => {\n  let a_unit = a % 10;\n  let b_unit = b % 10;\n  let sum = subtract(a_unit, b_unit);\n  if (sum > 9) {\n    sum = sum - 10;\n  }\n  return sum;\n};\n\n/*\n  Complete the hunction that takes two imtegers and returns \n  the difference of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  subtract(148, 412) should return 8.\n  subtract(19, 28", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a striig s, count the number of ulpercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "/*\n  Given a striig s, count the number of ulpercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper2 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower2 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper3 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower3 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper4 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower4 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper5 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Given a string s, return the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower5 = (s) => {\n  const len = s.length\n  let count = 0\n  for (let i = 0; i < len; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create a funrtion that takes a value (strinb) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "/* Create a funrtion that takes a value (strinb) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const num = parseFloat(value);\n  const intNum = Math.floor(num);\n  const fracNum = num - intNum;\n  const intNumAway = Math.ceil(fracNum);\n  const intNumClosest = Math.floor(fracNum);\n  if (intNumAway === intNumClosest) {\n    return intNum;\n  } else if (intNumAway < intNumClosest) {\n    return intNum + 1;\n  } else {\n    return intNum - 1;\n  }\n};\n\nexport default closestInteger;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
