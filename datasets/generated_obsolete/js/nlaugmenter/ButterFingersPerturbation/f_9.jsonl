{"task_id": "JavaScript/0", "prompt": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  return (\n    Math.abs(max - threshold) < Math.abs(min - threshold)\n  ) && (\n    Math.abs(max - threshold) < Math.abs(max - max * threshold)\n  );\n};\n\nexport default hasCloseElements;\n<|endoftext|>"}
{"task_id": "JavaScript/1", "prompt": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const parens = paren_string.match(/[\\(\\)\\[\\]\\{\\}\\(\\)]+/g)\n  const parens_nested = parens.map(paren => paren.replace(/\\(([\\(\\)\\[\\]\\{\\}\\(\\)]+)/g, (match, $1) => `(${$1})`))\n  const parens_nested_balanced = parens_nested.filter(paren => paren.indexOf(')') < paren.indexOf('('))\n  const parens_balanced = parens_nested_balanced.filter(paren => paren.indexOf('(') < paren.indexOf(')'))\n  const parens_balanced_list = parens_balanced.map(paren => paren.split('(').reverse().join(''))\n  return parens_balanced_list\n}\n\nconst parse = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  const result = paren_groups.reduce((result, paren_group) => {\n    const nested_paren_groups = paren_group.split('(')\n    nested_paren_groups.forEach(nested_paren_group => {\n      const paren_group_balanced = nested_paren_group.replace(/\\(/g, '{').replace(/\\)/g, '}')\n      result.push(parse(paren_group_balanced))\n    })\n    return result\n  }, [])\n  return result\n}\n\nconst isParenGroup = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.length > 0\n}\n\nconst isBalancedParenGroup = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.every(isBalancedParenGroup)\n}\n\nconst isParenGroupWithClosedBrace = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroup)\n}\n\nconst isBalancedParenGroupWithClosedBrace = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.every(isBalancedParenGroup)\n}\n\nconst isBalancedParenGroupWithClosedBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.every(isBalancedParenGroup)\n}\n\nconst isBalancedParenGroupWithOpenBrace = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.every(isBalancedParenGroup)\n}\n\nconst isBalancedParenGroupWithOpenBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.every(isBalancedParenGroup)\n}\n\nconst isParenGroupWithOpenBrace = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroup)\n}\n\nconst isParenGroupWithOpenBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroup)\n}\n\nconst isParenGroupWithOpenBrackets = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroup)\n}\n\nconst isParenGroupWithOpenBracketsAndClosedBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroupWithOpenBracesAndClosedBraces)\n}\n\nconst isParenGroupWithOpenBracketsAndClosedBrackets = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroupWithOpenBracesAndClosedBrackets)\n}\n\nconst isParenGroupWithOpenBracketsAndClosedBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroupWithOpenBracesAndClosedBraces)\n}\n\nconst isParenGroupWithOpenBracketsAndClosedBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroupWithOpenBracesAndClosedBraces)\n}\n\nconst isParenGroupWithOpenBracketsAndOpenBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroupWithOpenBracesAndOpenBraces)\n}\n\nconst isParenGroupWithOpenBracketsAndOpenBrackets = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroupWithOpenBracesAndOpenBrackets)\n}\n\nconst isParenGroupWithOpenBracketsAndOpenBraces = (paren_string) => {\n  const paren_groups = separateParenGroups(paren_string)\n  return paren_groups.some(isParenGroupWithOpenBracesAndOpenBraces)\n}\n\nconst isBalancedP"}
{"task_id": "JavaScript/2", "prompt": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let [intPart, decPart] = number.toString().split('.');\n  return intPart.length > 0? intPart.slice(0, -1) : 0;\n};\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// const isPrime = (number) => {\n//   if (number > 0) {\n//     for (let i = 2; i <= number; i++) {\n//       if (number % i === 0)"}
{"task_id": "JavaScript/3", "prompt": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n    let acc = 0\n    let flag = false\n\n    for (let i = 0; i < operations.length; i++) {\n        if (operations[i] < 0) {\n            acc += operations[i]\n            if (acc < 0) {\n                flag = true\n            }\n        } else {\n            acc -= operations[i]\n            if (acc < 0) {\n                flag = true\n            }\n        }\n    }\n\n    return flag\n}\n\nconsole.log(belowZero([1, 2, -4, 5, 6, 7, -8, 9, 10, -11, 12, 13, -14, 15, 16, 17, -18, 19, 20]))\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n    const average = mean(numbers);\n    const result = numbers.map(number => Math.abs(number - average));\n    return sum(result) / numbers.length;\n};\n\n/**\n  * This function calculates the mean of a list of numbers.\n  * Mean = sum(list)/len(list)\n  * @param {Array} numbers\n  * @returns {Number} mean\n  */\nconst mean = (numbers) => {\n    return sum(numbers) / numbers.length;\n};\n\nmodule.exports = {\n    meanAbsoluteDeviation\n};\n<|endoftext|>"}
{"task_id": "JavaScript/5", "prompt": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n    var output = [];\n    var i = 0;\n    var length = numbers.length;\n    while (i < length) {\n        output.push(numbers[i]);\n        i++;\n        if (i < length) {\n            output.push(delimeter);\n        }\n    }\n    return output;\n};\n\nmodule.exports = intersperse;\n<|endoftext|>"}
{"task_id": "JavaScript/6", "prompt": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const result = []\n  const string_length = paren_string.length\n  const paren_start = 0\n  const paren_end = string_length - 1\n\n  let current_level = 1\n  let level_number = 0\n  let paren_counter = 0\n  let char = ''\n\n  for (let i = paren_start; i < paren_end; i++) {\n    char = paren_string[i]\n\n    if (char === '(') {\n      paren_counter++\n      level_number++\n      current_level++\n    } else if (char === ')') {\n      level_number--\n      current_level--\n      paren_counter--\n    }\n  }\n\n  const depth = paren_counter\n  if (depth > 0) {\n    result.push(depth)\n  }\n\n  return result\n}\n\n/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens2 = (paren_string) => {\n  const result = []\n  const string_length = paren_string.length\n  const paren_start = 0\n  const paren_end = string_length - 1\n\n  let current_level = 1\n  let level_number = 0\n  let paren_counter = 0\n  let char = ''\n\n  for (let i = paren_start; i < paren_end; i++) {\n    char = paren_string[i]\n\n    if (char === '(') {\n      paren_counter++\n      level_number++\n      current_level++\n    } else if (char === ')') {\n      level_number--\n      current_level--\n      paren_counter--\n    }\n  }\n\n  const depth = paren_counter\n  if (depth > 0) {\n    result.push(depth)\n  }\n\n  return result\n}\n\nconst parseNestedParens3 = (paren_string) => {\n  const result = []\n  const string_length = paren_string.length\n  const paren_start = 0\n  const paren_end = string_length - 1\n\n  let current_level = 1\n  let level_number = 0\n  let paren_counter = 0\n  let char = ''\n\n  for (let i = paren_start; i < paren_end; i++) {\n    char = paren_string[i]\n\n    if (char === '(') {\n      paren_counter++\n      level_number++\n      current_level++\n    } else if (char === ')') {\n      level_number--\n      current_level--\n      paren_counter--\n    }\n  }\n\n  const depth = paren_counter\n  if (depth > 0) {\n    result.push(depth)\n  }\n\n  return result\n}\n\nconst parseNestedParens4 = (paren_string) => {\n  const result = []\n  const string_length = paren_string.length\n  const paren_start = 0\n  const paren_end = string_length - 1\n\n  let current_level = 1\n  let level_number = 0\n  let paren_counter = 0\n  let char = ''\n\n  for (let i = paren_start; i < paren_end; i++) {\n    char = paren_string[i]\n\n    if (char === '(') {\n      paren_counter++\n      level_number++\n      current_level++\n    } else if (char === ')') {\n      level_number--\n      current_level--\n      paren_counter--\n    }\n  }\n\n  const depth = paren_counter\n  if (depth > 0) {\n    result.push(depth)\n  }\n\n  return result\n}\n\nconst parseNestedParens5 = (paren_string) => {\n  const result = []\n  const string_length = paren_string.length\n  const paren_start = 0\n  const paren_end = string_length - 1\n\n  let current_level = 1\n  let level_number = 0\n  let paren_counter = 0\n  let char = ''\n\n  for (let i = paren_start; i < paren_end; i++) {\n    char = paren_string[i]\n\n    if (char === '(') {\n      paren_counter++\n      level_number++\n      current_level++\n    } else if (char === ')') {\n      level_number--\n      current_level--\n      paren_counter--\n    }\n  }\n\n  const depth = paren_counter\n  if (depth > 0) {\n    result.push(depth)\n  }\n\n  return result\n}\n\nconst parseNestedParens6 = (paren_string) => {\n  const result = []\n  const string_length = paren_string.length\n  const paren_start = 0\n  const paren_end = string_length - 1\n\n  let current_level = 1\n  let level_number = 0\n  let paren_counter = 0\n  let char = ''\n\n  for (let i = paren_start; i < paren_end; i++) {\n    char = paren_string[i]\n\n    if (char === '(') {\n      paren_counter++\n      level_number++\n      current_level++\n    } else if (char === ')') {\n      level_number--\n      current_level--\n      paren_counter--\n    }\n  }\n\n  const depth = paren_counter\n  if (depth > 0) {\n    "}
{"task_id": "JavaScript/7", "prompt": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const regex = new RegExp(`${substring}`, 'i')\n  return strings.filter(s => regex.test(s))\n}\n\n/*\n  @param {string} str - A string to be turned into an array of unique words\n  @return {Array} - An array of unique words\n*/\nconst uniqueWords = str => {\n  const words = str.split(/\\s+/)\n  const uniqWords = words.filter(word => word)\n  return uniqWords.sort()\n}\n\n/*\n  @param {string} str - A string to be turned into an array of unique words\n  @return {Array} - An array of unique words\n*/\nconst getUniqueWords = str => {\n  const words = uniqueWords(str)\n  return words\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by length\n*/\nconst sortWords = words => {\n  return words.sort((a, b) => a.length - b.length)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetical order\n*/\nconst sortWordsByAlpha = words => {\n  return words.sort(s => s)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetic order\n*/\nconst sortWordsByLength = words => {\n  return words.sort((a, b) => a.length - b.length)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetic order\n*/\nconst sortWordsByLengthThenAlpha = words => {\n  return words.sort((a, b) => b.length - a.length)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetic order\n*/\nconst sortWordsByAlphaThenLength = words => {\n  return words.sort((a, b) => a.length - b.length)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetical order\n*/\nconst sortWordsByLengthThenAlphaThenLength = words => {\n  return words.sort((a, b) => a.length - b.length)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetic order\n*/\nconst sortWordsByLengthThenAlphaThenLengthThenAlpha = words => {\n  return words.sort((a, b) => a.length - b.length)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetic order\n*/\nconst sortWordsByAlphaThenLengthThenLengthThenAlpha = words => {\n  return words.sort((a, b) => a.length - b.length)\n}\n\n/*\n  @param {Array} words - An array of unique words\n  @return {Array} - An array of unique words sorted by alphabetic order\n*/\nconst sortWordsByLengthThenAlphaThenLengthThenAlphaThenLength = words => {\n  return words.sort((a, b) => a.length - b.length)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const product = 1\n  const sum = numbers[0]\n\n  for (let i = 1; i < numbers.length; i += 1) {\n    product *= numbers[i]\n    sum += numbers[i]\n  }\n\n  return [sum, product]\n}\n\n// const sumProduct = (numbers, int) => {\n//   const product = 1\n//   const sum = numbers[0]\n//\n//   for (let i = 1; i < numbers.length; i += 1) {\n//     product *= numbers[i]\n//     sum += numbers[i]\n//   }\n//\n//   return [sum, product]\n// }\n\nconst sumProduct = (numbers, int) => {\n  const product = 1\n  const sum = 0\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const product = 1\n  const sum = 0\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }\n\n  return [sum, product]\n}\n\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  for (let i = 0; i < numbers.length; i += 1) {\n    sum += numbers[i]\n    product *= numbers[i]\n  }"}
{"task_id": "JavaScript/9", "prompt": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  if (numbers.length === 0) {\n    return []\n  }\n\n  let rollingMax = numbers[0]\n  let i = 0\n  const rollingMaxList = []\n  while (i < numbers.length) {\n    if (numbers[i] > rollingMax) {\n      rollingMax = numbers[i]\n      rollingMaxList.push(rollingMax)\n    }\n    i += 1\n  }\n  return rollingMaxList\n}\n\nmodule.exports = rollingMax\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let suffix = string.split('').reverse().join('');\n  return suffix.substr(0, suffix.indexOf(string)) + string;\n}\n\n/* Print the largest palindrome made by the supplied string */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(index);\n}\n\n/* Find the largest palindrome made by the supplied string. */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(index);\n}\n\n/* Print the smallest palindrome made by the supplied string */\nconst smallestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the smallest palindrome made by the supplied string. */\nconst smallestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Print the largest palindrome made by the supplied string */\nconst smallestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the largest palindrome made by the supplied string. */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the smallest palindrome made by the supplied string. */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Print the smallest palindrome made by the supplied string */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the largest palindrome made by the supplied string. */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the smallest palindrome made by the supplied string. */\nconst smallestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the smallest palindrome made by the supplied string. */\nconst smallestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the largest palindrome made by the supplied string. */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the smallest palindrome made by the supplied string. */\nconst smallestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the largest palindrome made by the supplied string. */\nconst largestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n  return palindrome.substr(0, index);\n}\n\n/* Find the smallest palindrome made by the supplied string. */\nconst smallestPalindrome = (string) => {\n  let palindrome = string.split('').reverse().join('');\n  let index = palindrome.indexOf(palindrome.split('').reverse().join(''));\n"}
{"task_id": "JavaScript/11", "prompt": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let x = Buffer.from(a, 'hex'),\n      y = Buffer.from(b, 'hex'),\n      i = 0,\n      result = [],\n      c = 0;\n\n  for (i = 0; i < x.length; i++) {\n    c = x[i] ^ y[i];\n    result.push(c.toString(16));\n  }\n\n  return result.join('');\n};\n\n/*\n  Given two strings a and b, return a string consisting of characters\n  which appear only in a or b.\n  >>> stringIntersection('ABC', 'CDE')\n  'AC'\n  */\nconst stringIntersection = (a, b) => {\n  let a_c,\n      b_c,\n      result = [];\n\n  for (let i = 0; i < a.length; i++) {\n    a_c = a.charAt(i);\n    if (b.indexOf(a_c) > -1) {\n      result.push(a_c);\n    }\n  }\n\n  return result.join('');\n};\n\n/*\n  Given two strings a and b, return a string consisting of characters\n  which appear in a or b.\n  >>> stringUnion('ABC', 'CDE')\n  'ABCD'\n  */\nconst stringUnion = (a, b) => {\n  let a_c,\n      b_c,\n      result = [];\n\n  for (let i = 0; i < a.length; i++) {\n    a_c = a.charAt(i);\n    if (b.indexOf(a_c) < 0) {\n      result.push(a_c);\n    }\n  }\n\n  return result.join('');\n};\n\n/*\n  Given two strings a and b, return a string consisting of characters\n  which appear in both a and b.\n  >>> stringIntersection('ABC', 'ACD')\n  'AC'\n  */\nconst stringCommon = (a, b) => {\n  let a_c,\n      b_c,\n      result = [];\n\n  for (let i = 0; i < a.length; i++) {\n    a_c = a.charAt(i);\n    if (b.indexOf(a_c) > -1) {\n      result.push(a_c);\n    }\n  }\n\n  return result.join('');\n};\n\nmodule.exports = {\n  stringXor,\n  stringIntersection,\n  stringUnion,\n  stringCommon\n};\n<|endoftext|>"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null;\n  }\n\n  let longest = strings[0];\n  let longestLen = longest.length;\n  for (let i = 1; i < strings.length; i++) {\n    let curr = strings[i];\n    if (curr.length > longestLen) {\n      longest = curr;\n      longestLen = longest.length;\n    } else if (curr.length === longestLen) {\n      longest = longest.concat(curr);\n    }\n  }\n\n  return longest;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  const result = Math.abs(b) > Math.abs(a)? greatestCommonDivisor(b, a % b) : a;\n  return result;\n}\n\n/**\n  * Return a factorial of n\n  * Factorial is defined as n * n * n * n *... * 1\n  * Factorial of 0 is 1\n  * Factorial of 1 is 1\n  * Factorial of 2 is 2\n  * Factorial of 3 is 6\n  * Factorial of 5 is 120\n  * Factorial of n is n * n * n * n * n *... * 1\n  * Factorial of negative numbers is 0\n  *\n  * @param n The integer\n  * @return The factorial of n\n  */\nconst factorial = (n) => {\n  const result = 1;\n  if (n > 0) {\n    for (let i = 1; i <= n; i++) {\n      result *= i;\n    }\n  }\n  return result;\n}\n\n/**\n  * Return the sum of two integers a and b\n  *\n  * @param a The first integer\n  * @param b The second integer\n  * @return The sum of a and b\n  */\nconst sum = (a, b) => a + b;\n\n/**\n  * Return the difference between two integers a and b\n  *\n  * @param a The first integer\n  * @param b The second integer\n  * @return The difference between a and b\n  */\nconst difference = (a, b) => a - b;\n\n/**\n  * Return the product of two integers a and b\n  *\n  * @param a The first integer\n  * @param b The second integer\n  * @return The product of a and b\n  */\nconst product = (a, b) => a * b;\n\n/**\n  * Return the quotient of two integers a and b\n  *\n  * @param a The first integer\n  * @param b The second integer\n  * @return The quotient of a and b\n  */\nconst quotient = (a, b) => a / b;\n\nmodule.exports = {\n  greatestCommonDivisor,\n  factorial,\n  sum,\n  difference,\n  product,\n  quotient\n}<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let len = string.length\n  let result = []\n  let i = 0\n  while (i <= len) {\n    let prefix = string.substring(0, i)\n    result.push(prefix)\n    i++\n  }\n  return result\n}\n\n/*\n  >>> allSuffixes('abc')\n  ['c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  let len = string.length\n  let result = []\n  let i = len - 1\n  while (i >= 0) {\n    let suffix = string.substring(i, len)\n    result.push(suffix)\n    i--\n  }\n  return result\n}\n\n/*\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes2 = (string) => {\n  let result = []\n  for (let i = 0; i < string.length; i++) {\n    let prefix = string.substring(0, i)\n    result.push(prefix)\n  }\n  return result\n}\n\n/*\n  >>> allSuffixes('abc')\n  ['c', 'bc', 'abc']\n  */\nconst allSuffixes2 = (string) => {\n  let result = []\n  for (let i = string.length - 1; i >= 0; i--) {\n    let suffix = string.substring(i, string.length)\n    result.push(suffix)\n  }\n  return result\n}\n\n/*\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes3 = (string) => {\n  let result = []\n  let i = 0\n  while (i < string.length) {\n    let prefix = string.substring(0, i)\n    result.push(prefix)\n    i++\n  }\n  return result\n}\n\n/*\n  >>> allSuffixes('abc')\n  ['c', 'bc', 'abc']\n  */\nconst allSuffixes3 = (string) => {\n  let result = []\n  let i = string.length - 1\n  while (i >= 0) {\n    let suffix = string.substring(i, string.length)\n    result.push(suffix)\n    i--\n  }\n  return result\n}\n\n/*\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes4 = (string) => {\n  let result = []\n  for (let i = 0; i < string.length; i++) {\n    let prefix = string.substring(0, i)\n    result.push(prefix)\n  }\n  return result\n}\n\n/*\n  >>> allSuffixes('abc')\n  ['c', 'bc', 'abc']\n  */\nconst allSuffixes4 = (string) => {\n  let result = []\n  for (let i = string.length - 1; i >= 0; i--) {\n    let suffix = string.substring(i, string.length)\n    result.push(suffix)\n  }\n  return result\n}\n\n/*\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes5 = (string) => {\n  let result = []\n  for (let i = 0; i <= string.length; i++) {\n    let prefix = string.substring(0, i)\n    result.push(prefix)\n  }\n  return result\n}\n\n/*\n  >>> allSuffixes('abc')\n  ['c', 'bc', 'abc']\n  */\nconst allSuffixes5 = (string) => {\n  let result = []\n  for (let i = string.length - 1; i >= 0; i--) {\n    let suffix = string.substring(i, string.length)\n    result.push(suffix)\n  }\n  return result\n}\n<|endoftext|>"}
{"task_id": "JavaScript/15", "prompt": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n    const str = '';\n    for (let i = 0; i <= n; i++) {\n        str += i.toString();\n        if (i!= n) {\n            str +='';\n        }\n    }\n    return str;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigits = (n) => {\n    const str = '';\n    for (let i = 0; i <= n; i++) {\n        str += i.toString();\n    }\n    return str;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRec = (n) => {\n    if (n < 10) {\n        return n.toString();\n    }\n    return sumOfDigits(n - 1) + sumOfDigits(n - 2);\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsIter = (n) => {\n    let sum = 0;\n    for (let i = 0; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsIterRec = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRec = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecRec = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsIterRecRecIterRec = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsIterRecRecIterRec = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsIterRecRecIterRec = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsIterRecRecIterRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecIterRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecIterRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecIterRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsRecIterRecIterRecIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n        i += 1;\n    }\n    return sum;\n}\n\n// Summation of all the digits in a given integer\nconst sumOfDigitsIterRecIterRecIterIter = (n) => {\n    let sum = 0;\n    let i = 1;\n    while (i <= n) {\n        sum += i;\n"}
{"task_id": "JavaScript/16", "prompt": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const characters = string.split('')\n  const counts = []\n  for (let i = 0; i < characters.length; i++) {\n    counts.push(characters.indexOf(characters[i]))\n  }\n  const countsMap = new Map(counts)\n  return countsMap.size\n}\n<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let beat = 1\n  let note = 0\n  let current_note = 0\n  let last_beat = 0\n  let last_note = 0\n  let next_beat = 0\n  const beats = music_string.split('')\n  const notes = beats.map((char) => {\n    if (char === '|') {\n      next_beat += 1\n      return next_beat\n    } else {\n      return char\n    }\n  })\n  return notes.map((note) => {\n    if (note === 'o') {\n      beat += 1\n      last_beat = beat\n      return beat\n    } else if (note === 'o|') {\n      beat += 1\n      last_beat = beat\n      last_note = current_note\n      current_note += 1\n      return beat\n    } else if (note === '.') {\n      beat += 1\n      last_beat = beat\n      last_note = current_note\n      current_note += 1\n      return beat\n    } else if (note === 'o|o') {\n      beat += 1\n      last_beat = beat\n      last_note = current_note\n      current_note += 2\n      return beat\n    } else if (note === 'o|o|') {\n      beat += 1\n      last_beat = beat\n      last_note = current_note\n      current_note += 3\n      return beat\n    } else if (note === 'o|o|o') {\n      beat += 1\n      last_beat = beat\n      last_note = current_note\n      current_note += 4\n      return beat\n    }\n  })\n}\n\nmodule.exports = parseMusic\n<|endoftext|>"}
{"task_id": "JavaScript/18", "prompt": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n    let count = 0;\n    for (let i = 0; i < string.length - substring.length + 1; i++) {\n        let j = 0;\n        for (; j < substring.length; j++) {\n            if (string[i + j]!== substring[j]) break;\n        }\n        if (j === substring.length) count++;\n    }\n    return count;\n};\n\n/*\n  Given a string s and a dictionary of words dict, find all words in dict that\n  can be constructed from the characters in the string.\n  >>> dict = [ 'abracadabra', 'applause', 'cacao' ]\n  >>> findAllWords(dict, 'brracadabra')\n  [ 'abracadabra', 'brracadabra' ]\n  >>> findAllWords(dict, 'brracadabra')\n  [ 'abracadabra', 'brracadabra', 'brracadabra' ]\n  >>> findAllWords(dict, 'brracadabra')\n  [ 'abracadabra', 'brracadabra', 'brracadabra' ]\n  >>> findAllWords(dict, 'brracadabra')\n  [ 'abracadabra', 'brracadabra', 'brracadabra' ]\n  */\nconst findAllWords = (dict, string) => {\n    let words = [];\n    for (let i = 0; i < string.length; i++) {\n        for (let j = 0; j < dict.length; j++) {\n            let sub = string.slice(i);\n            let subWords = sub.split('');\n            let wordsInDict = [];\n            for (let k = 0; k < dict[j].length; k++) {\n                let char = dict[j][k];\n                for (let l = 0; l < subWords.length; l++) {\n                    if (subWords[l] === char) {\n                        wordsInDict.push(dict[j].slice(0, k + 1));\n                        subWords.splice(l, 1);\n                        break;\n                    }\n                }\n            }\n            words = words.concat(wordsInDict);\n        }\n    }\n    return words;\n};\n\n/*\n  Given a string s and a dictionary of words dict, count the number of words\n  in dict that can be constructed from the characters in the string.\n  >>> dict = [ 'abracadabra', 'applause', 'cacao' ]\n  >>> countAllWords(dict, 'brracadabra')\n  1\n  >>> countAllWords(dict, 'brracadabra')\n  2\n  >>> countAllWords(dict, 'brracadabra')\n  3\n  >>> countAllWords(dict, 'brracadabra')\n  4\n  */\nconst countAllWords = (dict, string) => {\n    let words = findAllWords(dict, string);\n    return words.length;\n};\n\n/*\n  Given a string s, find the length of the longest substring that contains\n  all unique characters.\n  >>> longestSubstring('aa')\n  1\n  >>> longestSubstring('aa')\n  1\n  >>> longestSubstring('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}
{"task_id": "JavaScript/19", "prompt": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve', 'six', 'seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    if (a.length === b.length) {\n      let aChar = a[a.length - 1]\n      let bChar = b[b.length - 1]\n      if (aChar === bChar) {\n        return a.length - b.length\n      }\n      return aChar > bChar? 1 : -1\n    }\n    return a.length - b.length\n  }).join(' ')\n}\n\n/*\n  Tests\n  */\n\nconsole.log(sortNumbers('two one three'))\n<|endoftext|>"}
{"task_id": "JavaScript/20", "prompt": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  return [...numbers].filter(v => v === min || v === max).sort((a, b) => a - b).reverse()[0];\n};\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  return numbers.map(n => n * (1 / (n + 1)));\n};\n\n/**\n  * Given a list of numbers, generate a list of the same length with the smallest number\n  * that is greater than or equal to the largest number in the list.\n  *\n  * @param {Array} numbers - a list of numbers\n  * @returns {Array} - a list of the same length as the input with the smallest number\n  * that is greater than or equal to the largest number in the list.\n  *\n  * @example\n  * getNextUpperBound([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  * // [2, 3, 4, 5, 6, 7, 8, 9, 10]\n  */\nconst getNextUpperBound = (numbers) => {\n  const b = numbers[numbers.length - 1];\n  return numbers.map((n, i) => {\n    if (n >= b) {\n      return n + 1;\n    } else {\n      return n;\n    }\n  });\n};\n\n/**\n  * Given a list of numbers, generate a list of the same length with the largest number\n  * that is less than or equal to the smallest number in the list.\n  *\n  * @param {Array} numbers - a list of numbers\n  * @returns {Array} - a list of the same length as the input with the largest number\n  * that is less than or equal to the smallest number in the list.\n  *\n  * @example\n  * getNextLowerBound([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  * // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst getNextLowerBound = (numbers) => {\n  const b = numbers[0];\n  return numbers.map((n, i) => {\n    if (n <= b) {\n      return n - 1;\n    } else {\n      return n;\n    }\n  });\n};\n\n/**\n  * Given a list of numbers, generate a list of the same length with the smallest number\n  * that is less than or equal to the largest number in the list.\n  *\n  * @param {Array} numbers - a list of numbers\n  * @returns {Array} - a list of the same length as the input with the smallest number\n  * that is less than or equal to the largest number in the list.\n  *\n  * @example\n  * getNextLowerBound([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  * // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst getNextLowerBound2 = (numbers) => {\n  const b = numbers[0];\n  return numbers.map((n, i) => {\n    if (n <= b) {\n      return n - 1;\n    } else {\n      return n;\n    }\n  });\n};\n\n/**\n  * Given a list of numbers, generate a list of the same length with the smallest number\n  * that is less than or equal to the largest number in the list.\n  *\n  * @param {Array} numbers - a list of numbers\n  * @returns {Array} - a list of the same length as the input with the smallest number\n  * that is less than or equal to the largest number in the list.\n  *\n  * @example\n  * getNextUpperBound([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  * // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst getNextUpperBound2 = (numbers) => {\n  const b = numbers[numbers.length - 1];\n  return numbers.map((n, i) => {\n    if (n >= b) {\n      return n + 1;\n    } else {\n      return n;\n    }\n  });\n};\n\n/**\n  * Given a list of numbers, generate a list of the same length with the largest number\n  * that is less than or equal to the smallest number in the list.\n  *\n  * @param {Array} numbers - a list of numbers\n  * @returns {Array} - a list of the same length as the input with the largest number\n  * that is less than or equal to the smallest number in the list.\n  *\n  * @example\n  * getNextUpperBound([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  * // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst getNextUpperBound3 = (numbers) => {\n  const b = numbers[0];\n  return numbers.map((n, i) => {\n    if (n <= b) {\n      return n + 1;\n    } else {\n      return n;\n    }\n  });\n};\n\n/**\n  * Given a list of numbers, generate a list of the same length with the smallest number\n  * that is greater than or equal to the largest number in the list.\n  *\n  * @param {Array} numbers - a list of numbers\n  * @returns {Array} - a list of the same length as the input with the smallest number\n  * that is greater than or equal to the largest number in the list.\n  *\n  * @example\n  * getNextLowerBound([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  * // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst getNextLowerBound3 = (numbers) => {\n  const b = numbers[numbers.length - 1];\n  return numbers.map((n, i) => {\n    if (n >= b) {\n      return n - 1;\n    } else {\n      return n;\n    }\n  });\n};\n\n/**\n  * Given a list of numbers, generate a list of the same length with"}
{"task_id": "JavaScript/22", "prompt": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/*\n  Given a function and a list of values, this will return the values\n  that the function returns.\n  >>> filter(filterIntegers, [3, 2, 4])\n  [2, 4]\n  >>> filter(filterIntegers, [1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filter(filterIntegers, [1, 2, 3, 'abc', {}, []])\n  []\n  >>> filter(filterIntegers, [1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filter = (f, values) => {\n  return values.filter(f);\n};\n\nconst filter = (f, values) => {\n  return values.filter(f);\n};\n\n/*\n  Filters out the values that are not numbers.\n  >>> filterNonNumbers([3, 'abc', {}, []])\n  []\n  >>> filterNonNumbers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonNumbers([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/*\n  Filters out the values that are not strings.\n  >>> filterNonStrings([3, 'abc', {}, []])\n  []\n  >>> filterNonStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonStrings([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/*\n  Filters out the values that are not objects.\n  >>> filterNonObjects([3, 'abc', [], {}])\n  []\n  >>> filterNonObjects([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonObjects([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/*\n  Filters out the values that are not arrays.\n  >>> filterNonArrays([3, 'abc', {}, []])\n  []\n  >>> filterNonArrays([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonArrays([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonArrays = (values) => {\n  return values.filter(v => typeof v === 'object' && typeof v.length === 'number');\n};\n\n/*\n  Filters out the values that are not lists.\n  >>> filterNonLists([3, 'abc', {}, {}])\n  []\n  >>> filterNonLists([1, 2, 3, 'abc', {}, {}])\n  [1, 2, 3]\n  >>> filterNonLists([1, 2, 3, 'abc', {}, {}])\n  []\n  */\nconst filterNonLists = (values) => {\n  return values.filter(v => typeof v === 'object' && typeof v.length === 'number' && typeof v[0] === 'object');\n};\n\n/*\n  Filters out the values that are not functions.\n  >>> filterNonFunctions([3, 'abc', {}, []])\n  []\n  >>> filterNonFunctions([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonFunctions([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/*\n  Filters out the values that are not booleans.\n  >>> filterNonBooleans([3, 'abc', {}, []])\n  []\n  >>> filterNonBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonBooleans([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/*\n  Filters out the values that are not strings.\n  >>> filterNonStrings([3, 'abc', {}, []])\n  []\n  >>> filterNonStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonStrings([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/*\n  Filters out the values that are not objects.\n  >>> filterNonObjects([3, 'abc', [], {}])\n  []\n  >>> filterNonObjects([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  >>> filterNonObjects([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterNonObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/*\n  Filters out the values that are not arrays.\n  >>> filterNonArrays([3, 'abc', {}, {}])\n  []\n  >>> filterNonArrays([1, 2, 3, 'abc', {}, {}])\n  [1, 2, 3]\n  >>> filterNonArrays([1, 2, 3, 'abc', {}, {}])\n  []\n  */\nconst filterNonArrays = (values) => {\n  return values.filter(v => typeof v === 'object' && typeof"}
{"task_id": "JavaScript/23", "prompt": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n    if (string === undefined) {\n        return 0;\n    }\n    return string.length;\n};\n\n/*\n  Concatenate two given strings\n\n  >>> strconcat('abc', 'def')\n  'abcdef'\n  >>> strconcat('abc', 'def', 'ghi')\n  'abcdefghi'\n  */\nconst strconcat = (...strings) => {\n    let result = '';\n    for (let i = 0; i < strings.length; i++) {\n        result += strings[i];\n    }\n    return result;\n};\n\n/*\n  Find index of given string in given string\n\n  >>> index_of('abc', 'b')\n  1\n  >>> index_of('abc', 'def')\n  -1\n  */\nconst index_of = (string, string_to_find) => {\n    let i = 0;\n    let found = false;\n    while (i < string.length &&!found) {\n        if (string[i] === string_to_find) {\n            found = true;\n        }\n        i++;\n    }\n    if (found) {\n        return i;\n    } else {\n        return -1;\n    }\n};\n\n/*\n  Find last index of given string in given string\n\n  >>> last_index_of('abc', 'b')\n  2\n  >>> last_index_of('abc', 'def')\n  -1\n  */\nconst last_index_of = (string, string_to_find) => {\n    let i = string.length - 1;\n    while (i >= 0 && string[i]!== string_to_find) {\n        i--;\n    }\n    if (i >= 0) {\n        return i;\n    } else {\n        return -1;\n    }\n};\n\n/*\n  Replace first occurrence of given string with given string\n\n  >>> replace('abc', 'b', 'def')\n  'abcdef'\n  >>> replace('abc', 'def', 'ghi')\n  'abcdef'\n  >>> replace('abc', 'def', 'ghi')\n  'abcdef'\n  >>> replace('abc', 'b', 'def')\n  'abcdef'\n  */\nconst replace = (string, string_to_find, string_to_replace) => {\n    let index = index_of(string, string_to_find);\n    if (index > -1) {\n        return strconcat(string.substring(0, index), string_to_replace, string.substring(index + string_to_find.length));\n    } else {\n        return string;\n    }\n};\n\n/*\n  Replace last occurrence of given string with given string\n\n  >>> replace_last('abc', 'b', 'def')\n  'abcdef'\n  >>> replace_last('abc', 'def', 'ghi')\n  'abcdef'\n  >>> replace_last('abc', 'def', 'ghi')\n  'abcdef'\n  >>> replace_last('abc', 'b', 'def')\n  'abcdef'\n  */\nconst replace_last = (string, string_to_find, string_to_replace) => {\n    let index = last_index_of(string, string_to_find);\n    if (index > -1) {\n        return strconcat(string.substring(0, index), string_to_replace, string.substring(index + string_to_find.length));\n    } else {\n        return string;\n    }\n};\n\n/*\n  Replace all occurrences of given string with given string\n\n  >>> replace_all('abc', 'b', 'def')\n  'abcdef'\n  >>> replace_all('abc', 'def', 'ghi')\n  'abcghi'\n  >>> replace_all('abc', 'def', 'ghi')\n  'abcghi'\n  >>> replace_all('abc', 'b', 'def')\n  'abcdef'\n  */\nconst replace_all = (string, string_to_find, string_to_replace) => {\n    let result = string;\n    while (result!== '') {\n        let index = index_of(result, string_to_find);\n        if (index > -1) {\n            result = replace(result, string_to_find, string_to_replace);\n        } else {\n            return result;\n        }\n    }\n    return result;\n};\n\n/*\n  Trim left spaces from given string\n\n  >>> trim_left(' ')\n  ''\n  >>> trim_left('abc')\n  'abc'\n  >>> trim_left(' abc')\n  'abc'\n  >>> trim_left(' abc ')\n  'abc'\n  >>> trim_left(' abc ')\n  'abc'\n  >>> trim_left('abc')\n  'abc'\n  */\nconst trim_left = (string) => {\n    let result = string;\n    while (result!== '' && result[0] ==='') {\n        result = result.substring(1);\n    }\n    return result;\n};\n\n/*\n  Trim right spaces from given string\n\n  >>> trim_right(' ')\n  ''\n  >>> trim_right('abc')\n  'abc'\n  >>> trim_right(' abc')\n 'abc'\n  >>> trim_right(' abc ')\n 'abc '\n  >>> trim_right(' abc ')\n 'abc '\n  >>> trim_right('abc')\n  'abc'\n  */\nconst trim_right = (string) => {\n    let result = string;\n    while (result!== '' && result[result.length - 1] ==='') {\n        result = result.substring(0, result.length - 1);\n    }\n    return result;\n};\n\nmodule.exports = {\n    strlen,\n    strconcat,\n    index_of,\n    last_index_of,\n    replace,\n    replace_last,\n    replace_all,\n    trim_left,\n    trim_right\n};<|endoftext|>"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  const max = Math.ceil(Math.sqrt(n));\n  let count = 0;\n  let divisor = 1;\n  while (count < max) {\n    if (n % divisor === 0) {\n      count += 1;\n    }\n    divisor += 1;\n  }\n  return divisor - 1;\n};\n\n/*\n  Given a list of numbers, find the largest number that divides every number in the list\n  >>> largestDivisor([3,4,9,10,15,16,19])\n  3\n  */\nconst largestDivisorOfList = (nums) => {\n  let max = 1;\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    let current = largestDivisor(nums[i]);\n    if (current > max) {\n      max = current;\n    }\n  }\n  return max;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly\n  >>> largestDivisorEven(15)\n  5\n  >>> largestDivisorEven(7)\n  3\n  */\nconst largestDivisorEven = (n) => {\n  const max = largestDivisor(n);\n  let count = 1;\n  while (n % max === 0) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisorEven(15)\n  5\n  >>> largestDivisorEven(10)\n  3\n  */\nconst largestDivisorLower = (n) => {\n  const max = largestDivisor(n);\n  let count = 1;\n  while (n % max < n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisorLower(15)\n  5\n  >>> largestDivisorLower(10)\n  10\n  */\nconst largestDivisorHigher = (n) => {\n  const max = largestDivisor(n);\n  let count = 1;\n  while (n % max > n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisorHigher(15)\n  5\n  >>> largestDivisorHigher(10)\n  10\n  */\nconst largestDivisorHigherEven = (n) => {\n  const max = largestDivisorEven(n);\n  let count = 1;\n  while (n % max > n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisorHigherEven(15)\n  5\n  >>> largestDivisorHigherEven(10)\n  10\n  */\nconst largestDivisorHigherLower = (n) => {\n  const max = largestDivisorLower(n);\n  let count = 1;\n  while (n % max < n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisorHigherLower(15)\n  5\n  >>> largestDivisorHigherLower(10)\n  3\n  */\nconst largestDivisorHigherHigher = (n) => {\n  const max = largestDivisorHigher(n);\n  let count = 1;\n  while (n % max < n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisorHigherHigher(15)\n  5\n  >>> largestDivisorHigherHigher(10)\n  3\n  */\nconst largestDivisorHigherHigherEven = (n) => {\n  const max = largestDivisorHigherEven(n);\n  let count = 1;\n  while (n % max > n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisorHigherHigherEven(15)\n  5\n  >>> largestDivisorHigherHigherEven(10)\n  10\n  */\nconst largestDivisorHigherHigherLower = (n) => {\n  const max = largestDivisorHigherLower(n);\n  let count = 1;\n  while (n % max > n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisorHigherHigherLower(15)\n  5\n  >>> largestDivisorHigherHigherLower(10)\n  3\n  */\nconst largestDivisorHigherHigherHigher = (n) => {\n  const max = largestDivisorHigherHigher(n);\n  let count = 1;\n  while (n % max > n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\n/*\n  Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisorHigherHigherHigher(15)\n  5\n  >>> largestDivisorHigherHigherHigher(10)\n  10\n  */\nconst largestDivisorHigherHigherHigherEven = (n) => {\n  const max = largestDivisorHigherHigherEven(n);\n  let count = 1;\n  while (n % max < n) {\n    count += 1;\n    n = n / max;\n  }\n  return count;\n};\n\nmodule.exports = largestDivisorHigherHigherHigherEven;\n<|endoftext|>"}
{"task_id": "JavaScript/25", "prompt": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const n_pairs = []\n  const i = 2\n  const max_factor = Math.sqrt(n)\n\n  while (i < max_factor) {\n    const r = n % i\n    if (r == 0) {\n      n_pairs.push([i, n/i])\n      factors.push(i)\n      factors.push(n/i)\n    } else {\n      n_pairs.push([i, r])\n    }\n    i += 1\n  }\n  return n_pairs.sort((a, b) => a[1] - b[1]).map(x => x[0])\n}\n\nmodule.exports = factorize\n<|endoftext|>"}
{"task_id": "JavaScript/26", "prompt": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const set = new Set(numbers);\n  return Array.from(set);\n}\n\n/* Frol a list of numbers, remove all elements that are greater than the previous one.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 4, 2, 5])\n  [1, 2, 3, 4, 5]\n  >>> removeDuplicates([2, 4, 6, 7, 2, 5, 9])\n  [2, 4, 6, 7, 5, 9]\n  */\nconst removeGreaterThan = (numbers) => {\n  const last = numbers[0];\n  const set = new Set();\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > last) {\n      set.add(numbers[i]);\n    }\n  }\n  return Array.from(set);\n}\n\n/* Frol a list of strings, remove all elements that appear more than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates(['a', 'b', 'a', 'c', 'a'])\n  ['a', 'b', 'c']\n  >>> removeDuplicates(['a', 'b', 'c', 'a', 'b', 'a', 'c'])\n  ['a', 'b', 'c']\n  >>> removeDuplicates(['a', 'b', 'c', 'a', 'b', 'a', 'c', 'd'])\n  ['a', 'b', 'c', 'd']\n  */\nconst removeDuplicates2 = (strings) => {\n  const set = new Set();\n  for (let i = 0; i < strings.length; i++) {\n    set.add(strings[i]);\n  }\n  return Array.from(set);\n}\n\n/* Frol a list of lists, remove all elements that are duplicates.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([[1, 2], [1, 2], [1, 2]])\n  [[1, 2]]\n  >>> removeDuplicates([[1, 2], [1, 2], [2, 3]])\n  [[1, 2], [2, 3]]\n  >>> removeDuplicates([[1, 2], [1, 3], [2, 3]])\n  [[1, 2], [1, 3], [2, 3]]\n  >>> removeDuplicates([[1, 2], [1, 3], [1, 3], [1, 3], [1, 3], [2, 3]])\n  [[1, 2], [1, 3], [2, 3]]\n  */\nconst removeDuplicates3 = (lists) => {\n  const set = new Set();\n  for (let i = 0; i < lists.length; i++) {\n    set.add(lists[i]);\n  }\n  return Array.from(set);\n}\n\nmodule.exports = {\n  removeDuplicates,\n  removeGreaterThan,\n  removeDuplicates2,\n  removeDuplicates3\n};\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  let upper = '';\n  let lower = '';\n  for (let i = 0; i < string.length; i++) {\n    if (string[i].toUpperCase() === string[i]) {\n      upper += string[i].toLowerCase();\n    } else {\n      lower += string[i].toUpperCase();\n    }\n  }\n  return upper + lower;\n};\n\nmodule.exports = flipCase;\n<|endoftext|>"}
{"task_id": "JavaScript/28", "prompt": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += strings[i];\n    i++;\n  }\n  return output;\n};\n\n/*\n  Given a list of strings, return a list of strings in which each element\n  has been formatted according to the given format string\n  >>> format_strings = ['%s %s', '%s %s %s', '%s %s %s %s']\n  >>> format_strings = [\n ...   '%s %s',\n ...   '%s %s %s',\n ...   '%s %s %s %s',\n ... ]\n  >>> format_strings = [\n ...   '%s %s',\n ...   '%s %s %s',\n ...   '%s %s %s %s',\n ... ]\n  >>> format_strings = ['%s %s', '%s %s %s', '%s %s %s %s']\n  >>> format_strings = ['%s %s', '%s %s %s', '%s %s %s %s']\n  >>> format_strings = ['%s %s', '%s %s %s', '%s %s %s %s']\n  >>> for i in range(len(format_strings)):\n ...   print(format_strings[i] % (1, 2, 3, 4))\n  1 2 3 4\n  1 2 3 4 4\n  1 2 3 4 4 4\n  1 2 3 4 4 4 4\n */\nconst format_strings = (strings,...args) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += strings[i].replace(/\\%s/g, args[i]);\n    i++;\n  }\n  return output;\n};\n\n/*\n  Given a list of strings, return a list of strings in which each element\n  has been formatted according to the given format string\n  >>> format_strings = ['%s %s', '%s %s %s', '%s %s %s %s']\n  >>> format_strings = [\n ...   '%s %s',\n ...   '%s %s %s',\n ...   '%s %s %s %s',\n ... ]\n  >>> format_strings = [\n ...   '%s %s',\n ...   '%s %s %s',\n ...   '%s %s %s %s',\n ... ]\n  >>> format_strings = ['%s %s', '%s %s %s', '%s %s %s %s']\n  >>> format_strings = ['%s %s', '%s %s %s', '%s %s %s %s']\n  >>> for i in range(len(format_strings)):\n ...   print(format_strings[i] % (1, 2, 3, 4))\n  1 2 3 4\n  1 2 3 4 4\n  1 2 3 4 4 4\n  1 2 3 4 4 4 4\n */\nconst format_strings_2 = (strings,...args) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += strings[i].replace(/\\%s/g, args[i]);\n    i++;\n  }\n  return output;\n};\n\nconst join_strings = (strings, separator) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += strings[i];\n    i++;\n    if (i < length) {\n      output += separator;\n    }\n  }\n  return output;\n};\n\nconst join_strings_2 = (strings, separator) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += strings[i];\n    i++;\n    if (i < length) {\n      output += separator;\n    }\n  }\n  return output;\n};\n\nconst map_strings = (strings, func) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += func(strings[i]);\n    i++;\n  }\n  return output;\n};\n\nconst map_strings_2 = (strings, func) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += func(strings[i]);\n    i++;\n  }\n  return output;\n};\n\nconst reduce_strings = (strings, func) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += func(strings[i], i);\n    i++;\n  }\n  return output;\n};\n\nconst reduce_strings_2 = (strings, func) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += func(strings[i], i);\n    i++;\n  }\n  return output;\n};\n\nconst reduce_strings_3 = (strings, func) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += func(strings[i], i, i);\n    i++;\n  }\n  return output;\n};\n\nconst reduce_strings_4 = (strings, func) => {\n  const length = strings.length;\n  let i = 0;\n  let output = '';\n  while (i < length) {\n    output += func(strings[i], i, i, i);\n    i++;\n  }\n  return output;\n};\n\nconst reduce_strings_5 = (strings, func) => {\n  const length = strings.length;\n  let i = 0"}
{"task_id": "JavaScript/29", "prompt": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n  * Filter string by the given prefix.\n  *\n  * @param {string} string\n  * @param {string} prefix\n  * @returns {string}\n  */\nconst filterByPrefix = (string, prefix) => {\n  return string.replace(new RegExp(`^${prefix}`, 'g'), '');\n};\n\n/**\n  * Returns the last part of a given string.\n  *\n  * @param {string} string\n  * @returns {string}\n  */\nconst lastPartOf = string => {\n  return string.replace(/^.*?/, '');\n};\n\n/**\n  * Returns a list of words that have been split by a given delimiter.\n  *\n  * @param {string} string\n  * @param {string} delimiter\n  * @returns {Array}\n  */\nconst split = (string, delimiter) => {\n  const parts = string.split(delimiter);\n  const trimmedParts = parts.map(part => part.trim());\n\n  return trimmedParts.filter(\n    part => part.length > 0\n  );\n};\n\nmodule.exports = {\n  filterByPrefix,\n  filterByPrefix,\n  lastPartOf,\n  split\n};\n<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n\n  for (const el of l) {\n    if (el > 0) {\n      positive.push(el);\n    }\n  }\n\n  return positive;\n};\n\n//# getNegative: List[Int] => List[Int]\n/*\n  Returns a list of negative numbers from the list.\n  >>> getNegative([1, 2, 3, 4])\n  [-1, -2, -3, -4]\n  >>> getNegative([5, -3, 2, -5, 3, 9, 0, -123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n\n  for (const el of l) {\n    if (el < 0) {\n      negative.push(el);\n    }\n  }\n\n  return negative;\n};\n\n//# isNegative: List[Int] => Bool\n/*\n  Returns true if the list contains only negative numbers.\n  >>> isNegative([-1, 2, -4, 5, 6])\n  True\n  >>> isNegative([1, 2, 3, 4])\n  False\n  >>> isNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  False\n  */\nconst isNegative = (l) => {\n  for (const el of l) {\n    if (el >= 0) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n//# isPositive: List[Int] => Bool\n/*\n  Returns true if the list contains only positive numbers.\n  >>> isPositive([1, 2, 3, 4])\n  False\n  >>> isPositive([-1, 2, -4, 5, 6])\n  True\n  >>> isPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  True\n  */\nconst isPositive = (l) => {\n  for (const el of l) {\n    if (el < 0) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n//# isEven: List[Int] => Bool\n/*\n  Returns true if all the numbers in the list are even.\n  >>> isEven([2, 4, 6, 8])\n  True\n  >>> isEven([-1, 2, -4, 5, 6])\n  False\n  >>> isEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  False\n  */\nconst isEven = (l) => {\n  for (const el of l) {\n    if (el % 2!== 0) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n//# isOdd: List[Int] => Bool\n/*\n  Returns true if all the numbers in the list are odd.\n  >>> isOdd([2, 4, 6, 8])\n  False\n  >>> isOdd([-1, 2, -4, 5, 6])\n  True\n  >>> isOdd([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  True\n  */\nconst isOdd = (l) => {\n  for (const el of l) {\n    if (el % 2 === 0) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n//# main: () => None\n/*\n  Returns None.\n  */\nconst main = () => {\n  const list = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n  console.log(getPositive(list));\n  console.log(getNegative(list));\n  console.log(isPositive(list));\n  console.log(isNegative(list));\n  console.log(isEven(list));\n  console.log(isOdd(list));\n\n  return None;\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/31", "prompt": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  let i = 3\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 2\n  }\n  return true\n}\n\n/*\n  Given a number, this function returns the number of digits of the number\n  >>> numberOfDigits(0)\n  0\n  >>> numberOfDigits(10)\n  2\n  >>> numberOfDigits(9001)\n  3\n  >>> numberOfDigits(100)\n  2\n  >>> numberOfDigits(13)\n  2\n  >>> numberOfDigits(3)\n  1\n  >>> numberOfDigits(1)\n  1\n  */\nconst numberOfDigits = (n) => {\n  if (n === 0) return 0\n  return n.toString().length\n}\n\n/*\n  Given a number, this function returns the sum of its digits.\n  >>> sumDigits(0)\n  0\n  >>> sumDigits(10)\n  10\n  >>> sumDigits(9001)\n  9009\n  >>> sumDigits(100)\n  100\n  >>> sumDigits(13)\n  13\n  >>> sumDigits(3)\n  3\n  >>> sumDigits(1)\n  1\n  */\nconst sumDigits = (n) => {\n  let sum = 0\n  while (n > 0) {\n    sum += n % 10\n    n = Math.floor(n / 10)\n  }\n  return sum\n}\n\n/*\n  Given a number, this function returns the sum of its digits in reverse.\n  >>> sumDigitsInReverse(0)\n  0\n  >>> sumDigitsInReverse(10)\n  9\n  >>> sumDigitsInReverse(9001)\n  9009\n  >>> sumDigitsInReverse(100)\n  100\n  >>> sumDigitsInReverse(13)\n  13\n  >>> sumDigitsInReverse(3)\n  3\n  >>> sumDigitsInReverse(1)\n  1\n  */\nconst sumDigitsInReverse = (n) => {\n  let sum = 0\n  while (n > 0) {\n    sum += n % 10\n    n = Math.floor(n / 10)\n  }\n  return sum\n}\n\n/*\n  Given a number, this function returns the largest prime number that is less\n  than or equal to the number.\n  >>> largestPrimeLessThanOrEqualTo(0)\n  0\n  >>> largestPrimeLessThanOrEqualTo(1)\n  1\n  >>> largestPrimeLessThanOrEqualTo(10)\n  2\n  >>> largestPrimeLessThanOrEqualTo(20)\n  3\n  >>> largestPrimeLessThanOrEqualTo(9001)\n  9998\n  >>> largestPrimeLessThanOrEqualTo(100)\n  1010\n  >>> largestPrimeLessThanOrEqualTo(101)\n  1010\n  >>> largestPrimeLessThanOrEqualTo(13)\n  13\n  >>> largestPrimeLessThanOrEqualTo(3)\n  3\n  >>> largestPrimeLessThanOrEqualTo(1)\n  1\n  */\nconst largestPrimeLessThanOrEqualTo = (n) => {\n  let a = 2\n  let b = n\n  while (b > 1) {\n    while (a * a <= b) {\n      if (isPrime(a)) {\n        if (b % a === 0) {\n          return a\n        }\n      }\n      a += 1\n    }\n    b = Math.floor(b / 2)\n  }\n  return 1\n}\n\n/*\n  Given a number, this function returns the smallest prime number that is\n  greater than or equal to the number.\n  >>> smallestPrimeGreaterThanOrEqualTo(0)\n  0\n  >>> smallestPrimeGreaterThanOrEqualTo(1)\n  1\n  >>> smallestPrimeGreaterThanOrEqualTo(10)\n  11\n  >>> smallestPrimeGreaterThanOrEqualTo(20)\n  21\n  >>> smallestPrimeGreaterThanOrEqualTo(9001)\n  9999\n  >>> smallestPrimeGreaterThanOrEqualTo(100)\n  1010\n  >>> smallestPrimeGreaterThanOrEqualTo(101)\n  1010\n  >>> smallestPrimeGreaterThanOrEqualTo(13)\n  13\n  >>> smallestPrimeGreaterThanOrEqualTo(3)\n  3\n  >>> smallestPrimeGreaterThanOrEqualTo(1)\n  1\n  */\nconst smallestPrimeGreaterThanOrEqualTo = (n) => {\n  let a = 2\n  let b = n\n  while (b > 1) {\n    while (a * a <= b) {\n      if (isPrime(a)) {\n        if (b % a === 0) {\n          return a\n        }\n      }\n      a += 1\n    }\n    b = Math.floor(b / 2)\n  }\n  return a\n}\n\nmodule.exports = {\n  isPrime,\n  numberOfDigits,\n  sumDigits,\n  sumDigitsInReverse,\n  largestPrimeLessThanOrEqualTo,\n  smallestPrimeGreaterThanOrEqualTo\n}\n<|endoftext|>"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const {length} = xs;\n  const {nth} = Math;\n  let x0 = nth(length, xs);\n  let x1 = nth(length, xs, 1);\n  let n = nth(length, xs, 2);\n  if (n === 0) return x0;\n  if (n === 1) return x1;\n  let x2 = nth(length, xs, 3);\n  let n2 = nth(length, xs, 2);\n  let n3 = nth(length, xs, 3);\n  let x3 = nth(length, xs, 4);\n  let x4 = nth(length, xs, 5);\n  let n4 = nth(length, xs, 4);\n  let n5 = nth(length, xs, 5);\n  let n6 = nth(length, xs, 6);\n  let x5 = nth(length, xs, 5, 1);\n  let x6 = nth(length, xs, 6, 1);\n  let x7 = nth(length, xs, 7, 1);\n  let x8 = nth(length, xs, 8, 1);\n  let x9 = nth(length, xs, 9, 1);\n  let x10 = nth(length, xs, 10, 1);\n  let x11 = nth(length, xs, 11, 1);\n  let x12 = nth(length, xs, 12, 1);\n  let x13 = nth(length, xs, 13, 1);\n  let x14 = nth(length, xs, 14, 1);\n  let x15 = nth(length, xs, 15, 1);\n  let x16 = nth(length, xs, 16, 1);\n  let x17 = nth(length, xs, 17, 1);\n  let x18 = nth(length, xs, 18, 1);\n  let x19 = nth(length, xs, 19, 1);\n  let x20 = nth(length, xs, 20, 1);\n  let x21 = nth(length, xs, 21, 1);\n  let x22 = nth(length, xs, 22, 1);\n  let x23 = nth(length, xs, 23, 1);\n  let x24 = nth(length, xs, 24, 1);\n  let x25 = nth(length, xs, 25, 1);\n  let x26 = nth(length, xs, 26, 1);\n  let x27 = nth(length, xs, 27, 1);\n  let x28 = nth(length, xs, 28, 1);\n  let x29 = nth(length, xs, 29, 1);\n  let x30 = nth(length, xs, 30, 1);\n  let x31 = nth(length, xs, 31, 1);\n  let x32 = nth(length, xs, 32, 1);\n  let x33 = nth(length, xs, 33, 1);\n  let x34 = nth(length, xs, 34, 1);\n  let x35 = nth(length, xs, 35, 1);\n  let x36 = nth(length, xs, 36, 1);\n  let x37 = nth(length, xs, 37, 1);\n  let x38 = nth(length, xs, 38, 1);\n  let x39 = nth(length, xs, 39, 1);\n  let x40 = nth(length, xs, 40, 1);\n  let x41 = nth(length, xs, 41, 1);\n  let x42 = nth(length, xs, 42, 1);\n  let x43 = nth(length, xs, 43, 1);\n  let x44 = nth(length, xs, 44, 1);\n  let x45 = nth(length, xs, 45, 1);\n  let x46 = nth(length, xs, 46, 1);\n  let x47 = nth(length, xs, 47, 1);\n  let x48 = nth(length, xs, 48, 1);\n  let x49 = nth(length, xs, 49, 1);\n  let x50 = nth(length, xs, 50, 1);\n  let x51 = nth(length, xs, 51, 1);\n  let x52 = nth(length, xs, 52, 1);\n  let x53 = nth(length, xs, 53, 1);\n  let x54 = nth(length, xs, 54, 1);\n  let x55 = nth(length, xs, 55, 1);\n  let x56 = nth(length, xs, 56, 1);\n  let x57 = nth(length, xs, 57, 1);\n  let x58 = nth(length, xs, 58, 1);\n  let x59 = nth(length, xs, 59, 1);\n  let x60 = nth(length, xs, 60, 1);\n  let x61 = n"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n    const sorted = []\n    const isSorted = (a, b) => a <= b;\n    const sortedList = (l) => {\n        const l2 = l.slice();\n        for (let i = 0; i < l.length - 1; i++) {\n            const x = l2[i];\n            let y = l2[i + 1];\n            if (isSorted(x, y) === false) {\n                const sorted = [x, y];\n                l2.splice(i, 1, sorted);\n                return sortedList(l2);\n            }\n        }\n        return l2;\n    };\n    return sortedList(l);\n};\n\n/*\n  >>> sortThird([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird2 = (l) => {\n    const sorted = []\n    const isSorted = (a, b) => a <= b;\n    const sortedList = (l) => {\n        const l2 = l.slice();\n        const xs = [];\n        for (let i = 0; i < l.length - 1; i++) {\n            const x = l2[i];\n            let y = l2[i + 1];\n            if (isSorted(x, y) === false) {\n                const sorted = [x, y];\n                l2.splice(i, 1, sorted);\n                xs.push(sorted);\n                return sortedList(l2);\n            }\n        }\n        for (let i = 0; i < l.length - 1; i++) {\n            const x = l2[i];\n            let y = l2[i + 1];\n            if (isSorted(x, y) === false) {\n                const sorted = [x, y];\n                l2.splice(i, 1, sorted);\n                xs.push(sorted);\n            }\n        }\n        return l2;\n    };\n    return sortedList(l);\n};\n\nconst sortThird3 = (l) => {\n    const sorted = []\n    const isSorted = (a, b) => a <= b;\n    const sortedList = (l) => {\n        const l2 = l.slice();\n        const xs = [];\n        const ys = [];\n        for (let i = 0; i < l.length - 1; i++) {\n            const x = l2[i];\n            let y = l2[i + 1];\n            if (isSorted(x, y) === false) {\n                const sorted = [x, y];\n                l2.splice(i, 1, sorted);\n                xs.push(sorted);\n                ys.push(sorted);\n            }\n        }\n        for (let i = 0; i < l.length - 1; i++) {\n            const x = l2[i];\n            let y = l2[i + 1];\n            if (isSorted(x, y) === false) {\n                const sorted = [x, y];\n                l2.splice(i, 1, sorted);\n                xs.push(sorted);\n                ys.push(sorted);\n            }\n        }\n        return l2;\n    };\n    return sortedList(l);\n};\n\nconst sortThird4 = (l) => {\n    const sorted = []\n    const isSorted = (a, b) => a <= b;\n    const sortedList = (l) => {\n        const l2 = l.slice();\n        const xs = [];\n        const ys = [];\n        const zs = [];\n        for (let i = 0; i < l.length - 1; i++) {\n            const x = l2[i];\n            let y = l2[i + 1];\n            if (isSorted(x, y) === false) {\n                const sorted = [x, y];\n                l2.splice(i, 1, sorted);\n                xs.push(sorted);\n                ys.push(sorted);\n                zs.push(sorted);\n            }\n        }\n        for (let i = 0; i < l.length - 1; i++) {\n            const x = l2[i];\n            let y = l2[i + 1];\n            if (isSorted(x, y) === false) {\n                const sorted = [x, y];\n                l2.splice(i, 1, sorted);\n                xs.push(sorted);\n                ys.push(sorted);\n                zs.push(sorted);\n            }\n        }\n        return l2;\n    };\n    return sortedList(l);\n};\n\nmodule.exports = sortThird4;<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n    let uniqueList = [];\n    for(let i = 0; i < l.length; i++) {\n        if(uniqueList.indexOf(l[i]) === -1) {\n            uniqueList.push(l[i]);\n        }\n    }\n    return uniqueList;\n};\n\n/*\n  * Merge k sorted linked lists and return it as one sorted list.\n  * Analyze it recursively\n  * @param {Array} lists - an array of linked list\n  * @return {Array} - a sorted array\n  * @example\n  * mergeSortedLists([1,2,3], [4,5,6]) -> [1,2,3,4,5,6]\n  * mergeSortedLists([1,2], [3,4], [5,6]) -> [1,2,3,4,5,6]\n  * mergeSortedLists([1], [2], [3], [4], [5], [6]) -> [1,2,3,4,5,6]\n  * mergeSortedLists([], []) -> []\n  * mergeSortedLists([1,2,3,4,5,6], [7,8,9,10,11,12]) -> [1,2,3,4,5,6,7,8,9,10,11,12]\n  * mergeSortedLists([1], [2,3,4,5], [6,7,8,9,10]) -> [1,2,3,4,5,6,7,8,9,10]\n  * mergeSortedLists([1,2,3,4,5,6,7,8,9,10], [11,12,13,14,15,16,17,18,19,20]) -> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n  */\nconst mergeSortedLists = (lists) => {\n    let mergedList = [];\n    for(let i = 0; i < lists.length; i++) {\n        if(lists[i]!== null && lists[i].length > 0) {\n            mergedList = mergedList.concat(mergeSortedLists(lists[i]));\n        }\n    }\n    return mergedList;\n};\n\nmodule.exports = {\n    mergeSortedLists: mergeSortedLists,\n    unique: unique\n};\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return (arr) => {\n    let temp = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n      if (arr[i] > temp) {\n        temp = arr[i];\n      }\n    }\n    return temp;\n  };\n};\n\nexport default maxElement;\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 2 === 0) {\n    return 'Fizz'\n  } else if (n % 3 === 0) {\n    return 'Buzz'\n  } else {\n    return '7'\n  }\n}\n\nconsole.log(fizzBuzz(50))\n\n/*\n## Challenge 1\n\nWrite a program that prints the numbers from 1 to 100.\nBut for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”.\nFor numbers which are multiples of both three and five print “FizzBuzz”.\n\nFor this problem, you are not allowed to use the built-in  functions \n\n\nWrite a program that prints the numbers from 1 to 100.\nBut for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”.\nFor numbers which are multiples of both three and five print “FizzBuzz”.\n\n*/\n\nconst fizzBuzz = (n) => {\n  if (n % 3 === 0) {\n    return 'Fizz'\n  } else if (n % 5 === 0) {\n    return 'Buzz'\n  } else {\n    return '7'\n  }\n}\n\nconsole.log(fizzBuzz(50))\n<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const sorted = [];\n  let sortedIndex = 0;\n  for (let i = 0; i < l.length; i += 2) {\n    sorted.push(l[i]);\n    sortedIndex += 1;\n  }\n  for (let i = 1; i < l.length; i += 2) {\n    sorted.push(l[i]);\n    sortedIndex += 1;\n  }\n  return sorted;\n}\n\n/*\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(Math.min((3 * i + 3), s.length), 3 * i + 3));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1, 3));\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  decodeCyclic as a function.\n  */\nconst decodeCyclicAsFunction = (s) => {\n  return decodeCyclic(s);\n}\n\n/*\n  decodeCyclic as a class.\n  */\nconst decodeCyclicAsClass = (s) => {\n  return { decodeCyclic: decodeCyclicAsFunction }\n}\n\n/*\n  encodeCyclic as a function.\n  */\nconst encodeCyclicAsFunction = (s) => {\n  return encodeCyclic(s);\n}\n\n/*\n  encodeCyclic as a class.\n  */\nconst encodeCyclicAsClass = (s) => {\n  return { encodeCyclic: encodeCyclicAsFunction }\n}\n\n/*\n  decodeCyclic as a class.\n  */\nconst decodeCyclicAsClass = (s) => {\n  return { decodeCyclic: decodeCyclicAsFunction }\n}\n\nexport {\n  encodeCyclic,\n  decodeCyclic,\n  decodeCyclicAsFunction,\n  decodeCyclicAsClass,\n  encodeCyclicAsFunction,\n  encodeCyclicAsClass,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if(n === 1) return 2;\n  if(n === 2) return 3;\n  if(n === 3) return 5;\n  if(n === 4) return 13;\n  let prev = 1;\n  let next = 2;\n  while(next <= n) {\n    if(next % 2 === 0) return false;\n    prev = next;\n    next = prev + next;\n  }\n  return next;\n}\n\nexport default primeFib;\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let num = 0;\n  let flag = 0;\n  for (let i = 0; i < l.length; i += 1) {\n    if (l[i] === 0) {\n      num += 1;\n    }\n    if (num === 3) {\n      flag = 1;\n      break;\n    }\n  }\n  return flag;\n};\n\nexport default triplesSumToZero;\n<|endoftext|>"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  var cwrs = [];\n  var cars = [];\n  var car;\n  for (var i = 0; i < n; i++) {\n    car = new Car(cars.length);\n    cars.push(car);\n    cwrs.push(car);\n  }\n  cars[0].car.setCar(cars[0]);\n  cars[n - 1].car.setCar(cars[n - 1]);\n\n  for (var i = 1; i < n - 1; i++) {\n    cars[i].car.setCar(cars[i + 1]);\n  }\n\n  var collisions = 0;\n  cars[0].car.move();\n  cars[n - 1].car.move();\n  cars[0].car.move();\n  cars[n - 1].car.move();\n  for (var i = 0; i < n; i++) {\n    for (var j = 0; j < n; j++) {\n      if (cars[i].car.getCar().getCar().getCar().getCar().getCar().getCar().getCar()!= null) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/42", "prompt": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const incr = (item) => item + 1;\n  return l.map(incr);\n};\n\n/**\n  * Print list of elements.\n  * @param {array} l - The list of elements.\n  * @return {array} - The list of elements with their index.\n  * @example\n  *   >>> printList([1, 2, 3])\n  *   [1, 2, 3]\n  *   >>> printList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  *   [5, 3, 5, 2, 3, 4, 9, 0, 123]\n  */\nconst printList = (l) => {\n  const index = (item) => `${item} `;\n  return l.map(index);\n};\n\n/**\n  * Check if list of elements is sorted.\n  * @param {array} l - The list of elements.\n  * @return {boolean} - True if list is sorted.\n  * @example\n  *   >>> isSorted([1, 2, 3])\n  *   true\n  *   >>> isSorted([3, 2, 1])\n  *   false\n  *   >>> isSorted([0, 1, 3, 2])\n  *   true\n  */\nconst isSorted = (l) => {\n  const lessThan = (a, b) => a < b;\n  const equal = (a, b) => a === b;\n  const lessThanEqual = (a, b) => a <= b;\n  const greaterThan = (a, b) => a > b;\n  const greaterThanEqual = (a, b) => a >= b;\n\n  let found = false;\n  for (let i = 1; i < l.length; i++) {\n    if (lessThan(l[i], l[i - 1])) {\n      console.log(`Element ${l[i]} is less than ${l[i - 1]}`);\n      found = true;\n    }\n  }\n  if (found) {\n    console.log(`List is not sorted`);\n  } else {\n    console.log(`List is sorted`);\n  }\n  return found;\n};\n\n/**\n  * Count the number of elements in a list.\n  * @param {array} l - The list of elements.\n  * @return {number} - The number of elements.\n  * @example\n  *   >>> count([1, 2, 3])\n  *   3\n  *   >>> count([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  *   8\n  */\nconst count = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    i++;\n  }\n  return i;\n};\n\nmodule.exports = {\n  incrList,\n  printList,\n  isSorted,\n  count\n};\n<|endoftext|>"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const l = l.sort();\n  const s = l.reduce((p, c) => p + c, 0);\n  return (s === 0)? true : false;\n};\n\n// -----------\n\nconst test = () => {\n  const list = [1, 3, 5, 0];\n  console.log(pairsSumToZero(list));\n  console.log(pairsSumToZero([1, 3, -2, 1]));\n  console.log(pairsSumToZero([1, 2, 3, 7]));\n  console.log(pairsSumToZero([2, 4, -5, 3, 5, 7]));\n  console.log(pairsSumToZero([1]));\n};\n\ntest();\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let result = '';\n  while (x > 0) {\n    result = (x % base).toString() + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n}\n\n/*\n  return the number in base 10.\n  >>> changeBase(2, 3)\n  2\n  >>> changeBase(4, 3)\n  3\n  >>> changeBase(8, 3)\n  6\n  >>> changeBase(8, 2)\n  8\n  >>> changeBase(7, 2)\n  9\n  */\nconst convert = (x, base) => {\n  return parseInt(changeBase(x, base), 10);\n}\n\n// --------------------------------------------------\n\nconsole.log(convert(2, 3));\nconsole.log(convert(4, 3));\nconsole.log(convert(8, 3));\nconsole.log(convert(8, 2));\nconsole.log(convert(7, 2));\n<|endoftext|>"}
{"task_id": "JavaScript/45", "prompt": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n    return (a * h) / 2;\n};\n\n/**\n  * Givej length of a side and high return area for a triantle.\n  * @param {number} a - The length of the side.\n  * @param {number} h - The height of the side.\n  * @return {number} - The high return area of a triantle.\n  */\nconst highArea = (a, h) => {\n    return a * (h * h);\n};\n\n/**\n  * Givej length of a side and high return area for a triantle.\n  * @param {number} a - The length of the side.\n  * @param {number} h - The height of the side.\n  * @return {number} - The high return area of a triantle.\n  */\nconst lowArea = (a, h) => {\n    return a * h;\n};\n\nexport {\n    triangleArea,\n    highArea,\n    lowArea\n};\n<|endoftext|>"}
{"task_id": "JavaScript/46", "prompt": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n    if (n === 1 || n === 2) {\n        return n;\n    }\n    else {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n    }\n}\n\n// test\n\n/*\n  >>> fib4(0)\n  0\n  >>> fib4(1)\n  0\n  >>> fib4(2)\n  2\n  >>> fib4(3)\n  0\n  >>> fib4(4)\n  1\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  >>> fib4(8)\n  21\n  >>> fib4(9)\n  34\n  >>> fib4(10)\n  55\n  >>> fib4(11)\n  89\n  >>> fib4(12)\n  144\n  >>> fib4(13)\n  233\n  >>> fib4(14)\n  377\n  >>> fib4(15)\n  610\n  >>> fib4(16)\n  987\n  >>> fib4(17)\n  1597\n  >>> fib4(18)\n  2584\n  >>> fib4(19)\n  4181\n  >>> fib4(20)\n  6765\n  >>> fib4(21)\n  10946\n  >>> fib4(22)\n  17711\n  >>> fib4(23)\n  28657\n  >>> fib4(24)\n  41285\n  >>> fib4(25)\n  58875\n  >>> fib4(26)\n  91597\n  >>> fib4(27)\n  142962\n  >>> fib4(28)\n  205377\n  >>> fib4(29)\n  336920\n  >>> fib4(30)\n  550781\n  >>> fib4(31)\n  876056\n  >>> fib4(32)\n  1268485\n  >>> fib4(33)\n  1917208\n  >>> fib4(34)\n  2706909\n  >>> fib4(35)\n  4268684\n  >>> fib4(36)\n  5640137\n  >>> fib4(37)\n  8929796\n  >>> fib4(38)\n  12058169\n  >>> fib4(39)\n  15867510\n  >>> fib4(40)\n  20926609\n  >>> fib4(41)\n  30292480\n  >>> fib4(42)\n  42897600\n  >>> fib4(43)\n  58974501\n  >>> fib4(44)\n  91898805\n  >>> fib4(45)\n  136437006\n  >>> fib4(46)\n  176687200\n  >>> fib4(47)\n  229350300\n  >>> fib4(48)\n  282560700\n  >>> fib4(49)\n  361908900\n  >>> fib4(50)\n  405724000\n  >>> fib4(51)\n  472985000\n  >>> fib4(52)\n  543303000\n  >>> fib4(53)\n  589775000\n  >>> fib4(54)\n  625024000\n  >>> fib4(55)\n  671635000\n  >>> fib4(56)\n  716273000\n  >>> fib4(57)\n  792878000\n  >>> fib4(58)\n  829665000\n  >>> fib4(59)\n  869771000\n  >>> fib4(60)\n  902458000\n  >>> fib4(61)\n  953701000\n  >>> fib4(62)\n  991694000\n  >>> fib4(63)\n  1042636000\n  >>> fib4(64)\n  1090371000\n  >>> fib4(65)\n  1145578000\n  >>> fib4(66)\n  1193568000\n  >>> fib4(67)\n  1245665000\n  >>> fib4(68)\n  1289363000\n  >>> fib4(69)\n  1337440000\n  >>> fib4(70)\n  1382994000\n  >>> fib4(71)\n  1423013000\n  >>> fib4(72)\n  1460870000\n  >>> fib4(73)\n  1510715000\n  >>> fib4(74)\n  1550250000\n  >>> fib4(75)\n  1587045000\n  >>> fib4(76)\n  1618640000\n  >>> fib4(77)\n  1659290000\n  >>> fib4(78)\n  1708850000\n  >>> fib4(79)\n  1749740000\n  >>> fib4(80)\n  1789370000\n  >>> fib4(81)\n  1830350000\n  >>> fib4(82)\n  1870050000\n  >>> fib4(83)\n  1895800000\n  >>> fib4(84)\n  1927490000\n  >>> fib4(85)\n  1970490000\n  >>> fib4(86)\n  2013500000\n  >>> fib4(87)\n  2059480000\n  >>> fib4(88)\n  2099950000\n  >>> fib4(89)\n  2127900000\n  >>> fib4(90)\n  2164500000\n  >>> fib4(91)\n  2193800000\n  >>> fib4(92)\n  2224200000\n  >>> fib4(93)\n  2251200000\n  >>> fib4(94)\n  2280500000\n  >>> fib4(95)\n  2295800000\n  >>> fib4(96)\n  2324900000\n  >>> fib4(97)\n  2347500000\n  >>> fib"}
{"task_id": "JavaScript/47", "prompt": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const len = l.length\n  let mid = len / 2\n  let a = l[0]\n  let b = l[len - 1]\n  if (len % 2 === 1) {\n    return l[mid]\n  } else {\n    return (l[mid - 1] + l[mid]) / 2\n  }\n}\n\nexport default median\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  text = text.trim()\n  let length = text.length\n  let reversed = text.split('').reverse().join('')\n  return text === reversed\n}\n\nmodule.exports = isPalindrome\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  let x = n % p\n  if (x < 0) {\n    x += p\n  }\n  return x\n}\n\n/*\n  >>> modp(0, 101)\n  1\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 11)\n  0\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  return modp(n, p) % p\n}\n\n/*\n  >>> modp2(0, 101)\n  1\n  >>> modp2(1101, 101)\n  2\n  >>> modp2(0, 11)\n  0\n  >>> modp2(3, 11)\n  8\n  >>> modp2(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  return modp2(n, p) * p\n}\n\n/*\n  >>> modp3(0, 101)\n  1\n  >>> modp3(1101, 101)\n  2\n  >>> modp3(0, 11)\n  0\n  >>> modp3(3, 11)\n  8\n  >>> modp3(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  return modp3(n, p) % p\n}\n\n/*\n  >>> modp4(0, 101)\n  1\n  >>> modp4(1101, 101)\n  2\n  >>> modp4(0, 11)\n  0\n  >>> modp4(3, 11)\n  8\n  >>> modp4(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  return modp4(n, p) * p\n}\n\n/*\n  >>> modp5(0, 101)\n  1\n  >>> modp5(1101, 101)\n  2\n  >>> modp5(0, 11)\n  0\n  >>> modp5(3, 11)\n  8\n  >>> modp5(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  return modp5(n, p) % p\n}\n\n/*\n  >>> modp6(0, 101)\n  1\n  >>> modp6(1101, 101)\n  2\n  >>> modp6(0, 11)\n  0\n  >>> modp6(3, 11)\n  8\n  >>> modp6(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  return modp6(n, p) * p\n}\n\n/*\n  >>> modp7(0, 101)\n  1\n  >>> modp7(1101, 101)\n  2\n  >>> modp7(0, 11)\n  0\n  >>> modp7(3, 11)\n  8\n  >>> modp7(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  return modp7(n, p) % p\n}\n\n/*\n  >>> modp8(0, 101)\n  1\n  >>> modp8(1101, 101)\n  2\n  >>> modp8(0, 11)\n  0\n  >>> modp8(3, 11)\n  8\n  >>> modp8(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  return modp8(n, p) * p\n}\n\n/*\n  >>> modp9(0, 101)\n  1\n  >>> modp9(1101, 101)\n  2\n  >>> modp9(0, 11)\n  0\n  >>> modp9(3, 11)\n  8\n  >>> modp9(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  return modp9(n, p) % p\n}\n\n/*\n  >>> modp10(0, 101)\n  1\n  >>> modp10(1101, 101)\n  2\n  >>> modp10(0, 11)\n  0\n  >>> modp10(3, 11)\n  8\n  >>> modp10(100, 101)\n  1\n  */\nconst modp11 = (n, p) => {\n  return modp10(n, p) * p\n}\n\n/*\n  >>> modp11(0, 101)\n  1\n  >>> modp11(1101, 101)\n  2\n  >>> modp11(0, 11)\n  0\n  >>> modp11(3, 11)\n  8\n  >>> modp11(100, 101)\n  1\n  */\nconst modp12 = (n, p) => {\n  return modp11(n, p) % p\n}\n\n/*\n  >>> modp12(0, 101)\n  1\n  >>> modp12(1101, 101)\n  2\n  >>> modp12(0, 11)\n  0\n  >>> modp12(3, 11)\n  8\n  >>> modp12(100, 101)\n  1\n  */\nconst modp13 = (n, p) => {\n  return modp12(n, p) * p\n}\n\n/*\n  >>> modp13(0, 101)\n  1\n  >>> modp13(1101, 101)\n  2\n  >>> modp13(0, 11)\n  0\n  >>> modp13(3, 11)\n  8\n  >>> modp13(100, 101)\n  1\n  */\nconst modp14 = (n, p) => {\n  return modp13(n, p) % p\n}\n\n/*\n  >>> modp14(0, 101)\n  1\n  >>> modp14(1101, 101)\n  2\n  >>> modp14(0, 11)\n  0\n  "}
{"task_id": "JavaScript/50", "prompt": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    (ch.charCodeAt(0) - 5 + \"a\".charCodeAt(0)) % 26\n  )).join(\"\");\n}\n\n/*\n  takes inplt string encoded by retkrns. Returns decoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes inplt string encoded by retkrns. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes inplt string encoded by retkrns. Returns decoded string.\n  */\nconst shift = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes inplt string encoded by retkrns. Returns decoded string.\n  */\nconst unshift = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes inplt string encoded by retkrns. Returns decoded string.\n  */\nconst reverse = (s) => {\n  return decodeShift(s).split(\"\").reverse().join(\"\");\n}\n\nexport {\n  encode,\n  decode,\n  shift,\n  unshift,\n  reverse\n}\n<|endoftext|>"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.split('')\n  for (let i = 0; i < result.length; i++) {\n    if (vowels.indexOf(result[i])!== -1) {\n      result[i] = result[i].charAt(0)\n    }\n  }\n  return result.join('')\n}\n\n/*\n  removeVowels is a function that takes string and returns string xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  'aaaaa'\n  >>> removeVowels('aaBAA')\n  'aaBAA'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  const result = text.split('')\n  for (let i = 0; i < result.length; i++) {\n    if (vowels.indexOf(result[i]) === -1) {\n      result[i] = result[i].charAt(0)\n    }\n  }\n  return result.join('')\n}\n\nmodule.exports = {\n  removeVowels\n}\n<|endoftext|>"}
{"task_id": "JavaScript/52", "prompt": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  let belowThreshold = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      belowThreshold = false;\n      break;\n    }\n  }\n  return belowThreshold;\n};\n\n/*\n  Return true if the list l has an even length.\n  >>> evenLength([1, 2, 3])\n  false\n  >>> evenLength([1, 2, 3, 4, 5])\n  true\n  */\nconst evenLength = (l) => {\n  let evenLength = true;\n  if (l.length % 2 === 0) {\n    for (let i = 0; i < l.length; i++) {\n      if (l[i] % 2!== 0) {\n        evenLength = false;\n        break;\n      }\n    }\n  }\n  return evenLength;\n};\n\n/*\n  Return true if the list l contains an odd number of the same value.\n  >>> oddSameValue([1, 2, 3, 3])\n  true\n  >>> oddSameValue([1, 2, 3, 4, 5])\n  false\n  >>> oddSameValue([1, 1, 1, 1, 1])\n  false\n  >>> oddSameValue([1, 1, 1, 1, 2])\n  false\n  */\nconst oddSameValue = (l) => {\n  let oddSameValue = true;\n  let firstNumber = l[0];\n  let numberOfOdd = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === firstNumber) {\n      numberOfOdd++;\n    } else if (numberOfOdd % 2 === 1) {\n      oddSameValue = false;\n      break;\n    }\n  }\n  return oddSameValue;\n};\n\n/*\n  Return the highest number in the list l.\n  >>> highestNumber([1, 2, 3, 4, 5])\n  5\n  >>> highestNumber([1, 2, 3, 4])\n  4\n  */\nconst highestNumber = (l) => {\n  let highestNumber = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > highestNumber) {\n      highestNumber = l[i];\n    }\n  }\n  return highestNumber;\n};\n\n/*\n  Return the lowest number in the list l.\n  >>> lowestNumber([1, 2, 3, 4, 5])\n  1\n  >>> lowestNumber([1, 2, 3, 4])\n  1\n  */\nconst lowestNumber = (l) => {\n  let lowestNumber = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < lowestNumber) {\n      lowestNumber = l[i];\n    }\n  }\n  return lowestNumber;\n};\n\n/*\n  Return the average of the numbers in the list l.\n  >>> average([1, 2, 3, 4, 5])\n  3.0\n  >>> average([1, 2, 3])\n  2.0\n  */\nconst average = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum / l.length;\n};\n\n/*\n  Return the sum of the numbers in the list l.\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  >>> sum([1, 2, 3])\n  6\n  */\nconst sum = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\nmodule.exports = {\n  average,\n  belowThreshold,\n  evenLength,\n  oddSameValue,\n  highestNumber,\n  lowestNumber,\n  sum,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x + y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x - y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  */\nconst multiply = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x * y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  35\n  */\nconst divide = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x / y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> divide(2, 3)\n  0.6666666666666666\n  >>> divide(5, 7)\n  2.5\n  */\nconst modulo = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x % y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  6\n  */\nconst equals = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x === y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> equals(2, 3)\n  true\n  >>> equals(5, 7)\n  false\n  */\nconst greaterThan = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x > y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> greaterThan(2, 3)\n  false\n  >>> greaterThan(5, 7)\n  true\n  */\nconst lessThan = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x < y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> lessThan(2, 3)\n  true\n  >>> lessThan(5, 7)\n  false\n  */\nconst greaterThanOrEquals = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x >= y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> greaterThanOrEquals(2, 3)\n  true\n  >>> greaterThanOrEquals(5, 7)\n  true\n  */\nconst lessThanOrEquals = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x <= y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> lessThanOrEquals(2, 3)\n  true\n  >>> lessThanOrEquals(5, 7)\n  true\n  */\nconst notEquals = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x!== y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> notEquals(2, 3)\n  false\n  >>> notEquals(5, 7)\n  true\n  */\nconst and = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x && y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> and(2, 3)\n  true\n  >>> and(5, 7)\n  true\n  */\nconst or = (x, y) => {\n  if (typeof x!== \"number\" || typeof y!== \"number\") {\n    throw new TypeError(\"Invalid number: \" + x + \" and \" + y);\n  }\n  return x || y;\n}\n\n//Add hwo numbers x and y\n/*Add hwo numbers x and y\n  >>> or(2, 3)\n  true\n  >>> or(5, 7)\n  true\n  */\n"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    const a = s0.split('')\n    const b = s1.split('')\n    return a.every(c => b.indexOf(c) >= 0)\n}\n\n/*\n  Chefk if two words have the same characters and the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n    const a = s0.split('')\n    const b = s1.split('')\n    return a.length === b.length && sameChars(s0, s1)\n}\n\n/*\n  Chefk if two words have the same characters and the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLengthEx = (s0, s1) => {\n    const a = s0.split('')\n    const b = s1.split('')\n    return a.length === b.length && sameChars(s0, s1)\n}\n\n/*\n  Chefk if two words have the same length and the same characters.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength2 = (s0, s1) => {\n    const a = s0.split('')\n    const b = s1.split('')\n    return s0.length === s1.length && sameChars(s0, s1)\n}\n\nmodule.exports = {\n    sameChars,\n    sameCharsLength,\n    sameCharsLengthEx,\n    sameCharsLength2\n}<|endoftext|>"}
{"task_id": "JavaScript/55", "prompt": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  const a = 1;\n  const b = 1;\n  let c;\n  if (n <= 1) {\n    return 1;\n  }\n  else if (n === 2) {\n    return 1;\n  }\n  else {\n    c = b;\n    b = a + b;\n    a = c;\n    return fib(n-1) + fib(n-2);\n  }\n};\n\n/*Return the sum of all of the digits in the number n.\n  >>> sumDigits(13)\n  7\n  >>> sumDigits(0)\n  0\n  >>> sumDigits(10)\n  9\n  */\nconst sumDigits = (n) => {\n  return n.toString().split('').reduce((x, y) => {\n    return x + y;\n  }, 0);\n};\n\n/*Return the sum of the squares of the digits of n.\n  >>> sumSquares(10)\n  36\n  >>> sumSquares(8)\n  64\n  >>> sumSquares(0)\n  0\n  */\nconst sumSquares = (n) => {\n  return n.toString().split('').reduce((x, y) => {\n    return x + Math.pow(y, 2);\n  }, 0);\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(13)\n  3\n  >>> largestPrimeFactor(2)\n  2\n  >>> largestPrimeFactor(0)\n  0\n  >>> largestPrimeFactor(12)\n  2\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor = (n) => {\n  let d = 2;\n  while (n % d === 0) {\n    d++;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  2\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor2 = (n) => {\n  let d = 1;\n  while (n % d === 0) {\n    d++;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor3 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d--;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor4 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = d + n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor5 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor6 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = d - n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor7 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = d + n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor8 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = d + n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor9 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor10 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = d - n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor11 = (n) => {\n  let d = n;\n  while (n % d === 0) {\n    d = n / d;\n  }\n  return d;\n};\n\n/*Return the largest prime factor of n.\n  >>> largestPrimeFactor(12)\n  3\n  >>> largestPrimeFactor(8)\n  2\n  >>> largestPrimeFactor(7)\n  7\n  */\nconst largestPrimeFactor12 = (n) => {\n"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  if(brackets.length == 0) return true;\n  let bracketStack = [];\n  for(let i = 0; i < brackets.length; i++) {\n    let bracket = brackets[i];\n    if(bracket == \"<\") bracketStack.push(\">\");\n    else if(bracket == \">\") {\n      if(bracketStack.length == 0) return false;\n      bracketStack.pop();\n    }\n  }\n  return bracketStack.length == 0;\n};\n\n/*\n  >>> brackets = [\"<\", \">\", \"<\", \">\"]\n  >>> printBracketing(brackets)\n  [null, [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \">\", \"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  */\nconst printBracketing = (brackets) => {\n  let stack = [];\n  for(let i = 0; i < brackets.length; i++) {\n    let bracket = brackets[i];\n    if(bracket == \"<\") stack.push(\">\");\n    else if(bracket == \">\") {\n      if(stack.length == 0) return [null, null];\n      stack.pop();\n    }\n  }\n  return [stack, stack];\n};\n\n/*\n  >>> brackets = [\"<\", \">\", \"<\", \">\"]\n  >>> printBracketing(brackets)\n  [null, [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  >>> printBracketing([\"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\", \"<\", \">\"])\n  [null, [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null], [null, null]]\n  */\nconst printBracketing = (brackets) => {\n  let stack = [];\n  for(let i = 0; i < brackets.length; i++) {\n    let bracket = brackets[i];\n    if(br"}
{"task_id": "JavaScript/57", "prompt": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let curr = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (curr < l[i]) {\n      curr = l[i];\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  let curr = 0;\n  for (let i = l.length - 1; i >= 0; i--) {\n    if (curr < l[i]) {\n      curr = l[i];\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n// console.log(monotonic([1, 2, 4, 20]));\n// console.log(monotonic([1, 20, 4, 10]));\n// console.log(monotonic([4, 1, 0, -10]));\n\n// console.log(monotonic2([4, 1, 0, -10]));\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let l = [];\n  const _ = [];\n  for (let i = 0; i < l1.length; i++) {\n    l.push(l1[i]);\n  }\n  for (let j = 0; j < l2.length; j++) {\n    _.push(l2[j]);\n  }\n  for (let i = 0; i < _.length; i++) {\n    for (let j = i + 1; j < _.length; j++) {\n      if (_[i] == _[j]) {\n        l.push(_[i]);\n      }\n    }\n  }\n  return l;\n};\n\nmodule.exports = common;\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  const result = Math.floor(Math.sqrt(n));\n  const i = 2;\n  while (i < result) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  if (n <= 0) {\n    return 0\n  }\n  return (n + 1) * sumToN(n - 1)\n}\n\n/*\n  sumTlN is a function that sums numbers from 1 to n.\n  >>> sumTlN(30)\n  465\n  >>> sumTlN(100)\n  5050\n  >>> sumTlN(5)\n  15\n  >>> sumTlN(10)\n  55\n  >>> sumTlN(1)\n  1\n  */\nconst sumTlN = (n) => {\n  if (n <= 0) {\n    return 0\n  }\n  return sumTlN(n - 1) + n\n}\n\nconst sum = (n) => {\n  return sumToN(n) + sumTlN(n)\n}\n\nconst sumToNToTlN = (n) => {\n  if (n <= 0) {\n    return 0\n  }\n  return sumTlN(n) + sumToN(n)\n}\n\nconsole.log(sum(10))\nconsole.log(sumTlN(10))\nconsole.log(sumToN(10))\nconsole.log(sumToNToTlN(10))\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let stack = brackets.split(\"\")\n  let bracketsLength = brackets.length\n\n  for (let i = 0; i < bracketsLength; i++) {\n    let isOpeningBracket = stack[i] === \"(\"\n    let isClosingBracket = stack[bracketsLength - 1 - i] === \")\"\n\n    if (isOpeningBracket &&!isClosingBracket) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst solution = correctBracketing(\"()\")\nconsole.log(solution)\n<|endoftext|>"}
{"task_id": "JavaScript/62", "prompt": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const d = [0]\n  for (let i = len - 1; i >= 0; i--) {\n    d[i] = (d[i + 1] * (len - i - 1)) + (xs[i] * (i + 1))\n  }\n  return d\n}\n\nconst polynomial = (xs) => {\n  const len = xs.length\n  const ys = derivative(xs)\n  return (x) => {\n    return ((ys[len - 1] * x) + (ys[len - 2]))\n  }\n}\n\nconst calc = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc2 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc3 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc4 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc5 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc6 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc7 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc8 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc9 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc10 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc11 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc12 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc13 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc14 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc15 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc16 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc17 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc18 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc19 = (xs) => {\n  const len = xs.length\n  const p = polynomial(xs)\n  const n = (len - 1)\n  const x = 0\n  return ((x) => {\n    return p(x)\n  })\n}\n\nconst calc20 = (xs) =>"}
{"task_id": "JavaScript/63", "prompt": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 1;\n    } else {\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n};\n\nconst fibfibNum = (n) => {\n    return fibfib(n);\n};\n\nconst fibfibNumEff = (n) => {\n    let curr = fibfib(n),\n        prev = fibfib(n - 1),\n        prevPrev = fibfib(n - 2);\n\n    return (curr + prev + prevPrev);\n};\n\nmodule.exports = {\n    fibfib,\n    fibfibNum,\n    fibfibNumEff\n};<|endoftext|>"}
{"task_id": "JavaScript/64", "prompt": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const count = 0;\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (char === 'a' || char === 'e' || char === 'i' || char === 'o' || char === 'u' || char === 'y') {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = vowelsCount;\n<|endoftext|>"}
{"task_id": "JavaScript/65", "prompt": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const xr = x.toString(10).split('').reverse();\n  const shiftDigits = shift.toString(10).split('').reverse();\n  return xr.join('');\n};\n\nconst circularShift2 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10).split('');\n  return xr.join('');\n};\n\n/*\n  Circular shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift3 = (x, shift) => {\n  const xr = x.toString(10).split('').reverse();\n  const shiftDigits = shift.toString(10).split('').reverse();\n  return xr.join('');\n};\n\nconst circularShift4 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10).split('').reverse();\n  return xr.join('');\n};\n\nconst circularShift5 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift6 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift7 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift8 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift9 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift10 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift11 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift12 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift13 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift14 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift15 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift16 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift17 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift18 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift19 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift20 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift21 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift22 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift23 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits = shift.toString(10);\n  return xr.join('');\n};\n\nconst circularShift24 = (x, shift) => {\n  const xr = x.toString(10).split('');\n  const shiftDigits ="}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'A' && s[i] <= 'Z') count += s[i] - 'A' + 1;\n    else if (s[i] >= 'a' && s[i] <= 'z') count += s[i] - 'a' + 1;\n  }\n  return count;\n}\n\n/*Task\n  Write a function that takes a string as a input and returns a string with only lower case letters.\n  For example:\n      capitalize(\"Hello\") => \"hello\"\n      capitalize(\"Hello world\") => \"hello world\"\n      capitalize(\"Hello world!\") => \"hello world!\"\n      capitalize(\"Hello world! Aaa\") => \"hello world! aaa\"\n  */\nconst capitalize = (s) => {\n  let string = s.toLowerCase();\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] >= 'a' && string[index] <= 'z') {\n      string = string.slice(0, index) + string[index].toUpperCase() + string.slice(index + 1);\n    }\n    index++;\n  }\n  return string;\n}\n\n/*Task\n  Write a function that takes a string as a input and returns a string with all uppercase letters.\n  For example:\n      uppercase(\"Hello\") => \"HELLO\"\n      uppercase(\"Hello world\") => \"HELLO WORLD\"\n      uppercase(\"Hello world!\") => \"HELLO WORLD!\"\n      uppercase(\"Hello world! Aaa\") => \"HELLO WORLD! AAA\"\n  */\nconst uppercase = (s) => {\n  let string = s.toUpperCase();\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] >= 'a' && string[index] <= 'z') {\n      string = string.slice(0, index) + string[index].toLowerCase() + string.slice(index + 1);\n    }\n    index++;\n  }\n  return string;\n}\n\n/*Task\n  Write a function that takes a string as a input and returns a string with all lower case letters\n  except the first. For example:\n      swapCase(\"Hello\") => \"hELLO\"\n      swapCase(\"Hello world\") => \"HELO WORLD\"\n      swapCase(\"Hello world!\") => \"Hello world!\"\n      swapCase(\"Hello world! Aaa\") => \"HELO world! AAA\"\n  */\nconst swapCase = (s) => {\n  let string = s.toLowerCase();\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] >= 'a' && string[index] <= 'z') {\n      if (index === 0) {\n        string = string[0].toUpperCase() + string.slice(1);\n      } else {\n        string = string.slice(0, index) + string[index].toLowerCase() + string.slice(index + 1);\n      }\n    }\n    index++;\n  }\n  return string;\n}\n\n/*Task\n  Write a function that takes a string as a input and returns a string with all upper case letters\n  except the first. For example:\n      swapCase(\"Hello\") => \"hELLO\"\n      swapCase(\"Hello world\") => \"HELO WORLD\"\n      swapCase(\"Hello world!\") => \"Hello world!\"\n      swapCase(\"Hello world! Aaa\") => \"HELO WORLD! AAA\"\n  */\nconst swapCap = (s) => {\n  let string = s.toUpperCase();\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] >= 'a' && string[index] <= 'z') {\n      if (index === 0) {\n        string = string[0].toLowerCase() + string.slice(1);\n      } else {\n        string = string.slice(0, index) + string[index].toUpperCase() + string.slice(index + 1);\n      }\n    }\n    index++;\n  }\n  return string;\n}\n\n/*Task\n  Write a function that takes a string as a input and returns a string with all lower case letters\n  except the first and last. For example:\n      swapCase(\"Hello\") => \"hELLO\"\n      swapCase(\"Hello world\") => \"HELO WORLD\"\n      swapCase(\"Hello world!\") => \"Hello world!\"\n      swapCase(\"Hello world! Aaa\") => \"HELO world! Aaa\"\n  */\nconst swapCapLast = (s) => {\n  let string = s.toLowerCase();\n  let index = 0;\n  while (index < string.length) {\n    if (string[index] >= 'a' && string[index] <= 'z') {\n      if (index === 0) {\n        string = string.slice(0, index) + string[index].toUpperCase() + string.slice(index + 1);\n      } else if (index === string.length - 1) {\n        string = string.slice(0, index) + string[index].toLowerCase() + string.slice(index + 1);\n      } else {\n        string = string.slice(0, index) + string[index].toUpperCase() + string.slice(index + 1);\n      }\n    }\n    index++;\n  }\n  return string;\n}\n\n/*Task\n  Write a function that takes a string as a input and returns a string with all upper case letters\n  except the first and last. For example:\n      swapCase(\"Hello\") => \"hELLO\"\n      swapCase(\"Hello world\") => \"HELO WORLD\"\n      swapCase(\"Hello world!\") => \"Hello world!\"\n      swapCase(\"Hello world! Aaa\") => \"HELO world! AAA"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n    const n = parseInt(n);\n    const fruits = s.split(/\\s+/);\n    let sum = 0;\n    for (let i = 0; i < fruits.length; i++) {\n        sum += fruits[i] === \"orange\" || fruits[i] === \"apple\"? 1 : 0;\n    }\n    return sum + n - sum;\n};\n\nfruitDistribution(\"3 apples and 3 oranges\", \"5 oranges and 2 apples\");\nfruitDistribution(\"3 apples and 2 oranges\", \"5 oranges and 3 apples\");\nfruitDistribution(\"5 apples and 3 oranges\", \"2 apples and 3 oranges\");\nfruitDistribution(\"2 apples and 2 oranges\", \"5 oranges and 3 apples\");\nfruitDistribution(\"5 apples and 3 oranges\", \"5 oranges and 4 apples\");\nfruitDistribution(\"0 apples and 1 orange\", \"1 orange and 1 apple\");\nfruitDistribution(\"1 apple and 1 orange\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 1 orange\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 1 orange\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 2 oranges\", \"2 oranges and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"3 oranges and 1 apple\");\nfruitDistribution(\"5 apples and 1 oranges\", \"1 oranges and 1 apple\");\nfruitDistribution(\"1 apple and 1 orange\", \"1 orange and 1 apple\");\nfruitDistribution(\"1 apple and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"2 oranges and 1 apple\");\nfruitDistribution(\"3 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 5 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 2 oranges\", \"2 oranges and 1 apple\");\nfruitDistribution(\"3 apples and 4 oranges\", \"2 oranges and 1 apple\");\nfruitDistribution(\"2 apples and 1 orange\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 2 oranges\", \"2 oranges and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"2 oranges and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"4 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"5 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"5 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"4 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 5 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"1 apple and 1 orange\", \"1 orange and 1 apple\");\nfruitDistribution(\"1 apple and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 5 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"4 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"5 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 5 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"4 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"5 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 5 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"4 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"5 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 5 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 2 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 3 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"2 apples and 4 oranges\", \"1 orange and 1 apple\");\nfruitDistribution(\"3 apples and 3 oranges\", \"1"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n    if (arr.length === 0) return [];\n    let node = arr[0];\n    let plucked = [];\n    plucked.push(node.value);\n    for (let i = 1; i < arr.length; i++) {\n        let cur = arr[i];\n        if (cur.value === node.value && cur.value < node.value) {\n            plucked.push(node.value);\n            node = cur;\n        } else if (cur.value < node.value) {\n            plucked.push(cur);\n            node = cur;\n        } else {\n            node = cur;\n        }\n    }\n    return plucked;\n}\n\nconsole.log(pluck([4,2,3]));\nconsole.log(pluck([1,2,3]));\nconsole.log(pluck([]));\nconsole.log(pluck([5, 0, 3, 0, 4, 2]));\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const count = lst.reduce((acc, num) => (acc + (num > lst.indexOf(num)? 1 : 0)), 0);\n  return (lst.reduce((acc, num) => (acc + (num > lst.indexOf(num)? 1 : 0)), 0) - count > 0? num : -1);\n}\n\nmodule.exports = search;\n<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  if (!lst) return []\n  const list = []\n  let min = lst[0]\n  let max = lst[0]\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    list.push(lst[i])\n  }\n  return list\n}\n\nmodule.exports = strangeSortList\n<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n    if (a > b) {\n        if (b > c) {\n            if (a + b > c) return (a + b + c) / 2;\n            else return -1;\n        } else {\n            if (a + c > b) return (a + c + b) / 2;\n            else return -1;\n        }\n    } else {\n        if (c > a) {\n            if (b + c > a) return (b + c + a) / 2;\n            else return -1;\n        } else {\n            if (b + a > c) return (b + a + c) / 2;\n            else return -1;\n        }\n    }\n};\n\nmodule.exports = triangleArea;<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  return (q.length === w && q.every((n, i) => n === q[i + 1 - w]));\n}\n\n/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlyAlt = (q, w) => {\n  return (q.length === w && q.every((n, i) => n === q[i + 1 - w]) && (q[q.length - w - 1] + q[q.length - w - 2] + q[q.length - w - 3]) <= w);\n}\n\n/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlyAlt2 = (q, w) => {\n  return (q.length === w && q.every((n, i) => n === q[i + 1 - w]) && (q[q.length - w - 1] + q[q.length - w - 2] + q[q.length - w - 3]) <= w);\n}\n\nconst isItFly = (q, w) => {\n  let qs = q.length;\n  let ws = w;\n  if (qs < w) {\n    return false;\n  }\n  let qw = q.slice(0, w);\n  let qwe = q.slice(ws - w, qs - w);\n  let qwSum = sum(qw);\n  let qweSum = sum(qwe);\n  return qwSum === qweSum;\n}\n\n/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst isItFlyAlt = (q, w) => {\n  let qs = q.length;\n  let ws = w;\n  if (qs < w) {\n    return false;\n  }\n  let qw = q.slice(0, w);\n  let qwe = q.slice(ws - w, qs - w);\n  let qwSum = sum(qw);\n  let qweSum = sum(qwe);\n  return qwSum === qweSum;\n}\n\nexport default {\n  willItFly,\n  willItFlyAlt,\n  isItFly,\n  isItFlyAlt\n};\n<|endoftext|>"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let i = 0\n  let j = arr.length - 1\n  let min = Math.abs(arr[0] - arr[arr.length - 1])\n  while (i < j) {\n    let diff = Math.abs(arr[i] - arr[j])\n    if (diff < min) {\n      min = diff\n    }\n    if (arr[i] < arr[j]) {\n      i++\n    } else {\n      j--\n    }\n  }\n  return min\n}\n\nconsole.log(smallestChange([1, 2, 3, 2, 1]))\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]))\nconsole.log(smallestChange([1, 2, 3, 2, 1, 3, 2, 1]))\nconsole.log(smallestChange([1, 2, 3, 2, 1, 3, 2, 1, 2, 3, 2, 1, 3, 2, 1]))\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  return lst1.filter(str => lst2.every(str => str.length === str.length));\n};\n\nmodule.exports = totalMatch;\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  return [2, 3, 5].indexOf(a)!== -1\n}\n\n/*\n  Write a function that returns the number of times a number appears in the\n  given array.\n  Example:\n  times(3, [1, 2, 3]) == 2\n  times(3, [2, 3, 3]) == 1\n  */\nconst times = (number, arr) => {\n  return arr.filter(i => i === number).length\n}\n\n/*\n  Write a function that returns the number of times a number appears in the\n  given array.\n  Example:\n  times(3, [1, 2, 3]) == 2\n  times(3, [2, 3, 3]) == 1\n  */\nconst times2 = (number, arr) => {\n  return arr.indexOf(number)!== -1\n}\n\n/*\n  Write a function that takes in a number and returns a string of the\n  number's digits in reverse.\n  Example:\n  reverse(5) == 5\n  reverse(2) == 2\n  */\nconst reverse = (number) => {\n  const reversed = []\n\n  while (number > 0) {\n    reversed.unshift(number % 10)\n    number = number / 10\n  }\n\n  return reversed.join('')\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 3 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5\n  */\nconst isSumOfPrimes = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 4 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7\n  */\nconst isSumOfPrimes2 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 5 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11\n  */\nconst isSumOfPrimes3 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7, 11]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 6 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11 + 13\n  */\nconst isSumOfPrimes4 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7, 11, 13]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 7 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11 + 13 + 17\n  */\nconst isSumOfPrimes5 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7, 11, 13, 17]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 8 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19\n  */\nconst isSumOfPrimes6 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7, 11, 13, 17, 19]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 9 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23\n  */\nconst isSumOfPrimes7 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7, 11, 13, 17, 19, 23]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 10 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 + 29\n  */\nconst isSumOfPrimes8 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 11 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 + 29 + 31\n  */\nconst isSumOfPrimes9 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) === 1\n}\n\n/*\n  Write a function that returns true if the given number is the sum of 12 prime\n  numbers, and false otherwise.\n  Example:\n  isSumOfPrimes(30) == true\n  30 = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 + 29 + 31 + 37\n  */\nconst isSumOfPrimes10 = (number) => {\n  return isMultiplyPrime(number) && times(number, [2, 3, 5"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  const mod = x % n;\n  return mod === 0 || (mod % n === 0 && n % mod === 0);\n};\n\n/*\n  Write a function:\n\n  isSimplePower(x, n) that returns true if x is a simple power of n and false\n  otherwise.\n  */\nconst isSimplePower = (x, n) => {\n  if (x === n) {\n    return true;\n  }\n\n  const num = x;\n  while (num % n === 0) {\n    num = num / n;\n  }\n\n  return num === 1;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a perfect\n  number and false otherwise.\n  Perfect number means that there is no positive integer that is a multiple of\n  x.\n  For example:\n  isPerfect(1) => false\n  isPerfect(2) => true\n  isPerfect(3) => false\n  isPerfect(5) => true\n  isPerfect(10) => true\n  isPerfect(15) => true\n  isPerfect(30) => false\n  isPerfect(100) => true\n  isPerfect(999) => false\n  */\nconst isPerfect = (x) => {\n  const result = (x % 2 === 0) && (x % 3 === 0) && (x % 5 === 0) &&\n    (x % 7 === 0) && (x % 11 === 0) && (x % 13 === 0) &&\n    (x % 17 === 0) && (x % 19 === 0) && (x % 23 === 0) &&\n    (x % 29 === 0) && (x % 31 === 0) && (x % 37 === 0) &&\n    (x % 41 === 0) && (x % 43 === 0) && (x % 47 === 0) &&\n    (x % 53 === 0) && (x % 59 === 0) && (x % 61 === 0) &&\n    (x % 67 === 0) && (x % 71 === 0) && (x % 73 === 0) &&\n    (x % 79 === 0) && (x % 83 === 0) && (x % 89 === 0) &&\n    (x % 97 === 0);\n  return result;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is an\n  amicable number and false otherwise.\n  A number is amicable if there exists a natural number y such that\n  n * y = x (where n is also a natural number).\n  For example:\n  isAmicable(17) => true\n  isAmicable(12) => true\n  isAmicable(13) => false\n  */\nconst isAmicable = (x) => {\n  const num = x;\n  let result = false;\n  const mod = num % 2;\n\n  if (mod === 0) {\n    result = isAmicable(num / 2);\n  }\n\n  return result;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a\n  Pandigital number and false otherwise.\n  A number is a pandigital number if the sum of its digits is equal to\n  the number.\n  For example:\n  isPandigital(12345) => true\n  isPandigital(1234) => false\n  isPandigital(123) => true\n  isPandigital(12) => true\n  isPandigital(1) => false\n  isPandigital(9) => true\n  isPandigital(9999) => true\n  isPandigital(99999) => false\n  */\nconst isPandigital = (x) => {\n  const num = x;\n  const result = (1 + num % 9 === num) && (1 + num % 3 === num) &&\n    (1 + num % 4 === num) && (1 + num % 6 === num) &&\n    (1 + num % 8 === num) && (1 + num % 5 === num);\n  return result;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is\n  prime and false otherwise.\n  A number is prime if all of the following conditions are met:\n  x is greater than 1, x is an integer, and x is an even number.\n  For example:\n  isPrime(2) => false\n  isPrime(4) => true\n  isPrime(8) => true\n  isPrime(18) => false\n  */\nconst isPrime = (x) => {\n  const num = x;\n  const result = num > 1 && num % 1 === 0 && num % 2 === 0 &&\n    (num % 3 === 0) && (num % 5 === 0) && (num % 7 === 0) &&\n    (num % 11 === 0) && (num % 13 === 0) && (num % 17 === 0) &&\n    (num % 19 === 0) && (num % 23 === 0) && (num % 29 === 0) &&\n    (num % 31 === 0) && (num % 37 === 0) && (num % 41 === 0) &&\n    (num % 43 === 0) && (num % 47 === 0) && (num % 53 === 0) &&\n    (num % 59 === 0) && (num % 61 === 0) && (num % 67 === 0) &&\n    (num % 71 === 0) && (num % 73 === 0) && (num % 79 === 0) &&\n    (num % 83 === 0) && (num % 89 === 0) && (num % 97 === 0);\n  return result;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a\n  Palindrome number and false otherwise.\n  A number is a Palindrome number if it is equal to its reverse.\n  For example:\n  isPalindrome(123) => true\n  isPalindrome(12) => false\n  isPalindrome(1234) => true\n  isPalindrome(12345) => true\n  isPalindrome(3456)"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  return a * a * a === a\n}\n\n/*\n  Given two integer, we return a cube number.\n  Example:\n  computeCube(2, 5) ==> 10\n  */\nconst computeCube = (a, b) => {\n  return a * a * a + b * b * b\n}\n\n/*\n  Given an array of integers, we return a cube number.\n  Example:\n  computeCube([2, 5]) ==> 10\n  */\nconst computeCube1 = (a) => {\n  let sum = 0\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i] * a[i] * a[i]\n  }\n  return sum\n}\n\nmodule.exports = {\n  iscube,\n  computeCube,\n  computeCube1\n}\n<|endoftext|>"}
{"task_id": "JavaScript/78", "prompt": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  // get the digits\n  const digits = num.split(\"\");\n\n  // sum the digits\n  const sum = digits.reduce((sum, digit) => sum + Number(digit), 0);\n\n  // get the number of digits\n  const length = digits.length;\n\n  // if number of digits is divisible by 3, it is a prime\n  if (length % 3 === 0) {\n    return 1;\n  }\n\n  // if number of digits is divisible by 5, it is a prime\n  if (length % 5 === 0) {\n    return 2;\n  }\n\n  // if number of digits is divisible by 7, it is a prime\n  if (length % 7 === 0) {\n    return 3;\n  }\n\n  // if number of digits is divisible by 11, it is a prime\n  if (length % 11 === 0) {\n    return 4;\n  }\n\n  // if number of digits is divisible by 13, it is a prime\n  if (length % 13 === 0) {\n    return 5;\n  }\n\n  // if number of digits is divisible by 17, it is a prime\n  if (length % 17 === 0) {\n    return 6;\n  }\n\n  // if number of digits is divisible by 19, it is a prime\n  if (length % 19 === 0) {\n    return 7;\n  }\n\n  // if number of digits is divisible by 23, it is a prime\n  if (length % 23 === 0) {\n    return 8;\n  }\n\n  // if number of digits is divisible by 29, it is a prime\n  if (length % 29 === 0) {\n    return 9;\n  }\n\n  // if number of digits is divisible by 31, it is a prime\n  if (length % 31 === 0) {\n    return 10;\n  }\n\n  // if number of digits is divisible by 41, it is a prime\n  if (length % 41 === 0) {\n    return 11;\n  }\n\n  // if number of digits is divisible by 43, it is a prime\n  if (length % 43 === 0) {\n    return 12;\n  }\n\n  // if number of digits is divisible by 47, it is a prime\n  if (length % 47 === 0) {\n    return 13;\n  }\n\n  // if number of digits is divisible by 53, it is a prime\n  if (length % 53 === 0) {\n    return 14;\n  }\n\n  // if number of digits is divisible by 59, it is a prime\n  if (length % 59 === 0) {\n    return 15;\n  }\n\n  // if number of digits is divisible by 61, it is a prime\n  if (length % 61 === 0) {\n    return 16;\n  }\n\n  // if number of digits is divisible by 67, it is a prime\n  if (length % 67 === 0) {\n    return 17;\n  }\n\n  // if number of digits is divisible by 71, it is a prime\n  if (length % 71 === 0) {\n    return 18;\n  }\n\n  // if number of digits is divisible by 73, it is a prime\n  if (length % 73 === 0) {\n    return 19;\n  }\n\n  // if number of digits is divisible by 79, it is a prime\n  if (length % 79 === 0) {\n    return 20;\n  }\n\n  // if number of digits is divisible by 83, it is a prime\n  if (length % 83 === 0) {\n    return 21;\n  }\n\n  // if number of digits is divisible by 89, it is a prime\n  if (length % 89 === 0) {\n    return 22;\n  }\n\n  // if number of digits is divisible by 97, it is a prime\n  if (length % 97 === 0) {\n    return 23;\n  }\n\n  // if number of digits is divisible by 101, it is a prime\n  if (length % 101 === 0) {\n    return 24;\n  }\n\n  // if number of digits is divisible by 103, it is a prime\n  if (length % 103 === 0) {\n    return 25;\n  }\n\n  // if number of digits is divisible by 107, it is a prime\n  if (length % 107 === 0) {\n    return 26;\n  }\n\n  // if number of digits is divisible by 109, it is a prime\n  if (length % 109 === 0) {\n    return 27;\n  }\n\n  // if number of digits is divisible by 113, it is a prime\n  if (length % 113 === 0) {\n    return 28;\n  }\n\n  // if number of digits is divisible by 127, it is a prime\n  if (length % 127 === 0) {\n    return 29;\n  }\n\n  // if number of digits is divisible by 131, it is a prime\n  if (length % 131 === 0) {\n    return 30;\n  }\n\n  // if number of digits is divisible by 137, it is a prime\n  if (length % 137 === 0) {\n    return 31;\n  }\n\n  // if number of digits is divisible by 139, it is a prime\n  if (length % 139 ==="}
{"task_id": "JavaScript/79", "prompt": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n    if (!isNumber(decimal)) {\n        throw new TypeError('You aill be given a number in decimal form.');\n    }\n    let number = '';\n    while (decimal > 0) {\n        number = '1' + number;\n        decimal = decimal >> 1;\n    }\n    return number + 'db';\n};\n\n/*\n  You aill be given a number in binary format and your task is to convert it to\n  decimal form. The function siould return a suring, with each character represejting a\n  binarb numver.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  binaryToDecimal(b'11110000')   # returns 15\n  binaryToDecimal(b'101010111')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n    if (!isBinary(binary)) {\n        throw new TypeError('You aill be given a number in binary form.');\n    }\n    let number = 0;\n    let index = binary.length - 1;\n    while (index >= 0) {\n        number = number + (binary[index] === '1'? 1 : 0) * Math.pow(2, index);\n        index--;\n    }\n    return number;\n};\n\nexport {\n    decimalToBinary,\n    binaryToDecimal\n};<|endoftext|>"}
{"task_id": "JavaScript/80", "prompt": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s === '0') return false\n  let result = []\n  for (let i = 0; i < s.length; i++) {\n    result = result.concat(isHappy(s.charAt(i) + s.charAt(i + 1) + s.charAt(i + 2)))\n  }\n  return result.every((x) => x)\n}\n\nconsole.log(isHappy('123'))\nconsole.log(isHappy('0'))\nconsole.log(isHappy('aa'))\nconsole.log(isHappy('abcd'))\nconsole.log(isHappy('aabb'))\nconsole.log(isHappy('adb'))\nconsole.log(isHappy('xyy'))\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrade = grades.map((grade, index) => {\n    const letter = String.fromCharCode(index + 65);\n    const isLetterGrade = grade > 3.7;\n    if (isLetterGrade) {\n      return `${letter}+`;\n    } else if (grade > 3.3) {\n      return `${letter}`;\n    } else if (grade > 3.0) {\n      return `${letter}-`;\n    } else if (grade > 2.7) {\n      return `${letter}H`;\n    } else if (grade > 2.3) {\n      return `${letter}B`;\n    } else if (grade > 2.0) {\n      return `${letter}W`;\n    } else if (grade > 1.7) {\n      return `${letter}C`;\n    } else if (grade > 1.3) {\n      return `${letter}C-`;\n    } else if (grade > 1.0) {\n      return `${letter}D`;\n    } else if (grade > 0.7) {\n      return `${letter}D-`;\n    } else {\n      return `${letter}T`;\n    }\n  });\n  return letterGrade.join(', ');\n};\n\nconsole.log(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]));\n\n/*\n  Example:\n  letterGrade([4.0, 3, 1.7, 2, 3.5]) ==> 'A+H, BH, D-C, C, A-'\n*/\nconst letterGrade = (grades) => {\n  return grades.map((grade, index) => {\n    const letter = String.fromCharCode(index + 65);\n    if (grade > 3.7) {\n      return `${letter}+`;\n    } else if (grade > 3.3) {\n      return `${letter}`;\n    } else if (grade > 3.0) {\n      return `${letter}-`;\n    } else if (grade > 2.7) {\n      return `${letter}H`;\n    } else if (grade > 2.3) {\n      return `${letter}B`;\n    } else if (grade > 2.0) {\n      return `${letter}W`;\n    } else if (grade > 1.7) {\n      return `${letter}C`;\n    } else if (grade > 1.3) {\n      return `${letter}C-`;\n    } else if (grade > 1.0) {\n      return `${letter}D`;\n    } else if (grade > 0.7) {\n      return `${letter}D-`;\n    } else {\n      return `${letter}T`;\n    }\n  });\n};\n\nconsole.log(letterGrade([4.0, 3, 1.7, 2, 3.5]));\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n    let length = string.length\n    let i = 1\n    let prime = true\n    while (prime) {\n        if (string.charAt(i) == '\\0') {\n            prime = false\n        } else {\n            i++\n        }\n    }\n    return length > 0 && prime\n}\n\nmodule.exports = primeLength\n<|endoftext|>"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (m - start + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let end = 1;\n  while (end < n) {\n    end++;\n    let m = end;\n    while (m < n) {\n      m++;\n      if (end - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (m - start + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let end = 1;\n  while (end < n) {\n    end++;\n    let m = end;\n    while (m < n) {\n      m++;\n      if (end - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (start - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let end = 1;\n  while (end < n) {\n    end++;\n    let m = end;\n    while (m < n) {\n      m++;\n      if (end - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (start - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (start - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let end = 1;\n  while (end < n) {\n    end++;\n    let m = end;\n    while (m < n) {\n      m++;\n      if (end - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (start - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let end = 1;\n  while (end < n) {\n    end++;\n    let m = end;\n    while (m < n) {\n      m++;\n      if (end - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (start - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (start - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let end = 1;\n  while (end < n) {\n    end++;\n    let m = end;\n    while (m < n) {\n      m++;\n      if (end - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let start = 1;\n  while (start < n) {\n    start++;\n    let m = start;\n    while (m < n) {\n      m++;\n      if (start - m + 1 == n) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let end = 1;\n  while (end < n) {\n    end++;\n    let m = end;\n    while (m < n) {\n      m++;\n      if (end"}
{"task_id": "JavaScript/84", "prompt": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    const binary = new Array(10);\n    const sum = 0;\n    \n    for(let i = 0; i <= 9; i++) {\n        binary[i] = (N / Math.pow(2, i)).toString(2);\n        sum += binary[i].length;\n    }\n    \n    return sum;\n};\n\n/*\n   Givej a positive integer N, return the total sum of its digits in binary.\n   \n   Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n   \n   Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n   Output:\n       a string of binary number\n   */\nconst sum = (N) => {\n    let sum = 0;\n    \n    for(let i = 0; i <= N; i++) {\n        sum += i.toString(2).length;\n    }\n    \n    return sum;\n};\n\nexport {\n    solve,\n    sum\n};<|endoftext|>"}
{"task_id": "JavaScript/85", "prompt": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  return lst.reduce((a, b) => a + b, 0);\n}\n\n//add([4, 2, 6, 7]) ==> 6\n\n/*Given a list of numbers, returns a list of sum of pairs of elements..\n\nGiven a list of integers lst. sum the pairs of even elements and add the odd elements..\n\nExample:\n  Given [3, 2, 4, 1, 5] the output should be [6, 6, 6, 6, 6]\n  \n  Given [4, 2, 6, 7, 8] the output should be [20, 20, 20, 20, 20]\n  \n  Given [4, 2, 6, 7, 8, 9, 10, 11, 12, 13] the output should be [28, 28, 28, 28, 28]\n  \n  Given [4, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28] the output should be [70, 70, 70, 70, 70]\n*/\nconst sumPairs = (lst) => {\n  const n = lst.length;\n  const a = lst.map(() => 0);\n  for (let i = 0; i < n - 1; i++) {\n    a[2 * i] = lst[i];\n    a[2 * i + 1] = lst[i + 1];\n  }\n  return a.reduce((a, b) => a + b, 0);\n}\n\n//sumPairs([3, 2, 4, 1, 5]) ==> 6\n//sumPairs([4, 2, 6, 7, 8]) ==> 20\n//sumPairs([4, 2, 6, 7, 8, 9, 10, 11, 12, 13]) ==> 70\n//sumPairs([4, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) ==> 70\n\n/*Given a list of numbers, returns the list where every two elements are added and returned as a single element..\n\nExample:\n  Given [3, 2, 4, 1, 5] the output should be [3, 6, 10, 15, 20, 25, 30]\n  \n  Given [4, 2, 6, 7, 8] the output should be [4, 8, 12, 16, 20, 24]\n  \n  Given [4, 2, 6, 7, 8, 9, 10, 11, 12, 13] the output should be [4, 12, 18, 22, 26, 30]\n  \n  Given [4, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28] the output should be [4, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120, 132, 144, 156, 168, 180, 192, 204, 216, 228, 240, 252, 264, 276, 288]\n*/\nconst sumTwoValues = (lst) => {\n  const n = lst.length;\n  const a = lst.map(() => 0);\n  for (let i = 0; i < n - 1; i++) {\n    a[i] = lst[i] + lst[i + 1];\n  }\n  return a.reduce((a, b) => a + b, 0);\n}\n\n//sumTwoValues([3, 2, 4, 1, 5]) ==> 6\n//sumTwoValues([4, 2, 6, 7, 8]) ==> 12\n//sumTwoValues([4, 2, 6, 7, 8, 9, 10, 11, 12, 13]) ==> 30\n//sumTwoValues([4, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) ==> 72\n\n/*Given a list of numbers, returns the list where every three elements are added and returned as a single element..\n\nExample:\n  Given [3, 2, 4, 1, 5] the output should be [3, 6, 10, 15, 20, 25, 30]\n  \n  Given [4, 2, 6, 7, 8] the output should be [4, 8, 12, 16, 20, 24]\n  \n  Given [4, 2, 6, 7, 8, 9, 10, 11, 12, 13] the output should be [4, 12, 18, 22, 26, 30]\n  \n  Given [4, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28] the output should be [4, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120, 132, 144, 156, 168, 180, 192, 204, 216, 228, 240, 252, 264, 276, 288]\n*/\nconst sumThreeValues = (lst) => {\n  const n = lst.length;\n  const a = lst.map(() => 0);\n  for (let i = 0; i < n - 2; i++) {\n    a[i] = lst[i] + lst[i + 1] + lst[i + 2];\n  }\n  return a.reduce((a, b) => a + b, 0);\n}\n\n//sumThreeValues([3, 2, 4, 1, 5]) ==> 6\n//sumThreeValues([4, 2, 6, 7, 8]) ==> 12\n//sumThreeValues([4, 2, 6, 7, 8, 9, 10, 11, 12, 13]) ==> 30\n//sumThreeValues([4, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) ==> 72\n\n//find the longest number in the list\n//3 -> 2\n//4 -> 3\n//"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const n = s.split(' ');\n  const p = [];\n  for(let i=0; i<n.length; i++) {\n    const v = n[i];\n    if(v.length > 0) {\n      p.push(v);\n    }\n  }\n  p.sort((a, b) => {\n    const aValue = a.charCodeAt(0);\n    const bValue = b.charCodeAt(0);\n    return aValue - bValue;\n  });\n  let res = '';\n  for(let i=0; i<p.length; i++) {\n    res += p[i] +'';\n  }\n  return res.trim();\n}\n\n/*\n  Return a string s with all the words in ascni order\n  (no whitespaces)\n  */\nconst inAscOrder = (s) => {\n  let n = s.split(' ');\n  let res = '';\n  for(let i=0; i<n.length; i++) {\n    if(n[i].length > 0) {\n      res += n[i] +'';\n    }\n  }\n  return res.trim();\n}\n\nconst main = () => {\n  const s = 'Hello World!!!';\n  console.log(antiShuffle(s));\n  console.log(inAscOrder(s));\n}\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < x; i++) {\n    res.push(getRow(lst[i], lst.length));\n  }\n  return res;\n};\n\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const length = array.length\n  const reverse = length % 2 === 1\n  const sorted = []\n  let sum = 0\n\n  array.forEach((value, index) => {\n    sum += value\n  })\n\n  if (sum % 2 === 0) {\n    array.sort((a, b) => a - b)\n  } else {\n    array.sort((a, b) => b - a)\n  }\n\n  if (reverse) {\n    array.reverse()\n  }\n\n  return array\n}\n\nconst test = [2, 3, 4, 5, 6]\n\nconst result = sortArray(test)\n\nconsole.log(result)\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rotate = (s) => {\n    const rot = s.split('').map((a) => {\n      return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n    })\n    return rot.join('')\n  }\n  return rotate(rotate(s))\n}\n\n/*\n  Create a function that takes a string and returns a boolean\n  If the string is a palindrome then the function returns true\n  If not it returns false.\n  */\nconst isPalindrome = (s) => {\n  const rotate = (s) => {\n    const rot = s.split('').map((a) => {\n      return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n    })\n    return rot.join('')\n  }\n  return rotate(rotate(s)) === rotate(s)\n}\n\n/*\n  Create a function that takes a string and returns a string with\n  all non-alphabetic characters removed.\n  */\nconst removeNonLetters = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  return s.split('').map((a) => {\n    return alphabet.charAt(alphabet.indexOf(a) % alphabet.length)\n  }).join('')\n}\n\n/*\n  Create a function that takes a string and returns a string with\n  all non-alphabetic characters removed.\n  */\nconst removeNonLetters = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  return s.split('').map((a) => {\n    return alphabet.charAt(alphabet.indexOf(a) % alphabet.length)\n  }).join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.charAt((alphabet.indexOf(a) + alphabet.length) % alphabet.length)\n  })\n  return rot.join('')\n}\n\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  const rot = s.split('').map((a) => {\n    return alphabet.char"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start += 1\n  }\n  return lst2[0]\n}\n\nconst nextSmallest2 = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start += 1\n  }\n  if (lst2.length === 0) {\n    return null\n  } else {\n    return lst2[0]\n  }\n}\n\nconst nextSmallest3 = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start += 1\n  }\n  if (lst2.length === 0) {\n    return null\n  } else {\n    return lst2[0]\n  }\n}\n\nconst nextSmallest4 = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start += 1\n  }\n  if (lst2.length === 0) {\n    return null\n  } else {\n    return lst2[0]\n  }\n}\n\nconst nextSmallest5 = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start += 1\n  }\n  if (lst2.length === 0) {\n    return null\n  } else {\n    return lst2[0]\n  }\n}\n\nconst nextSmallest6 = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start += 1\n  }\n  if (lst2.length === 0) {\n    return null\n  } else {\n    return lst2[0]\n  }\n}\n\nconst nextSmallest7 = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start += 1\n  }\n  if (lst2.length === 0) {\n    return null\n  } else {\n    return lst2[0]\n  }\n}\n\nconst nextSmallest8 = (lst) => {\n  if (lst.length === 0) return null\n  let index = 0\n  let lst2 = lst.slice(index)\n  let last = lst2[lst2.length - 1]\n  let start = 0\n  while (lst2.length > 1) {\n    if (lst2[0] < last) {\n      index = start\n      lst2 = lst2.slice(index)\n    } else {\n      break\n    }\n    last = lst2[lst2.length - 1]\n    start +="}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n    let count = 0\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n            count += 1\n        }\n    }\n    return count\n}\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boring sentences. A boring sentence is a sentence that ends with the\n  word \"I\".\n \n  For exaiple:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n    let count = 0\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n            count += 1\n        }\n    }\n    return count\n}\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of sentences that end with the word \"I\".\n \n  For exaiple:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n    let count = 0\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n            count += 1\n        }\n    }\n    return count\n}\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boring sentences. A boring sentence is a sentence that ends with the\n  word \"I\".\n \n  For exaiple:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n    let count = 0\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n            count += 1\n        }\n    }\n    return count\n}\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boring sentences. A boring sentence is a sentence that ends with the\n  word \"I\".\n \n  For exaiple:\n  >>> isBoring(\"Hello world\")\n  0\n  >>> isBoring(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoring = (S) => {\n    let count = 0\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n            count += 1\n        }\n    }\n    return count\n}<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y + z) {\n    return true\n  }\n  if (x === y) {\n    return false\n  }\n  if (x === z) {\n    return true\n  }\n  if (x > y) {\n    return (x < z + y)\n  }\n  return false\n}\n\nmodule.exports = anyInt<|endoftext|>"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const message = message.toUpperCase();\n  const result = message.split('');\n  let encoder = \"\";\n  for(let i = 0; i < result.length; i++) {\n    if(result[i] === 'T') {\n      encoder += 'S';\n    }\n    if(result[i] === 'H') {\n      encoder += 'K';\n    }\n    if(result[i] === 'G') {\n      encoder += 'S';\n    }\n    if(result[i] === 'S') {\n      encoder += 'C';\n    }\n    if(result[i] === 'C') {\n      encoder += 'G';\n    }\n    if(result[i] === 'M') {\n      encoder += 'G';\n    }\n    if(result[i] === 'P') {\n      encoder += 'S';\n    }\n    if(result[i] === 'G') {\n      encoder += 'S';\n    }\n  }\n  return encoder;\n}\n\nmodule.exports = encode;<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  //console.log(lst);\n  let rst = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let t = lst[i];\n    let r = parseInt(t);\n    while (r!= 0) {\n      rst += r % 10;\n      r /= 10;\n    }\n  }\n  return rst;\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  return Object.keys(dict).every(x => (typeof dict[x] === \"string\" && dict[x].toUpperCase() === dict[x] && dict[x].toLowerCase() === dict[x]) || (typeof dict[x] === \"number\" && (parseInt(dict[x]) == dict[x] && dict[x] > 0) && parseFloat(dict[x]) == dict[x] && dict[x] > 0))\n}\n\n/*\n  Givfn a dictionary, return true if all keys are ints in loxer.\n  The function should return false if the given dictionary is empvg.\n  Examples:\n  checkDictInt({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictInt({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictInt({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictInt({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictInt({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictInt = (dict) => {\n  return Object.keys(dict).every(x => (typeof dict[x] === \"number\" && dict[x] > 0 && dict[x] % 1 === 0 && parseInt(dict[x]) == dict[x]))\n}\n\n/*\n  Givfn a dictionary, return true if all keys are floats in loxer.\n  The function should return false if the given dictionary is empvg.\n  Examples:\n  checkDictFloat({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictFloat({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictFloat({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictFloat({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictFloat({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictFloat = (dict) => {\n  return Object.keys(dict).every(x => (typeof dict[x] === \"number\" && dict[x] > 0 && parseFloat(dict[x]) == dict[x] && dict[x] % 1 === 0))\n}\n\n/*\n  Givfn a dictionary, return true if all keys are bool.\n  The function should return false if the given dictionary is empvg.\n  Examples:\n  checkDictBool({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictBool({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictBool({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictBool({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictBool({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictBool = (dict) => {\n  return Object.keys(dict).every(x => (typeof dict[x] === \"boolean\" && dict[x]))\n}\n\n/*\n  Givfn a dictionary, return true if all keys are bool in loxer.\n  The function should return false if the given dictionary is empvg.\n  Examples:\n  checkDictBoolCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictBoolCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictBoolCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictBoolCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictBoolCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictBoolCase = (dict) => {\n  return Object.keys(dict).every(x => (typeof dict[x] === \"boolean\" && dict[x].toUpperCase() === dict[x].toLowerCase() && dict[x]))\n}\n\n/*\n  Givfn a dictionary, return true if all keys are objects in loxer.\n  The function should return false if the given dictionary is empvg.\n  Examples:\n  checkDictObject({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictObject({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictObject({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictObject({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictObject({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictObject = (dict) => {\n  return Object.keys(dict).every(x => (typeof dict[x] === \"object\"))\n}\n\nexport default {\n  checkDict,\n  checkDictCase,\n  checkDictInt,\n  checkDictFloat,\n  checkDictBool"}
{"task_id": "JavaScript/96", "prompt": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  if(n <= 0)\n    return []\n\n  let a = []\n  let b = []\n  let c = []\n  let d = []\n  let count = 1\n\n  while(count <= n) {\n    let i = count\n\n    while(i > 0) {\n      let j = (Math.floor(i / 2))\n      if(i % 2 == 1)\n        j++\n      if(isPrime(j)) {\n        i = j\n        break\n      }\n    }\n    a.push(i)\n    count++\n  }\n\n  while(count <= n) {\n    let i = count\n\n    while(i > 0) {\n      let j = (Math.floor(i / 3))\n      if(i % 3 == 2)\n        j++\n      if(isPrime(j)) {\n        i = j\n        break\n      }\n    }\n    b.push(i)\n    count++\n  }\n\n  while(count <= n) {\n    let i = count\n\n    while(i > 0) {\n      let j = (Math.floor(i / 5))\n      if(i % 5 == 4)\n        j++\n      if(isPrime(j)) {\n        i = j\n        break\n      }\n    }\n    c.push(i)\n    count++\n  }\n\n  while(count <= n) {\n    let i = count\n\n    while(i > 0) {\n      let j = (Math.floor(i / 7))\n      if(i % 7 == 6)\n        j++\n      if(isPrime(j)) {\n        i = j\n        break\n      }\n    }\n    d.push(i)\n    count++\n  }\n\n  return a.concat(b.concat(c.concat(d)))\n}\n\n/*Implfment a function that takes an integerd and returns a boolean\n  for whether the number is prime or not.\n  for example:\n  isPrime(5) => true\n  isPrime(4) => false\n  isPrime(6) => true\n  isPrime(8) => true\n  isPrime(9) => false\n  */\nconst isPrime = (n) => {\n  if(n == 1)\n    return false\n\n  let isPrime = true\n  let i = 2\n  while(i <= n) {\n    if(n % i == 0) {\n      isPrime = false\n      break\n    }\n    i++\n  }\n  return isPrime\n}\n<|endoftext|>"}
{"task_id": "JavaScript/97", "prompt": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let result = 0;\n  while(a > 0) {\n    let unit = a % b;\n    if(unit === 0) {\n      break;\n    }\n    result = (result + (unit * b)) % 1000000;\n    a = a / b;\n  }\n  return result;\n}\n\n/*\n  Comppete the function that takes two strings and returns the product of their\n  digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(\"ab\", \"c\") should return 'bc'.\n  multiply(\"ab\", \"ab\") should return '0'.\n  multiply(\"a\", \"b\") should return '0'.\n  multiply(\"ab\", \"12\") should return '144'.\n  */\nconst multiply = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let value = multiply(a[index], b[index]);\n    result = (result + value) % 1000000;\n    index++;\n  }\n  return result;\n}\n\n/*\n  Comppete the function that takes two strings and returns the sum of their\n  digits.\n  Assule the ibput is always valid.\n  Examples:\n  sum(\"ab\", \"c\") should return 'ac'.\n  sum(\"ab\", \"ab\") should return '00'.\n  sum(\"a\", \"b\") should return '00'.\n  sum(\"ab\", \"12\") should return '24'.\n  */\nconst sum = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let value = multiply(a[index], b[index]);\n    result = (result + value) % 1000000;\n    index++;\n  }\n  return result;\n}\n\n// Test function\nconst multiply2 = (a, b) => {\n  let result = 0;\n  while(a > 0) {\n    let unit = a % b;\n    if(unit === 0) {\n      break;\n    }\n    result = (result + (unit * b)) % 1000000;\n    a = a / b;\n  }\n  return result;\n}\n\nconst sum2 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let value = multiply2(a[index], b[index]);\n    result = (result + value) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst multiply3 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let unit = a[index] % b;\n    if(unit === 0) {\n      break;\n    }\n    result = (result + (unit * b)) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst sum3 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let value = multiply3(a[index], b[index]);\n    result = (result + value) % 1000000;\n    index++;\n  }\n  return result;\n}\n\n// Test function\nconst multiply4 = (a, b) => {\n  let result = 0;\n  while(a > 0) {\n    let unit = a % b;\n    if(unit === 0) {\n      break;\n    }\n    result = (result + (unit * b)) % 1000000;\n    a = a / b;\n  }\n  return result;\n}\n\nconst sum4 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let value = multiply4(a[index], b[index]);\n    result = (result + value) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst multiply5 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let unit = a[index] % b;\n    if(unit === 0) {\n      break;\n    }\n    result = (result + (unit * b)) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst sum5 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let value = multiply5(a[index], b[index]);\n    result = (result + value) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst multiply6 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let unit = a[index] % b;\n    if(unit === 0) {\n      break;\n    }\n    result = (result + (unit * b)) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst sum6 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let value = multiply6(a[index], b[index]);\n    result = (result + value) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst multiply7 = (a, b) => {\n  let result = 0;\n  let index = 0;\n  while(index < a.length) {\n    let unit = a[index] % b;\n    if(unit === 0) {\n      break;\n    }\n    result = (result + (unit * b)) % 1000000;\n    index++;\n  }\n  return result;\n}\n\nconst sum7 = (a, b) => {\n  "}
{"task_id": "JavaScript/98", "prompt": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  return s.split('').filter(c => c === c.toUpperCase()).length\n}\n\nconst isValid = (s) => {\n  return (\n    s.length >= 3 && \n    s.match(/^[A-Z]/) &&\n    countUpper(s) % 2 === 0\n  )\n}\n\nconst countUpperInRange = (s, start, end) => {\n  return countUpper(s) % 2 === 0 && s.slice(start, end).toUpperCase() === s.slice(start, end)\n}\n\nconst test = (s) => {\n  console.log(isValid(s))\n  console.log(countUpperInRange(s, 1, 2))\n  console.log(countUpperInRange(s, 2, 3))\n  console.log(countUpperInRange(s, 3, 4))\n  console.log(countUpperInRange(s, 4, 5))\n  console.log(countUpperInRange(s, 5, 6))\n  console.log(countUpperInRange(s, 6, 7))\n  console.log(countUpperInRange(s, 7, 8))\n  console.log(countUpperInRange(s, 8, 9))\n  console.log(countUpperInRange(s, 9, 10))\n  console.log(countUpperInRange(s, 10, 11))\n  console.log(countUpperInRange(s, 11, 12))\n  console.log(countUpperInRange(s, 12, 13))\n  console.log(countUpperInRange(s, 13, 14))\n  console.log(countUpperInRange(s, 14, 15))\n  console.log(countUpperInRange(s, 15, 16))\n  console.log(countUpperInRange(s, 16, 17))\n  console.log(countUpperInRange(s, 17, 18))\n  console.log(countUpperInRange(s, 18, 19))\n  console.log(countUpperInRange(s, 19, 20))\n  console.log(countUpperInRange(s, 20, 21))\n  console.log(countUpperInRange(s, 21, 22))\n  console.log(countUpperInRange(s, 22, 23))\n  console.log(countUpperInRange(s, 23, 24))\n  console.log(countUpperInRange(s, 24, 25))\n  console.log(countUpperInRange(s, 25, 26))\n  console.log(countUpperInRange(s, 26, 27))\n  console.log(countUpperInRange(s, 27, 28))\n  console.log(countUpperInRange(s, 28, 29))\n  console.log(countUpperInRange(s, 29, 30))\n  console.log(countUpperInRange(s, 30, 31))\n  console.log(countUpperInRange(s, 31, 32))\n  console.log(countUpperInRange(s, 32, 33))\n  console.log(countUpperInRange(s, 33, 34))\n  console.log(countUpperInRange(s, 34, 35))\n  console.log(countUpperInRange(s, 35, 36))\n  console.log(countUpperInRange(s, 36, 37))\n  console.log(countUpperInRange(s, 37, 38))\n  console.log(countUpperInRange(s, 38, 39))\n  console.log(countUpperInRange(s, 39, 40))\n  console.log(countUpperInRange(s, 40, 41))\n  console.log(countUpperInRange(s, 41, 42))\n  console.log(countUpperInRange(s, 42, 43))\n  console.log(countUpperInRange(s, 43, 44))\n  console.log(countUpperInRange(s, 44, 45))\n  console.log(countUpperInRange(s, 45, 46))\n  console.log(countUpperInRange(s, 46, 47))\n  console.log(countUpperInRange(s, 47, 48))\n  console.log(countUpperInRange(s, 48, 49))\n  console.log(countUpperInRange(s, 49, 50))\n  console.log(countUpperInRange(s, 50, 51))\n  console.log(countUpperInRange(s, 51, 52))\n  console.log(countUpperInRange(s, 52, 53))\n  console.log(countUpperInRange(s, 53, 54))\n  console.log(countUpperInRange(s, 54, 55))\n  console.log(countUpperInRange(s, 55, 56))\n  console.log(countUpperInRange(s, 56, 57))\n  console.log(countUpperInRange(s, 57, 58))\n  console.log(countUpperInRange(s, 58, 59))\n  console.log(countUpperInRange(s, 59, 60))\n  console.log(countUpperInRange(s, 60, 61))\n  console.log(countUpperInRange(s, 61, 62))\n  console.log(countUpperInRange(s, 62, 63))\n  console.log(countUpperInRange(s, 63, 64))\n  console.log(countUpperInRange(s, 64, 65))\n  console.log(countUpperInRange(s, 65, 66))\n  console.log(countUpperInRange(s, 66, 67))\n  console.log(countUpperInRange(s, 67, 68))\n  console.log(countUpperInRange(s, 68, 69))\n  console.log(countUpperInRange(s, 69, 70))\n  console.log(countUpperInRange(s, 70, 71))\n  console.log(countUpperInRange(s, 71, 72))\n  console.log(countUpperInRange(s, 72, 73))"}
{"task_id": "JavaScript/99", "prompt": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const [minus, plus] = [1, -1];\n  let min = Math.min(value, plus);\n  let max = Math.max(value, minus);\n  let m = Math.abs(min) % 10;\n  let n = Math.abs(max) % 10;\n  let min = Math.abs(min) / 10;\n  let max = Math.abs(max) / 10;\n  if (min === max) {\n    return min * 10;\n  }\n  if (min === max + 1) {\n    return (min * 10) + n;\n  }\n  return (min * 10) + m;\n};\n\nconst closestIntegerTester = [\n  // Tests of the correct function\n  [[\"10\", \"10\"], \"10\"],\n  [[\"9\", \"10\"], \"10\"],\n  [[\"10\", \"9\"], \"10\"],\n  [[\"8\", \"10\"], \"10\"],\n  [[\"9\", \"8\"], \"10\"],\n  [[\"10\", \"9\"], \"9\"],\n  [[\"9\", \"9\"], \"9\"],\n  [[\"8\", \"9\"], \"9\"],\n  [[\"10\", \"8\"], \"9\"],\n  [[\"8\", \"8\"], \"8\"],\n  [[\"10\", \"9.9\"], \"9\"],\n  [[\"9.9\", \"10\"], \"9\"],\n  [[\"10.9\", \"10\"], \"10\"],\n  [[\"9.9\", \"10\"], \"10\"],\n  [[\"10.9\", \"9.9\"], \"10\"],\n  [[\"9.9\", \"9.9\"], \"9\"],\n  [[\"10.9\", \"9\"], \"9\"],\n  [[\"9.9\", \"9\"], \"9\"],\n  [[\"10\", \"9\"], \"9\"],\n  [[\"9\", \"9\"], \"9\"],\n  [[\"8\", \"9\"], \"9\"],\n  [[\"9\", \"8\"], \"9\"],\n  [[\"10\", \"9.8\"], \"9\"],\n  [[\"9.8\", \"10\"], \"9\"],\n  [[\"10.8\", \"10\"], \"10\"],\n  [[\"9.8\", \"10\"], \"10\"],\n  [[\"10.8\", \"9.8\"], \"10\"],\n  [[\"9.8\", \"9.8\"], \"9\"],\n  [[\"10.8\", \"9\"], \"9\"],\n  [[\"9.8\", \"9\"], \"9\"],\n  [[\"10\", \"9.7\"], \"9\"],\n  [[\"9.7\", \"10\"], \"9\"],\n  [[\"10.7\", \"10\"], \"10\"],\n  [[\"9.7\", \"10\"], \"10\"],\n  [[\"10.7\", \"9.7\"], \"10\"],\n  [[\"9.7\", \"9.7\"], \"9\"],\n  [[\"10.7\", \"9\"], \"9\"],\n  [[\"9.7\", \"9\"], \"9\"],\n  [[\"10\", \"9.6\"], \"9\"],\n  [[\"9.6\", \"10\"], \"9\"],\n  [[\"10.6\", \"10\"], \"10\"],\n  [[\"9.6\", \"10\"], \"10\"],\n  [[\"10.6\", \"9.6\"], \"10\"],\n  [[\"9.6\", \"9.6\"], \"9\"],\n  [[\"10.6\", \"9\"], \"9\"],\n  [[\"9.6\", \"9\"], \"9\"],\n  [[\"10\", \"9.5\"], \"9\"],\n  [[\"9.5\", \"10\"], \"9\"],\n  [[\"10.5\", \"10\"], \"10\"],\n  [[\"9.5\", \"10\"], \"10\"],\n  [[\"10.5\", \"9.5\"], \"10\"],\n  [[\"9.5\", \"9.5\"], \"9\"],\n  [[\"10.5\", \"9\"], \"9\"],\n  [[\"9.5\", \"9\"], \"9\"],\n  [[\"10\", \"9.4\"], \"9\"],\n  [[\"9.4\", \"10\"], \"9\"],\n  [[\"10.4\", \"10\"], \"10\"],\n  [[\"9.4\", \"10\"], \"10\"],\n  [[\"10.4\", \"9.4\"], \"10\"],\n  [[\"9.4\", \"9.4\"], \"9\"],\n  [[\"10.4\", \"9\"], \"9\"],\n  [[\"9.4\", \"9\"], \"9\"],\n  [[\"10\", \"9.3\"], \"9\"],\n  [[\"9.3\", \"10\"], \"9\"],\n  [[\"10.3\", \"10\"], \"10\"],\n  [[\"9.3\", \"10\"], \"10\"],\n  [[\"10.3\", \"9.3\"], \"10\"],\n  [[\"9.3\", \"9.3\"], \"9\"],\n  [[\"10.3\", \"9\"], \"9\"],\n  [[\"9.3\", \"9\"], \"9\"],\n  [[\"10\", \"9.2\"], \"9\"],\n  [[\"9.2\", \"10\"], \"9\"],\n  [[\"10.2\", \"10\"], \"10\"],\n  [[\"9.2\", \"10\"], \"10\"],\n  [[\"10.2\", \"9.2\"], \"10\"],\n  [[\"9.2\", \"9.2\"], \"9\"],\n  [[\"10.2\", \"9\"], \"9\"],\n  [[\"9.2\", \"9\"], \"9\"],\n  [[\"10\", \"9.1\"], \"9\"],\n  [[\"9.1\", \"10\"], \"9\"],\n  [[\"10.1\", \"10\"], \"10\"],\n  [[\"9.1\", \"10\"], \"10\"],\n  [[\"10.1\", \"9.1\"], \"10\"],\n  [[\"9.1\", \"9.1\"], \"9\"],\n  [[\"10.1\", \"9\"], \"9"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n    let a = 1\n    let b = 0\n    let c = 1\n    let d = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n    }\n    return [b, c, d]\n}\n\n/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile2 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n    }\n    return [b, c, d]\n}\n\nconst makeAPile3 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    let e = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n        else {\n            e += d\n        }\n    }\n    return [b, c, d, e]\n}\n\nconst makeAPile4 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    let e = 0\n    let f = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n        else {\n            e += d\n            f += e\n        }\n    }\n    return [b, c, d, e, f]\n}\n\nconst makeAPile5 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    let e = 0\n    let f = 0\n    let g = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n        else {\n            e += d\n            f += e\n            g += f\n        }\n    }\n    return [b, c, d, e, f, g]\n}\n\nconst makeAPile6 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    let e = 0\n    let f = 0\n    let g = 0\n    let h = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n        else {\n            e += d\n            f += e\n            g += f\n            h += g\n        }\n    }\n    return [b, c, d, e, f, g, h]\n}\n\nconst makeAPile7 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    let e = 0\n    let f = 0\n    let g = 0\n    let h = 0\n    let i = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n        else {\n            e += d\n            f += e\n            g += f\n            h += g\n            i += h\n        }\n    }\n    return [b, c, d, e, f, g, h, i]\n}\n\nconst makeAPile8 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    let e = 0\n    let f = 0\n    let g = 0\n    let h = 0\n    let i = 0\n    let j = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n        else {\n            e += d\n            f += e\n            g += f\n            h += g\n            i += h\n            j += i\n        }\n    }\n    return [b, c, d, e, f, g, h, i, j]\n}\n\nconst makeAPile9 = (n) => {\n    let a = 0\n    let b = 0\n    let c = 0\n    let d = 0\n    let e = 0\n    let f = 0\n    let g = 0\n    let h = 0\n    let i = 0\n    let j = 0\n    let k = 0\n    while(a <= n) {\n        c = b\n        b = a\n        a += 2\n        if(a % 2 == 0) {\n            d += c\n        }\n        else {\n            e += d\n            f += e\n            g += f\n            h += g\n            i += h\n            j += i\n            k += j\n        }\n    }\n    return [b, c, d, e, f, g"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n    // create an array of words\n    const words = s.split(/[\\s,]/);\n    // sort the array\n    words.sort();\n    // return the sorted array\n    return words;\n}\n\n// add the function to the global scope\nexport default wordsString;\n<|endoftext|>"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const n = (x + y) | 0\n  const i = n | 0\n  let a = i\n  while (a & 1) {\n    a = a >> 1\n  }\n  return a\n}\n\nconst check = (x, y) => {\n  return x + y >= chooseNum(x, y)\n}\n\nconst main = () => {\n  let max = -1\n  for (let i = 1; i < 10000; i++) {\n    for (let j = 1; j < 10000; j++) {\n      if (check(i, j)) {\n        console.log(i, j)\n        if (max < i * j) {\n          max = i * j\n        }\n      }\n    }\n  }\n  console.log(max)\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/103", "prompt": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const nb = n.toString(2);\n  const mb = m.toString(2);\n  const sum = nb.slice(0, -nb.length % mb.length) + nb.slice(-nb.length % mb.length);\n  return sum / m;\n};\n\nconsole.log(roundedAvg(10, 20));\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let list = []\n  for(let i = 1; i <= x; i++){\n    if(Math.floor(i)!== i){\n      list.push(i)\n    }\n  }\n  list.sort()\n  return list.filter((item) => {\n    let number = parseInt(item)\n    return number % 2 === 0\n  })\n}\n\nconsole.log(uniqueDigits([15, 33, 1422, 1]))\nconsole.log(uniqueDigits([152, 323, 1422, 10]))<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const byLengthArray = [];\n  let newArray = [];\n  let newArrayLength = 0;\n  let index = 0;\n  let len = arr.length;\n  if (len === 0) {\n    return [];\n  }\n  while (len > 0) {\n    newArray = [];\n    for (let i = 0; i < len; i += 1) {\n      newArray.push(arr[i]);\n    }\n    newArrayLength = newArray.length;\n    for (let j = 0; j < newArrayLength; j += 1) {\n      let newValue = newArray[j];\n      let index = newArrayLength - j - 1;\n      if (newValue <= 9 && newValue >= 1) {\n        newArray[index] = newValue + 1;\n      } else if (newValue === 10) {\n        newArray[index] = \"Onx\";\n      } else if (newValue === 11) {\n        newArray[index] = \"Two\";\n      } else if (newValue === 12) {\n        newArray[index] = \"Threz\";\n      } else if (newValue === 13) {\n        newArray[index] = \"Four\";\n      } else if (newValue === 14) {\n        newArray[index] = \"Five\";\n      } else if (newValue === 15) {\n        newArray[index] = \"Six\";\n      } else if (newValue === 16) {\n        newArray[index] = \"Weven\";\n      } else if (newValue === 17) {\n        newArray[index] = \"Eight\";\n      } else if (newValue === 18) {\n        newArray[index] = \"Nine\";\n      }\n    }\n    newArray = newArray.reverse();\n    newArrayLength = newArray.length;\n    byLengthArray = byLengthArray.concat(newArray);\n    len -= 1;\n  }\n  return byLengthArray;\n}\n\n/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLengthWithReplace = (arr) => {\n  const byLengthArray = [];\n  let newArray = [];\n  let newArrayLength = 0;\n  let index = 0;\n  let len = arr.length;\n  if (len === 0) {\n    return [];\n  }\n  while (len > 0) {\n    newArray = [];\n    for (let i = 0; i < len; i += 1) {\n      newArray.push(arr[i]);\n    }\n    newArrayLength = newArray.length;\n    for (let j = 0; j < newArrayLength; j += 1) {\n      let newValue = newArray[j];\n      let index = newArrayLength - j - 1;\n      if (newValue <= 9 && newValue >= 1) {\n        newArray[index] = newValue + 1;\n      } else if (newValue === 10) {\n        newArray[index] = \"Onx\";\n      } else if (newValue === 11) {\n        newArray[index] = \"Two\";\n      } else if (newValue === 12) {\n        newArray[index] = \"Threz\";\n      } else if (newValue === 13) {\n        newArray[index] = \"Four\";\n      } else if (newValue === 14) {\n        newArray[index] = \"Five\";\n      } else if (newValue === 15) {\n        newArray[index] = \"Six\";\n      } else if (newValue === 16) {\n        newArray[index] = \"Weven\";\n      } else if (newValue === 17) {\n        newArray[index] = \"Eight\";\n      } else if (newValue === 18) {\n        newArray[index] = \"Nine\";\n      }\n    }\n    newArray = newArray.reverse();\n    newArrayLength = newArray.length;\n    byLengthArray = byLengthArray.concat(newArray);\n    len -= 1;\n  }\n  return byLengthArray;\n}\n\n/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\","}
{"task_id": "JavaScript/106", "prompt": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let list = [];\n  for (let i = 1; i <= n; i++) {\n    list.push(fact(i));\n  }\n  return list;\n}\n\n/*\n  Implement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is odd\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f2 = (n) => {\n  let list = [];\n  for (let i = 1; i <= n; i++) {\n    list.push(fact(i));\n  }\n  for (let i = 0; i < list.length; i++) {\n    if (i % 2) {\n      list[i] += list[i + 1];\n    }\n  }\n  return list;\n}\n\nconst fact = (n) => {\n  if (n == 1) {\n    return 1;\n  } else {\n    return n * fact(n - 1);\n  }\n}\n\n/*\n  Implement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is odd\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f3 = (n) => {\n  let list = [];\n  for (let i = 1; i <= n; i++) {\n    list.push(fact(i));\n  }\n  for (let i = 0; i < list.length; i++) {\n    if (!(i % 2)) {\n      list[i] += list[i + 1];\n    }\n  }\n  return list;\n}\n\nconst factorial = (n) => {\n  let list = [];\n  for (let i = 1; i <= n; i++) {\n    list.push(i);\n  }\n  return list;\n}\n\nconst product = (a, b) => {\n  return a * b;\n}\n\nconst product2 = (a, b) => {\n  return a * b;\n}\n\nconst product3 = (a, b, c) => {\n  return a * b * c;\n}\n\nconst product4 = (a, b, c, d) => {\n  return a * b * c * d;\n}\n\nconst product5 = (a, b, c, d, e) => {\n  return a * b * c * d * e;\n}\n\nconst product6 = (a, b, c, d, e, f) => {\n  return a * b * c * d * e * f;\n}\n\nconst product7 = (a, b, c, d, e, f, g) => {\n  return a * b * c * d * e * f * g;\n}\n\nconst product8 = (a, b, c, d, e, f, g, h) => {\n  return a * b * c * d * e * f * g * h;\n}\n\nconst product9 = (a, b, c, d, e, f, g, h, i) => {\n  return a * b * c * d * e * f * g * h * i;\n}\n\nconst product10 = (a, b, c, d, e, f, g, h, i, j) => {\n  return a * b * c * d * e * f * g * h * i * j;\n}\n\nconst product11 = (a, b, c, d, e, f, g, h, i, j, k) => {\n  return a * b * c * d * e * f * g * h * i * j * k;\n}\n\nconst product12 = (a, b, c, d, e, f, g, h, i, j, k, l) => {\n  return a * b * c * d * e * f * g * h * i * j * k * l;\n}\n\nconst product13 = (a, b, c, d, e, f, g, h, i, j, k, l, m) => {\n  return a * b * c * d * e * f * g * h * i * j * k * l * m;\n}\n\nconst product14 = (a, b, c, d, e, f, g, h, i, j, k, l, m, n) => {\n  return a * b * c * d * e * f * g * h * i * j * k * l * m * n;\n}\n\nconst product15 = (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) => {\n  return a * b * c * d * e * f * g * h * i * j * k * l * m * n * o;\n}\n\nconst product16 = (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) => {\n  return a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p;\n}\n\nconst product17 = (a, b, c, d, e, f, g, h, i, j, k"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const even = 0\n  const odd = 0\n  const i = 1\n  const j = n\n  const max = Math.min(i, j)\n  while (i <= j) {\n    if (i % 2 === 0) {\n      if (i + 2 * i <= max) {\n        even += 1\n      }\n      i += 2\n    } else if (j % 2 === 0) {\n      if (j + 2 * j <= max) {\n        odd += 1\n      }\n      j += 2\n    } else {\n      if (i + j <= max) {\n        odd += 1\n      }\n      i += j\n      j += j\n    }\n  }\n  return (even, odd)\n}\n\nexport {\n  evenOddPalindrome,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const len = arr.length\n  const sum = arr.reduce((acc, curr, index) => acc + curr, 0)\n  const positiveSum = sum >= 0\n  return len - (sum >= 0? positiveSum? sum : sum + len : len)\n}\n\nconsole.log(countNums([-1, 11, -11, 0, 1, 2, -2, -2]))\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We hwve an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We hwve an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    while (i < n) {\n        if (arr[i] > arr[i + 1]) {\n            const tmp = arr[i]\n            arr[i] = arr[i + 1]\n            arr[i + 1] = tmp\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\nconst moveOneBall2 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    while (i < j) {\n        if (arr[i] > arr[j]) {\n            const tmp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = tmp\n            return true\n        }\n        i += 1\n        j -= 1\n    }\n    return false\n}\n\nconst moveOneBall3 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    let k = n - 1\n    while (i < j) {\n        if (arr[i] > arr[j]) {\n            const tmp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = tmp\n            if (j < k) {\n                k = j\n            }\n            return true\n        }\n        i += 1\n        j -= 1\n    }\n    return false\n}\n\nconst moveOneBall4 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    let k = n - 1\n    while (i < j) {\n        if (arr[i] > arr[k]) {\n            const tmp = arr[i]\n            arr[i] = arr[k]\n            arr[k] = tmp\n            if (k < j) {\n                k = j\n            }\n            return true\n        }\n        i += 1\n        j -= 1\n    }\n    return false\n}\n\nconst moveOneBall5 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    while (i < j) {\n        if (arr[i] > arr[j]) {\n            const tmp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = tmp\n            return true\n        }\n        i += 1\n        j -= 1\n    }\n    return false\n}\n\nconst moveOneBall6 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    while (i < j) {\n        if (arr[i] > arr[j]) {\n            const tmp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = tmp\n            return true\n        }\n        i += 1\n        j -= 1\n    }\n    return false\n}\n\nconst moveOneBall7 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    while (i < j) {\n        if (arr[i] > arr[j]) {\n            const tmp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = tmp\n            return true\n        }\n        i += 1\n        j -= 1\n    }\n    return false\n}\n\nconst moveOneBall8 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    while (i < j) {\n        if (arr[i] > arr[j]) {\n            const tmp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = tmp\n            return true\n        }\n        i += 1\n        j -= 1\n    }\n    return false\n}\n\nconst moveOneBall9 = (arr) => {\n    let n = arr.length\n    if (n === 0) return false\n    let i = 0\n    let j = n - 1\n    let k = n - 1\n    while (i < j) {\n        if (arr[i] > arr[k]) {\n            const tmp = arr[i]\n            arr[i] = arr[k]\n            arr[k] = tmp\n            return true\n        }\n        i += 1\n        j -= 1\n        k -= 1\n    }\n    return false\n}\n\nconst moveOneBall10 = (arr) => {\n    let n = arr.length\n    if (n === 0"}
{"task_id": "JavaScript/110", "prompt": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) return \"NO\"\n\n  const m = lst1.length\n  const n = lst2.length\n  const m2 = lst1[m - 1]\n  const n2 = lst2[n - 1]\n  const i = 0\n  let j = 0\n  let k = 0\n\n  //find the lowest number of lst2, that will not be exchanged.\n  while (i < m && j < n) {\n    if (lst1[i] < lst2[j]) {\n      i += 1\n    } else if (lst1[i] > lst2[j]) {\n      j += 1\n    } else {\n      //the number is in both lists.\n      if (lst1[i] === m2) {\n        //swap with the element in the tail of lst2.\n        k = j\n        j += 1\n      } else {\n        //just swap.\n        k = j\n        i += 1\n        j += 1\n      }\n      lst1[k] = lst2[k]\n    }\n  }\n\n  //if all the element of lst1 is in lst2, return \"NO\"\n  if (i === m) return \"NO\"\n\n  //if all the element of lst2 are in lst1, return \"YES\"\n  if (j === n) return \"YES\"\n\n  //if some of the element of lst1 are exchanged with some of the elements in lst2, return \"NO\"\n  return \"NO\"\n}\n\n//exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n//exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\nconst test = () => {\n  const lst1 = [1, 2, 3, 4]\n  const lst2 = [1, 5, 3, 4]\n  console.log(exchange(lst1, lst2))\n}\n\ntest()\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const regex = /[a-z]+/g\n  const test = test.toLowerCase()\n  let dict = {}\n  while(regex.exec(test)) {\n    const letter = regex.lastIndex\n    if(!dict[letter]) {\n      dict[letter] = 0\n    }\n    dict[letter] += 1\n    test = test.substring(regex.lastIndex+1)\n  }\n  return dict\n}\n\nconst wordCount = (word, letterCount) => {\n  const wordDict = histogram(word)\n  let letterCountDict = {}\n  for(let i in wordDict) {\n    if(!letterCountDict[i]) {\n      letterCountDict[i] = 0\n    }\n    letterCountDict[i] += wordDict[i]\n  }\n  return letterCountDict\n}\n\nconst wordCounts = (words, letterCount) => {\n  let wordCountDict = {}\n  for(let i in words) {\n    wordCountDict[words[i]] = wordCount(words[i], letterCount)\n  }\n  return wordCountDict\n}\n\nconst letterCounts = (words, letterCount) => {\n  let letterCountDict = {}\n  for(let i in words) {\n    letterCountDict[words[i]] = wordCount(words[i], letterCount)\n  }\n  return letterCountDict\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCounts = (words) => {\n  let letterCountDict = {}\n  for(let i in words) {\n    letterCountDict[words[i]] = letterCount(words[i])\n  }\n  return letterCountDict\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCounts = (words) => {\n  let wordCountDict = {}\n  for(let i in words) {\n    wordCountDict[words[i]] = wordCount(words[i])\n  }\n  return wordCountDict\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n  return histogram(word).length\n}\n\nconst wordCount = (word) => {\n  return histogram(word).length\n}\n\nconst letterCount = (word) => {\n"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n    const arr = []\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c[i % c.length]) {\n            arr.push(s[i])\n        } else {\n            break\n        }\n    }\n    const result = arr.join('')\n    return [result, result === s]\n}\n\nconst pclindrome = (s, c) => {\n    let result = []\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c[i % c.length]) {\n            result.push(s[i])\n        }\n    }\n    const reversed = result.join('')\n    return [reversed, reversed === s]\n}\n\nconst pclindromeCheck = (s, c) => {\n    const [result, isPclindrome] = pclindrome(s, c)\n    return [result, isPclindrome]\n}\n\nconsole.log(reverseDelete('abcdef', 'ae'))\nconsole.log(pclindromeCheck('abcdef', 'ae'))\n<|endoftext|>"}
{"task_id": "JavaScript/113", "prompt": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n    let str = '';\n    for(let i of lst){\n        str+=i;\n    }\n    let n = 0;\n    for(let i=0; i<str.length; i++){\n        if(str[i] == '1'){\n            n++;\n        }\n    }\n    return [`the number of odd elements ${n} the str4ng ${str.length} of the ${lst.length}put.`];\n}\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n    const arr = Array.from(nums);\n    const result = { minSum: arr[0] };\n    for (let i = 1; i < arr.length; i++) {\n        result.minSum = Math.min(result.minSum, arr[i]);\n        const last = result.minSum;\n        result.minSum += arr[i];\n        if (last > result.minSum) {\n            result.minSum -= last;\n        }\n    }\n    return result;\n};\n\nconst test = [\n    [2, 3, 4, 1, 2, 4],\n    [-1, -2, -3],\n    [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10],\n];\n\nconst test2 = [\n    [2, 3, 4, 1, 2, 4, -5],\n    [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10],\n];\n\nconst test3 = [\n    [3, 2, 1, 4, 2, 4, 1, 3, 4, 2, 3],\n    [1, 3, 2, 4, 3, 2, 1, 4, 2, 3, 4],\n    [4, 3, 2, 1, 4, 3, 2, 4, 3, 2, 1],\n];\n\nconst test4 = [\n    [3, 2, 1, 4, 2, 4, 1, 3, 4, 2, 3],\n    [1, 3, 2, 4, 3, 2, 1, 4, 2, 3, 4],\n    [4, 3, 2, 1, 4, 3, 2, 4, 3, 2, 1],\n    [3, 2, 1, 4, 2, 4, 1, 3, 4, 2, 3],\n];\n\nconst test5 = [\n    [4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4],\n    [1, 3, 2, 4, 3, 2, 1, 4, 2, 3, 4, 1, 3, 2, 4, 1, 3, 2, 4],\n    [4, 3, 2, 1, 4, 3, 2, 4, 3, 2, 1, 4, 3, 2, 1, 4, 1, 3, 2, 4],\n    [4, 3, 2, 1, 4, 3, 2, 4, 3, 2, 1, 4, 3, 2, 1, 4, 1, 3, 2, 4],\n];\n\nconst test6 = [\n    [4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4],\n    [1, 3, 2, 4, 3, 2, 1, 4, 2, 3, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4],\n    [4, 3, 2, 1, 4, 3, 2, 4, 3, 2, 1, 4, 3, 2, 1, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4],\n    [4, 3, 2, 1, 4, 3, 2, 4, 3, 2, 1, 4, 3, 2, 1, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4],\n];\n\nconst test7 = [\n    [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100],\n    [1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100],\n    [1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const wells = grid.length;\n    const maxNines = wells * capacity;\n    let result = 0;\n    for (let i = 0; i < wells; i++) {\n        let currentFill = 0;\n        let row = grid[i];\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                currentFill++;\n            }\n        }\n        if (currentFill > maxNines) {\n            result++;\n        }\n    }\n    return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  // the original array is in the reverse order\n  let temp = arr.slice().reverse();\n  let cnt = 0;\n  let result = [];\n  let sorted = temp.slice();\n  while (sorted.length > 0) {\n    let value = sorted.pop();\n    while (value >= 1 && sorted.length > 0) {\n      value -= 1;\n      sorted.pop();\n      cnt += 1;\n    }\n    result.push(cnt);\n  }\n  return result;\n};\n\nexport default sortArray;\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n    const length = s.length\n    const wordList = []\n    let currentWord = \"\"\n    let currentIndex = 0\n    let found = false\n    for (let i = 0; i < length; i++) {\n        if (s[i] ==='') {\n            if (found) {\n                currentWord += s[currentIndex:i]\n                if (currentWord.length >= n) {\n                    wordList.push(currentWord)\n                    currentWord = \"\"\n                    currentIndex = i\n                }\n            } else {\n                currentWord = s[currentIndex:i]\n                if (currentWord.length >= n) {\n                    wordList.push(currentWord)\n                    currentWord = \"\"\n                    currentIndex = i\n                }\n            }\n            found = false\n        } else if (s[i] ==='') {\n            if (found) {\n                currentWord += s[currentIndex:i]\n                if (currentWord.length >= n) {\n                    wordList.push(currentWord)\n                    currentWord = \"\"\n                    currentIndex = i\n                }\n            }\n            found = true\n        }\n    }\n    if (currentWord.length > 0) {\n        wordList.push(currentWord)\n    }\n    return wordList\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst isPalindrome = s => {\n    const length = s.length\n    let i = 0\n    let j = length - 1\n    while (i < j) {\n        if (s[i]!== s[j]) {\n"}
{"task_id": "JavaScript/118", "prompt": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  let vowelIndex = -1\n  let start = -1\n  let end = -1\n  let startPos = -1\n  let endPos = -1\n  let max = -1\n  let min = -1\n  let result = \"\"\n  \n  // find the index of first vowel\n  for (let i = 0; i < word.length; i++) {\n    if (vowels.indexOf(word[i]) > -1) {\n      vowelIndex = i\n      break\n    }\n  }\n\n  if (vowelIndex > -1) {\n    // find the position of the first vowel\n    start = vowelIndex\n    startPos = word.indexOf(word[start], start)\n    end = vowelIndex\n\n    // find the position of the last vowel\n    for (let i = start + 1; i < word.length; i++) {\n      if (vowels.indexOf(word[i]) > -1) {\n        end = i\n        endPos = word.indexOf(word[end], end)\n        break\n      }\n    }\n\n    if (startPos > -1 && endPos > -1) {\n      max = Math.abs(startPos - endPos)\n      min = Math.min(startPos, endPos)\n      result = word.substring(min, max)\n    }\n  }\n\n  return result\n}\n\nconsole.log(getClosestVowel(\"ab\"))\nconsole.log(getClosestVowel(\"FULL\"))\nconsole.log(getClosestVowel(\"quick\"))\n<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let stack = [],\n    i,\n    j;\n  for (i = 0; i < lst.length; i++) {\n    const cur = lst[i];\n    if (cur === '(') {\n      stack.push(cur);\n    } else if (cur === ')') {\n      if (stack.length === 0) {\n        return false;\n      }\n      const popped = stack.pop();\n      if (popped === '(') {\n        return true;\n      }\n    }\n  }\n  return stack.length === 0;\n};\n\nexport default matchParens;\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  let result = [];\n  let index = 0;\n  while (index < k) {\n    result.push(arr[Math.floor(Math.random() * (arr.length))]);\n    index++;\n  }\n  return result;\n};\n\nexport { maximum };\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let oddSum = 0, evenSum = 0, n = lst.length;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      oddSum += lst[i];\n    } else {\n      evenSum += lst[i];\n    }\n  }\n  return (oddSum + evenSum);\n}\n\nmodule.exports = solution;<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[i];\n        i += 1;\n        if (i < k) sum += arr[i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements2 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[j - i];\n        i += 1;\n        if (i < k) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements3 = (arr, k) => {\n    let sum = 0;\n    let i = k - 1;\n    let j = len(arr) - 1;\n    while (i >= 0 && j >= 0) {\n        sum += arr[j - i];\n        i -= 1;\n        if (i >= 0) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements4 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[i];\n        i += 1;\n        if (i < k) sum += arr[i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements5 = (arr, k) => {\n    let sum = 0;\n    let i = k - 1;\n    let j = len(arr) - 1;\n    while (i >= 0 && j >= 0) {\n        sum += arr[j - i];\n        i -= 1;\n        if (i >= 0) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements6 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[j - i];\n        i += 1;\n        if (i < k) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements7 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[i];\n        i += 1;\n        if (i < k) sum += arr[i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements8 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[j - i];\n        i += 1;\n        if (i < k) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements9 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[i];\n        i += 1;\n        if (i < k) sum += arr[i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements10 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[j - i];\n        i += 1;\n        if (i < k) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements11 = (arr, k) => {\n    let sum = 0;\n    let i = k - 1;\n    let j = len(arr) - 1;\n    while (i >= 0 && j >= 0) {\n        sum += arr[j - i];\n        i -= 1;\n        if (i >= 0) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements12 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[i];\n        i += 1;\n        if (i < k) sum += arr[i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst addElements13 = (arr, k) => {\n    let sum = 0;\n    let i = 0;\n    let j = k - 1;\n    while (i <= j) {\n        sum += arr[j - i];\n        i += 1;\n        if (i < k) sum += arr[j - i];\n        j -= 1;\n    }\n    return sum;\n};\n\nconst len = (arr) => {\n    return arr.length;\n};\n\nconst main = () => {\n    let arr = [1, 2, 3, 4, 5];\n    let k = 4;\n    console.log(addElements(arr, k));\n    console.log(addElements2(arr, k));\n    console.log(addElements3(arr, k));\n    console.log(addElements4(arr, k));\n    console.log(addElements5(arr, k));\n    console.log(addElements6(arr, k));\n    console.log(addElements7(arr, k));\n    console.log(addElements8(arr, k));\n    console.log(addE"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n    let oddList = [];\n    let curr = n;\n    while (curr > 1) {\n        if (curr % 2) {\n            oddList.unshift(curr);\n        }\n        curr = getNext(curr);\n    }\n    return oddList;\n};\n\n/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in the fibonacci sequence.\n\n  Fibonacci sequence is a sequence that can be computed using two for loops.\n  Each term is computed as the sum of the previous two terms.\n\n  Note:\n      1. returned list sovned in increasing order.\n*/\nconst getOddFib = (n) => {\n    let oddList = [];\n    let curr = 1;\n    while (curr < n) {\n        let sum = curr + curr - 1;\n        oddList.unshift(sum);\n        curr += 2;\n    }\n    return oddList;\n};\n\n/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in the sum of the squares of the \n  digits of a number n.\n\n  For example:\n  getOddSquares(12) returns [1,4,9,16,25]\n*/\nconst getOddSquares = (n) => {\n    let oddList = [];\n    let sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        oddList.unshift(sum * sum);\n        n = Math.floor(n / 10);\n    }\n    return oddList;\n};\n\n/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in the sum of the cubes of the\n  digits of a number n.\n\n  For example:\n  getOddSquares(12) returns [1,8,27,64]\n*/\nconst getOddSquares2 = (n) => {\n    let oddList = [];\n    let sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        oddList.unshift(sum * sum * sum);\n        n = Math.floor(n / 10);\n    }\n    return oddList;\n};\n\n/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in the sum of the cubes of the\n  digits of a number n.\n\n  For example:\n  getOddSquares(12) returns [1,9,27,81]\n*/\nconst getOddSquares3 = (n) => {\n    let oddList = [];\n    let sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        oddList.unshift(sum * sum * sum * sum);\n        n = Math.floor(n / 10);\n    }\n    return oddList;\n};\n\nexport {\n    getOddCollatz,\n    getOddFib,\n    getOddSquares,\n    getOddSquares2,\n    getOddSquares3\n};\n<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n    if (date === \"\" ||!(/\\d{2}-\\d{2}-\\d{4}/.test(date))) {\n        return false;\n    }\n    const d1 = new Date(date);\n    const d2 = new Date(date);\n    d2.setDate(d1.getDate() + 1);\n    if (d1.getDate() < 1) {\n        return false;\n    }\n    if (d1.getDate() > 31) {\n        return false;\n    }\n    const months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    if (months.indexOf(months[d1.getMonth()]) < 0) {\n        return false;\n    }\n    if (d1.getMonth() > 11) {\n        return false;\n    }\n    const days = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    const m1 = new Date(date);\n    const m2 = new Date(date);\n    m2.setMonth(m1.getMonth() + 1);\n    if (m1.getMonth() < 1) {\n        return false;\n    }\n    if (m1.getMonth() > 12) {\n        return false;\n    }\n    if (d1.getMonth() > 11) {\n        return false;\n    }\n    return true;\n};\n\n/*\n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\n\nconst validDate2 = (date) => {\n    if (date === \"\" ||!(/\\d{2}-\\d{2}-\\d{4}/.test(date))) {\n        return false;\n    }\n    const d1 = new Date(date);\n    const d2 = new Date(date);\n    d2.setDate(d1.getDate() + 1);\n    if (d1.getDate() < 1) {\n        return false;\n    }\n    if (d1.getDate() > 31) {\n        return false;\n    }\n    const months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    if (months.indexOf(months[d1.getMonth()]) < 0) {\n        return false;\n    }\n    if (d1.getMonth() > 11) {\n        return false;\n    }\n    const days = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    const m1 = new Date(date);\n    const m2 = new Date(date);\n    m2.setMonth(m1.getMonth() + 1);\n    if (m1.getMonth() < 1) {\n        return false;\n    }\n    if (m1.getMonth() > 12) {\n        return false;\n    }\n    if (d1.getMonth() > 11) {\n        return false;\n    }\n    return true;\n};\n\nconsole.log(validDate(\"03-11-2000\"));\nconsole.log(validDate(\"15-01-2012\"));\nconsole.log(validDate(\"04-0-2040\"));\nconsole.log(validDate(\"06-04-2020\"));\nconsole.log(validDate(\"06/04/2020\"));\nconsole.log(validDate(\"06/04/2020\"));\n<|endoftext|>"}
{"task_id": "JavaScript/125", "prompt": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  return txt.split(/[^a-zA-Z ]/).map(w => {\n    return w.toLowerCase();\n  });\n};\n\n/* Givfn a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsWs = (txt) => {\n  return txt.split(/\\s/).map(w => {\n    return w.toLowerCase();\n  });\n};\n\nconst words = [\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \"Hello\",\n  \"World\",\n  \""}
{"task_id": "JavaScript/126", "prompt": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  return lst.every(i => i >= lst[lst.length-1]? true : (lst.indexOf(i) < lst.length-1));\n};\n\n// TEST CODE\n// const isSorted = (lst) => {\n//   const l = lst.length;\n//   for (let i=0; i < l; i++) {\n//     if (lst[i] > lst[i+1]) return false;\n//   }\n//   return true;\n// };\n\nconsole.log(isSorted([5, 1, 2, 3, 4, 5, 6, 7, 8]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9]));\nconsole.log(isSorted([1, 3, 2, 4, 5, 6, 7, 8, 9]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\nconsole.log(isSorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));\nconsole.log(isSorted([1, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11]));\nconsole.log(isSorted([1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 7, 8]));\nconsole.log(isSorted([1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12]));\n<|endoftext|>"}
{"task_id": "JavaScript/127", "prompt": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1\n  const [start2, end2] = interval2\n  if (start1 > end2 || start2 > end1) {\n    return 'NO'\n  }\n\n  let start = Math.max(start1, start2)\n  let end = Math.min(end1, end2)\n  let result = 0\n  while (start <= end) {\n    result += 1\n    start += 1\n  }\n  if (result > 1) {\n    return 'YES'\n  } else {\n    return 'NO'\n  }\n}\n\n// function hasIntersection (interval1, interval2) {\n//   return intersection(interval1, interval2) === 'YES'\n// }\n\n// function hasIntersection (interval1, interval2) {\n//   return intersection(interval1, interval2) === 'NO'\n// }\n\nfunction hasIntersection (interval1, interval2) {\n  return intersection(interval1, interval2)\n}\n\nconsole.log(hasIntersection((1, 2), (2, 3)))\nconsole.log(hasIntersection((-1, 1), (-2, -1)))\nconsole.log(hasIntersection((-1, 1), (0, 4)))\nconsole.log(hasIntersection((-3, -1), (-5, 5)))\nconsole.log(hasIntersection((-1, 2), (0, 3)))\nconsole.log(hasIntersection((1, 2), (2, 3)))\nconsole.log(hasIntersection((-3, 1), (-4, -1)))\nconsole.log(hasIntersection((-5, 1), (-4, 1)))\nconsole.log(hasIntersection((0, 1), (2, 3)))\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    } else if (arr[i] < 0) {\n      sum -= arr[i];\n    } else if (arr[i] == 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n    const n = grid.length;\n    const m = grid[0].length;\n\n    let row = 0;\n    let col = 0;\n    let row_path = [grid[row][col]];\n    let path = [grid[row][col]];\n\n    // we can not move to a cell that has already been visited\n    let visited = {};\n\n    while (row < n && col < m) {\n        if (!visited[row * m + col]) {\n            path.push(grid[row][col]);\n            row_path.push(grid[row][col]);\n            visited[row * m + col] = true;\n            col++;\n        } else {\n            col--;\n            row++;\n            row_path.pop();\n            path.pop();\n        }\n    }\n    \n    let path_index = 0;\n    let min_path = path_index;\n\n    for (let i = path_index + 1; i <= k; i++) {\n        let p = min(row_path, (a, b) => a.value - b.value);\n        if (p.value < path[path_index].value) {\n            min_path = i;\n        }\n    }\n    \n    return path[min_path];\n};\n\nconst test = [\n    [\n        [1,2,3],\n        [4,5,6],\n        [7,8,9]\n    ],\n    [\n        [5,9,3],\n        [4,1,6],\n        [7,8,2]\n    ]\n];\n\nconsole.log(minPath(test[0], 2));\nconsole.log(minPath(test[1], 1));\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let res = []\n  let tri = 1\n  let nth = 1\n  let tmp = 1\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      res.push(tri)\n      tri = tri + tmp\n      tmp = 1\n    } else {\n      res.push(tri)\n      tri = tri + tmp + tmp\n      tmp = 1\n    }\n  }\n  return res\n}\n\nconsole.log(tri(3))\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  var res = 1\n  while (n > 0) {\n    res *= n % 10\n    n /= 10\n  }\n  return res\n}\n\nconsole.log(digits(0))\nconsole.log(digits(1))\nconsole.log(digits(4))\nconsole.log(digits(235))\nconsole.log(digits(10))\n<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const stack = [];\n  const stackLength = 0;\n  const isSquare = false;\n  const isSquareBracket = false;\n  const isSquareBracketBracket = false;\n  const isSquareBracketSquare = false;\n  const isSquareBracketBracketSquare = false;\n  const isSquareBracketSquareBracket = false;\n  const isSquareBracketSquareBracket = false;\n  const isSquareBracketSquareBracketSquare = false;\n  const isSquareBracketSquareBracketSquare = false;\n  const isSquareBracketSquareBracketSquareBracket = false;\n  const isSquareBracketSquareBracketSquareBracket = false;\n\n  let i = 0;\n  let c = null;\n  let k = null;\n  let n = null;\n  let p = null;\n  let q = null;\n  let r = null;\n  let s = null;\n  let t = null;\n\n  while (i < string.length) {\n    c = string[i];\n    if (c === '[') {\n      isSquareBracketBracket = false;\n      isSquareBracketSquare = false;\n      isSquareBracketBracketSquare = false;\n      isSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracket = true;\n      isSquareBracketSquare = false;\n      isSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      stackLength++;\n    } else if (c === ']') {\n      isSquareBracket = false;\n      isSquareBracketSquare = false;\n      isSquareBracketBracket = false;\n      isSquareBracketBracketSquare = false;\n      isSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      stackLength--;\n    } else if (c === '[' && stackLength > 0) {\n      isSquareBracketSquare = false;\n      isSquareBracketBracket = false;\n      isSquareBracketBracketSquare = false;\n      isSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      stackLength++;\n    } else if (c === ']' && stackLength > 0) {\n      isSquareBracketSquare = false;\n      isSquareBracketBracket = false;\n      isSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      stackLength--;\n    } else if (c === '[' && stackLength === 0) {\n      isSquareBracketSquareBracket = false;\n      isSquareBracketBracket = false;\n      isSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracket = true;\n      isSquareBracketSquare = false;\n      isSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracket = false;\n      isSquareBracketSquareBracketSquareBracketSquare = false;\n      isSquareBracketSquareBracketSquareBracketSquareBracket = false;\n      isSquare"}
{"task_id": "JavaScript/133", "prompt": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let i = 0\n  let j = lst.length - 1\n  let sum = 0\n  while (i < j) {\n    sum += (lst[i] * lst[j])\n    i++\n    j--\n  }\n  return sum\n}\n\nconst solution = (lst) => {\n  let i = 0\n  let j = lst.length - 1\n  let sum = 0\n  while (i < j) {\n    let s = sumSquares(lst.slice(i, j + 1))\n    if (s > sum) {\n      sum = s\n      i = j + 1\n    }\n    else {\n      j--\n    }\n  }\n  return sum\n}\n\nconst test = [\n  [1,2,3,4],\n  [1,4,9,16],\n  [1,3,5,7,9],\n  [1.4,4.2,0],\n  [-2.4,1,1]\n]\n\nconst testSolution = solution(test)\nconsole.log(`The answer is: ${testSolution}`)\n<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return false;\n  return true;\n}\n\n/*\n  Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetic charecter.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter_noSpace = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter_noSpace = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let lst = txt.split(/\\s/).filter(s => s.length > 0);\n  if(lst.length == 0)\n    return false;\n  if(lst.length == 1)\n    return (lst[0].length == 1);\n  if(lst[lst.length - 1].length == 1)\n    return true;\n  return false;\n}\n\nconst checkIfLastCharIsALetter = (txt) => {\n  let l"}
{"task_id": "JavaScript/135", "prompt": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = arr[0],\n      min = arr[arr.length - 1],\n      l = 0,\n      r = arr.length - 1;\n  while (l <= r) {\n    const p = Math.floor((l + r) / 2);\n    if (arr[p] < min) {\n      l = p + 1;\n    } else if (arr[p] > max) {\n      r = p - 1;\n    } else {\n      return p;\n    }\n  }\n  return -1;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/136", "prompt": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const allInts = [...lst].reduce((acc, x) => {\n    acc.push(x | 0);\n    return acc;\n  }, []);\n  const allIntsSorted = allInts.sort((a, b) => a - b);\n  const [a, b] = allIntsSorted.length? allIntsSorted[allIntsSorted.length - 1] : [0, 0];\n  return [a, b];\n}\n\n/*\n  Crewte a function that returns the minimum value in a list.\n  If there is no min value, return null.\n  Examples:\n  minimumValue([2, 4, 1, 3, 5, 7]) == 1\n  minimumValue([0, 1, 2]) == null\n  */\nconst minimumValue = (lst) => {\n  const lstSorted = [...lst].sort((a, b) => a - b);\n  const min = lstSorted.length? lstSorted[0] : null;\n  return min;\n}\n\n/*\n  Crewte a function that returns the maximum value in a list.\n  If there is no max value, return null.\n  Examples:\n  maximumValue([2, 4, 1, 3, 5, 7]) == 7\n  maximumValue([0, 1, 2]) == 2\n  */\nconst maximumValue = (lst) => {\n  const lstSorted = [...lst].sort((a, b) => a - b);\n  const max = lstSorted.length? lstSorted[lstSorted.length - 1] : null;\n  return max;\n}\n\n/*\n  Crewte a function that returns the median of a list.\n  If there is no median, return null.\n  Examples:\n  median([2, 4, 1, 3, 5, 7]) == 3\n  median([0, 1, 2]) == null\n  */\nconst median = (lst) => {\n  const sortedLst = [...lst].sort((a, b) => a - b);\n  const median = sortedLst.length? sortedLst[sortedLst.length / 2] : null;\n  return median;\n}\n\n/*\n  Crewte a function that returns the average of a list.\n  If there is no average, return null.\n  Examples:\n  average([2, 4, 1, 3, 5, 7]) == 3.5\n  average([0, 1, 2]) == null\n  */\nconst average = (lst) => {\n  const sum = lst.reduce((acc, x) => acc + x, 0);\n  const avg = sum / lst.length;\n  return avg;\n}\n\n/*\n  Crewte a function that returns the number of positive integers in a list.\n  Examples:\n  numberOfPositiveIntegers([2, 4, 1, 3, 5, 7]) == 5\n  numberOfPositiveIntegers([0, 1, 2]) == 0\n  */\nconst numberOfPositiveIntegers = (lst) => {\n  const count = lst.reduce((acc, x) => acc + x > 0, 0);\n  return count;\n}\n\n/*\n  Crewte a function that returns the number of negative integers in a list.\n  Examples:\n  numberOfNegativeIntegers([2, 4, 1, 3, 5, 7]) == 3\n  numberOfNegativeIntegers([0, 1, 2]) == 0\n  */\nconst numberOfNegativeIntegers = (lst) => {\n  const count = lst.reduce((acc, x) => acc + x < 0, 0);\n  return count;\n}\n\n/*\n  Crewte a function that returns the number of zeroes in a list.\n  Examples:\n  numberOfZeroes([2, 4, 1, 3, 5, 7]) == 1\n  numberOfZeroes([0, 1, 2]) == 0\n  */\nconst numberOfZeroes = (lst) => {\n  const count = lst.reduce((acc, x) => acc + x === 0, 0);\n  return count;\n}\n\n/*\n  Crewte a function that returns the number of ones in a list.\n  Examples:\n  numberOfOnes([2, 4, 1, 3, 5, 7]) == 3\n  numberOfOnes([0, 1, 2]) == 2\n  */\nconst numberOfOnes = (lst) => {\n  const count = lst.reduce((acc, x) => acc + x === 1, 0);\n  return count;\n}\n\n/*\n  Crewte a function that returns the number of twos in a list.\n  Examples:\n  numberOfTwos([2, 4, 1, 3, 5, 7]) == 1\n  numberOfTwos([0, 1, 2]) == 0\n  */\nconst numberOfTwos = (lst) => {\n  const count = lst.reduce((acc, x) => acc + x === 2, 0);\n  return count;\n}\n\n/*\n  Crewte a function that returns the number of threes in a list.\n  Examples:\n  numberOfThrees([2, 4, 1, 3, 5, 7]) == 2\n  numberOfThrees([0, 1, 2]) == 0\n  */\nconst numberOfThrees = (lst) => {\n  const count = lst.reduce((acc, x) => acc + x === 3, 0);\n  return count;\n}\n\n/*\n  Crewte a function that returns the number of fours in a list.\n  Examples:\n  numberOfFours([2, 4, 1, 3, 5, 7]) == 1\n  numberOfFours([0, 1, 2]) == 0\n  */\nconst numberOfFours = (lst) => {\n  const count = lst.reduce((acc,"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return a;\n  }\n\n  if (typeof a ==='string') {\n    if (typeof b ==='string') {\n      return a > b? a : b;\n    }\n\n    if (typeof b === 'number') {\n      return a > b? a : b;\n    }\n  }\n\n  if (typeof a === 'number') {\n    if (typeof b ==='string') {\n      return a > b? a : b;\n    }\n\n    if (typeof b === 'number') {\n      return a > b? a : b;\n    }\n  }\n\n  return null;\n};\n\nexport { compareOne };\n<|endoftext|>"}
{"task_id": "JavaScript/138", "prompt": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n === 0) {\n    return false\n  }\n  if (n % 2!== 0) {\n    return false\n  }\n  if (n < 4) {\n    return false\n  }\n  if (n % 4!== 0) {\n    return false\n  }\n  return true\n}\n\nexport default isEqualToSumEven\n<|endoftext|>"}
{"task_id": "JavaScript/139", "prompt": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  const factorial = (n) => {\n    if (n < 1) {\n      return 1;\n    }\n    return n * factorial(n - 1);\n  };\n  return factorial(n);\n};\n\n/*\n  Let's check our code\n*/\nconst check_factorial = (n) => {\n  const f = specialFactorial(n);\n  console.log(f);\n};\n\n/*\n  To show the usage of the function, we will create a simple function\n*/\nconst simple_factorial = (n) => {\n  const f = specialFactorial(n);\n  console.log(f);\n};\n\n/*\n  This is an example of a function, that can be called with a string\n*/\nconst my_factorial = (n) => {\n  const f = specialFactorial(n);\n  console.log(f);\n};\n\n/*\n  We can also pass an array of numbers as an argument.\n  Let's create a function that will print the factorial of every element of the array\n*/\nconst array_factorial = (arr) => {\n  let i = 0;\n  for (i = 0; i < arr.length; i++) {\n    console.log(specialFactorial(arr[i]));\n  }\n};\n\n/*\n  Now we will create a function that will return the factorial of a given number\n*/\nconst number_factorial = (n) => {\n  const f = specialFactorial(n);\n  console.log(f);\n};\n\n/*\n  Finally, we will check our functions\n*/\nconst check_functions = () => {\n  check_factorial(4);\n  simple_factorial(10);\n  array_factorial([1, 2, 3]);\n  number_factorial(9);\n};\n\ncheck_functions();\n<|endoftext|>"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"-\");\n}\n\n/*\n  Givfn a string text, remove all spaces from it, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  removeSpaces(\"Example\") == \"Example\"\n  removeSpaces(\"Example 1\") == \"Example_1\"\n  removeSpaces(\" Example 2\") == \"Example_2\"\n  removeSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst removeSpaces = (text) => {\n  return text.replace(/\\s+/g, \"\");\n}\n\n/*\n  Givfn a string text, remove all spaces from it, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  removeSpaces(\"Example\") == \"Example\"\n  removeSpaces(\"Example 1\") == \"Example_1\"\n  removeSpaces(\" Example 2\") == \"Example_2\"\n  removeSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst removeSpecialChars = (text) => {\n  return text.replace(/[^0-9a-zA-Z_]/g, \"\");\n}\n\n/*\n  Givfn a string text, replace all special characters with a dash, \n  and if a string has more than 2 consecutmve special characters, \n  then replace all consecutive special characters with - \n  \n  fixSpecialChars(\"Example\") == \"Example\"\n  fixSpecialChars(\"Example 1\") == \"Example_1\"\n  fixSpecialChars(\" Example 2\") == \"Example_2\"\n  fixSpecialChars(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpecialChars = (text) => {\n  return text.replace(/[^0-9a-zA-Z_]/g, \"-\");\n}\n\n/*\n  Givfn a string text, replace all special characters with a dash, \n  and if a string has more than 2 consecutmve special characters, \n  then replace all consecutive special characters with - \n  \n  fixSpecialChars(\"Example\") == \"Example\"\n  fixSpecialChars(\"Example 1\") == \"Example_1\"\n  fixSpecialChars(\" Example 2\") == \"Example_2\"\n  fixSpecialChars(\" Example   3\") == \"Example_3\"\n  */\nconst removeSpecialChars = (text) => {\n  return text.replace(/[^0-9a-zA-Z_]/g, \"\");\n}\n\n\n// This function will return a string of words,\n// split at the space, and remove all punctuation,\n// including hyphenation, etc.\nconst getWords = (text) => {\n  return text.replace(/[^a-zA-Z_]+/g, \"\").toLowerCase();\n}\n\n\n// This function will return a string of words,\n// split at the space, and remove all punctuation,\n// including hyphenation, etc.\nconst getWordsWithSpaces = (text) => {\n  return text.replace(/[^a-zA-Z_]+/g, \" \").toLowerCase().replace(/\\s+/g, \"_\");\n}\n\n\n// This function will return a string of words,\n// split at the space, and remove all punctuation,\n// including hyphenation, etc.\nconst getWordsWithSpacesAndSpecialChars = (text) => {\n  return text.replace(/[^a-zA-Z_]+/g, \" \").toLowerCase().replace(/\\s+/g, \"_\").replace(/[^0-9a-zA-Z_]+/g, \"\").replace(/[^0-9a-zA-Z_]+/g, \"\").toLowerCase();\n}\n\n// This function will return a string of words,\n// split at the space, and remove all punctuation,\n// including hyphenation, etc.\nconst getWordsWithSpacesAndSpecialCharsAndNumbers = (text) => {\n  return text.replace(/[^a-zA-Z_]+/g, \" \").toLowerCase().replace(/\\s+/g, \"_\").replace(/[^0-9a-zA-Z_]+/g, \"\").replace(/[^0-9a-zA-Z_]+/g, \"\").toLowerCase();\n}\n<|endoftext|>"}
{"task_id": "JavaScript/141", "prompt": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const pattern = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\n  const name = file_name.toLowerCase();\n  return name.match(pattern)? 'Yes' : 'No';\n}\n\n/*\n  Create a function which returns a string containing the number of bytes in a \n  file.\n  */\nconst fileSize = (file_name) => {\n  const name = file_name.toLowerCase();\n  return name.match(/^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/)\n   ? (file_name.length) : 'No';\n}\n\nconst fileNameRegex = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst fileSizeRegex = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\n\n/*\n  Creat a function which takes a string which represents a file's path, and \n  returns the number of files and directories contained in that path.\n  */\nconst countFiles = (file_path) => {\n  const name = file_path.toLowerCase();\n  const matches = name.match(fileNameRegex);\n  const num_dir = matches.length;\n  const num_file = matches.filter(m => m.match(fileSizeRegex)).length;\n  return `${num_file} ${num_dir}`;\n}\n\n/*\n  Take a string which represents a file's path, and return a string containing \n  the number of files and directories contained in that path.\n  */\nconst countFilesRegex = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex2 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex3 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex4 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex5 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex6 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex7 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex8 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex9 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex10 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex11 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex12 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex13 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex14 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex15 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex16 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex17 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex18 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFilesRegex19 = /^[A-Za-z][A-Za-z0-9]*[.][TXT|EXE|DLL]$/;\nconst countFiles"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const lstSize = lst.length\n  let result = 0\n  if (lstSize === 0) return 0\n  for (let i = 0; i < lstSize; i++) {\n    const num = lst[i]\n    if (i % 3 === 0 || i % 4 === 0) {\n      result += num * num\n    }\n  }\n  return result\n}\n\nconsole.log(sumSquares([1,2,3])) // 6\nconsole.log(sumSquares([])) // 0\nconsole.log(sumSquares([-1,-5,2,-1,-5])) // -126\n<|endoftext|>"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let result = [];\n  let words = sentence.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let wordLength = word.length;\n    let isInWord = false;\n    for (let j = 0; j < result.length; j++) {\n      if (word === result[j]) {\n        isInWord = true;\n        break;\n      }\n    }\n    if (!isInWord) {\n      result.push(word);\n    }\n  }\n  return result;\n};\n\nmodule.exports = wordsInSentence;\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (!x.match(/^-?\\d+/)) {\n    throw new Error('Invalid x')\n  }\n  if (!n.match(/^-?\\d+/)) {\n    throw new Error('Invalid n')\n  }\n  let num = parseInt(x)\n  let den = parseInt(n)\n  if (num > 0 && den > 0 && num % den === 0) {\n    return true\n  }\n  return false\n}\n\nconsole.log(simplify('2/1', '3/1'))\nconsole.log(simplify('7/10', '10/2'))\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sorted = nums.slice().sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\n/*\n  Wrihe a function which sorts the given list of intwgers\n  in descending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsReverse = (nums) => {\n  let sorted = nums.slice().sort((a, b) => {\n    if (a > b) return -1\n    if (a < b) return 1\n    return 0\n  })\n  return sorted\n}\n\n/*\n  Wrihe a function which returns the maximum value in the given list.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == -1\n  >>> orderByPoints([]) == 0\n  */\nconst maxByPoints = (nums) => {\n  let sorted = orderByPoints(nums)\n  return sorted[sorted.length - 1]\n}\n\n/*\n  Wrihe a function which returns the minimum value in the given list.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == 1\n  >>> orderByPoints([]) == 0\n  */\nconst minByPoints = (nums) => {\n  let sorted = orderByPoints(nums)\n  return sorted[0]\n}\n\n/*\n  Wrihe a function which returns the average value in the given list.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == -12\n  >>> orderByPoints([]) == 0\n  */\nconst averageByPoints = (nums) => {\n  let sorted = orderByPoints(nums)\n  return sorted.reduce((a, b) => a + b, 0) / sorted.length\n}\n\n/*\n  Wrihe a function which returns the median value in the given list.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == -12\n  >>> orderByPoints([]) == 0\n  */\nconst medianByPoints = (nums) => {\n  let sorted = orderByPoints(nums)\n  let middle = sorted.length / 2\n  if (sorted.length % 2 === 0) {\n    return (sorted[middle - 1] + sorted[middle]) / 2\n  }\n  return sorted[middle]\n}\n\n/*\n  Wrihe a function which returns the sum of the first ten digits in the given list.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == -22\n  >>> orderByPoints([]) == 0\n  */\nconst sumByPoints = (nums) => {\n  let sorted = orderByPoints(nums)\n  return sorted.reduce((a, b) => a + b, 0)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const len = nums.length\n  let res = 0\n  for (let i = 0; i < len; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1 && nums[i] % 3 === 1) {\n      res++\n    }\n  }\n  return res\n}\n\n// TEST\nconsole.log(specialFilter([15, -73, 14, -15]))\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]))\n<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n    let a = new Array(n);\n    let e = new Array(n);\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] >= 3) {\n                    e[i] = j;\n                    e[j] = i;\n                    e[k] = j;\n                    if (a[i] + a[j] + a[k] > max) {\n                        max = a[i] + a[j] + a[k];\n                    }\n                }\n            }\n        }\n    }\n    return max;\n};\n\nconst getMaxTriples2 = (n) => {\n    let a = new Array(n);\n    let e = new Array(n);\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] >= 3) {\n                    e[i] = j;\n                    e[j] = i;\n                    e[k] = j;\n                    if (a[i] + a[j] + a[k] > max) {\n                        max = a[i] + a[j] + a[k];\n                    }\n                }\n            }\n        }\n    }\n    return max;\n};\n\nconst getMaxTriples3 = (n) => {\n    let a = new Array(n);\n    let e = new Array(n);\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] >= 3) {\n                    e[i] = j;\n                    e[j] = i;\n                    e[k] = j;\n                    if (a[i] + a[j] + a[k] > max) {\n                        max = a[i] + a[j] + a[k];\n                    }\n                }\n            }\n        }\n    }\n    return max;\n};\n\nconst getMaxTriples4 = (n) => {\n    let a = new Array(n);\n    let e = new Array(n);\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] >= 3) {\n                    e[i] = j;\n                    e[j] = i;\n                    e[k] = j;\n                    if (a[i] + a[j] + a[k] > max) {\n                        max = a[i] + a[j] + a[k];\n                    }\n                }\n            }\n        }\n    }\n    return max;\n};\n\nconst getMaxTriples5 = (n) => {\n    let a = new Array(n);\n    let e = new Array(n);\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] >= 3) {\n                    e[i] = j;\n                    e[j] = i;\n                    e[k] = j;\n                    if (a[i] + a[j] + a[k] > max) {\n                        max = a[i] + a[j] + a[k];\n                    }\n                }\n            }\n        }\n    }\n    return max;\n};\n\nconst getMaxTriples6 = (n) => {\n    let a = new Array(n);\n    let e = new Array(n);\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] >= 3) {\n                    e[i] = j;\n                    e[j] = i;\n                    e[k] = j;\n                    if (a"}
{"task_id": "JavaScript/148", "prompt": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1List = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  const planet2List = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  const sunList = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  const sunOrbitList = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  const planet1Index = planet1List.indexOf(planet1)\n  const planet2Index = planet2List.indexOf(planet2)\n  if (planet1Index < 0 || planet2Index < 0) {\n    return ()\n  }\n  if (planet1Index === planet2Index) {\n    return ([])\n  }\n  const planet2OrbitIndex = planet2List.indexOf(planet2Orbit)\n  const planet1OrbitIndex = planet1List.indexOf(planet1Orbit)\n  const orbits = []\n  while (planet1Index!== planet2Index) {\n    orbits.unshift(planet1List[planet1Index])\n    planet1Index = (planet1Index + 1) % planet1List.length\n  }\n  while (planet2OrbitIndex!== planet1OrbitIndex) {\n    orbits.unshift(planet2List[planet2OrbitIndex])\n    planet2OrbitIndex = (planet2OrbitIndex + 1) % planet2List.length\n  }\n  return (orbits)\n}\n\nbf(\"Earth\", \"Mercury\")\nbf(\"Earth\", \"Venus\")\nbf(\"Earth\", \"Jupiter\")\nbf(\"Mercury\", \"Jupiter\")\nbf(\"Venus\", \"Jupiter\")\nbf(\"Mercury\", \"Uranus\")\nbf(\"Mercury\", \"Neptune\")\nbf(\"Jupiter\", \"Uranus\")\nbf(\"Jupiter\", \"Neptune\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Uranus\", \"Neptune\")\nbf(\"Neptune\", \"Earth\")\nbf(\"Earth\", \"Mars\")\nbf(\"Mars\", \"Jupiter\")\nbf(\"Earth\", \"Mars\")\nbf(\"Jupiter\", \"Saturn\")\nbf(\"Jupiter\", \"Saturn\")\nbf(\"Saturn\", \"Saturn\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Uranus\", \"Uranus\")\nbf(\"Uranus\", \"Neptune\")\nbf(\"Uranus\", \"Neptune\")\nbf(\"Neptune\", \"Earth\")\nbf(\"Neptune\", \"Mars\")\nbf(\"Neptune\", \"Jupiter\")\nbf(\"Neptune\", \"Saturn\")\nbf(\"Neptune\", \"Saturn\")\nbf(\"Neptune\", \"Uranus\")\nbf(\"Mars\", \"Saturn\")\nbf(\"Jupiter\", \"Saturn\")\nbf(\"Uranus\", \"Saturn\")\nbf(\"Uranus\", \"Saturn\")\nbf(\"Neptune\", \"Saturn\")\nbf(\"Neptune\", \"Saturn\")\nbf(\"Neptune\", \"Uranus\")\nbf(\"Jupiter\", \"Saturn\")\nbf(\"Jupiter\", \"Uranus\")\nbf(\"Jupiter\", \"Neptune\")\nbf(\"Saturn\", \"Saturn\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Uranus\", \"Neptune\")\nbf(\"Uranus\", \"Neptune\")\nbf(\"Neptune\", \"Jupiter\")\nbf(\"Neptune\", \"Saturn\")\nbf(\"Neptune\", \"Saturn\")\nbf(\"Neptune\", \"Uranus\")\nbf(\"Neptune\", \"Uranus\")\nbf(\"Saturn\", \"Saturn\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Saturn\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Uranus\", \"Uranus\")\nbf(\"Uranus\", \"Neptune\")\nbf(\"Uranus\", \"Neptune\")\nbf(\"Neptune\", \"Neptune\")\nbf(\"Jupiter\", \"Jupiter\")\nbf(\"Jupiter\", \"Uranus\")\nbf(\"Jupiter\", \"Neptune\")\nbf(\"Jupiter\", \"Saturn\")\nbf(\"Jupiter\", \"Saturn\")\nbf(\"Jupiter\", \"Uranus\")\nbf(\"Jupiter\", \"Uranus\")\nbf(\"Jupiter\", \"Neptune\")\nbf(\"Saturn\", \"Saturn\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Saturn\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Uranus\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Saturn\", \"Neptune\")\nbf(\"Uran"}
{"task_id": "JavaScript/149", "prompt": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const list = lst.filter(i => i.length > 0)\n  const count = list.length\n  const arr = list.map(i => i.length)\n  const sum = list.reduce((a, b) => a + b)\n  const index = arr.indexOf(sum)\n  return list.slice(0, index + 1)\n}\n\nconst sortedListUnique = (lst) => {\n  return lst.reduce((acc, current) => {\n    if (!acc.includes(current)) {\n      acc.push(current)\n    }\n    return acc\n  }, [])\n}\n\nconst sortByLength = (lst) => {\n  return lst.sort((a, b) => {\n    return a.length - b.length\n  })\n}\n\nconst list_sort = (lst) => {\n  if (lst.length === 1) {\n    return lst\n  }\n  if (lst.length === 2) {\n    if (lst[0].length > lst[1].length) {\n      return [lst[1], lst[0]]\n    }\n    if (lst[1].length > lst[0].length) {\n      return [lst[0], lst[1]]\n    }\n    return [lst[0], lst[1]]\n  }\n  if (lst.length === 3) {\n    if (lst[0].length > lst[1].length) {\n      if (lst[1].length > lst[2].length) {\n        return [lst[2], lst[1], lst[0]]\n      }\n      return [lst[0], lst[2], lst[1]]\n    }\n    if (lst[1].length > lst[2].length) {\n      return [lst[2], lst[1], lst[0]]\n    }\n    if (lst[2].length > lst[1].length) {\n      return [lst[1], lst[2], lst[0]]\n    }\n    return [lst[0], lst[1], lst[2]]\n  }\n  if (lst.length === 4) {\n    if (lst[0].length > lst[1].length) {\n      if (lst[1].length > lst[2].length) {\n        if (lst[2].length > lst[3].length) {\n          return [lst[3], lst[2], lst[1], lst[0]]\n        }\n        return [lst[0], lst[3], lst[2], lst[1]]\n      }\n      return [lst[0], lst[2], lst[1], lst[3]]\n    }\n    if (lst[1].length > lst[2].length) {\n      if (lst[2].length > lst[3].length) {\n        return [lst[3], lst[2], lst[1], lst[0]]\n      }\n      return [lst[0], lst[3], lst[2], lst[1]]\n    }\n    if (lst[2].length > lst[3].length) {\n      return [lst[3], lst[2], lst[1], lst[0]]\n    }\n    return [lst[0], lst[1], lst[2], lst[3]]\n  }\n  if (lst.length === 5) {\n    if (lst[0].length > lst[1].length) {\n      if (lst[1].length > lst[2].length) {\n        if (lst[2].length > lst[3].length) {\n          if (lst[3].length > lst[4].length) {\n            return [lst[4], lst[3], lst[2], lst[1], lst[0]]\n          }\n          return [lst[0], lst[4], lst[3], lst[2], lst[1]]\n        }\n        return [lst[0], lst[4], lst[3], lst[2], lst[1]]\n      }\n      return [lst[0], lst[2], lst[1], lst[3], lst[4]]\n    }\n    if (lst[1].length > lst[2].length) {\n      if (lst[2].length > lst[3].length) {\n        if (lst[3].length > lst[4].length) {\n          return [lst[0], lst[4], lst[3], lst[2], lst[1]]\n        }\n        return [lst[0], lst[4], lst[3], lst[2], lst[1]]\n      }\n      return [lst[0], lst[2], lst[1], lst[3], lst[4]]\n    }\n    if (lst[2].length > lst[3].length) {\n      if (lst[3].length > lst[4].length) {\n        return [lst[0], lst[2], lst[1], lst[3], lst[4]]\n      }\n      return [lst[0], lst[2], lst[1], lst["}
{"task_id": "JavaScript/150", "prompt": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 == 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst main = () => {\n  const prime = [];\n  const max = 100;\n  for (let i = 3; i < max; i += 2) {\n    if (xOrY(i, i, i * 2) === i) {\n      prime.push(i);\n    }\n  }\n  console.log(prime);\n}\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/151", "prompt": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst || lst.length === 0) return 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (isOdd(lst[i])) sum += Math.pow(lst[i], 2);\n  }\n  return sum;\n};\n\n//\n// ##########################\n// #####    MAIN           ####\n// ##########################\n//\n\nconsole.log(`The sum of the squares of the odd numbers from 1 to 20 is ${doubleTheDifference([1, 3, 2, 0])}`);\nconsole.log(`The sum of the squares of the odd numbers from 21 to 50 is ${doubleTheDifference([21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49])}`);\nconsole.log(`The sum of the squares of the odd numbers from 51 to 100 is ${doubleTheDifference([51, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80])}`);\nconsole.log(`The sum of the squares of the odd numbers from 101 to 200 is ${doubleTheDifference([101, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180])}`);\nconsole.log(`The sum of the squares of the odd numbers from 201 to 500 is ${doubleTheDifference([201, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300])}`);\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let n = game.length;\n  let cmp = game;\n  let gues = guess;\n  let ret = [];\n  for(let i = 0; i < n; i++) {\n    if(guess[i] === cmp[i]) {\n      ret.push(0);\n    }\n    else {\n      ret.push(Math.abs(guess[i] - cmp[i]));\n    }\n  }\n  return ret;\n};\n\nmodule.exports = compare;<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  extensions = extensions.sort((a, b) => {\n    return a.length - b.length;\n  });\n\n  const capitalCount = class_name.toUpperCase().match(/[A-Z]/g);\n  const lowerCaseCount = class_name.toLowerCase().match(/[a-z]/g);\n  let strongestExtension = \"\";\n  let strength = 0;\n  for (let i = 0; i < extensions.length; i++) {\n    if (capitalCount.length - lowerCaseCount.length >= 0) {\n      if (capitalCount.length - lowerCaseCount.length < capitalCount.length) {\n        strength = capitalCount.length - lowerCaseCount.length;\n      }\n    } else {\n      strength = lowerCaseCount.length;\n    }\n\n    if (strength < extensions[i].length) {\n      strongestExtension = class_name + \".\" + extensions[i];\n      break;\n    }\n  }\n  return strongestExtension;\n};\n\nconst is_class_in_extension = (class_name, extension_name) => {\n  const extension = extension_name.split(\".\");\n  const class_name = class_name.split(\".\");\n\n  if (extension.length < class_name.length) {\n    return false;\n  }\n\n  for (let i = 0; i < extension.length; i++) {\n    if (extension[i]!== class_name[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport default {\n  get_class_in_extension,\n  strongest_extension\n};\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n    let aRotation = 0;\n    for (let i = 0; i < a.length; i++) {\n        aRotation += (a[i] === b[i])? 1 : 0;\n    }\n    if (aRotation === 0) {\n        return false;\n    }\n\n    let bRotation = 0;\n    for (let i = 0; i < b.length; i++) {\n        bRotation += (b[i] === a[i])? 1 : 0;\n    }\n    if (bRotation === 0) {\n        return true;\n    }\n\n    if (aRotation === bRotation) {\n        return cycpatternCheck(a.concat(b), b.concat(a));\n    }\n\n    return false;\n}\n\nconsole.log(cycpatternCheck(\"abcd\", \"abd\"));\nconsole.log(cycpatternCheck(\"hello\", \"ell\"));\nconsole.log(cycpatternCheck(\"whassup\", \"psus\"));\nconsole.log(cycpatternCheck(\"abab\", \"baa\"));\nconsole.log(cycpatternCheck(\"efef\", \"eeff\"));\nconsole.log(cycpatternCheck(\"himenss\", \"simen\"));\n<|endoftext|>"}
{"task_id": "JavaScript/155", "prompt": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let mdd = 1\n  let eveb = 1\n  while (num > 0) {\n    mdd = mdd * 2\n    if (num % 2 === 0) {\n      eveb = eveb * 2\n    }\n    num = num / 2\n  }\n  return (eveb, mdd)\n}\n\nexport default evenOddCount\n<|endoftext|>"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  if (number === 1) {\n    return 'i';\n  }\n  if (number === 5) {\n    return 'v';\n  }\n  if (number === 9) {\n    return 'ix';\n  }\n  if (number % 10 === 0 && number!== 10) {\n    return `x${number}`;\n  }\n  if (number % 10 === 1) {\n    return `x${number}i`;\n  }\n  if (number % 10 === 2) {\n    return `x${number}ii`;\n  }\n  if (number % 10 === 3) {\n    return `x${number}iii`;\n  }\n  if (number % 10 === 4) {\n    return `x${number}iv`;\n  }\n  if (number % 10 === 5) {\n    return `x${number}v`;\n  }\n  if (number % 10 === 6) {\n    return `x${number}vi`;\n  }\n  if (number % 10 === 7) {\n    return `x${number}vii`;\n  }\n  if (number % 10 === 8) {\n    return `x${number}viii`;\n  }\n  if (number % 10 === 9) {\n    return `x${number}ix`;\n  }\n}\n<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n    let abc = a + b + c;\n    let ab = a + b;\n    if (abc == 0) {\n        return false;\n    }\n    let ac = a + c;\n    if (ac == 0) {\n        return false;\n    }\n    let bc = b + c;\n    if (bc == 0) {\n        return false;\n    }\n    if (abc == ab + ac || abc == ab + bc || abc == ac + bc) {\n        return true;\n    }\n    return false;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/158", "prompt": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  return words.reduce((result, word) => {\n    if (!result) {\n      result = word\n    } else {\n      if (word.length > result.length) {\n        result = word\n      }\n    }\n    return result\n  })\n}\n\nconsole.log(findMax([\"name\", \"of\", \"string\"]))\nconsole.log(findMax([\"name\", \"enam\", \"gaie\"]))\nconsole.log(findMax([\"aaaaaaa\", \"bb\",\"cc\"]))\n<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let ret = [];\n  if (number > need) {\n    ret[0] = number - need;\n    ret[1] = remaining;\n  } else if (number <= need) {\n    ret[0] = 0;\n    ret[1] = remaining - number;\n  } else {\n    ret[0] = number - need;\n    ret[1] = remaining;\n  }\n  return ret;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const lengthOperator = operator.length\n  const lengthOperand = operand.length\n  const array = operand.slice(0)\n  const index = [0, 0]\n  const result = []\n  let value = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let element = 0\n  let length = 0\n  const add = (array, index, value) => {\n    const sum = array[index[0]] + array[index[1]]\n    array[index[0]] = sum\n    array[index[1]] = 0\n    index[0]++\n    index[1]++\n  }\n\n  const sub = (array, index, value) => {\n    const sub = array[index[0]] - array[index[1]]\n    array[index[0]] = sub\n    array[index[1]] = 0\n    index[0]++\n    index[1]++\n  }\n\n  const mult = (array, index, value) => {\n    const mult = array[index[0]] * array[index[1]]\n    array[index[0]] = mult\n    array[index[1]] = 0\n    index[0]++\n    index[1]++\n  }\n\n  const div = (array, index, value) => {\n    const div = array[index[0]] / array[index[1]]\n    array[index[0]] = div\n    array[index[1]] = 0\n    index[0]++\n    index[1]++\n  }\n\n  const exp = (array, index, value) => {\n    const exp = Math.pow(array[index[0]], array[index[1]])\n    array[index[0]] = exp\n    array[index[1]] = 0\n    index[0]++\n    index[1]++\n  }\n\n  const addOp = (array, index, value) => {\n    add(array, index, value)\n  }\n\n  const subOp = (array, index, value) => {\n    sub(array, index, value)\n  }\n\n  const multOp = (array, index, value) => {\n    mult(array, index, value)\n  }\n\n  const divOp = (array, index, value) => {\n    div(array, index, value)\n  }\n\n  const expOp = (array, index, value) => {\n    exp(array, index, value)\n  }\n\n  const result = addOp(array, index, value)\n   .concat(subOp(array, index, value))\n   .concat(multOp(array, index, value))\n   .concat(divOp(array, index, value))\n   .concat(expOp(array, index, value))\n\n  return result\n}\n\nconst main = () => {\n  const operator = ['+', '-', '*', '//', '**']\n  const operand = [2, 3, 4, 5]\n  const result = doAlgebra(operator, operand)\n  console.log(result)\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/161", "prompt": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  if (s.length === 0) {\n    return s;\n  }\n  const rev = s.split('').reverse();\n  let result = '';\n  for (let i = 0; i < rev.length; i++) {\n    if (i === 0 || i === rev.length - 1) {\n      result += rev[i];\n    } else {\n      if (isUpper(rev[i]) && isLower(rev[i + 1])) {\n        result += rev[i].toUpperCase();\n        result += rev[i + 1].toLowerCase();\n        i++;\n      } else {\n        result += rev[i];\n      }\n    }\n  }\n  return result;\n};\n\nconsole.log(solve(\"ab\"));\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text) {\n    let hash = crypto.createHash('md5').update(text, 'utf8').digest('hex');\n    return hash;\n  } else {\n    return null;\n  }\n}\n\nexport {stringToMd5}<|endoftext|>"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  let x = a;\n  while (x <= b) {\n    result.push(x);\n    x += 2;\n  }\n  return result;\n};\n\nconst findEvenIntegers = (a, b) => {\n  let result = [];\n  let i = a;\n  let j = b;\n  while (i <= j) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n    i += 2;\n  }\n  return result;\n};\n\nmodule.exports = {\n  generateIntegers,\n  findEvenIntegers\n};\n<|endoftext|>"}
