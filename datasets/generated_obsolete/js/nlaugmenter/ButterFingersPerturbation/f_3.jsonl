{"task_id": "JavaScript/0", "prompt": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  let nums = numbers.sort();\n  let diff = Math.abs(numbers[numbers.length - 1] - nums[0]);\n  return diff < threshold;\n};\n\nmodule.exports = hasCloseElements;\n<|endoftext|>"}
{"task_id": "JavaScript/1", "prompt": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let left_stack = [];\n  let right_stack = [];\n  let opening_braces = 0;\n  let i = 0;\n  let group = \"\";\n\n  while (i < paren_string.length) {\n    let c = paren_string.charAt(i);\n\n    if (c === '(') {\n      opening_braces += 1;\n    } else if (c === ')') {\n      opening_braces -= 1;\n      if (opening_braces === 0) {\n        let new_group = group.replace(/^\\(/,'');\n        let new_group_array = new_group.split('');\n        for (let j = 0; j < new_group_array.length; j++) {\n          if (new_group_array[j] === ')') {\n            left_stack.push(new_group_array[j]);\n            right_stack.push(new_group_array[j]);\n            new_group = new_group.substring(0, j) + new_group_array[j].substring(1);\n            new_group_array = new_group.split('');\n          }\n        }\n        group = new_group;\n      }\n    } else {\n      if (opening_braces === 0) {\n        group += c;\n      }\n    }\n\n    i += 1;\n  }\n\n  if (group!== \"\") {\n    let new_group_array = group.split('');\n    for (let j = 0; j < new_group_array.length; j++) {\n      if (new_group_array[j] === ')') {\n        left_stack.push(new_group_array[j]);\n        right_stack.push(new_group_array[j]);\n      }\n    }\n  }\n\n  let groups = [];\n  let group_length = 0;\n  let right_index = 0;\n  let left_index = 0;\n  let open_brace = false;\n  while (right_index < right_stack.length) {\n    if (right_stack[right_index] === '(') {\n      group_length += 1;\n    } else if (right_stack[right_index] === ')') {\n      group_length -= 1;\n    }\n\n    if (group_length === 0) {\n      let group_array = [];\n      let k = 0;\n      while (k < left_stack.length) {\n        group_array.push(left_stack[k]);\n        k += 1;\n      }\n\n      groups.push(group_array);\n      right_index += 1;\n      open_brace = false;\n    }\n\n    if (group_length > 0) {\n      right_index += 1;\n    }\n  }\n\n  return groups;\n};\n\n// @TODO: fix this so it takes in an array of nested parentheses\n// @TODO: fix this so it takes in a string and returns a list of nested groups\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters an empty string\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so it doesn't throw an error when it encounters a bad group\n// @TODO: fix this so"}
{"task_id": "JavaScript/2", "prompt": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = number\n  let decimals = 0\n  let integer = Math.floor(number)\n  while (integer - integerPart > 0.0000001) {\n    integerPart = integer\n    integer = Math.floor(integer)\n    decimals += 1\n  }\n  return number - integerPart + (decimals? 0.01 : 0)\n}\n\n/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the number of decimals of thx number.\n  >>> truncateNumber(3.5)\n  2\n  */\nconst truncateNumberDecimals = (number) => {\n  let integerPart = number\n  let decimals = 0\n  let integer = Math.floor(number)\n  while (integer - integerPart > 0.0000001) {\n    integerPart = integer\n    integer = Math.floor(integer)\n    decimals += 1\n  }\n  return decimals\n}\n\n/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the rounded number of thx number.\n  >>> truncateNumber(3.5)\n  4\n  */\nconst truncateNumberRounded = (number) => {\n  let integerPart = number\n  let decimals = 0\n  let integer = Math.floor(number)\n  while (integer - integerPart > 0.0000001) {\n    integerPart = integer\n    integer = Math.floor(integer)\n    decimals += 1\n  }\n  return Math.round(integer) + (decimals? 0.01 : 0)\n}\n\n/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the number of decimals of thx number.\n  >>> truncateNumber(3.5)\n  2\n  */\nconst truncateNumberDecimalsRounded = (number) => {\n  let integerPart = number\n  let decimals = 0\n  let integer = Math.floor(number)\n  while (integer - integerPart > 0.0000001) {\n    integerPart = integer\n    integer = Math.floor(integer)\n    decimals += 1\n  }\n  return Math.round(integer) + (decimals? 0.01 : 0)\n}\n\n/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the number of decimals of thx number.\n  >>> truncateNumber(3.5)\n  2\n  */\nconst truncateNumberDecimalsRounded2 = (number) => {\n  let integerPart = number\n  let decimals = 0\n  let integer = Math.floor(number)\n  while (integer - integerPart > 0.0000001) {\n    integerPart = integer\n    integer = Math.floor(integer)\n    decimals += 1\n  }\n  return Math.round(integer) + (decimals? 0.01 : 0)\n}\n\n/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the number of decimals of thx number.\n  >>> truncateNumber(3.5)\n  2\n  */\nconst truncateNumberDecimalsRounded3 = (number) => {\n  let integerPart = number\n  let decimals = 0\n  let integer = Math.floor(number)\n  while (integer - integerPart > 0.0000001) {\n    integerPart = integer\n    integer = Math.floor(integer)\n    decimals += 1\n  }\n  return Math.round(integer) + (decimals? 0.01 : 0)\n}\n\n/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the number of decimals of thx number.\n  >>> truncateNumber(3.5)\n  2\n  */\nconst truncateNumberDecimalsRounded4 = (number) => {\n  let integerPart = number\n  let decimals = 0\n  let integer = Math.floor(number)\n  while (integer - integerPart > 0.0000001) {\n    integerPart = integer\n    integer = Math.floor(integer)\n    decimals += 1\n  }\n  return Math.round(integer) + (decimals? 0.01 : 0)\n}\n\nmodule.exports = {\n  truncateNumber,\n  truncateNumberDecimals,\n  truncateNumberRounded,\n  truncateNumberDecimalsRounded,\n  truncateNumberDecimalsRounded2,\n  truncateNumberDecimalsRounded3,\n  truncateNumberDecimalsRounded4\n}\n<|endoftext|>"}
{"task_id": "JavaScript/3", "prompt": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const total = 0\n  for (let i = 0; i < operations.length; i++) {\n    total += operations[i]\n    if (total < 0) {\n      return true\n    }\n  }\n  return false\n}\n\nconst belowZeroTest = belowZero([1, 2, 3, 4, 5])\nconsole.log(belowZeroTest)\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const sum = numbers.reduce((a, b) => a + b, 0)\n  const mean = sum / numbers.length\n  const difference = numbers.reduce((a, b) => a + Math.abs(b - mean), 0)\n  return difference / numbers.length\n}\n\nmodule.exports = meanAbsoluteDeviation\n<|endoftext|>"}
{"task_id": "JavaScript/5", "prompt": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n    if(typeof delimeter!== 'number'){\n        throw Error('delimeter must be a number')\n    }\n    if(!Array.isArray(numbers)){\n        throw Error('numbers must be an array')\n    }\n\n    if(numbers.length === 0){\n        return []\n    }\n    const len = numbers.length\n    const half = len/2\n    const head = numbers.slice(0, half)\n    const tail = numbers.slice(half, len)\n    return [].concat(head, intersperse(tail, delimeter), tail)\n}\n\n//------------------------------------------------------------------------------\n//\n//   * @returns {string}\n//   * @description\n//   * Returns a string made by concatenating each element of the array\n//   * in order with a delimiter.\n//   *\n//   * @example\n//   * const a = ['a', 'b', 'c']\n//   * intersperse(a,'')\n//   * // 'a b c'\n//\n//   * @param {Array} `numbers`\n//   * @param {number} `delimeter`\n//   */\nconst intersperse2 = (numbers, delimeter) => {\n    if(typeof delimeter!== 'number'){\n        throw Error('delimeter must be a number')\n    }\n    if(!Array.isArray(numbers)){\n        throw Error('numbers must be an array')\n    }\n\n    if(numbers.length === 0){\n        return ''\n    }\n    const len = numbers.length\n    const half = len/2\n    const head = numbers.slice(0, half)\n    const tail = numbers.slice(half, len)\n    return head.join(delimeter) + tail.join(delimeter)\n}\n\n//------------------------------------------------------------------------------\n//\n//   * @returns {string}\n//   * @description\n//   * Returns a string made by concatenating each element of the array\n//   * in order with a delimiter.\n//   *\n//   * @example\n//   * const a = ['a', 'b', 'c']\n//   * intersperse(a,'')\n//   * // 'a b c'\n//\n//   * @param {Array} `numbers`\n//   * @param {number} `delimeter`\n//   */\nconst intersperse3 = (numbers, delimeter) => {\n    if(typeof delimeter!== 'number'){\n        throw Error('delimeter must be a number')\n    }\n    if(!Array.isArray(numbers)){\n        throw Error('numbers must be an array')\n    }\n\n    if(numbers.length === 0){\n        return ''\n    }\n    const len = numbers.length\n    const half = len/2\n    const head = numbers.slice(0, half)\n    const tail = numbers.slice(half, len)\n    return tail.join(delimeter) + head.join(delimeter)\n}\n\n//------------------------------------------------------------------------------\n//\n//   * @returns {string}\n//   * @description\n//   * Returns a string made by concatenating each element of the array\n//   * in order with a delimiter.\n//   *\n//   * @example\n//   * const a = ['a', 'b', 'c']\n//   * intersperse(a,'')\n//   * // 'a b c'\n//\n//   * @param {Array} `numbers`\n//   * @param {number} `delimeter`\n//   */\nconst intersperse4 = (numbers, delimeter) => {\n    if(typeof delimeter!== 'number'){\n        throw Error('delimeter must be a number')\n    }\n    if(!Array.isArray(numbers)){\n        throw Error('numbers must be an array')\n    }\n\n    if(numbers.length === 0){\n        return ''\n    }\n    const len = numbers.length\n    const half = len/2\n    const head = numbers.slice(0, half)\n    const tail = numbers.slice(half, len)\n    return tail.join(delimeter) + head.join(delimeter)\n}\n\n//------------------------------------------------------------------------------\n//\n//   * @returns {string}\n//   * @description\n//   * Returns a string made by concatenating each element of the array\n//   * in order with a delimiter.\n//   *\n//   * @example\n//   * const a = ['a', 'b', 'c']\n//   * intersperse(a,'')\n//   * // 'a b c'\n//\n//   * @param {Array} `numbers`\n//   * @param {number} `delimeter`\n//   */\nconst intersperse5 = (numbers, delimeter) => {\n    if(typeof delimeter!== 'number'){\n        throw Error('delimeter must be a number')\n    }\n    if(!Array.isArray(numbers)){\n        throw Error('numbers must be an array')\n    }\n\n    if(numbers.length === 0){\n        return ''\n    }\n    const len = numbers.length\n    const half = len/2\n    const head = numbers.slice(0, half)\n    const tail = numbers.slice(half, len)\n    return tail.join(delimeter) + head.join(delimeter)\n}\n\n//------------------------------------------------------------------------------\n//\n//   * @returns {string}\n//   * @description\n//   * Returns a string made by concatenating each element of the array\n//   * in order with a delimiter.\n//   *\n//   * @example\n//   * const a = ['a', 'b', 'c']\n//   * intersperse(a,'')\n//   * // 'a b c'\n//\n//   * @param {Array} `numbers`\n//   * @param {number} `delimeter`\n//   */\nconst intersperse6 = (numbers, delimeter) => {\n    if(typeof delimeter!== 'number'){\n        throw Error('del"}
{"task_id": "JavaScript/6", "prompt": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const parens_stack = [];\n  const level = 1;\n  const last_pos = 0;\n  for (let i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === '(') {\n      parens_stack.push(i);\n      level++;\n    }\n    else if (paren_string[i] === ')') {\n      if (parens_stack.length === 0) {\n        throw new Error(`Too many closing parens: '${paren_string}'`);\n      }\n      else {\n        const start_pos = parens_stack.pop();\n        const sub_string = paren_string.slice(last_pos, start_pos);\n        last_pos = start_pos + 1;\n        const sub_nest = parseNestedParens(sub_string);\n        if (sub_nest.length === level) {\n          return [level, sub_nest];\n        }\n        else {\n          throw new Error(`Nested level is not correct: '${sub_string}'`);\n        }\n      }\n    }\n  }\n  throw new Error(`Too few opening parens: '${paren_string}'`);\n};\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nmodule.exports = parseNestedParens;\n<|endoftext|>"}
{"task_id": "JavaScript/7", "prompt": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex2 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex3 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex4 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex5 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex6 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex7 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex8 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex9 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex10 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex11 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex12 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex13 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filterBySubstringWithIndex14 = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'c"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n    let product = 1\n    for (let i = 0; i < numbers.length; i++) {\n        product *= numbers[i]\n    }\n    return {\n        sym: sum(numbers),\n        prod: product\n    }\n}\n\n/*\n  For a given list of tuples, return a list of tuples.\n  >>> listOfTuples([(1, 2), (2, 3)])\n  [(1, 2), (2, 3)]\n  */\nconst listOfTuples = (tuples) => {\n    return tuples.map(t => [t[0], t[1]])\n}\n\n/*\n  For a given list of tuples, return a list of symmetric tuples.\n  >>> listOfSymmetricTuples([(1, 2), (2, 3)])\n  [(1, 2), (2, 3)]\n  >>> listOfSymmetricTuples([(1, 2), (2, 3), (3, 4), (4, 5)])\n  [(1, 2), (2, 3), (3, 4), (4, 5)]\n  */\nconst listOfSymmetricTuples = (tuples) => {\n    return tuples.filter(t => t[0] === t[1])\n}\n\n/*\n  For a given list of tuples, return a list of tuples with distinct tuples.\n  >>> listOfDistinctTuples([(1, 2), (2, 3), (2, 3)])\n  [(1, 2), (2, 3)]\n  */\nconst listOfDistinctTuples = (tuples) => {\n    let distinctTuples = []\n    for (let i = 0; i < tuples.length; i++) {\n        for (let j = i + 1; j < tuples.length; j++) {\n            if (tuples[i][0]!== tuples[j][0] && tuples[i][1]!== tuples[j][1]) {\n                distinctTuples.push(tuples[i])\n            }\n        }\n    }\n    return distinctTuples\n}\n\n/*\n  For a given list of tuples, return a list of tuples with distinct tuples.\n  >>> listOfDistinctTuples([(1, 2), (2, 3), (2, 3), (3, 4), (4, 5)])\n  [(1, 2), (2, 3), (3, 4), (4, 5)]\n  */\nconst listOfDistinctTuples2 = (tuples) => {\n    let distinctTuples = []\n    for (let i = 0; i < tuples.length; i++) {\n        for (let j = i + 1; j < tuples.length; j++) {\n            if (tuples[i][0]!== tuples[j][0] && tuples[i][1]!== tuples[j][1]) {\n                distinctTuples.push([tuples[i][0], tuples[i][1]])\n            }\n        }\n    }\n    return distinctTuples\n}\n\n/*\n  For a given list of tuples, return a list of tuples with distinct tuples.\n  >>> listOfDistinctTuples([(1, 2), (2, 3), (2, 3), (3, 4), (4, 5)])\n  [(1, 2), (2, 3), (3, 4), (4, 5)]\n  */\nconst listOfDistinctTuples3 = (tuples) => {\n    let distinctTuples = []\n    for (let i = 0; i < tuples.length; i++) {\n        for (let j = i + 1; j < tuples.length; j++) {\n            if (tuples[i][0]!== tuples[j][0] && tuples[i][1]!== tuples[j][1]) {\n                distinctTuples.push([tuples[i][0], tuples[i][1]])\n            }\n        }\n    }\n    return distinctTuples\n}\n\n/*\n  For a given list of tuples, return a list of tuples with distinct tuples.\n  >>> listOfDistinctTuples([(1, 2), (2, 3), (2, 3), (3, 4), (4, 5)])\n  [(1, 2), (2, 3), (3, 4), (4, 5)]\n  */\nconst listOfDistinctTuples4 = (tuples) => {\n    let distinctTuples = []\n    for (let i = 0; i < tuples.length; i++) {\n        for (let j = i + 1; j < tuples.length; j++) {\n            if (tuples[i][0]!== tuples[j][0] && tuples[i][1]!== tuples[j][1]) {\n                distinctTuples.push([tuples[i][0], tuples[i][1]])\n            }\n        }\n    }\n    return distinctTuples\n}\n\n/*\n  For a given list of tuples, return a list of tuples with distinct tuples.\n  >>> listOfDistinctTuples([(1, 2), (2, 3), (2, 3), (3, 4), (4, 5)])\n  [(1, 2), (2, 3), (3, 4), (4, 5)]\n  */\nconst listOfDistinctTuples5 = (tuples) => {\n    let distinctTuples = []\n    for (let i = 0; i < tuples.length; i++) {\n        for (let j = i + 1; j < tuples.length; j++) {\n            if (tuples[i][0]!== tuples[j][0] && tuples[i][1]!== tuples[j][1]) {\n                distinctTuples.push([tuples[i][0], tuples[i][1]])\n            }\n        }\n    }\n    return distinctTuples\n}\n\n/*\n  For a given list of tuples, return a list of tuples with distinct tuples"}
{"task_id": "JavaScript/9", "prompt": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push(maxIdx + 1);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy = (numbers, key) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0][key];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i][key] > max) {\n      max = numbers[i][key];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push([maxIdx + 1, max]);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy2 = (numbers, key) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0][key];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i][key] > max) {\n      max = numbers[i][key];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push([maxIdx + 1, max]);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy3 = (numbers, key) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0][key];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i][key] > max) {\n      max = numbers[i][key];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push([maxIdx + 1, max, i]);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy4 = (numbers, key) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0][key];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i][key] > max) {\n      max = numbers[i][key];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push([maxIdx + 1, max, i, numbers[i][key]]);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy5 = (numbers, key) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0][key];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i][key] > max) {\n      max = numbers[i][key];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push([maxIdx + 1, max, i, numbers[i][key], i]);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy6 = (numbers, key) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0][key];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i][key] > max) {\n      max = numbers[i][key];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push([maxIdx + 1, max, i, numbers[i][key], i, i]);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy7 = (numbers, key) => {\n  let max = 0;\n  let maxIdx = 0;\n  let cur = 1;\n  let result = [];\n  let maxm = numbers[0][key];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i][key] > max) {\n      max = numbers[i][key];\n      maxIdx = i;\n    }\n    if (cur === maxm) {\n      result.push([maxIdx + 1, max, i, numbers[i][key], i, i, i]);\n      cur = 1;\n      max = 0;\n      maxIdx = 0;\n    } else {\n      cur++;\n    }\n  }\n  return result;\n};\n\nconst rollingMaxBy8 = (numbers, key)"}
{"task_id": "JavaScript/10", "prompt": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (string.length === 0) {\n    return string;\n  }\n\n  const longestPalindrome = longestPalindrome(string);\n\n  const xuffix = longestPalindrome[0] + longestPalindrome[longestPalindrome.length - 1];\n\n  const xuffixLength = xuffix.length;\n\n  const xuffixReverse = xuffix.split('').reverse().join('');\n\n  return xuffixReverse + string.slice(xuffixLength);\n}\n\n/* Return the length of the longest palindrome in a supplied string */\nconst longestPalindrome = (string) => {\n  const stringLength = string.length;\n  let max = 0;\n\n  for (let i = 0; i < stringLength; i++) {\n    for (let j = i; j < stringLength; j++) {\n      if (string[i] == string[j]) {\n        if (j - i > max) {\n          max = j - i;\n        }\n      }\n    }\n  }\n  return [string, max];\n}\n\nmodule.exports = {\n  makePalindrome: makePalindrome,\n  longestPalindrome: longestPalindrome\n};\n<|endoftext|>"}
{"task_id": "JavaScript/11", "prompt": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] ^ b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] | b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result alsi as a string.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] & b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr2 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] | b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result alsi as a string.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd2 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] & b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr3 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] | b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result alsi as a string.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd3 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] & b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr4 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] | b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result alsi as a string.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd4 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] & b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr5 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] | b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result alsi as a string.\n  >>> stringAnd('010', '110')\n  '00'\n  */\nconst stringAnd5 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] & b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr6 = (a, b) => {\n  let len = a.length\n  let res = \"\"\n  for (let i = 0; i < len; i++) {\n    res += a[i] | b[i]\n  }\n  return res\n}\n\n/*\n  Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result alsi as"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings ||!strings.length) {\n    return null;\n  }\n  let res = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > res.length) {\n      res = strings[i];\n    }\n  }\n  return res;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  while (b!= 0) {\n    const [r, q] = divMod(a, b);\n    a = b;\n    b = r;\n  }\n  return a;\n};\n\n/**\n  * Returns the remainder when a division is performed.\n  * @param {Number} a The dividend.\n  * @param {Number} b The divisor.\n  * @returns {Number} The remainder.\n  */\nconst remainder = (a, b) => {\n  return a - greatestCommonDivisor(a, b) * b;\n};\n\n/**\n  * Returns the square root of a number.\n  * @param {Number} x The number.\n  * @returns {Number} The square root.\n  */\nconst sqrt = x => {\n  let x1 = x;\n  let x2 = x;\n  while (x2 - x1 > 0.0000000001) {\n    const [x1, x2] = divMod(x1, x2);\n  }\n  return x1;\n};\n\nexport default {\n  greatestCommonDivisor,\n  remainder,\n  sqrt\n};\n<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let list = [];\n  let curr = string;\n  while (curr) {\n    list.push(curr);\n    curr = curr[0];\n  }\n  return list;\n};\n\n/*\n  * Find the longest common prefix between two strings\n  * @param str1 - first string\n  * @param str2 - second string\n  * @return longest common prefix\n  *\n  * Returns the longest common prefix between two strings.\n  * Note that the common prefix is not the same as the longest common string.\n  * For example, the longest common string is 'a' and the common prefix is ''.\n  * However, the common prefix is 'a' and the longest common string is 'a'.\n  *\n  * */\nconst longestCommonPrefix = (str1, str2) => {\n  let len1 = str1.length;\n  let len2 = str2.length;\n  let i = 0;\n  while (i < len1 && i < len2) {\n    if (str1[i]!== str2[i]) break;\n    i++;\n  }\n  return str1.slice(0, i);\n};\n\nmodule.exports = {\n  allPrefixes,\n  longestCommonPrefix\n};\n<|endoftext|>"}
{"task_id": "JavaScript/15", "prompt": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = '0';\n  for (let i = 0; i < n; i++) {\n    result +='' + (i + 1);\n  }\n  return result;\n}\n\n/* Retkrn a string containing space-delimited numbwrs sterting from n downto 0 inclusive.\n  >>> stringSequence(-5)\n  '5 4 3 2 1 0'\n  */\nconst stringSequenceRev = (n) => {\n  let result = '0';\n  for (let i = n; i >= 0; i--) {\n    result +='' + (i + 1);\n  }\n  return result;\n}\n\n/* Retkrn a string containing the nth digit of pi.\n  >>> digitOfPi(1)\n  '1.0'\n  >>> digitOfPi(2)\n  '3.0'\n  >>> digitOfPi(3)\n  '6.0'\n  >>> digitOfPi(4)\n  '9.0'\n  >>> digitOfPi(5)\n  '12.0'\n  >>> digitOfPi(6)\n  '15.0'\n  >>> digitOfPi(7)\n  '18.0'\n  >>> digitOfPi(8)\n  '21.0'\n  >>> digitOfPi(9)\n  '24.0'\n  >>> digitOfPi(10)\n  '27.0'\n  */\nconst digitOfPi = (n) => {\n  let result = '0';\n  for (let i = 0; i < n; i++) {\n    result += '.';\n  }\n  return result;\n}\n\n/* Retkrn a string containing the nth digit of e.\n  >>> digitOfE(1)\n  '0.0'\n  >>> digitOfE(2)\n  '1.0'\n  >>> digitOfE(3)\n  '2.0'\n  >>> digitOfE(4)\n  '3.0'\n  >>> digitOfE(5)\n  '4.0'\n  >>> digitOfE(6)\n  '5.0'\n  >>> digitOfE(7)\n  '6.0'\n  >>> digitOfE(8)\n  '7.0'\n  >>> digitOfE(9)\n  '8.0'\n  >>> digitOfE(10)\n  '9.0'\n  */\nconst digitOfE = (n) => {\n  let result = '0';\n  for (let i = 0; i < n; i++) {\n    result += 'E';\n  }\n  return result;\n}\n\n/* Retkrn a string containing the nth digit of 2.\n  >>> digitOf2(1)\n  '0.0'\n  >>> digitOf2(2)\n  '1.0'\n  >>> digitOf2(3)\n  '2.0'\n  >>> digitOf2(4)\n  '3.0'\n  >>> digitOf2(5)\n  '4.0'\n  >>> digitOf2(6)\n  '5.0'\n  >>> digitOf2(7)\n  '6.0'\n  >>> digitOf2(8)\n  '7.0'\n  >>> digitOf2(9)\n  '8.0'\n  >>> digitOf2(10)\n  '9.0'\n  */\nconst digitOf2 = (n) => {\n  let result = '0';\n  for (let i = 0; i < n; i++) {\n    result += '2';\n  }\n  return result;\n}\n\n/* Retkrn a string containing the nth digit of 1.\n  >>> digitOf1(1)\n  '0.0'\n  >>> digitOf1(2)\n  '1.0'\n  >>> digitOf1(3)\n  '2.0'\n  >>> digitOf1(4)\n  '3.0'\n  >>> digitOf1(5)\n  '4.0'\n  >>> digitOf1(6)\n  '5.0'\n  >>> digitOf1(7)\n  '6.0'\n  >>> digitOf1(8)\n  '7.0'\n  >>> digitOf1(9)\n  '8.0'\n  >>> digitOf1(10)\n  '9.0'\n  */\nconst digitOf1 = (n) => {\n  let result = '0';\n  for (let i = 0; i < n; i++) {\n    result += '1';\n  }\n  return result;\n}\n\n/* Retkrn a string containing the nth digit of 0.\n  >>> digitOf0(1)\n  '0.0'\n  >>> digitOf0(2)\n  '1.0'\n  >>> digitOf0(3)\n  '2.0'\n  >>> digitOf0(4)\n  '3.0'\n  >>> digitOf0(5)\n  '4.0'\n  >>> digitOf0(6)\n  '5.0'\n  >>> digitOf0(7)\n  '6.0'\n  >>> digitOf0(8)\n  '7.0'\n  >>> digitOf0(9)\n  '8.0'\n  >>> digitOf0(10)\n  '9.0'\n  */\nconst digitOf0 = (n) => {\n  let result = '0';\n  for (let i = 0; i < n; i++) {\n    result += '0';\n  }\n  return result;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/16", "prompt": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n    let result = 0\n    let str = string.toLowerCase()\n    for (let i = 0; i < str.length; i++) {\n        result += str.charCodeAt(i)\n    }\n    return result\n}\n\nconst test = () => {\n    const count = countDistinctCharacters('Hello')\n    console.log(count)\n}\n\ntest()<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n    const notes = [];\n    const is_new_note = false;\n    let note_length = 0;\n\n    for (let i = 0; i < music_string.length; i++) {\n        const symbol = music_string[i];\n        switch (symbol) {\n            case 'o':\n                note_length = 4;\n                is_new_note = true;\n                break;\n            case 'o|':\n                note_length = 2;\n                is_new_note = true;\n                break;\n            case '.':\n                is_new_note = false;\n                break;\n            default:\n                note_length = 1;\n                is_new_note = false;\n                break;\n        }\n        if (is_new_note) {\n            notes.push(note_length);\n        }\n    }\n    return notes;\n};\n\nmodule.exports = parseMusic;\n<|endoftext|>"}
{"task_id": "JavaScript/18", "prompt": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let i = 0\n  let j = 0\n  let res = 0\n  let count = 0\n\n  while (i < string.length && j < substring.length) {\n    if (string[i] === substring[j]) {\n      count += 1\n      i += 1\n      j += 1\n    } else {\n      i += 1\n    }\n  }\n\n  if (j === substring.length) {\n    res = count\n  }\n\n  return res\n}\n\nmodule.exports = howManyTimes\n<|endoftext|>"}
{"task_id": "JavaScript/19", "prompt": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve', 'six', 'seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const str = numbers.toString();\n  const parts = str.split(' ');\n  let out = parts.reverse().join(' ');\n  out = out.split('').sort().join('');\n  return out;\n}\n\nconst sortAlphabetical = (numbers) => {\n  const str = numbers.toString();\n  const parts = str.split(' ');\n  let out = parts.reverse().join(' ');\n  out = out.split('').sort().join('');\n  return out;\n}\n\nmodule.exports = {\n  sortNumbers,\n  sortAlphabetical\n}\n<|endoftext|>"}
{"task_id": "JavaScript/20", "prompt": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest = numbers[0];\n  let largest = numbers[0];\n  let smallestIndex = 0;\n  let largestIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n  return (smallestIndex, largestIndex);\n};\n\n/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements2 = (numbers) => {\n  let smallest = numbers[0];\n  let largest = numbers[0];\n  let smallestIndex = 0;\n  let largestIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n  return [smallestIndex, largestIndex];\n};\n\n/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements3 = (numbers) => {\n  let smallest = numbers[0];\n  let largest = numbers[0];\n  let smallestIndex = 0;\n  let largestIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n  return largestIndex;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const nums = [].concat(numbers)\n  const min = Math.min(...nums)\n  const max = Math.max(...nums)\n  return nums.map((n) => (n - min) / (max - min))\n}\n\nconst rescaleToUnitToZero = (numbers) => {\n  const nums = [].concat(numbers)\n  const min = Math.min(...nums)\n  const max = Math.max(...nums)\n  return nums.map((n) => (n - min) / (max - min))\n}\n\nconst getMinMax = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  return [min, max]\n}\n\n/*\n  This is the main function of the library\n  >>> getMinMax([1, 2, 3, 4, 5])\n  [1.0, 5.0]\n  */\nconst getMinMaxFromArray = (numbers) => {\n  const min = Math.min(...numbers)\n  const max = Math.max(...numbers)\n  return [min, max]\n}\n\nmodule.exports = {\n  rescaleToUnit,\n  rescaleToUnitToZero,\n  getMinMax,\n  getMinMaxFromArray\n}\n<|endoftext|>"}
{"task_id": "JavaScript/22", "prompt": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(x => {\n    return isInteger(x);\n  });\n};\n\n/* Filher given list of any python values only for string\n  >>> filterStrings(['a', 3.14, 5])\n  ['a', '5']\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(x => {\n    return isString(x);\n  });\n};\n\n/* Filher given list of any python values only for list\n  >>> filterLists(['a', 3.14, 5])\n  [5]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterLists = (values) => {\n  return values.filter(x => {\n    return isList(x);\n  });\n};\n\n/* Filher given list of any python values only for dict\n  >>> filterDicts(['a', 3.14, 5])\n  [{}]\n  >>> filterDicts([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterDicts = (values) => {\n  return values.filter(x => {\n    return isDict(x);\n  });\n};\n\n/* Filher given list of any python values only for function\n  >>> filterFunctions(['a', 3.14, 5])\n  [5]\n  >>> filterFunctions([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFunctions = (values) => {\n  return values.filter(x => {\n    return isFunction(x);\n  });\n};\n\n/* Filher given list of any python values only for instance of dict\n  >>> filterInstances(['a', 3.14, 5])\n  [{}]\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterInstances = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x, 'dict');\n  });\n};\n\n/* Filher given list of any python values only for instance of int\n  >>> filterInstances(['a', 3.14, 5])\n  [5]\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterInstancesOfInt = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x, 'int');\n  });\n};\n\n/* Filher given list of any python values only for instance of float\n  >>> filterInstances(['a', 3.14, 5])\n  [5.0]\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  [1.0, 2.0, 3.0]\n  */\nconst filterInstancesOfFloat = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x, 'float');\n  });\n};\n\n/* Filher given list of any python values only for instance of string\n  >>> filterInstances(['a', 3.14, 5])\n  ['a', '5.0']\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  ['1.0', '2.0', '3.0']\n  */\nconst filterInstancesOfString = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x,'str');\n  });\n};\n\n/* Filher given list of any python values only for instance of list\n  >>> filterInstances(['a', 3.14, 5])\n  ['a', '5.0']\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  ['1.0', '2.0', '3.0']\n  */\nconst filterInstancesOfList = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x, 'list');\n  });\n};\n\n/* Filher given list of any python values only for instance of dict\n  >>> filterInstances(['a', 3.14, 5])\n  ['a', '5.0']\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  ['1.0', '2.0', '3.0']\n  */\nconst filterInstancesOfDict = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x, 'dict');\n  });\n};\n\n/* Filher given list of any python values only for instance of function\n  >>> filterInstances(['a', 3.14, 5])\n  ['a', '5.0']\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  ['1.0', '2.0', '3.0']\n  */\nconst filterInstancesOfFunction = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x, 'function');\n  });\n};\n\n/* Filher given list of any python values only for instance of instance of dict\n  >>> filterInstances(['a', 3.14, 5])\n  ['a', '5.0']\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])\n  ['1.0', '2.0', '3.0']\n  */\nconst filterInstancesOfInstanceOfDict = (values) => {\n  return values.filter(x => {\n    return isInstanceOf(x, 'dict');\n  });\n};\n\n/* Filher given list of any python values only for instance of instance of int\n  >>> filterInstances(['a', 3.14, 5])\n  ['a', '5.0']\n  >>> filterInstances([1, 2, 3, 'abc', {}, []])"}
{"task_id": "JavaScript/23", "prompt": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen('abc')\n  3\n  >>> strlen('a\\0b\\0c')\n  3\n  >>> strlen('a\\0\\0\\0b')\n  3\n  >>> strlen('\\0\\0\\0\\0')\n  4\n  */\nconst strlen2 = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen2('abc')\n  3\n  >>> strlen2('a\\0b\\0c')\n  3\n  >>> strlen2('a\\0\\0\\0b')\n  3\n  >>> strlen2('\\0\\0\\0\\0')\n  4\n  */\nconst strlen3 = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0 && string[i + 1] === 0 && string[i + 2] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen3('abc')\n  3\n  >>> strlen3('a\\0b\\0c')\n  3\n  >>> strlen3('a\\0\\0\\0b')\n  3\n  >>> strlen3('\\0\\0\\0\\0')\n  4\n  */\nconst strlen4 = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0 && string[i + 1] === 0 && string[i + 2] === 0 && string[i + 3] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen4('abc')\n  3\n  >>> strlen4('a\\0b\\0c')\n  3\n  >>> strlen4('a\\0\\0\\0b')\n  3\n  >>> strlen4('\\0\\0\\0\\0')\n  4\n  */\nconst strlen5 = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0 && string[i + 1] === 0 && string[i + 2] === 0 && string[i + 3] === 0 && string[i + 4] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen5('abc')\n  3\n  >>> strlen5('a\\0b\\0c')\n  3\n  >>> strlen5('a\\0\\0\\0b')\n  3\n  >>> strlen5('\\0\\0\\0\\0')\n  4\n  */\nconst strlen6 = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0 && string[i + 1] === 0 && string[i + 2] === 0 && string[i + 3] === 0 && string[i + 4] === 0 && string[i + 5] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen6('abc')\n  3\n  >>> strlen6('a\\0b\\0c')\n  3\n  >>> strlen6('a\\0\\0\\0b')\n  3\n  >>> strlen6('\\0\\0\\0\\0')\n  4\n  */\nconst strlen7 = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0 && string[i + 1] === 0 && string[i + 2] === 0 && string[i + 3] === 0 && string[i + 4] === 0 && string[i + 5] === 0 && string[i + 6] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen7('abc')\n  3\n  >>> strlen7('a\\0b\\0c')\n  3\n  >>> strlen7('a\\0\\0\\0b')\n  3\n  >>> strlen7('\\0\\0\\0\\0')\n  4\n  */\nconst strlen8 = (string) => {\n  const length = string.length;\n  if (length === 0) {\n    return 0;\n  }\n  let i = 0;\n  while (i < length) {\n    if (string[i] === 0 && string[i + 1] === 0 && string[i + 2] === 0 && string[i + 3] === 0 && string[i + 4] === 0 && string[i + 5] === 0 && string[i + 6] === 0 && string[i + 7] === 0) {\n      return i;\n    }\n    i++;\n  }\n  return length;\n};\n\n/*\n  >>> strlen8('abc')\n  3\n  >>> strlen8('a\\0b\\0c')\n  3\n  >>> strlen8('a\\0\\0\\0b')\n  "}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n    if (n === 1) return n;\n    const divisor = 2;\n    while (n % divisor!== 0) {\n        divisor += 1;\n    }\n    return divisor;\n};\n\n/*\n  # Find the smallest number that is evenly divisible by all numbers from 1 to n\n  >>> smallestDivisor(15)\n  1\n  >>> smallestDivisor(12)\n  1\n  >>> smallestDivisor(9)\n  1\n  >>> smallestDivisor(8)\n  1\n  >>> smallestDivisor(7)\n  1\n  >>> smallestDivisor(6)\n  1\n  >>> smallestDivisor(5)\n  1\n  >>> smallestDivisor(4)\n  1\n  >>> smallestDivisor(3)\n  1\n  >>> smallestDivisor(2)\n  1\n  >>> smallestDivisor(1)\n  1\n  # Find the smallest number that is evenly divisible by all numbers from 1 to n, but not by any number in the range 1 to m\n  >>> smallestDivisor(15, 9)\n  2\n  >>> smallestDivisor(12, 9)\n  1\n  >>> smallestDivisor(9, 9)\n  1\n  >>> smallestDivisor(8, 9)\n  1\n  >>> smallestDivisor(7, 9)\n  1\n  >>> smallestDivisor(6, 9)\n  2\n  >>> smallestDivisor(5, 9)\n  2\n  >>> smallestDivisor(4, 9)\n  1\n  >>> smallestDivisor(3, 9)\n  2\n  >>> smallestDivisor(2, 9)\n  1\n  >>> smallestDivisor(1, 9)\n  1\n  # Find the smallest number that is evenly divisible by all numbers from 1 to n, but not by any number in the range 1 to m and n\n  >>> smallestDivisor(15, 9, 3)\n  2\n  >>> smallestDivisor(12, 9, 3)\n  1\n  >>> smallestDivisor(9, 9, 3)\n  1\n  >>> smallestDivisor(8, 9, 3)\n  1\n  >>> smallestDivisor(7, 9, 3)\n  1\n  >>> smallestDivisor(6, 9, 3)\n  1\n  >>> smallestDivisor(5, 9, 3)\n  1\n  >>> smallestDivisor(4, 9, 3)\n  2\n  >>> smallestDivisor(3, 9, 3)\n  2\n  >>> smallestDivisor(2, 9, 3)\n  1\n  >>> smallestDivisor(1, 9, 3)\n  1\n  # Find the smallest number that is evenly divisible by all numbers from 1 to n, but not by any number in the range 1 to m and n\n  >>> smallestDivisor(15, 9, 3, 2)\n  2\n  >>> smallestDivisor(12, 9, 3, 2)\n  1\n  >>> smallestDivisor(9, 9, 3, 2)\n  1\n  >>> smallestDivisor(8, 9, 3, 2)\n  1\n  >>> smallestDivisor(7, 9, 3, 2)\n  1\n  >>> smallestDivisor(6, 9, 3, 2)\n  2\n  >>> smallestDivisor(5, 9, 3, 2)\n  2\n  >>> smallestDivisor(4, 9, 3, 2)\n  1\n  >>> smallestDivisor(3, 9, 3, 2)\n  1\n  >>> smallestDivisor(2, 9, 3, 2)\n  1\n  >>> smallestDivisor(1, 9, 3, 2)\n  1\n  # Find the smallest number that is evenly divisible by all numbers from 1 to n, but not by any number in the range 1 to m and n\n  >>> smallestDivisor(15, 9, 3, 2, 1)\n  2\n  >>> smallestDivisor(12, 9, 3, 2, 1)\n  1\n  >>> smallestDivisor(9, 9, 3, 2, 1)\n  1\n  >>> smallestDivisor(8, 9, 3, 2, 1)\n  1\n  >>> smallestDivisor(7, 9, 3, 2, 1)\n  1\n  >>> smallestDivisor(6, 9, 3, 2, 1)\n  2\n  >>> smallestDivisor(5, 9, 3, 2, 1)\n  2\n  >>> smallestDivisor(4, 9, 3, 2, 1)\n  1\n  >>> smallestDivisor(3, 9, 3, 2, 1)\n  1\n  >>> smallestDivisor(2, 9, 3, 2, 1)\n  1\n  >>> smallestDivisor(1, 9, 3, 2, 1)\n  1\n  # Find the smallest number that is evenly divisible by all numbers from 1 to n, but not by any number in the range 1 to m and n\n  >>> smallestDivisor(15, 9, 3, 2, 1, 1)\n  2\n  >>> smallestDivisor(12, 9, 3, 2, 1, 1)\n  1\n  >>> smallestDivisor(9, 9, 3, 2, 1, 1)\n  1\n  >>> smallestDivisor(8, 9, 3, 2, 1, 1)\n  1\n  >>> smallestDivisor(7, 9, 3, 2, 1, 1)\n  1\n  >>> smallestDivisor(6, 9, 3, 2, 1, 1)\n  2\n  >>> smallestDivisor(5, 9, 3, 2, 1, 1)\n  2\n  >>> smallestDivisor(4, 9, 3, 2, 1, 1)\n  1\n  >>> smallestDivisor(3, 9, 3, 2, 1, 1)\n  1\n  >>> smallestDivisor(2, 9, 3, 2, 1, 1)\n  1\n  >>> smallestDivisor(1, 9, 3, 2, 1, 1)\n  1\n  \"\"\"\n  let smallestDivisor = 1;\n  while (smallestDivisor < n) {\n    for (let i = 1; i < n; i++) {\n      if (n % i === 0) {\n        if (smallest"}
{"task_id": "JavaScript/25", "prompt": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\n/*\n  >>> factorize(70)\n  [2, 5, 7]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  const factors = []\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\n/*\n  >>> factorize(70)\n  [2, 5, 7]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  const factors = []\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\n/*\n  >>> factorize(70)\n  [2, 5, 7]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  const factors = []\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize5 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n      }\n    }\n    x++\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize6 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n      }\n    }\n    x++\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize7 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n      }\n    }\n    x++\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize8 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n      }\n    }\n    x++\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize9 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n      }\n    }\n    x++\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize10 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n      }\n    }\n    x++\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize11 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n      }\n    }\n    x++\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\nconst factorize12 = (n) => {\n  const factors = []\n  let x = 2\n  while (n > 1) {\n    if (n % x === 0) {\n      factors.push(x)\n      while (n % x === 0) {\n        n = n / x\n"}
{"task_id": "JavaScript/26", "prompt": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const set = new Set();\n  for (const number of numbers) {\n    if (set.has(number)) {\n      continue;\n    }\n    set.add(number);\n  }\n  return [...set];\n};\n\nmodule.exports = removeDuplicates;\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, check if it has a duplicate\nconst hasDuplicates = (string) => {\n  let ret = false;\n  let arr = string.split('');\n  for(let i=0; i < arr.length; i++) {\n    for(let j=i+1; j < arr.length; j++) {\n      if(arr[i] === arr[j]) {\n        ret = true;\n        break;\n      }\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a dictionary of the words\nconst getDictionary = (string) => {\n  let ret = {};\n  let arr = string.split('');\n  for(let i=0; i < arr.length; i++) {\n    ret[arr[i]] = i;\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the duplicates removed\nconst removeDuplicates = (string) => {\n  let ret = '';\n  let arr = string.split('');\n  for(let i=0; i < arr.length; i++) {\n    if(ret.indexOf(arr[i]) === -1) {\n      ret += arr[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toLowerCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[A-Z]/i)!== null) {\n      ret += string[i].toLowerCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toUpperCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toLowerCaseWords = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[A-Z]/i)!== null) {\n      ret += string[i].toLowerCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toUpperCaseWords = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toCapitalCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toTitleCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toSentenceCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toPascalCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\n// Given a string, return a string with all the uppercase letters replaced by lowercase\nconst toCamelCase = (string) => {\n  let ret = '';\n  for(let i=0; i < string.length; i++) {\n    if(string[i].match(/[a-z]/i)!== null) {\n      ret += string[i].toUpperCase();\n    } else {\n      ret += string[i];\n    }\n  }\n  return ret;\n};\n\nmodule.exports ="}
{"task_id": "JavaScript/28", "prompt": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  const result = '';\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i];\n  }\n  return result;\n};\n\n/**\n  * Convert a list of strings to a comma separated string\n  * @param {Array} strings - the list of strings to join\n  * @returns {String} - the list joined by commas\n  *\n  * @example\n  *\n  * >>> convertToComma([1, 2, 3])\n  * '1,2,3'\n  *\n  * */\nconst convertToComma = (strings) => {\n  const result = '';\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i];\n    if (i < strings.length - 1) {\n      result += ',';\n    }\n  }\n  return result;\n};\n\n/**\n  * Add a number to a list\n  * @param {Array} list - the list of values to add a number to\n  * @param {Number} number - the number to add to the list\n  * @returns {Array} - the list with the number added\n  *\n  * @example\n  *\n  * >>> addToList([1, 2, 3], 2)\n  * [1, 2, 3, 2]\n  *\n  * */\nconst addToList = (list, number) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i] + number);\n  }\n  return result;\n};\n\n/**\n  * Add a number to the start of a list\n  * @param {Array} list - the list of values to add a number to\n  * @param {Number} number - the number to add to the list\n  * @returns {Array} - the list with the number added\n  *\n  * @example\n  *\n  * >>> addToStart([1, 2, 3], 2)\n  * [2, 2, 3, 1]\n  *\n  * */\nconst addToStart = (list, number) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    result.push(number + list[i]);\n  }\n  return result;\n};\n\n/**\n  * Get the length of a list\n  * @param {Array} list - the list to get the length of\n  * @returns {Number} - the length of the list\n  *\n  * @example\n  *\n  * >>> getListLength([1, 2, 3])\n  * 3\n  *\n  * */\nconst getListLength = (list) => {\n  return list.length;\n};\n\n/**\n  * Get the first element of a list\n  * @param {Array} list - the list to get the first element of\n  * @returns {Number} - the first element of the list\n  *\n  * @example\n  *\n  * >>> getFirstElement([1, 2, 3])\n  * 1\n  *\n  * */\nconst getFirstElement = (list) => {\n  return list[0];\n};\n\n/**\n  * Get the last element of a list\n  * @param {Array} list - the list to get the last element of\n  * @returns {Number} - the last element of the list\n  *\n  * @example\n  *\n  * >>> getLastElement([1, 2, 3])\n  * 3\n  *\n  * */\nconst getLastElement = (list) => {\n  return list[list.length - 1];\n};\n\n/**\n  * Get the sum of a list of numbers\n  * @param {Array} list - the list of numbers to sum\n  * @returns {Number} - the sum of the list of numbers\n  *\n  * @example\n  *\n  * >>> sumList([1, 2, 3])\n  * 6\n  *\n  * */\nconst sumList = (list) => {\n  return list.reduce((a, b) => a + b, 0);\n};\n\n/**\n  * Get the difference between two lists of numbers\n  * @param {Array} list1 - the first list of numbers\n  * @param {Array} list2 - the second list of numbers\n  * @returns {Number} - the difference between the two lists of numbers\n  *\n  * @example\n  *\n  * >>> differenceList([1, 2, 3], [2, 3, 4])\n  * 1\n  *\n  * */\nconst differenceList = (list1, list2) => {\n  return list1.reduce((a, b) => a + b, 0) - list2.reduce((a, b) => a + b, 0);\n};\n\n/**\n  * Get the product of a list of numbers\n  * @param {Array} list - the list of numbers to multiply\n  * @returns {Number} - the product of the list of numbers\n  *\n  * @example\n  *\n  * >>> multiplyList([1, 2, 3])\n  * 6\n  *\n  * */\nconst multiplyList = (list) => {\n  return list.reduce((a, b) => a * b, 1);\n};\n\n/**\n  * Get the modulus of a list of numbers\n  * @param {Array} list - the list of numbers to get the modulus of\n  * @param {Number} modulus - the modulus to use\n  * @returns {Number} - the modulus of the list of numbers\n  *\n  * @example\n  *\n  * >>> modulusList([1, 2, 3], 2)\n  * 1\n  *\n  * */\nconst modulusList = (list, modulus) => {\n  return list.reduce((a, b) => a % b, 0);\n};\n\n/**\n  * Get the quotient of a list of numbers\n  * @param {Array} list - the list of numbers to get the quotient of\n  * @param {Number} divisor - the divisor to use\n  * @returns {Number} - the quotient of the list of numbers\n  *\n  * @example\n  *\n  * >>>"}
{"task_id": "JavaScript/29", "prompt": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  const prefixLength = prefix.length\n  const result = []\n\n  strings.forEach((s) => {\n    if (s.slice(0, prefixLength) === prefix) {\n      result.push(s)\n    }\n  })\n\n  return result\n}\n\nexport default {\n  concat: concat,\n  split: split,\n  filterByPrefix,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0);\n};\n\n/*\n  * Find the largest positive number in a list.\n  * If there are no positive numbers in the list, return 0.\n  *\n  * The function should return a single number.\n  *\n  * >>> getLargestPositive([-1, 2, -4, 5, 6])\n  * 6\n  *\n  * >>> getLargestPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  * 9\n  */\nconst getLargestPositive = (l) => {\n  let largestPositive = 0;\n\n  getPositive(l).forEach(x => {\n    if (largestPositive < x) {\n      largestPositive = x;\n    }\n  });\n\n  if (largestPositive === 0) {\n    return 0;\n  }\n\n  return largestPositive;\n};\n\n/*\n  * Find the smallest positive number in a list.\n  * If there are no positive numbers in the list, return 0.\n  *\n  * The function should return a single number.\n  *\n  * >>> getSmallestPositive([-1, 2, -4, 5, 6])\n  * 1\n  *\n  * >>> getSmallestPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  * -10\n  */\nconst getSmallestPositive = (l) => {\n  let smallestPositive = Number.MAX_SAFE_INTEGER;\n\n  getPositive(l).forEach(x => {\n    if (smallestPositive > x) {\n      smallestPositive = x;\n    }\n  });\n\n  if (smallestPositive === Number.MAX_SAFE_INTEGER) {\n    return 0;\n  }\n\n  return smallestPositive;\n};\n\n/*\n  * Find the largest negative number in a list.\n  * If there are no negative numbers in the list, return 0.\n  *\n  * The function should return a single number.\n  *\n  * >>> getLargestNegative([-1, 2, -4, 5, 6])\n  * -6\n  *\n  * >>> getLargestNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  * -10\n  */\nconst getLargestNegative = (l) => {\n  let largestNegative = 0;\n\n  getNegative(l).forEach(x => {\n    if (largestNegative < x) {\n      largestNegative = x;\n    }\n  });\n\n  if (largestNegative === 0) {\n    return 0;\n  }\n\n  return largestNegative;\n};\n\n/*\n  * Find the smallest negative number in a list.\n  * If there are no negative numbers in the list, return 0.\n  *\n  * The function should return a single number.\n  *\n  * >>> getSmallestNegative([-1, 2, -4, 5, 6])\n  * -1\n  *\n  * >>> getSmallestNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  * -10\n  */\nconst getSmallestNegative = (l) => {\n  let smallestNegative = Number.MIN_SAFE_INTEGER;\n\n  getNegative(l).forEach(x => {\n    if (smallestNegative > x) {\n      smallestNegative = x;\n    }\n  });\n\n  if (smallestNegative === Number.MIN_SAFE_INTEGER) {\n    return 0;\n  }\n\n  return smallestNegative;\n};\n\nmodule.exports = {\n  getPositive,\n  getLargestPositive,\n  getSmallestPositive,\n  getLargestNegative,\n  getSmallestNegative\n};\n<|endoftext|>"}
{"task_id": "JavaScript/31", "prompt": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false\n  }\n\n  if (n === 2) {\n    return true\n  }\n\n  if (n === 1 || n === 3) {\n    return false\n  }\n\n  let max = Math.sqrt(n)\n  for (let i = 2; i <= max; i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = isPrime\n<|endoftext|>"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length === 0) {\n    return NaN;\n  }\n  const len = xs.length;\n  let x = xs[0];\n  let prev = 0;\n  let next;\n  let curr;\n  let i = 1;\n  let j = 1;\n  let prevPrev;\n  let prevNext;\n  let nextNext;\n  do {\n    prevPrev = prev;\n    prev = prev + xs[i] * x;\n    curr = xs[i];\n    i += 1;\n    curr = xs[i];\n    j += 1;\n    if (i === len) {\n      return prev;\n    }\n    if (i === j) {\n      next = xs[i];\n      nextNext = xs[i + 1];\n      curr = xs[i];\n      next = xs[i + 1];\n      if (next!== 0) {\n        prev = prev + next * x;\n        i += 1;\n      }\n    } else {\n      next = xs[i];\n      nextNext = xs[i + 1];\n      curr = xs[i];\n      next = xs[i + 1];\n      if (next!== 0) {\n        prev = prev + next * x;\n        i += 1;\n      }\n    }\n  } while (prevPrev!== prev);\n  return NaN;\n}\n\n/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length === 0) {\n    return NaN;\n  }\n  const len = xs.length;\n  let x = xs[0];\n  let prev = 0;\n  let next;\n  let curr;\n  let i = 1;\n  let j = 1;\n  let prevPrev;\n  let prevNext;\n  let nextNext;\n  do {\n    prevPrev = prev;\n    prev = prev + xs[i] * x;\n    curr = xs[i];\n    i += 1;\n    curr = xs[i];\n    j += 1;\n    if (i === len) {\n      return prev;\n    }\n    if (i === j) {\n      next = xs[i];\n      nextNext = xs[i + 1];\n      curr = xs[i];\n      next = xs[i + 1];\n      if (next!== 0) {\n        prev = prev + next * x;\n        i += 1;\n      }\n    } else {\n      next = xs[i];\n      nextNext = xs[i + 1];\n      curr = xs[i];\n      next = xs[i + 1];\n      if (next!== 0) {\n        prev = prev + next * x;\n        i += 1;\n      }\n    }\n  } while (prevPrev!== prev);\n  return NaN;\n}\n\nmodule.exports = {\n  poly,\n  findZero\n};\n<|endoftext|>"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const ret = [];\n  let i = 0;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      ret.push(l[i]);\n      i++;\n    } else {\n      const x = l[i];\n      while (i < l.length && x > l[i]) {\n        ret.push(l[i]);\n        i++;\n      }\n      i++;\n    }\n  }\n  return ret;\n};\n\nexport default sortThird;\n<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const map = new Map();\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    result.push(l[i]);\n    map.set(l[i], 1);\n  }\n  return result;\n};\n\n/**\n  * Returns the number of unique elements in a list\n  * @param {Array} l - input list\n  * @return {Number} - number of unique elements in a list\n  */\nconst numberUnique = (l) => {\n  let map = new Map();\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    map.set(l[i], 1);\n    result++;\n  }\n  return result;\n};\n\n/**\n * Returns the number of unique elements in a list\n * @param {Array} l - input list\n * @return {Number} - number of unique elements in a list\n */\nexport const uniqueNumber = (l) => {\n  let map = new Map();\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    map.set(l[i], 1);\n    result++;\n  }\n  return result;\n};\n\n/**\n * Returns the number of unique elements in a list\n * @param {Array} l - input list\n * @return {Number} - number of unique elements in a list\n */\nexport const uniqueNumberSorted = (l) => {\n  let map = new Map();\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    map.set(l[i], 1);\n    result++;\n  }\n  return result;\n};\n\n/**\n * Returns the number of unique elements in a list\n * @param {Array} l - input list\n * @return {Number} - number of unique elements in a list\n */\nexport const uniqueNumberNumber = (l) => {\n  let map = new Map();\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    map.set(l[i], 1);\n    result++;\n  }\n  return result;\n};\n\n/**\n * Returns the number of unique elements in a list\n * @param {Array} l - input list\n * @return {Number} - number of unique elements in a list\n */\nexport const uniqueNumberNumberSorted = (l) => {\n  let map = new Map();\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    map.set(l[i], 1);\n    result++;\n  }\n  return result;\n};\n\n/**\n * Returns the number of unique elements in a list\n * @param {Array} l - input list\n * @return {Number} - number of unique elements in a list\n */\nexport const uniqueNumberSortedNumber = (l) => {\n  let map = new Map();\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    map.set(l[i], 1);\n    result++;\n  }\n  return result;\n};\n\n/**\n * Returns the number of unique elements in a list\n * @param {Array} l - input list\n * @return {Number} - number of unique elements in a list\n */\nexport const uniqueNumberSortedNumberSorted = (l) => {\n  let map = new Map();\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (map.has(l[i])) {\n      continue;\n    }\n    map.set(l[i], 1);\n    result++;\n  }\n  return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.reduce((prev, curr) => {\n    return curr > prev? curr : prev\n  }, -Infinity)\n}\n\n/*\n  Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  return l.reduce((prev, curr) => {\n    return curr < prev? curr : prev\n  }, Infinity)\n}\n\n/*\n  Return the first element in the list that is equal to `x`\n  >>> findElem([1, 2, 3], 2)\n  2\n  >>> findElem([1, 2, 3], 5)\n  None\n  */\nconst findElem = (l, x) => {\n  return l.reduce((prev, curr, index, arr) => {\n    if (curr === x) {\n      return prev\n    } else if (index === (l.length - 1)) {\n      return prev\n    } else {\n      return prev + curr\n    }\n  }, -1)\n}\n\n/*\n  Return the first element in the list that is not equal to `x`\n  >>> findElem([1, 2, 3], 2, x)\n  1\n  >>> findElem([1, 2, 3], 5, x)\n  3\n  */\nconst findElem = (l, x, notEqual) => {\n  return l.reduce((prev, curr, index, arr) => {\n    if (curr!== x) {\n      return prev\n    } else if (index === (l.length - 1)) {\n      return prev\n    } else {\n      return prev + curr\n    }\n  }, -1)\n}\n\n/*\n  Return the first element in the list that is equal to `x`\n  >>> findElem([1, 2, 3, x], x)\n  x\n  >>> findElem([1, 2, 3, x], 5, x)\n  None\n  */\nconst findElem = (l, x, equal) => {\n  return l.reduce((prev, curr, index, arr) => {\n    if (curr === x) {\n      return prev\n    } else if (index === (l.length - 1)) {\n      return prev\n    } else {\n      return prev + curr\n    }\n  }, -1)\n}\n\n/*\n  Return the last element in the list that is equal to `x`\n  >>> findElem([1, 2, 3, x], x)\n  x\n  >>> findElem([1, 2, 3, x], 5, x)\n  None\n  */\nconst findElem = (l, x, equal) => {\n  return l.reduce((prev, curr, index, arr) => {\n    if (curr === x) {\n      return prev\n    } else if (index === 0) {\n      return prev\n    } else {\n      return prev + curr\n    }\n  }, -1)\n}\n\n/*\n  Return the index of the first element in the list that is equal to `x`\n  >>> findElemIndex([1, 2, 3, x], x)\n  2\n  >>> findElemIndex([1, 2, 3, x], 5, x)\n  4\n  */\nconst findElemIndex = (l, x, equal) => {\n  let index = -1\n  l.forEach((curr, i) => {\n    if (curr === x) {\n      index = i\n    }\n  })\n  return index\n}\n\n/*\n  Return the index of the last element in the list that is equal to `x`\n  >>> findElemIndex([1, 2, 3, x], x)\n  2\n  >>> findElemIndex([1, 2, 3, x], 5, x)\n  4\n  */\nconst findElemIndex = (l, x, equal) => {\n  let index = -1\n  l.forEach((curr, i) => {\n    if (curr === x) {\n      index = i\n    }\n  })\n  return index\n}\n\n/*\n  Return the index of the first element in the list that is not equal to `x`\n  >>> findElemIndex([1, 2, 3, x], x, x)\n  0\n  >>> findElemIndex([1, 2, 3, x], 5, x)\n  2\n  */\nconst findElemIndex = (l, x, notEqual) => {\n  let index = -1\n  l.forEach((curr, i) => {\n    if (curr!== x) {\n      index = i\n    }\n  })\n  return index\n}\n\n/*\n  Return the index of the last element in the list that is not equal to `x`\n  >>> findElemIndex([1, 2, 3, x], x, x)\n  3\n  >>> findElemIndex([1, 2, 3, x], 5, x)\n  4\n  */\nconst findElemIndex = (l, x, notEqual) => {\n  let index = -1\n  l.forEach((curr, i) => {\n    if (curr!== x) {\n      index = i\n    }\n  })\n  return index\n}\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  const count = digits.reduce((acc, curr) => {\n    const val = +curr\n    const divisibleBy11 = val % 11 === 0\n    const divisibleBy13 = val % 13 === 0\n    if (divisibleBy11 || divisibleBy13) {\n      acc.push(curr)\n    }\n    return acc\n  }, [])\n  return count.reduce((acc, curr) => {\n    const divisibleBy11 = curr % 11 === 0\n    const divisibleBy13 = curr % 13 === 0\n    if (divisibleBy11 || divisibleBy13) {\n      acc.push(curr)\n    }\n    return acc\n  }, [])\n}\n\nconsole.log(fizzBuzz(79))\n<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const lCopy = l.slice()\n  const sorted = []\n  for (let i = 0; i < lCopy.length; i += 2) {\n    sorted.push(lCopy[i])\n  }\n  for (let i = 1; i < lCopy.length; i += 2) {\n    sorted.push(lCopy[i])\n  }\n  return sorted\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [2, 3, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [3, 4, 6, 5]\n  */\nconst sortOdd = (l) => {\n  const lCopy = l.slice()\n  const sorted = []\n  for (let i = 0; i < lCopy.length; i += 2) {\n    sorted.push(lCopy[i + 1])\n  }\n  for (let i = 1; i < lCopy.length; i += 2) {\n    sorted.push(lCopy[i + 1])\n  }\n  return sorted\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [2, 3, 1]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [3, 4, 6, 5]\n  */\nconst sortEvenOdd = (l) => {\n  const lCopy = l.slice()\n  const sorted = []\n  for (let i = 0; i < lCopy.length; i += 2) {\n    sorted.push(lCopy[i + 1])\n  }\n  for (let i = 1; i < lCopy.length; i += 2) {\n    sorted.push(lCopy[i + 1])\n  }\n  return sorted\n}\n\nexport default {\n  sortEven,\n  sortOdd,\n  sortEvenOdd\n}\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n  const n = s.length,\n        groups = [];\n  for (let i = 0; i < n; i++) {\n    if (s.charAt(i) == 'c')\n      groups.push(s.charAt(i + 1) + s.charAt(i + 2));\n    else\n      groups.push(s.charAt(i));\n  }\n  return groups.join('');\n}\n\n/*\n  retrns the cyclic form of the string.\n  */\nconst cyclic = (s) => {\n  const n = s.length;\n  for (let i = 0; i < n; i++) {\n    if (s.charAt(i) == 'c')\n      s = s.replace(s.charAt(i + 1), s.charAt(i + 2));\n  }\n  return s;\n}\n\n/*\n  retrns the form of the string with chqractecs (i.e. with cycles).\n  */\nconst cyclic2 = (s) => {\n  const n = s.length;\n  for (let i = 0; i < n; i++) {\n    if (s.charAt(i) == 'c')\n      s = s.replace(s.charAt(i + 1), s.charAt(i + 2));\n  }\n  return s;\n}\n\n/*\n  returns the cyclic form of the string.\n  */\nconst cyclic3 = (s) => {\n  const n = s.length;\n  for (let i = 0; i < n; i++) {\n    if (s.charAt(i) == 'c')\n      s = s.replace(s.charAt(i + 1), s.charAt(i + 2));\n    else\n      s = s.replace(s.charAt(i), s.charAt(i + 1));\n  }\n  return s;\n}\n\nmodule.exports = {\n  encodeCyclic,\n  decodeCyclic,\n  cyclic,\n  cyclic2,\n  cyclic3\n}\n<|endoftext|>"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n    let x = 2\n    let y = 1\n    let f = 2\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\n/*\n  primeFib2 rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib2(1)\n  2\n  >>> primeFib2(2)\n  3\n  >>> primeFib2(3)\n  5\n  >>> primeFib2(4)\n  13\n  >>> primeFib2(5)\n  89\n  */\nconst primeFib2 = (n) => {\n    let i = 2\n    let x = 1\n    let y = 2\n    let f = 1\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib3 = (n) => {\n    let i = 2\n    let x = 1\n    let y = 2\n    let f = 1\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\n/*\n  primeFib4 rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib4(1)\n  2\n  >>> primeFib4(2)\n  3\n  >>> primeFib4(3)\n  5\n  >>> primeFib4(4)\n  13\n  >>> primeFib4(5)\n  89\n  */\nconst primeFib4 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib5 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib6 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib7 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib8 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib9 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib10 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib11 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib12 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib13 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib14 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x - y\n        x = y\n        y = tmp\n    }\n    return f\n}\n\nconst primeFib15 = (n) => {\n    let i = 2\n    let x = 3\n    let y = 2\n    let f = 3\n    for (let i = 2; i <= n; i++) {\n        let tmp = f\n        f = x"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n\n  const a = l.reduce((p, c) => p + c, 0)\n  if (a === 0) {\n    return true\n  }\n\n  let r = a\n  l.forEach((c, i) => {\n    if (i!== 0) {\n      r = r - c\n    }\n  })\n\n  return r === 0\n}\n\nexport {\n  triplesSumToZero\n}\n<|endoftext|>"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let cars = [];\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars.push(0);\n  cars."}
{"task_id": "JavaScript/42", "prompt": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const output = [];\n  for (let i = 0; i < l.length; i++) {\n    output.push(l[i] + 1);\n  }\n  return output;\n};\n\nmodule.exports = incrList;\n<|endoftext|>"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i += 1) {\n        sum += l[i];\n        if (sum === 0) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconsole.log(pairsSumToZero([1, 3, 5, 0]));\nconsole.log(pairsSumToZero([1, 3, -2, 1]));\nconsole.log(pairsSumToZero([1, 2, 3, 7]));\nconsole.log(pairsSumToZero([2, 4, -5, 3, 5, 7]));\nconsole.log(pairsSumToZero([1]));\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  // base numbers are less thqn 10.\n  let num = x;\n  if (num >= base) {\n    while (num >= base) {\n      num = num / base;\n      base = base * 10;\n    }\n  }\n  let str = '';\n  while (num > 0) {\n    str = str + num % base +'';\n    num = num / base;\n  }\n  return str;\n}\n\n/*\n  print the number with given base.\n  number base is less thqn 10.\n  >>> printNumber(2)\n  1\n  >>> printNumber(2, 3)\n  12\n  >>> printNumber(8, 2)\n  1000\n  */\nconst printNumber = (x, base) => {\n  let str = changeBase(x, base);\n  console.log(str);\n}\n\nprintNumber(8, 2);\n\n/*\n  convert number x from base b to base c.\n  base b should be less thqn base c.\n  >>> convert(8, 2, 3)\n  12\n  >>> convert(8, 2, 3, 2)\n  22\n  >>> convert(8, 2, 4, 2)\n  24\n  >>> convert(8, 2, 8, 2)\n  112\n  >>> convert(8, 2, 10, 2)\n  20\n  >>> convert(8, 2, 2)\n  8\n  >>> convert(8, 2, 2, 2)\n  8\n  >>> convert(8, 2, 10, 3)\n  2\n  >>> convert(8, 2, 10, 4)\n  4\n  >>> convert(8, 2, 10, 8)\n  8\n  >>> convert(8, 2, 10, 9)\n  9\n  >>> convert(8, 2, 10, 10)\n  10\n  >>> convert(8, 2, 10, 11)\n  11\n  >>> convert(8, 2, 10, 12)\n  12\n  >>> convert(8, 2, 10, 13)\n  13\n  >>> convert(8, 2, 10, 14)\n  14\n  >>> convert(8, 2, 10, 15)\n  15\n  >>> convert(8, 2, 10, 16)\n  16\n  >>> convert(8, 2, 10, 17)\n  17\n  >>> convert(8, 2, 10, 18)\n  18\n  >>> convert(8, 2, 10, 19)\n  19\n  >>> convert(8, 2, 10, 20)\n  20\n  >>> convert(8, 2, 10, 21)\n  21\n  >>> convert(8, 2, 10, 22)\n  22\n  >>> convert(8, 2, 10, 23)\n  23\n  >>> convert(8, 2, 10, 24)\n  24\n  >>> convert(8, 2, 10, 25)\n  25\n  >>> convert(8, 2, 10, 26)\n  26\n  >>> convert(8, 2, 10, 27)\n  27\n  >>> convert(8, 2, 10, 28)\n  28\n  >>> convert(8, 2, 10, 29)\n  29\n  >>> convert(8, 2, 10, 30)\n  30\n  >>> convert(8, 2, 10, 31)\n  31\n  >>> convert(8, 2, 10, 32)\n  32\n  >>> convert(8, 2, 10, 33)\n  33\n  >>> convert(8, 2, 10, 34)\n  34\n  >>> convert(8, 2, 10, 35)\n  35\n  >>> convert(8, 2, 10, 36)\n  36\n  >>> convert(8, 2, 10, 37)\n  37\n  >>> convert(8, 2, 10, 38)\n  38\n  >>> convert(8, 2, 10, 39)\n  39\n  >>> convert(8, 2, 10, 40)\n  40\n  >>> convert(8, 2, 10, 41)\n  41\n  >>> convert(8, 2, 10, 42)\n  42\n  >>> convert(8, 2, 10, 43)\n  43\n  >>> convert(8, 2, 10, 44)\n  44\n  >>> convert(8, 2, 10, 45)\n  45\n  >>> convert(8, 2, 10, 46)\n  46\n  >>> convert(8, 2, 10, 47)\n  47\n  >>> convert(8, 2, 10, 48)\n  48\n  >>> convert(8, 2, 10, 49)\n  49\n  >>> convert(8, 2, 10, 50)\n  50\n  >>> convert(8, 2, 10, 51)\n  51\n  >>> convert(8, 2, 10, 52)\n  52\n  >>> convert(8, 2, 10, 53)\n  53\n  >>> convert(8, 2, 10, 54)\n  54\n  >>> convert(8, 2, 10, 55)\n  55\n  >>> convert(8, 2, 10, 56)\n  56\n  >>> convert(8, 2, 10, 57)\n  57\n  >>> convert(8, 2, 10, 58)\n  58\n  >>> convert(8, 2, 10, 59)\n  59\n  >>> convert(8, 2, 10, 60)\n  60\n  >>> convert(8, 2, 10, 61)\n  61\n  >>> convert(8, 2, 10, 62)\n  62\n  >>> convert(8, 2, 10, 63)\n  63\n  >>> convert(8, 2, 10, 64)\n  64\n  >>> convert(8, 2, 10, 65)\n  65\n  >>> convert(8, 2, 10, 66)\n  66\n  >>> convert(8, 2, 10, 67)\n  67\n  >>> convert(8, 2, 10, 68)\n  68\n  >>> convert(8, 2, 10, 69)\n  69\n  >>> convert(8, 2, 10, 70)\n  70\n  >>> convert(8, 2, 10, 71)\n  71\n  >>> convert(8, 2, 10, 72)\n  72\n  >>> convert(8, 2, 10, 73)\n  73\n  >>> convert"}
{"task_id": "JavaScript/45", "prompt": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (2 * a * h) / 3;\n}\n\n/*Givej the area of a square and high return area for a triantle.\n  >>> squareArea(10)\n  200\n  */\nconst squareArea = (a) => {\n  return a * a;\n}\n\n/*Givej the area of a rectangle and high return area for a triantle.\n  >>> rectangleArea(3, 4)\n  9\n  */\nconst rectangleArea = (w, h) => {\n  return w * h;\n}\n\n/*Givej the area of a circle and high return area for a triantle.\n  >>> circleArea(6)\n  3.5\n  */\nconst circleArea = (r) => {\n  return Math.PI * r * r;\n}\n\n/*Givej the area of a triangle and high return area for a triantle.\n  >>> triangleArea(3, 5)\n  7.5\n  */\nconst triangleArea2 = (a, b) => {\n  return triangleArea(a, b) / 2;\n}\n\n/*Givej the area of a rectangle and high return area for a triantle.\n  >>> rectangleArea(4, 5)\n  15\n  */\nconst rectangleArea2 = (w, h) => {\n  return rectangleArea(w, h) / 2;\n}\n\n/*Givej the area of a triangle and high return area for a triantle.\n  >>> triangleArea(3, 5)\n  7.5\n  */\nconst triangleArea3 = (a, b, c) => {\n  return triangleArea(a, b) + triangleArea(b, c) + triangleArea(a, c);\n}\n\n/*Givej the area of a rectangle and high return area for a triantle.\n  >>> rectangleArea(4, 5)\n  15\n  */\nconst rectangleArea3 = (w, h) => {\n  return rectangleArea(w, h) / 2;\n}\n\n/*Givej the area of a triangle and high return area for a triantle.\n  >>> triangleArea(3, 5)\n  7.5\n  */\nconst triangleArea4 = (a, b, c, d) => {\n  return triangleArea(a, b) + triangleArea(b, c) + triangleArea(c, d) + triangleArea(a, d);\n}\n\n/*Givej the area of a rectangle and high return area for a triantle.\n  >>> rectangleArea(4, 5)\n  15\n  */\nconst rectangleArea4 = (w, h) => {\n  return rectangleArea(w, h) / 2;\n}\n\n/*Givej the area of a triangle and high return area for a triantle.\n  >>> triangleArea(3, 5)\n  7.5\n  */\nconst triangleArea5 = (a, b, c, d, e) => {\n  return triangleArea(a, b) + triangleArea(b, c) + triangleArea(c, d) + triangleArea(d, e) + triangleArea(a, e);\n}\n\n/*Givej the area of a rectangle and high return area for a triantle.\n  >>> rectangleArea(4, 5)\n  15\n  */\nconst rectangleArea5 = (w, h) => {\n  return rectangleArea(w, h) / 2;\n}\n\n/*Givej the area of a triangle and high return area for a triantle.\n  >>> triangleArea(3, 5)\n  7.5\n  */\nconst triangleArea6 = (a, b, c, d, e, f) => {\n  return triangleArea(a, b) + triangleArea(b, c) + triangleArea(c, d) + triangleArea(d, e) + triangleArea(e, f) + triangleArea(a, f);\n}\n\n/*Givej the area of a rectangle and high return area for a triantle.\n  >>> rectangleArea(4, 5)\n  15\n  */\nconst rectangleArea6 = (w, h) => {\n  return rectangleArea(w, h) / 2;\n}\n\n/*Givej the area of a triangle and high return area for a triantle.\n  >>> triangleArea(3, 5)\n  7.5\n  */\nconst triangleArea7 = (a, b, c, d, e, f, g) => {\n  return triangleArea(a, b) + triangleArea(b, c) + triangleArea(c, d) + triangleArea(d, e) + triangleArea(e, f) + triangleArea(f, g) + triangleArea(a, g);\n}\n\n/*Givej the area of a rectangle and high return area for a triantle.\n  >>> rectangleArea(4, 5)\n  15\n  */\nconst rectangleArea7 = (w, h) => {\n  return rectangleArea(w, h) / 2;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/46", "prompt": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  let fib = [1, 2, 3, 5];\n  if(n === 0) return fib[0];\n  else if(n === 1) return fib[1];\n  else if(n === 2) return fib[2];\n  else if(n === 3) return fib[3];\n  else if(n === 4) return fib[4];\n  else if(n === 5) return fib[5];\n  else if(n === 6) return fib[6];\n  else if(n === 7) return fib[7];\n  else if(n === 8) return fib[8];\n  else if(n === 9) return fib[9];\n  else if(n === 10) return fib[10];\n  else if(n === 11) return fib[11];\n  else if(n === 12) return fib[12];\n  else if(n === 13) return fib[13];\n  else if(n === 14) return fib[14];\n  else if(n === 15) return fib[15];\n  else if(n === 16) return fib[16];\n  else if(n === 17) return fib[17];\n  else if(n === 18) return fib[18];\n  else if(n === 19) return fib[19];\n  else if(n === 20) return fib[20];\n  else if(n === 21) return fib[21];\n  else if(n === 22) return fib[22];\n  else if(n === 23) return fib[23];\n  else if(n === 24) return fib[24];\n  else if(n === 25) return fib[25];\n  else if(n === 26) return fib[26];\n  else if(n === 27) return fib[27];\n  else if(n === 28) return fib[28];\n  else if(n === 29) return fib[29];\n  else if(n === 30) return fib[30];\n  else if(n === 31) return fib[31];\n  else if(n === 32) return fib[32];\n  else if(n === 33) return fib[33];\n  else if(n === 34) return fib[34];\n  else if(n === 35) return fib[35];\n  else if(n === 36) return fib[36];\n  else if(n === 37) return fib[37];\n  else if(n === 38) return fib[38];\n  else if(n === 39) return fib[39];\n  else if(n === 40) return fib[40];\n  else if(n === 41) return fib[41];\n  else if(n === 42) return fib[42];\n  else if(n === 43) return fib[43];\n  else if(n === 44) return fib[44];\n  else if(n === 45) return fib[45];\n  else if(n === 46) return fib[46];\n  else if(n === 47) return fib[47];\n  else if(n === 48) return fib[48];\n  else if(n === 49) return fib[49];\n  else if(n === 50) return fib[50];\n  else if(n === 51) return fib[51];\n  else if(n === 52) return fib[52];\n  else if(n === 53) return fib[53];\n  else if(n === 54) return fib[54];\n  else if(n === 55) return fib[55];\n  else if(n === 56) return fib[56];\n  else if(n === 57) return fib[57];\n  else if(n === 58) return fib[58];\n  else if(n === 59) return fib[59];\n  else if(n === 60) return fib[60];\n  else if(n === 61) return fib[61];\n  else if(n === 62) return fib[62];\n  else if(n === 63) return fib[63];\n  else if(n === 64) return fib[64];\n  else if(n === 65) return fib[65];\n  else if(n === 66) return fib[66];\n  else if(n === 67) return fib[67];\n  else if(n === 68) return fib[68];\n  else if(n === 69) return fib[69];\n  else if(n === 70) return fib[70];\n  else if(n === 71) return fib[71];\n  else if(n === 72) return fib[72];\n  else if(n === 73) return fib[73];\n  else if(n === 74) return fib[74];\n  else if(n === 75) return fib[75];\n  else if(n === 76) return fib[76];\n  else if(n === 77) return fib[77];\n  else if(n === 78) return fib[78];\n  else if(n === 79) return fib[79];\n  else if(n === 80) return fib[80];\n  else if(n === 81) return fib[81];\n  else if(n === 82) return fib[82];\n  else if(n === 83) return fib[83];\n  else if(n === 84) return fib[84];\n  else if(n === 85) return fib[85];\n  else if(n === 86) return fib[86];\n  else if(n === 87) return fib[87];\n  else if(n === 88) return fib[88];\n  else if(n === 89) return fib[89];\n  else if(n === 90) return fib[90];\n  else if(n === 91) return fib[91];\n  else if(n === 92) return fib[92];\n  else if(n === 93) return fib[93];\n  else if(n === 94) return fib[94];\n  else if(n === 95) return"}
{"task_id": "JavaScript/47", "prompt": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    throw new Error('List is empty');\n  }\n  let half = Math.floor(l.length / 2);\n  return (l.length % 2 === 1)? l[half] : (l[half - 1] + l[half]) / 2.0;\n};\n\nexport default median;\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\nconst main = () => {\n  const text = [\n    '',\n    'A man, a plan, a canal-Panama',\n    'race a car',\n    'race a cat',\n    'race a duck',\n    'race a horse',\n    'race a pig',\n    'race a rat',\n    'race a shoe',\n    'race a swimmer',\n    'race a t-Rex',\n    'race a toad',\n    'race a zebra',\n    'race a zombie'\n  ].join('\\n');\n\n  const output = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n"}
{"task_id": "JavaScript/49", "prompt": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n    n = n % p;\n    if (n < 0) {\n        n += p;\n    }\n    return n;\n}\n\n/*\n  Test\n  \n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\n<|endoftext|>"}
{"task_id": "JavaScript/50", "prompt": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    (ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26 + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nmodule.exports = {\n  encodeShift,\n  decodeShift\n}\n<|endoftext|>"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  let string = text.toLowerCase()\n  for (let i = 0; i < vowels.length; i++) {\n    string = string.replace(vowels[i], '')\n  }\n  return string\n}\n\n/*\n  removeSuffixes is a function that takes string and returns string without\n  suffixes.\n  >>> removeSuffixes('')\n  ''\n  >>> removeSuffixes('abcdef')\n  'abcde'\n  >>> removeSuffixes('abcdefg')\n  'abcdef'\n  >>> removeSuffixes('aaaaa')\n  'aaaaa'\n  >>> removeSuffixes('aaBAA')\n  'BAA'\n  >>> removeSuffixes('zbcd')\n  'zbcd'\n  */\nconst removeSuffixes = (text) => {\n  const suffixes = ['s', 'd', 't']\n  let string = text.toLowerCase()\n  for (let i = 0; i < suffixes.length; i++) {\n    string = string.replace(suffixes[i], '')\n  }\n  return string\n}\n\n/*\n  removePrefixes is a function that takes string and returns string without\n  prefixes.\n  >>> removePrefixes('')\n  ''\n  >>> removePrefixes('abcdef')\n  'abcde'\n  >>> removePrefixes('abcdefg')\n  'abcdefg'\n  >>> removePrefixes('aaaaa')\n  'aaaaa'\n  >>> removePrefixes('aaBAA')\n  'BAA'\n  >>> removePrefixes('zbcd')\n  'zbcd'\n  */\nconst removePrefixes = (text) => {\n  const prefixes = ['a', 'an', 'an', 'the']\n  let string = text.toLowerCase()\n  for (let i = 0; i < prefixes.length; i++) {\n    string = string.replace(prefixes[i], '')\n  }\n  return string\n}\n\n/*\n  convertToCamelCase is a function that takes string and returns string\n  converted to CamelCase.\n  >>> convertToCamelCase('')\n  ''\n  >>> convertToCamelCase('abcdef')\n  'abcDef'\n  >>> convertToCamelCase('abcdefg')\n  'abcDefg'\n  >>> convertToCamelCase('aaaaa')\n  'AAAAa'\n  >>> convertToCamelCase('aaBAA')\n  'AaBAA'\n  >>> convertToCamelCase('zbcd')\n  'ZbCd'\n  */\nconst convertToCamelCase = (text) => {\n  let string = text.toLowerCase()\n  string = string.replace(/\\b[a-z]/g, (s) => s.toUpperCase())\n  string = string.replace(/\\b[A-Z]/g, (s) => s.toLowerCase())\n  return string\n}\n\n/*\n  convertToSnakeCase is a function that takes string and returns string\n  converted to snake case.\n  >>> convertToSnakeCase('')\n  ''\n  >>> convertToSnakeCase('abcdef')\n  'abc_def'\n  >>> convertToSnakeCase('abcdefg')\n  'abc_def_g'\n  >>> convertToSnakeCase('aaaaa')\n  'aaaa_a'\n  >>> convertToSnakeCase('aaBAA')\n  'aa_b_aa'\n  >>> convertToSnakeCase('zbcd')\n  'zb_cd'\n  */\nconst convertToSnakeCase = (text) => {\n  let string = text.toLowerCase()\n  string = string.replace(/\\b[a-z]/g, (s) => s.toUpperCase())\n  string = string.replace(/\\b[A-Z]/g, (s) => s.toLowerCase())\n  string = string.replace(/(^|\\s)[A-Z]/g, '$1_')\n  string = string.replace(/(^|\\s)[a-z]/g, '$1_')\n  return string\n}\n\n/*\n  convertToPascalCase is a function that takes string and returns string\n  converted to PascalCase.\n  >>> convertToPascalCase('')\n  ''\n  >>> convertToPascalCase('abcdef')\n  'ABCDEF'\n  >>> convertToPascalCase('abcdefg')\n  'ABCDEFG'\n  >>> convertToPascalCase('aaaaa')\n  'AAAAA'\n  >>> convertToPascalCase('aaBAA')\n  'AABAA'\n  >>> convertToPascalCase('zbcd')\n  'ZBCD'\n  */\nconst convertToPascalCase = (text) => {\n  let string = text.toLowerCase()\n  string = string.replace(/\\b[a-z]/g, (s) => s.toUpperCase())\n  string = string.replace(/\\b[A-Z]/g, (s) => s.toUpperCase())\n  string = string.replace(/[A-Z]/g, (s) => s.toUpperCase())\n  return string\n}\n\n/*\n  convertToPascalCase is a function that takes string and returns string\n  converted to PascalCase.\n  >>> convertToPascalCase('')\n  ''\n  >>> convertToPascalCase('abcdef')\n  'ABCDEF'\n  >>> convertToPascalCase('abcdefg')\n  'ABCDEFG'\n  >>> convertToPascalCase('aaaaa')\n  'AAAAA'\n  >>> convertToPascalCase('aaBAA')\n  'AaB"}
{"task_id": "JavaScript/52", "prompt": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  let total = l.reduce((a, b) => a + b, 0)\n  return l.every(a => a < t) && total < t\n}\n\n/*\n  *  Generate an array of unique random numbers\n  *  @param n  int\n  *  @param m  int\n  *  @return array\n  */\nconst randomArray = (n, m) => {\n  const a = []\n  for (let i = 0; i < n; i++) {\n    a.push(Math.random() * m)\n  }\n  return a\n}\n\n/*\n *  Find the largest and smallest number in an array\n *  @param a  array\n *  @return object\n */\nconst findMaxMin = (a) => {\n  const min = a[0]\n  const max = a[0]\n  a.forEach(v => {\n    if (v < min) {\n      min = v\n    }\n    if (v > max) {\n      max = v\n    }\n  })\n  return {\n    max,\n    min\n  }\n}\n\n/*\n *  Find the largest number in an array\n *  @param a  array\n *  @return number\n */\nconst findMax = (a) => {\n  const max = a[0]\n  a.forEach(v => {\n    if (v > max) {\n      max = v\n    }\n  })\n  return max\n}\n\n/*\n *  Find the smallest number in an array\n *  @param a  array\n *  @return number\n */\nconst findMin = (a) => {\n  const min = a[0]\n  a.forEach(v => {\n    if (v < min) {\n      min = v\n    }\n  })\n  return min\n}\n\n/*\n *  Find the mode of an array\n *  @param a  array\n *  @return number\n */\nconst findMode = (a) => {\n  const modes = {}\n  a.forEach(v => {\n    if (modes[v] == null) {\n      modes[v] = 1\n    } else {\n      modes[v]++\n    }\n  })\n  let max = 0\n  let max_count = 0\n  Object.keys(modes).forEach(k => {\n    if (modes[k] > max) {\n      max = modes[k]\n      max_count = 1\n    } else if (modes[k] === max) {\n      max_count++\n    }\n  })\n  return {\n    mode: max,\n    count: max_count\n  }\n}\n\n/*\n *  Find the sum of an array\n *  @param a  array\n *  @return number\n */\nconst findSum = (a) => {\n  return a.reduce((a, b) => a + b, 0)\n}\n\n/*\n *  Find the average of an array\n *  @param a  array\n *  @return number\n */\nconst findAverage = (a) => {\n  return findSum(a) / a.length\n}\n\n/*\n *  Find the median of an array\n *  @param a  array\n *  @return number\n */\nconst findMedian = (a) => {\n  const l = a.length\n  if (l % 2 == 1) {\n    return a[Math.floor(l / 2)]\n  } else {\n    return (a[Math.floor(l / 2)] + a[Math.floor(l / 2) - 1]) / 2\n  }\n}\n\n/*\n *  Find the mode of an array\n *  @param a  array\n *  @return number\n */\nconst findMode = (a) => {\n  const modes = {}\n  a.forEach(v => {\n    if (modes[v] == null) {\n      modes[v] = 1\n    } else {\n      modes[v]++\n    }\n  })\n  let max = 0\n  let max_count = 0\n  Object.keys(modes).forEach(k => {\n    if (modes[k] > max) {\n      max = modes[k]\n      max_count = 1\n    } else if (modes[k] === max) {\n      max_count++\n    }\n  })\n  return max\n}\n\n/*\n *  Find the variance of an array\n *  @param a  array\n *  @return number\n */\nconst findVariance = (a) => {\n  const sum = findSum(a)\n  const total = a.length\n  const avg = findAverage(a)\n  const variance = sum / total - avg\n  return variance\n}\n\n/*\n *  Find the standard deviation of an array\n *  @param a  array\n *  @return number\n */\nconst findStandardDeviation = (a) => {\n  return Math.sqrt(findVariance(a))\n}\n\nmodule.exports = {\n  findMaxMin,\n  findMax,\n  findMin,\n  findMode,\n  findMedian,\n  findMode,\n  findAverage,\n  findVariance,\n  findStandardDeviation,\n  belowThreshold,\n  randomArray,\n  findSum,\n  findMode,\n  findVariance,\n  findStandardDeviation\n}\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst sub = (x, y) => {\n  return x - y;\n};\n\n/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst mul = (x, y) => {\n  return x * y;\n};\n\n/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst div = (x, y) => {\n  return x / y;\n};\n\n/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst mod = (x, y) => {\n  return x % y;\n};\n\nmodule.exports = {\n  add,\n  sub,\n  mul,\n  div,\n  mod\n};\n<|endoftext|>"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    if (s0.length!== s1.length) {\n        return false;\n    }\n    let i = 0;\n    while (i < s0.length) {\n        if (s0[i]!== s1[i]) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nconst letterCombinations = (str, wordList) => {\n    let word = str.split('');\n    if (word.length === 1) {\n        return [str];\n    }\n\n    const result = [];\n    while (word.length > 0) {\n        const newWord = [];\n        const wordLength = word.length;\n        for (let i = 0; i < wordLength; i++) {\n            let index = word[i].charCodeAt(0);\n            for (let j = 0; j < wordList.length; j++) {\n                if (sameChars(word[i], wordList[j])) {\n                    index = index + 1;\n                    break;\n                }\n            }\n            newWord.push(String.fromCharCode(index));\n        }\n        result.push(newWord.join(''));\n        word = word.slice(1);\n    }\n    return result;\n}\n\nconst letterCombinations2 = (str, wordList) => {\n    let word = str.split('');\n    if (word.length === 1) {\n        return [str];\n    }\n    let result = [];\n    while (word.length > 0) {\n        const newWord = [];\n        const wordLength = word.length;\n        for (let i = 0; i < wordLength; i++) {\n            let index = word[i].charCodeAt(0);\n            for (let j = 0; j < wordList.length; j++) {\n                if (sameChars(word[i], wordList[j])) {\n                    index = index + 1;\n                    break;\n                }\n            }\n            newWord.push(String.fromCharCode(index));\n        }\n        result.push(newWord.join(''));\n        word = word.slice(1);\n    }\n    return result;\n}\n\nconst letterCombinations3 = (str, wordList) => {\n    if (str.length === 1) {\n        return [str];\n    }\n    let word = str.split('');\n    if (word.length === 0) {\n        return [];\n    }\n    let result = [];\n    while (word.length > 0) {\n        const newWord = [];\n        const wordLength = word.length;\n        for (let i = 0; i < wordLength; i++) {\n            let index = word[i].charCodeAt(0);\n            for (let j = 0; j < wordList.length; j++) {\n                if (sameChars(word[i], wordList[j])) {\n                    index = index + 1;\n                    break;\n                }\n            }\n            newWord.push(String.fromCharCode(index));\n        }\n        result.push(newWord.join(''));\n        word = word.slice(1);\n    }\n    return result;\n}\n\nconst letterCombinations4 = (str, wordList) => {\n    let word = str.split('');\n    if (word.length === 1) {\n        return [str];\n    }\n    let result = [];\n    while (word.length > 0) {\n        const newWord = [];\n        const wordLength = word.length;\n        for (let i = 0; i < wordLength; i++) {\n            let index = word[i].charCodeAt(0);\n            for (let j = 0; j < wordList.length; j++) {\n                if (sameChars(word[i], wordList[j])) {\n                    index = index + 1;\n                    break;\n                }\n            }\n            newWord.push(String.fromCharCode(index));\n        }\n        result.push(newWord.join(''));\n        word = word.slice(1);\n    }\n    return result;\n}\n\nconst letterCombinations5 = (str, wordList) => {\n    let word = str.split('');\n    if (word.length === 1) {\n        return [str];\n    }\n    let result = [];\n    while (word.length > 0) {\n        const newWord = [];\n        const wordLength = word.length;\n        for (let i = 0; i < wordLength; i++) {\n            let index = word[i].charCodeAt(0);\n            for (let j = 0; j < wordList.length; j++) {\n                if (sameChars(word[i], wordList[j])) {\n                    index = index + 1;\n                    break;\n                }\n            }\n            newWord.push(String.fromCharCode(index));\n        }\n        result.push(newWord.join(''));\n        word = word.slice(1);\n    }\n    return result;\n}\n\nconst letterCombinations6 = (str, wordList) => {\n    let word = str.split('');\n    if (word.length === 1) {\n        return [str];\n    }\n    let result = [];\n    while (word.length > 0) {\n        const newWord = [];\n        const wordLength = word.length;\n        for (let i = 0; i < wordLength; i++) {\n            let index = word[i].charCodeAt(0);\n            for (let j = 0; j < wordList.length; j++) {\n                if (sameChars(word[i], wordList[j])) {\n                    index = index + 1;\n                    break;\n                }\n            }"}
{"task_id": "JavaScript/55", "prompt": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  let f1 = 1, f2 = 1;\n  for (let i = 3; i <= n; i++) {\n    f1 = f2;\n    f2 = f1 + f2;\n  }\n  return f2;\n};\n\n/*\n  >>> fib(100)\n  33262154439441526816992388562667004907159682643816214685929638952\n  */\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n    const bracketsLength = brackets.length\n    let index = 0\n    while (index < bracketsLength) {\n        if (brackets[index] === \"<\") {\n            const openingBracket = brackets[index + 1]\n            if (openingBracket === \">\" || openingBracket === \">\") {\n                index = index + 2\n                continue\n            }\n        }\n        return false\n    }\n    return true\n}\n\n/**\n  * Return the number of brackets in a given string.\n  * @param {string} brackets - a string of \"<\" and \">\".\n  * @return {number}\n  */\nconst countBrackets = (brackets) => {\n    let counter = 0\n    brackets.split(\"\").forEach((element) => {\n        if (element === \"<\") {\n            counter++\n        } else if (element === \">\") {\n            counter--\n        }\n    })\n    return counter\n}\n\nmodule.exports = {\n    correctBracketing,\n    countBrackets\n}\n<|endoftext|>"}
{"task_id": "JavaScript/57", "prompt": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let l0 = l[0],\n    l1 = l[1],\n    l2 = l[2],\n    l3 = l[3],\n    t;\n\n  if (l0 <= l1) {\n    if (l2 <= l3) {\n      t = monotonic([l0, l1, l2, l3]);\n    } else {\n      t = monotonic([l0, l1, l3, l2]);\n    }\n  } else {\n    if (l2 <= l3) {\n      t = monotonic([l0, l2, l1, l3]);\n    } else {\n      t = monotonic([l0, l3, l2, l1]);\n    }\n  }\n\n  return t;\n};\n\nexport default monotonic;\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n    const ret = []\n    const len1 = l1.length\n    const len2 = l2.length\n    let i = 0\n    let j = 0\n    while (i < len1 && j < len2) {\n        if (l1[i] === l2[j]) {\n            ret.push(l1[i])\n            i++\n            j++\n        } else if (l1[i] < l2[j]) {\n            i++\n        } else {\n            j++\n        }\n    }\n    return ret\n}\n\nmodule.exports = common\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n    let maxPrime = 2;\n    let nPrime = 2;\n    while (nPrime < n) {\n        if (nPrime % 2 === 0) {\n            if (nPrime > maxPrime) {\n                maxPrime = nPrime;\n            }\n            nPrime = nPrime + 1;\n        } else {\n            nPrime = nPrime + 1;\n        }\n    }\n    return maxPrime;\n};\n\nconsole.log(largestPrimeFactor(13195));\nconsole.log(largestPrimeFactor(2048));\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n    let sum = 1;\n    while (sum < n) {\n        sum += sum;\n    }\n    return sum;\n};\n\nconsole.log(sumToN(30));\nconsole.log(sumToN(100));\nconsole.log(sumToN(5));\nconsole.log(sumToN(10));\nconsole.log(sumToN(1));\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const open = brackets.filter((i) => i === '(')\n  const close = brackets.filter((i) => i === ')')\n  return open.every(c => close.indexOf(c) > -1)\n}\n\n/*\n  Given a string of brackets,\n  return a list of the indices of the brackets\n  in the string, in order of appearance.\n  */\nconst bracketIndices = (brackets) => brackets.map((i) => i === '('? 1 : -1)\n\n/*\n  Given a string of brackets,\n  return a list of the indices of the\n  opening brackets in the string, in order\n  of appearance.\n  */\nconst openingBracketIndices = brackets => brackets.filter((i) => i === '(')\n\n/*\n  Given a string of brackets,\n  return a list of the indices of the\n  closing brackets in the string, in order\n  of appearance.\n  */\nconst closingBracketIndices = brackets => brackets.filter((i) => i === ')')\n\n/*\n  Given a string of brackets,\n  return a list of the indices of the\n  brackets that do not have an opening\n  or closing bracket, in order of\n  appearance.\n  */\nconst bracketIndicesWithoutOpeningAndClosing = brackets => brackets.filter((i) => i === '(' || i === ')')\n\n/*\n  Given a string of brackets,\n  return a list of the indices of the\n  brackets that do not have a closing\n  bracket, in order of appearance.\n  */\nconst bracketIndicesWithoutClosing = brackets => brackets.filter((i) => i === '(' || i === ')')\n\n/*\n  Given a string of brackets,\n  return a list of the indices of the\n  opening brackets in the string, in order\n  of appearance.\n  */\nconst openingBracketIndicesWithoutClosing = brackets => brackets.filter((i) => i === '(')\n\n/*\n  Given a string of brackets,\n  return a list of the indices of the\n  closing brackets in the string, in order\n  of appearance.\n  */\nconst closingBracketIndicesWithoutOpening = brackets => brackets.filter((i) => i === ')')\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBrackets = brackets => brackets.join('')\n\n/*\n  Given a string of brackets,\n  return the string without the opening\n  brackets.\n  */\nconst removeOpeningBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the closing\n  brackets.\n  */\nconst removeClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeOpeningBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeOpeningBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndOpeningBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without the brackets.\n  */\nconst removeBracketsAndClosingBrackets = brackets => brackets.join('').slice(1, -1)\n\n/*\n  Given a string of brackets,\n  return the string without"}
{"task_id": "JavaScript/62", "prompt": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n    let d = 0;\n    for (let i = 0; i < xs.length; i++) {\n        d += xs[i];\n    }\n    return d;\n};\n\n// Test functions\nconst test_derivative = (xs, expected) => {\n    const actual = derivative(xs);\n    assert.deepEqual(actual, expected);\n};\n\ntest_derivative([1, 2, 3], [2, 6]);\ntest_derivative([3, 1, 2, 4, 5], [1, 4, 12, 20]);\n\n// console.log(\"Passed test_derivative\");\n<|endoftext|>"}
{"task_id": "JavaScript/63", "prompt": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n    if (n === 1 || n === 2) {\n        return n;\n    } else {\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n};\n\n// f(n) = fibfib(n) + fibfib(n - 1)\nconst fib = (n) => {\n    if (n === 1 || n === 2) {\n        return n;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n};\n\nconst fibn = (n) => {\n    if (n === 1 || n === 2) {\n        return n;\n    } else {\n        return fibn(n - 1) + fibn(n - 2);\n    }\n};\n\nexport { fib, fibn };\n<|endoftext|>"}
{"task_id": "JavaScript/64", "prompt": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0\n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === 'a' || s.charAt(i) === 'e' || s.charAt(i) === 'i' || s.charAt(i) === 'o' || s.charAt(i) === 'u') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Exdmple:\n  >>> addTwo = (x, y) => x + y\n  >>> addTwo(1, 2)\n  3\n  >>> addTwo(1, 3)\n  4\n  >>> addTwo(2, 3)\n  5\n  >>> addTwo(2, 2)\n  4\n  >>> addTwo(1, 1)\n  2\n  >>> addTwo(0, 0)\n  0\n  >>> addTwo(3, 4)\n  9\n  */\nconst addTwo = (x, y) => x + y\n\n/*\n  Exdmple:\n  >>> add = (x, y) => x + y\n  >>> add(3, 4)\n  7\n  >>> add(3, 3)\n  6\n  >>> add(2, 2)\n  4\n  >>> add(0, 0)\n  0\n  >>> add(3, 5)\n  10\n  */\nconst add = (x, y) => x + y\n\n/*\n  Exdmple:\n  >>> subtract = (x, y) => x - y\n  >>> subtract(1, 2)\n  -1\n  >>> subtract(1, 3)\n  -2\n  >>> subtract(2, 3)\n  -1\n  >>> subtract(2, 2)\n  0\n  >>> subtract(0, 0)\n  0\n  >>> subtract(3, 5)\n  2\n  */\nconst subtract = (x, y) => x - y\n\n/*\n  Exdmple:\n  >>> multiply = (x, y) => x * y\n  >>> multiply(1, 2)\n  2\n  >>> multiply(1, 3)\n  3\n  >>> multiply(2, 3)\n  6\n  >>> multiply(2, 2)\n  4\n  >>> multiply(0, 0)\n  0\n  >>> multiply(3, 5)\n  15\n  */\nconst multiply = (x, y) => x * y\n\n/*\n  Exdmple:\n  >>> divide = (x, y) => x / y\n  >>> divide(1, 2)\n  0.5\n  >>> divide(1, 3)\n  0\n  >>> divide(2, 3)\n  1\n  >>> divide(2, 2)\n  1\n  >>> divide(0, 0)\n  NaN\n  >>> divide(3, 5)\n  0\n  */\nconst divide = (x, y) => x / y\n\n/*\n  Exdmple:\n  >>> multiplyBy = (x, y) => x * y\n  >>> multiplyBy(1, 2)\n  2\n  >>> multiplyBy(1, 3)\n  3\n  >>> multiplyBy(2, 3)\n  6\n  >>> multiplyBy(2, 2)\n  4\n  >>> multiplyBy(0, 0)\n  NaN\n  >>> multiplyBy(3, 5)\n  15\n  */\nconst multiplyBy = (x, y) => x * y\n\n/*\n  Exdmple:\n  >>> addTo = (x, y) => x + y\n  >>> addTo(1, 2)\n  3\n  >>> addTo(1, 3)\n  4\n  >>> addTo(2, 3)\n  5\n  >>> addTo(2, 2)\n  4\n  >>> addTo(0, 0)\n  NaN\n  >>> addTo(3, 5)\n  10\n  */\nconst addTo = (x, y) => x + y\n\n/*\n  Exdmple:\n  >>> subtractFrom = (x, y) => x - y\n  >>> subtractFrom(1, 2)\n  -1\n  >>> subtractFrom(1, 3)\n  -2\n  >>> subtractFrom(2, 3)\n  -1\n  >>> subtractFrom(2, 2)\n  0\n  >>> subtractFrom(0, 0)\n  NaN\n  >>> subtractFrom(3, 5)\n  2\n  */\nconst subtractFrom = (x, y) => x - y\n\n/*\n  Exdmple:\n  >>> subtractFromBy = (x, y) => x - y\n  >>> subtractFromBy(1, 2)\n  -1\n  >>> subtractFromBy(1, 3)\n  -2\n  >>> subtractFromBy(2, 3)\n  -1\n  >>> subtractFromBy(2, 2)\n  0\n  >>> subtractFromBy(0, 0)\n  NaN\n  >>> subtractFromBy(3, 5)\n  2\n  */\nconst subtractFromBy = (x, y) => x - y\n\n/*\n  Exdmple:\n  >>> multiplyByBy = (x, y) => x * y\n  >>> multiplyByBy(1, 2)\n  2\n  >>> multiplyByBy(1, 3)\n  3\n  >>> multiplyByBy(2, 3)\n  6\n  >>> multiplyByBy(2, 2)\n  4\n  >>> multiplyByBy(0, 0)\n  NaN\n  >>> multiplyByBy(3, 5)\n  15\n  */\nconst multiplyByBy = (x, y) => x * y\n\n/*\n  Exdmple:\n  >>> divideBy = (x, y) => x / y\n  >>> divideBy(1, 2)\n  0.5\n  >>> divideBy(1, 3)\n  0\n  >>> divideBy(2, 3)\n  1\n  >>> divideBy(2, 2)\n  1\n  >>> divideBy(0, 0)\n  NaN\n  >>> divideBy(3, 5)\n  0\n"}
{"task_id": "JavaScript/65", "prompt": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const len = x.length\n  const str = x.toString()\n  return str.slice(len - shift, len) + str.slice(0, len - shift)\n}\n\n/*\n  Find the nth to the left of the string.\n  >>> circularShift(12, 3)\n  \"4\"\n  >>> circularShift(12, 2)\n  \"1\"\n  >>> circularShift(12, 4)\n  \"2\"\n  */\nconst circularShiftN = (x, n) => {\n  const len = x.length\n  const str = x.toString()\n  const shift = n * len\n  return str.slice(len - shift, len) + str.slice(0, len - shift)\n}\n\n/*\n  Return the string to the right of the string\n  >>> circularShift(12, 3)\n  \"4\"\n  >>> circularShift(12, 2)\n  \"1\"\n  >>> circularShift(12, 4)\n  \"2\"\n  */\nconst circularShiftR = (x, n) => {\n  const len = x.length\n  const shift = n * len\n  const str = x.toString()\n  return str.slice(0, shift) + str.slice(len - shift, len)\n}\n\nmodule.exports = {\n  circularShift,\n  circularShiftN,\n  circularShiftR,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  return s.split('').reduce((pre, curr, idx) => {\n    return pre + curr.toUpperCase().charCodeAt(idx) - 'A'.charCodeAt(idx) + (curr.length - 1);\n  }, 0);\n};\n\nexport default digitSum;\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  // eslint-disable-line max-len\n  const fruitCount = s.split('').reduce((acc, curr) => {\n    const num = parseInt(curr);\n    if (!num) return acc;\n    return acc + num;\n  }, 0);\n\n  return n - fruitCount;\n};\n\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\",3));\nconsole.log(fruitDistribution(\"2 apples and 3 oranges\",100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\",120));\n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const arrLen = arr.length\n  if (arrLen === 0) {\n    return []\n  }\n  const plucked = []\n  const i = 1\n  while (i <= arrLen) {\n    if (arr[i - 1] % 2 === 1) {\n      plucked.push(arr[i - 1])\n      if (i === arrLen) {\n        return plucked\n      }\n      let j = i\n      while (arr[j] === 0) {\n        j++\n      }\n      plucked.push(arr[j - 1])\n      return plucked\n    }\n    i++\n  }\n  return plucked\n}\n\nconst arr = [4, 2, 3]\n\nconsole.log(pluck(arr))\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  return max;\n}\n\nconst search2 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search3 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  return max;\n}\n\nconst search4 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search5 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search6 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search7 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search8 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search9 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search10 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search11 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search12 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search13 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search14 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if (max < 1) {\n    return -1;\n  }\n  return max;\n}\n\nconst search15 = (lst) => {\n  let max = -1;\n  let i;\n  for (i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  if ("}
{"task_id": "JavaScript/70", "prompt": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n    let max = 0;\n    let min = 0;\n    lst.forEach(n => {\n        if (n > max) {\n            max = n;\n        }\n        if (n < min) {\n            min = n;\n        }\n    });\n    let i = 0;\n    let temp = 0;\n    let len = lst.length;\n    while (i < len) {\n        if (lst[i] > max) {\n            temp = lst[i];\n            lst[i] = max;\n            max = temp;\n            i++;\n        } else if (lst[i] < min) {\n            temp = lst[i];\n            lst[i] = min;\n            min = temp;\n            i++;\n        } else {\n            i++;\n        }\n    }\n    return lst;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return -1\n    }\n    if (a + b > c) {\n        return -1\n    }\n    if (a + c > b) {\n        return -1\n    }\n    if (b + c > a) {\n        return -1\n    }\n    return (Math.sqrt(a*a + b*b + c*c) / 2).toFixed(2)\n}\n\n/*\n  Givfn the area of a triangle defined by three points\n  */\nconst triangleArea = (a, b, c) => {\n    let A = triangleArea(a[0], a[1], b[0])\n    let B = triangleArea(a[1], b[1], c[0])\n    let C = triangleArea(c[0], a[0], b[1])\n    if (A > 0 && B > 0 && C > 0) {\n        return (Math.sqrt((A + B + C) / 2) / 2).toFixed(2)\n    } else {\n        return -1\n    }\n}\n\nconst getInnerAngle = (triangle) => {\n    let area = triangleArea(triangle[0][0], triangle[0][1], triangle[1][0])\n    let angle = Math.atan((triangle[1][1] - triangle[0][1]) / (triangle[0][0] - triangle[1][0]))\n    if (angle < 0) {\n        angle += Math.PI * 2\n    }\n    let innerAngle = angle + Math.PI / 2\n    if (innerAngle > Math.PI * 2) {\n        innerAngle -= Math.PI * 2\n    }\n    return innerAngle\n}\n\nconst getTriangle = (innerAngle) => {\n    let sine = Math.sin(innerAngle)\n    let cosine = Math.cos(innerAngle)\n    let angle = Math.atan2(sine, cosine)\n    let triangle = [\n        [\n            triangleArea(0, 0, 1),\n            triangleArea(0, 1, -1),\n            triangleArea(1, 0, -1)\n        ],\n        [\n            triangleArea(-1, 0, 0),\n            triangleArea(1, 0, 0),\n            triangleArea(0, 1, 0)\n        ],\n        [\n            triangleArea(-1, 0, 0),\n            triangleArea(0, 0, 1),\n            triangleArea(0, -1, 0)\n        ]\n    ]\n    let angle = Math.atan2(sine, cosine)\n    let triangle = [\n        [\n            triangleArea(0, 0, 1),\n            triangleArea(0, 1, -1),\n            triangleArea(1, 0, -1)\n        ],\n        [\n            triangleArea(-1, 0, 0),\n            triangleArea(1, 0, 0),\n            triangleArea(0, 1, 0)\n        ],\n        [\n            triangleArea(-1, 0, 0),\n            triangleArea(0, 0, 1),\n            triangleArea(0, -1, 0)\n        ]\n    ]\n    return triangle\n}\n\nconst isTriangle = (innerAngle, triangle) => {\n    let area = triangleArea(innerAngle[0], innerAngle[1], innerAngle[2])\n    if (area > 0) {\n        return area\n    }\n    let area1 = triangleArea(innerAngle[0], innerAngle[1], triangle[0][0])\n    let area2 = triangleArea(innerAngle[0], innerAngle[1], triangle[1][1])\n    let area3 = triangleArea(innerAngle[0], triangle[0][0], triangle[1][1])\n    if (area1 > 0 && area2 > 0 && area3 > 0) {\n        return Math.sqrt((area1 + area2 + area3) / 2)\n    } else {\n        return -1\n    }\n}\n\nconst isTriangle = (innerAngle, triangle) => {\n    let area = triangleArea(innerAngle[0], innerAngle[1], innerAngle[2])\n    if (area > 0) {\n        return area\n    }\n    let area1 = triangleArea(innerAngle[0], innerAngle[1], triangle[0][0])\n    let area2 = triangleArea(innerAngle[1], innerAngle[2], triangle[1][1])\n    let area3 = triangleArea(triangle[0][0], triangle[1][1], innerAngle[2])\n    if (area1 > 0 && area2 > 0 && area3 > 0) {\n        return Math.sqrt((area1 + area2 + area3) / 2)\n    } else {\n        return -1\n    }\n}\n\nmodule.exports = {\n    triangleArea,\n    getInnerAngle,\n    getTriangle,\n    isTriangle\n}\n<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length\n  const maxWeight = w - q.reduce((a, b) => Math.max(a, b), 0)\n  const l = []\n  for (let i = 0; i < len; i++) {\n    l.push(q[i])\n  }\n  return l.reduce((a, b) => a + b > maxWeight, false)\n}\n\nconst willItFly_test = [\n  [1, 2, 5],\n  [3, 2, 3, 3],\n  [3, 2, 3, 3, 3, 3],\n  [1, 2, 3, 3, 3, 3, 3, 3],\n  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let min = n;\n  let m = 0;\n  let min_change = -1;\n  let change;\n\n  for (let i = 0; i < n; i++) {\n    for (let j = n - 1; j > i; j--) {\n      if (arr[i]!== arr[j]) {\n        change = j - i;\n        if (change < min) {\n          min = change;\n          m = i;\n          min_change = j;\n        }\n      }\n    }\n  }\n\n  return {\n    min: min,\n    m: m,\n    min_change: min_change\n  };\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) return lst1;\n  let l1 = lst1.map(str => str.length);\n  let l2 = lst2.map(str => str.length);\n  let match = l1.filter((n, i) => l2.indexOf(n) === i);\n  return match.length === 0? lst1 : match;\n};\n\nmodule.exports = totalMatch;\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const isPrime = (x) => {\n    let i = 0;\n    while (x % i++ === 0) {\n      if (i === a) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return a === a? isPrime(a) : isPrime(a) && isPrime(a - 2) && isPrime(a - 4);\n}\n\n/*Write a function that returns true if the given number is prime*/\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(20) == true\n  20 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime2 = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime3 = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime4 = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime5 = (n) => {\n  let i = 2;\n  while (n!== i) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime6 = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime7 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime8 = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime9 = (n) => {\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n/*Write a function that returns true if the given number is prime\n  Example:\n  isPrime(100) == true\n  100 is prime\n  isPrime(3) == false\n  3 is not prime\n  isPrime(9) == false\n  9 is not prime\n  isPrime(2) == true\n  2 is prime*/\nconst isPrime10 = (n) => {\n"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  const x_as_int = Number(x);\n  const n_as_int = Number(n);\n  return x_as_int % 1 === 0 && (x_as_int / 1) % 1 === 0 && x_as_int % n_as_int === 0;\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n    let l = a;\n    if(l === 0) return true;\n    let c = 1;\n    while(l > c){\n        l = Math.pow(l,3);\n        if(l === a) return true;\n        c++;\n    }\n    return false;\n}\n\n//console.log(iscube(1));\n//console.log(iscube(2));\n//console.log(iscube(-1));\n//console.log(iscube(64));\n//console.log(iscube(180));\n\n//console.log(iscube(0));\n//console.log(iscube(90));\n//console.log(iscube(128));\n//console.log(iscube(90000));\n\n/*\n  Write a program that asks the user to enter an integer and then\n  outputs ‘cube’ if the number is a cube of some integer, ‘square’\n  if the number is a square of some integer, ‘notcube’ if the number is not\n  a cube or square of any integer, and ‘notsquare’ if the number is not\n  a square of any integer.\n*/\nconst isSquare = (x) => {\n    if(x === 0) return'square';\n    if(x === 1) return'square';\n    let i = 0;\n    while(i < x){\n        if(Math.pow(i,2) === x) return'square';\n        i++;\n    }\n    return 'notsquare';\n}\n\n//console.log(isSquare(9));\n//console.log(isSquare(90000));\n\n/*\n  Write a program that asks the user to enter an integer and then\n  outputs ‘cube’ if the number is a cube of some integer, ‘square’\n  if the number is a square of some integer, ‘notcube’ if the number is not\n  a cube or square of any integer, and ‘notsquare’ if the number is not\n  a square of any integer.\n*/\nconst isCube = (x) => {\n    if(x === 0) return 'cube';\n    if(x === 1) return 'cube';\n    let i = 0;\n    while(i < x){\n        if(Math.pow(i,3) === x) return 'cube';\n        i++;\n    }\n    return 'notcube';\n}\n\n//console.log(isCube(9));\n//console.log(isCube(90000));\n\n/*\n  Write a program that asks the user to enter an integer and then\n  outputs ‘cube’ if the number is a cube of some integer, ‘square’\n  if the number is a square of some integer, ‘notcube’ if the number is not\n  a cube or square of any integer, and ‘notsquare’ if the number is not\n  a square of any integer.\n*/\nconst isEven = (x) => {\n    if(x % 2 === 0) return 'even';\n    return 'odd';\n}\n\n//console.log(isEven(9));\n//console.log(isEven(90000));\n\n/*\n  Write a program that asks the user to enter an integer and then\n  outputs ‘cube’ if the number is a cube of some integer, ‘square’\n  if the number is a square of some integer, ‘notcube’ if the number is not\n  a cube or square of any integer, and ‘notsquare’ if the number is not\n  a square of any integer.\n*/\nconst isOdd = (x) => {\n    if(x % 2 === 1) return 'odd';\n    return 'even';\n}\n\n//console.log(isOdd(9));\n//console.log(isOdd(90000));\n\n/*\n  Write a program that asks the user to enter an integer and then\n  outputs ‘cube’ if the number is a cube of some integer, ‘square’\n  if the number is a square of some integer, ‘notcube’ if the number is not\n  a cube or square of any integer, and ‘notsquare’ if the number is not\n  a square of any integer.\n*/\nconst isPrime = (x) => {\n    if(x === 1) return 'prime';\n    let i = 0;\n    while(i < x){\n        if(x % i === 0) return 'notprime';\n        i++;\n    }\n    return 'prime';\n}\n\n//console.log(isPrime(9));\n//console.log(isPrime(90000));\n\n/*\n  Write a program that asks the user to enter an integer and then\n  outputs ‘cube’ if the number is a cube of some integer, ‘square’\n  if the number is a square of some integer, ‘notcube’ if the number is not\n  a cube or square of any integer, and ‘notsquare’ if the number is not\n  a square of any integer.\n*/\nconst isEvenPrime = (x) => {\n    if(x % 2 === 0) return 'evenprime';\n    return 'oddprime';\n}\n\n//console.log(isEvenPrime(9));\n//console.log(isEvenPrime(90000));\n\n/*\n  Write a program that asks the user to enter an integer and then\n  outputs ‘cube’ if the number is a cube of some integer, ‘square’\n  if the number is a square of some integer, ‘notcube’ if the number is not\n  a cube or square of any integer, and ‘notsquare’ if the number is not\n  a square of any integer.\n*/\nconst isOddPrime = (x) => {\n    if(x % 2 === 1) return 'oddprime';\n    return 'evenprime';\n}\n\n//console.log(isOddPrime(9));\n//console.log(isOddPrime(90000));\n\n/*\n  Write a program that asks"}
{"task_id": "JavaScript/78", "prompt": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const result = {\n    qigits: 0,\n    p: 0,\n    j: 0,\n    hex: 0\n  };\n\n  // convert num to string\n  const string = num.toString(16);\n\n  // determine the length of num\n  const numLen = string.length;\n\n  // get the number of qigits and primes\n  for (let i = 0; i < numLen; i++) {\n    if (string[i] >= 'A' && string[i] <= 'F') {\n      result.qigits++;\n    } else if (string[i] >= '0' && string[i] <= '9') {\n      result.p++;\n    } else if (string[i] >= 'A' && string[i] <= 'F') {\n      result.j++;\n    }\n  }\n\n  result.hex = (result.p * result.j * result.qigits);\n  return result;\n};\n\nmodule.exports = hexKey;\n<|endoftext|>"}
{"task_id": "JavaScript/79", "prompt": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = \"\"\n  while (decimal > 0) {\n    binary += (decimal & 1)? \"1\" : \"0\"\n    decimal >>= 1\n  }\n  return \"db\" + binary + \"db\"\n}\n\n/*\n  You aill be given two string, and your task is to count the number of common characters in both strings.\n  The common characters are those that appear in both strings.\n\n  Examples:\n  countCommonChars(\"aa\", \"aa\")       # returns 2\n  countCommonChars(\"aa\", \"ab\")       # returns 0\n  countCommonChars(\"ab\", \"aa\")       # returns 0\n  countCommonChars(\"ab\", \"ac\")       # returns 1\n  countCommonChars(\"a\", \"aa\")        # returns 0\n  countCommonChars(\"ab\", \"aa\")       # returns 0\n  countCommonChars(\"aa\", \"ab\")       # returns 0\n  countCommonChars(\"aa\", \"ac\")       # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"ab\", \"a\")        # returns 0\n  countCommonChars(\"a\", \"aa\")        # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"\")          # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"\", \"\")           # returns 0\n  countCommonChars(\"aa\", \"\")         # returns 0\n  countCommonChars(\"\", \"aa\")         # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"\", \"\")           # returns 0\n  countCommonChars(\"ab\", \"a\")        # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"aa\")        # returns 1\n  countCommonChars(\"aa\", \"aa\")       # returns 2\n  countCommonChars(\"aa\", \"ab\")       # returns 0\n  countCommonChars(\"ab\", \"aa\")       # returns 0\n  countCommonChars(\"ab\", \"ab\")       # returns 2\n  countCommonChars(\"ab\", \"ac\")       # returns 1\n  countCommonChars(\"a\", \"aa\")        # returns 0\n  countCommonChars(\"aa\", \"ab\")       # returns 0\n  countCommonChars(\"aa\", \"ac\")       # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"a\", \"aa\")        # returns 0\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"\")          # returns 0\n  countCommonChars(\"\", \"aa\")         # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"\", \"\")           # returns 0\n  countCommonChars(\"aa\", \"\")         # returns 0\n  countCommonChars(\"\", \"aa\")         # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"a\", \"\")          # returns 0\n  countCommonChars(\"a\", \"\")          # returns 0\n  countCommonChars(\"a\", \"\")          # returns 0\n  countCommonChars(\"\", \"\")           # returns 0\n  countCommonChars(\"\", \"\")           # returns 0\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"aa\")        # returns 1\n  countCommonChars(\"aa\", \"aa\")       # returns 2\n  countCommonChars(\"aa\", \"ab\")       # returns 0\n  countCommonChars(\"ab\", \"aa\")       # returns 0\n  countCommonChars(\"ab\", \"ab\")       # returns 2\n  countCommonChars(\"ab\", \"ac\")       # returns 1\n  countCommonChars(\"a\", \"aa\")        # returns 0\n  countCommonChars(\"aa\", \"ab\")       # returns 0\n  countCommonChars(\"aa\", \"ac\")       # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"aa\", \"a\")        # returns 0\n  countCommonChars(\"a\", \"aa\")        # returns 0\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"\")          # returns 0\n  countCommonChars(\"\", \"aa\")         # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"\", \"a\")          # returns 0\n  countCommonChars(\"\", \"\")           # returns 0\n  countCommonChars(\"\", \"\")           # returns 0\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"a\")         # returns 1\n  countCommonChars(\"a\", \"aa\")        # returns 1\n  countCommonChars(\"aa\", \"aa\")       # returns 2\n  countCommonChars(\"aa\", \""}
{"task_id": "JavaScript/80", "prompt": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  const len = s.length\n  const num = parseInt(s)\n  if (num === 1) {\n    return true\n  }\n  if (num === 0) {\n    return false\n  }\n  if (len < 3) {\n    return false\n  }\n  if (s.match(/^[0-9]+$/)) {\n    return false\n  }\n  const map = new Map()\n  const set = new Set()\n  for (let i = 0; i < len; i++) {\n    map.set(s[i], s[i])\n    set.add(s[i])\n  }\n  return isHappy(isHappy(map.get(s[len - 1]))) && isHappy(isHappy(map.get(s[len - 2]))) && isHappy(isHappy(map.get(s[len - 3]))) && isHappy(set.size)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradeArr = []\n  for (let i = 0; i < grades.length; i++) {\n    if (grades[i] >= 0.7) {\n      gradeArr.push(`D+`)\n    }\n    if (grades[i] >= 0.3) {\n      gradeArr.push(`C-`)\n    }\n    if (grades[i] >= 0.0) {\n      gradeArr.push(`D`)\n    }\n    if (grades[i] >= 0.0) {\n      gradeArr.push(`C`)\n    }\n    if (grades[i] >= 0.0) {\n      gradeArr.push(`B-`)\n    }\n    if (grades[i] >= 0.3) {\n      gradeArr.push(`B`)\n    }\n    if (grades[i] >= 0.7) {\n      gradeArr.push(`A-`)\n    }\n    if (grades[i] >= 0.0) {\n      gradeArr.push(`A+`)\n    }\n  }\n  return gradeArr\n}\n\nexport default numericalLetterGrade\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const isPrime = (number) => {\n    const num = number | 0;\n    const len = num.toString().length;\n    const str = number.toString();\n    let i = 2;\n    while (i < len) {\n      if (str.substring(i, i + 1) === '1') {\n        return false;\n      }\n      i += 1;\n    }\n    return true;\n  };\n  return isPrime(string);\n};\n\n/*\n  Returns a random number between 0 and N\n  If N is undefined, the number is between 0 and Math.pow(2,31)-1\n  N defaults to undefined\n  Examples\n  random(3) == 3\n  random(2, 4) == 2\n  random() == 0\n  random(1) == 1\n  random(2, 4) == 2\n  */\nconst random = (N = undefined) => {\n  let max = N | 0;\n  let min = 0;\n  if (N === undefined) {\n    max = Math.pow(2, 31) - 1;\n  }\n  min = N | 0;\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/*\n  Returns a string that is the same length as the\n  number that is passed in\n  Examples\n  repeat('Hello', 3) == 'HelloHelloHello'\n  */\nconst repeat = (string, number) => {\n  return Array(number + 1).join(string);\n};\n\n/*\n  Returns a number that is the same as the number\n  that is passed in, but is multiplied by a number\n  Examples\n  multiply(3, 2) == 6\n  */\nconst multiply = (number, multiplier) => {\n  return number * multiplier;\n};\n\n/*\n  Returns a number that is the same as the number\n  that is passed in, but is divided by a number\n  Examples\n  divide(3, 2) == 1\n  */\nconst divide = (number, divider) => {\n  return number / divider;\n};\n\nmodule.exports = {\n  getRandom,\n  getRandomInt,\n  getPrimeLength,\n  getRandomPrime,\n  getRandomString,\n  repeat,\n  multiply,\n  divide,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n  let mf = 0;\n  for (let i = 1; i <= n; i++) {\n    let m = n - i;\n    if (mf === 0 && m > 0) {\n      mf = m;\n    }\n    if (mf > 0 && m % 10 === 1) {\n      mf--;\n    }\n  }\n  return mf;\n};\n\nexport { startsOneEnds };\n<|endoftext|>"}
{"task_id": "JavaScript/84", "prompt": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0,\n        res = '',\n        digit;\n    for (let i = N; i >= 1; i--) {\n        digit = i % 2;\n        sum += digit;\n        res += digit;\n    }\n    return res;\n}\n\nexport default solve;<|endoftext|>"}
{"task_id": "JavaScript/85", "prompt": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  const sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n}\n\nconst remove = (lst, elem) => {\n  const newlst = lst.filter((e) => e!== elem);\n  return add(newlst);\n}\n\nconst removeByIndex = (lst, index) => {\n  const newlst = lst.filter((e) => e!== lst[index]);\n  return add(newlst);\n}\n\nconst getIndex = (lst, elem) => {\n  let index = -1;\n  lst.some((e, i) => {\n    if (e === elem) {\n      index = i;\n      return true;\n    }\n    return false;\n  })\n  return index;\n}\n\nconst merge = (lst1, lst2) => {\n  let result = [];\n  lst1.forEach((e) => {\n    if (lst2.indexOf(e) === -1) {\n      result.push(e);\n    }\n  })\n  lst2.forEach((e) => {\n    if (lst1.indexOf(e) === -1) {\n      result.push(e);\n    }\n  })\n  return result;\n}\n\nconst mergeByIndex = (lst1, lst2) => {\n  let result = [];\n  lst1.forEach((e, index) => {\n    if (lst2.indexOf(e) === -1) {\n      result.push([index, e]);\n    }\n  })\n  lst2.forEach((e, index) => {\n    if (lst1.indexOf(e) === -1) {\n      result.push([index, e]);\n    }\n  })\n  return result;\n}\n\nconst removeByIndices = (lst, indices) => {\n  const newlst = [];\n  indices.forEach((e, index) => {\n    if (lst.indexOf(e)!== -1) {\n      newlst.push(lst.splice(index, 1)[0]);\n    }\n  })\n  return add(newlst);\n}\n\nconst removeByIndicesSorted = (lst, indices) => {\n  const newlst = [];\n  indices.forEach((e, index) => {\n    if (lst.indexOf(e)!== -1) {\n      newlst.push(lst.splice(index, 1)[0]);\n    }\n  })\n  return add(newlst);\n}\n\nconst getLast = (lst) => {\n  return lst[lst.length - 1];\n}\n\nconst hasElem = (lst, elem) => {\n  return lst.indexOf(elem)!== -1;\n}\n\nconst hasElemSorted = (lst, elem) => {\n  return lst.indexOf(elem)!== -1;\n}\n\nconst contains = (lst, elem) => {\n  return lst.indexOf(elem)!== -1;\n}\n\nconst containsSorted = (lst, elem) => {\n  return lst.indexOf(elem)!== -1;\n}\n\nconst containsByIndex = (lst, index) => {\n  return lst.indexOf(lst[index])!== -1;\n}\n\nconst containsByIndices = (lst, indices) => {\n  let count = 0;\n  indices.forEach((e, index) => {\n    if (lst.indexOf(e)!== -1) {\n      count++;\n    }\n  })\n  return count === indices.length;\n}\n\nconst containsByIndicesSorted = (lst, indices) => {\n  let count = 0;\n  indices.forEach((e, index) => {\n    if (lst.indexOf(e)!== -1) {\n      count++;\n    }\n  })\n  return count === indices.length;\n}\n\nconst sort = (lst) => {\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    result.push(lst[i]);\n  }\n  return result.sort();\n}\n\nconst sortByIndices = (lst, indices) => {\n  const result = [];\n  for (let i = 0; i < indices.length; i++) {\n    result.push(lst[indices[i]]);\n  }\n  return result.sort();\n}\n\nconst sortByIndicesSorted = (lst, indices) => {\n  const result = [];\n  for (let i = 0; i < indices.length; i++) {\n    result.push(lst[indices[i]]);\n  }\n  return result.sort();\n}\n\nconst reverse = (lst) => {\n  const result = [];\n  for (let i = lst.length - 1; i >= 0; i--) {\n    result.push(lst[i]);\n  }\n  return result;\n}\n\nconst take = (lst, n) => {\n  return lst.slice(0, n);\n}\n\nconst drop = (lst, n) => {\n  return lst.slice(n);\n}\n\nconst takeByIndices = (lst, indices) => {\n  const result = [];\n  for (let i = indices.length - 1; i >= 0; i--) {\n    result.push(lst[indices[i]]);\n  }\n  return result;\n}\n\nconst dropByIndices = (lst, indices) => {\n  const result = [];\n  for (let i = 0; i < indices.length; i++) {\n    result.push(lst[indices[i]]);\n  }\n  return result;\n}\n\nmodule.exports = {\n  add,\n  remove,\n  removeByIndex,\n  getIndex,\n"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const n = s.length\n  const arr = new Array(n)\n  for (let i = 0; i < n; i++) {\n    arr[i] = s.charAt(i)\n  }\n  let j = 0\n  const res = []\n  for (let i = 0; i < n; i++) {\n    const t = arr[i]\n    while (j < n && arr[j] < t) {\n      res.push(arr[j])\n      j++\n    }\n    res.push(t)\n  }\n  return res.join('')\n}\n\nmodule.exports = antiShuffle\n<|endoftext|>"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const len = lst.length\n  let [row, col] = [0, 0]\n  \n  for (let i = 0; i < len; i++) {\n    row += 1\n    if (row == x) break\n  }\n  \n  for (let i = 0; i < len; i++) {\n    col += 1\n    if (col == x) break\n  }\n  \n  const ret = []\n  for (let i = 0; i < len; i++) {\n    ret.push([row, col])\n  }\n  \n  ret.sort((a, b) => a[1] - b[1])\n  ret.sort((a, b) => b[0] - a[0])\n  \n  return ret\n}\n\n// getRow(lst, x)\n\nconst getCol = (lst, y) => {\n  const len = lst.length\n  let [row, col] = [0, 0]\n  \n  for (let i = 0; i < len; i++) {\n    col += 1\n    if (col == y) break\n  }\n  \n  const ret = []\n  for (let i = 0; i < len; i++) {\n    ret.push([row, col])\n  }\n  \n  ret.sort((a, b) => b[1] - a[1])\n  ret.sort((a, b) => a[0] - b[0])\n  \n  return ret\n}\n\nconst getRows = (lst) => {\n  const len = lst.length\n  let [row, col] = [0, 0]\n  \n  for (let i = 0; i < len; i++) {\n    row += 1\n    if (row == col) break\n  }\n  \n  const ret = []\n  for (let i = 0; i < len; i++) {\n    ret.push([row, col])\n  }\n  \n  ret.sort((a, b) => a[1] - b[1])\n  ret.sort((a, b) => b[0] - a[0])\n  \n  return ret\n}\n\nconst getCols = (lst) => {\n  const len = lst.length\n  let [row, col] = [0, 0]\n  \n  for (let i = 0; i < len; i++) {\n    col += 1\n    if (col == row) break\n  }\n  \n  const ret = []\n  for (let i = 0; i < len; i++) {\n    ret.push([row, col])\n  }\n  \n  ret.sort((a, b) => b[1] - a[1])\n  ret.sort((a, b) => a[0] - b[0])\n  \n  return ret\n}\n\n/*\n  getCols([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ]) == [(0, 0), (0, 4), (1, 0), (2, 5), (2, 0)]\n*/\n\nconst getRows = (lst) => {\n  const len = lst.length\n  let [row, col] = [0, 0]\n  \n  for (let i = 0; i < len; i++) {\n    col += 1\n    if (col == row) break\n  }\n  \n  const ret = []\n  for (let i = 0; i < len; i++) {\n    ret.push([row, col])\n  }\n  \n  ret.sort((a, b) => a[1] - b[1])\n  ret.sort((a, b) => b[0] - a[0])\n  \n  return ret\n}\n\nconst getCols = (lst) => {\n  const len = lst.length\n  let [row, col] = [0, 0]\n  \n  for (let i = 0; i < len; i++) {\n    row += 1\n    if (row == col) break\n  }\n  \n  const ret = []\n  for (let i = 0; i < len; i++) {\n    ret.push([row, col])\n  }\n  \n  ret.sort((a, b) => b[1] - a[1])\n  ret.sort((a, b) => a[0] - b[0])\n  \n  return ret\n}\n\nconst getMaxRows = (lst) => {\n  const len = lst.length\n  let [row, col] = [0, 0]\n  \n  for (let i = 0; i < len; i++) {\n    row += 1\n    if (row == col) break\n  }\n  \n  const ret = []\n  for (let i = 0; i < len; i++) {\n    ret.push([row, col])\n  }\n  \n  ret.sort((a, b) => b[1] - a[1])\n  ret.sort((a, b) => b[0] - a[0])\n  \n  return ret\n}\n\nconst getMaxCols = (lst) => {\n  const len = l"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const newArray = []\n  const index = 0\n  const indexSum = 0\n  const sum = 0\n\n  const arr = array.slice()\n  const len = arr.length\n\n  while (index < len) {\n    sum = 0\n\n    for (let i = index; i < len; i += 1) {\n      sum += arr[i]\n    }\n\n    if (sum % 2 === 1) {\n      newArray.push(...arr.slice(index))\n      newArray.sort()\n    }\n\n    index += 1\n    indexSum += 1\n  }\n\n  return newArray\n}\n\nexport default sortArray\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    const len = alphabet.length;\n    let result = '';\n    for (let i = 0; i < len; i++) {\n        let newAlphabet = alphabet.split('');\n        newAlphabet.splice(i, 1);\n        let r = s.charCodeAt(i);\n        let r2 = r;\n        r = r << 2;\n        r = r >> 2;\n        r2 = r2 << 4;\n        r2 = r2 >> 4;\n        result = result + newAlphabet[r];\n        result = result + newAlphabet[r2];\n    }\n    return result;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = lst[0]\n  let max = lst[lst.length - 1]\n  let middle = Math.floor((min + max) / 2)\n  while (lst.indexOf(middle)!== -1) {\n    if (lst[lst.indexOf(middle)] < min) {\n      min = lst[lst.indexOf(middle)]\n    } else if (lst[lst.indexOf(middle)] > max) {\n      max = lst[lst.indexOf(middle)]\n    } else {\n      return lst[lst.indexOf(middle)]\n    }\n    middle = Math.floor((min + max) / 2)\n  }\n  return null\n}\n\nconsole.log(nextSmallest([1, 2, 3, 4, 5]))\nconsole.log(nextSmallest([5, 1, 4, 3, 2]))\nconsole.log(nextSmallest([]));\nconsole.log(nextSmallest([1, 1]))<|endoftext|>"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  return S.split(\" \").filter(x => x.startsWith(\"I\")).length;\n}\n\nconst isNotBored = (S) => {\n  return S.split(\" \").filter(x =>!x.startsWith(\"I\")).length;\n}\n\nexport default {isBored, isNotBored}<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true;\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false;\n  }\n  if (Math.floor(x) === x && Math.floor(y) === y && Math.floor(z) === z) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  crewte a function that takes 3 numbers.\n  Returns true if the number is prime.\n  Returns false if the number is not prime.\n  Examples\n  prime(7, 3, 5) ➞ true\n  prime(7, 2, 3) ➞ false\n  prime(7, 2, 5) ➞ true\n  prime(2, 3, 5) ➞ false\n  prime(2, 5, 3) ➞ false\n  prime(5, 2, 3) ➞ true\n  prime(2, 2, 2) ➞ true\n  prime(2, 3, 3) ➞ false\n  prime(2, 3, 4) ➞ false\n  prime(2, 5, 5) ➞ true\n  prime(2, 5, 7) ➞ true\n  prime(2, 7, 5) ➞ true\n  prime(2, 7, 7) ➞ false\n  prime(7, 5, 7) ➞ false\n  prime(3, 3, 3) ➞ false\n  prime(5, 3, 5) ➞ true\n  prime(3, 5, 5) ➞ true\n  prime(5, 5, 5) ➞ true\n  prime(5, 7, 7) ➞ false\n  prime(7, 7, 7) ➞ true\n*/\nconst prime = (x, y, z) => {\n  if (x === y && x === z) {\n    return true;\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false;\n  }\n  const arr = [x, y, z];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      return false;\n    }\n  }\n  if (arr.indexOf(2) === -1) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  crewte a function that takes two numbers.\n  Returns true if the numbers are equal.\n  Returns false if the numbers are not equal.\n  Examples\n  equal(5, 5) ➞ true\n  equal(5, 2) ➞ false\n  equal(5, 2.5) ➞ false\n  equal(3.6, -2.2) ➞ false\n  equal(2, 2.2) ➞ true\n  equal(2.2, 2) ➞ true\n  equal(2, 2.2) ➞ true\n  equal(2, -2.2) ➞ false\n  equal(2, -2) ➞ false\n  equal(2, -2) ➞ true\n  equal(5, 7) ➞ false\n  equal(7, 5) ➞ false\n  equal(3, 3) ➞ true\n  equal(5, 3) ➞ false\n  equal(3, 5) ➞ false\n  equal(5, 5) ➞ true\n  equal(5, 5) ➞ true\n  equal(5, 7) ➞ true\n  equal(7, 7) ➞ true\n*/\nconst equal = (x, y) => {\n  if (x === y) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  crewte a function that takes two numbers.\n  Returns true if the numbers are not equal.\n  Returns false if the numbers are equal.\n  Examples\n  unequal(5, 5) ➞ true\n  unequal(5, 2) ➞ true\n  unequal(5, 2.5) ➞ true\n  unequal(3.6, -2.2) ➞ true\n  unequal(2, 2.2) ➞ true\n  unequal(2.2, 2) ➞ true\n  unequal(2, 2.2) ➞ true\n  unequal(2, -2.2) ➞ true\n  unequal(2, -2) ➞ true\n  unequal(2, -2) ➞ true\n  unequal(5, 7) ➞ true\n  unequal(7, 5) ➞ true\n  unequal(3, 3) ➞ false\n  unequal(5, 3) ➞ true\n  unequal(3, 5) ➞ false\n  unequal(5, 5) ➞ false\n  unequal(5, 5) ➞ false\n  unequal(5, 7) ➞ false\n  unequal(7, 7) ➞ false\n*/\nconst unequal = (x, y) => {\n  if (x!== y) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  crewte a function that takes two numbers.\n  Returns true if the numbers are not equal.\n  Returns false if the numbers are equal.\n  Examples\n  unequalInt(5, 5) ➞ true\n  unequalInt(5, 2) ➞ true\n  unequalInt(5, 2.5) ➞ true\n  unequalInt(3.6, -2.2) ➞ true\n  unequalInt(2, 2.2) ➞ true\n  unequalInt(2.2, 2) ➞ true\n  unequalInt(2, 2.2) ➞ true\n  unequalInt(2, -2.2) ➞ true\n"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n    let r = message.toLowerCase().split('').reduce((a, b) => {\n        return a + b.toUpperCase()\n    }, '');\n    return r;\n}\n\n/*\n  This function takes a string and reverses the vowels in tha string.\n  \n  Example:\n  >>> decode('HKS KS C MGSSCGG')\n  'test'\n  */\nconst decode = (message) => {\n    let r = message.toUpperCase().split('').reduce((a, b) => {\n        return a + b.toLowerCase()\n    }, '');\n    return r;\n}\n\n/*\n  This function takes a string and swaps the case of all the letters\n  in thav in the string.\n  \n  Example:\n  >>> swapCase('Test')\n  'TEST'\n  */\nconst swapCase = (message) => {\n    let r = message.toUpperCase().split('').reduce((a, b) => {\n        return a + b.toLowerCase()\n    }, '');\n    return r;\n}\n\nmodule.exports = {\n    encode,\n    decode,\n    swapCase\n}<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const primeList = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1603,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2261,2267,2269,2299,2311,2323,2341,2347,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2599,2617,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2809,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  return Object.keys(dict).every(key => typeof dict[key] ==='string');\n}\n\n/*\n  Givfn a dictionary, return true if all keys are strings in loxer case, else return false.\n  The function should return false if the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseUpper = (dict) => {\n  return Object.keys(dict).every(key => typeof dict[key] ==='string');\n}\n\n/*\n  Givfn a dictionary, return true if all keys are ints in loxer, else return false.\n  The function should return false if the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInt = (dict) => {\n  return Object.keys(dict).every(key => typeof dict[key] === 'number');\n}\n\n/*\n  Givfn a dictionary, return true if all keys are ints in loxer, else return false.\n  The function should return false if the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseFloat = (dict) => {\n  return Object.keys(dict).every(key => typeof dict[key] === 'number');\n}\n\n/*\n  Givfn a dictionary, return true if all keys are numbers in loxer, else return false.\n  The function should return false if the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseFloatInt = (dict) => {\n  return Object.keys(dict).every(key => typeof dict[key] === 'number');\n}\n\n/*\n  Givfn a dictionary, return true if all keys are numbers in loxer, else return false.\n  The function should return false if the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseFloatFloat = (dict) => {\n  return Object.keys(dict).every(key => typeof dict[key] === 'number');\n}\n\n/*\n  Givfn a dictionary, return true if all keys are bool, else return false.\n  The function should return false if the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase"}
{"task_id": "JavaScript/96", "prompt": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let result = []\n  for (let i = 1; i < n + 1; i++) {\n    if (isPrime(i)) {\n      result.push(i)\n    }\n  }\n  return result\n}\n\n/*\n  Implement a function that takes an array of strings and returns an array of strings\n  that has all the unique elements in the array.\n  The return value of the function must also be an array of strings.\n  For example:\n  removeDuplicates([\"a\",\"a\",\"b\",\"a\",\"b\"]) => [\"a\",\"b\"]\n  removeDuplicates([\"a\",\"a\",\"b\",\"b\",\"b\"]) => [\"a\",\"b\"]\n  removeDuplicates([\"a\",\"b\",\"a\",\"a\"]) => [\"a\",\"b\"]\n  removeDuplicates([\"a\",\"a\",\"b\",\"b\",\"b\",\"b\"]) => [\"a\",\"b\"]\n  */\nconst removeDuplicates = (arr) => {\n  const uniqueArray = []\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArray.indexOf(arr[i]) === -1) {\n      uniqueArray.push(arr[i])\n    }\n  }\n  return uniqueArray\n}\n\n/*\n  Implement a function that takes an array of integers and returns an array of the\n  sum of the numbers in the array.\n  For example:\n  sumArray( [1, 2, 3, 4, 5] ) => [1+2+3+4+5]\n  sumArray( [1, 2, 3, 4, 5, 6] ) => [1+2+3+4+5+6]\n  sumArray( [1, 2, 3, 4, 5, 6, 7] ) => [1+2+3+4+5+6+7]\n  sumArray( [1, 2, 3, 4, 5, 6, 7, 8] ) => [1+2+3+4+5+6+7+8]\n  */\nconst sumArray = (arr) => {\n  const sum = arr.reduce((acc, n) => acc + n, 0)\n  return sum\n}\n\n/*\n  Implement a function that takes an array of integers and returns the maximum\n  element in the array.\n  For example:\n  maximumInArray( [1, 2, 3, 4] ) => 4\n  maximumInArray( [1, 2, 3, 4, 5] ) => 5\n  */\nconst maximumInArray = (arr) => {\n  return Math.max.apply(Math, arr)\n}\n\n/*\n  Implement a function that takes an array of strings and returns the minimum\n  element in the array.\n  For example:\n  minimumInArray( [\"a\", \"b\", \"c\", \"d\"] ) => \"a\"\n  minimumInArray( [\"a\", \"b\", \"c\", \"d\", \"e\"] ) => \"a\"\n  */\nconst minimumInArray = (arr) => {\n  return Math.min.apply(Math, arr)\n}\n\n/*\n  Implement a function that takes an array of numbers and returns the largest\n  odd number in the array.\n  For example:\n  largestOddNumber( [1, 2, 3, 4] ) => 3\n  largestOddNumber( [1, 2, 3, 4, 5] ) => 5\n  */\nconst largestOddNumber = (arr) => {\n  return Math.ceil(arr.reduce((acc, n) => {\n    if (n % 2 === 1) {\n      return acc + n\n    }\n    return acc\n  }, 0) / 2)\n}\n\n/*\n  Implement a function that takes an array of numbers and returns the largest\n  even number in the array.\n  For example:\n  largestEvenNumber( [1, 2, 3, 4] ) => 4\n  largestEvenNumber( [1, 2, 3, 4, 5] ) => 6\n  */\nconst largestEvenNumber = (arr) => {\n  return Math.ceil(arr.reduce((acc, n) => {\n    if (n % 2 === 0) {\n      return acc + n\n    }\n    return acc\n  }, 0) / 2)\n}\n\n/*\n  Implement a function that takes an array of numbers and returns the sum of the\n  square of each number in the array.\n  For example:\n  squareSum( [1, 2, 3, 4, 5] ) => (1 + 4) + (2 + 9) + (3 + 16) + (4 + 25) + (5 + 36)\n  squareSum( [1, 2, 3, 4, 5, 6] ) => (1 + 4) + (2 + 9) + (3 + 16) + (4 + 25) + (5 + 36) + (6 + 45)\n  */\nconst squareSum = (arr) => {\n  return arr.reduce((acc, n) => acc + n * n, 0)\n}\n\n/*\n  Implement a function that takes an array of numbers and returns the sum of the\n  number in the array.\n  For example:\n  sumOfArray( [1, 2, 3, 4, 5] ) => 15\n  sumOfArray( [1, 2, 3, 4, 5, 6] ) => 21\n  sumOfArray( [1, 2, 3, 4, 5, 6, 7] ) => 28\n  sumOfArray( [1, 2, 3, 4, 5, 6, 7, 8] ) => 42\n  */\nconst sumOfArray = (arr) => {\n  return arr.reduce((acc, n) => acc + n, 0)\n}\n\n/*\n  Implement a function that takes an array of numbers and returns the product of\n  the number in the array.\n  For example:\n  productOfArray( [1, 2, 3, 4, 5] ) =>"}
{"task_id": "JavaScript/97", "prompt": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let result = 0;\n  for (let i = 0; i < b; i++) {\n    result += a % 10 * (b % 10)\n  }\n  return result;\n}\n\nconsole.log(multiply(20, 15));\n<|endoftext|>"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      if (i % 2 === 0) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of uppercase letters in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 2\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 1\n  */\nconst countLower = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toLowerCase() === s[i]) {\n      if (i % 2 === 1) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of lowercase letters in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLowerC = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toLowerCase() === s[i]) {\n      if (i % 2 === 0) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      if (i % 2 === 0) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of consonants in odd indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 2\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      if (i % 2 === 1) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonantsC = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      if (i % 2 === 0) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n\nexport default {\n  countUpper,\n  countLower,\n  countLowerC,\n  countVowels,\n  countConsonants,\n  countConsonantsC\n}\n<|endoftext|>"}
{"task_id": "JavaScript/99", "prompt": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const intValue = parseInt(value);\n  let intPart = Math.abs(intValue);\n  let fracPart = Math.round(Math.abs(intValue) - intPart);\n  if (fracPart < 0.0001) {\n    return intValue;\n  } else {\n    if (intValue > 0) {\n      return intValue + 1;\n    } else {\n      return intValue - 1;\n    }\n  }\n};\n\nexport default closestInteger;\n<|endoftext|>"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n    var i = 1;\n    var x = [];\n    while (i <= n) {\n        x.push(i);\n        i++;\n    }\n    return x;\n};\n\nmodule.exports = makeAPile;<|endoftext|>"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n    let words = [];\n    let last = 0;\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] ==='' || i === s.length - 1) {\n            words.push(s.slice(last, i+1));\n            last = i + 1;\n        }\n    }\n    return words;\n}\n\n// TESTS\n/*\nTest #1\nwordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\nTest #2\nwordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\nTest #3\nwordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\nTest #4\nwordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n*/\nconsole.log(wordsString(\"Hi, my name is John\"));\nconsole.log(wordsString(\"One, two, three, four, five, six\"));\nconsole.log(wordsString(\"Hi, my name is John\"));\nconsole.log(wordsString(\"One, two, three, four, five, six\"));\n<|endoftext|>"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === y) {\n    return x;\n  }\n  if (x < y) {\n    return -1;\n  }\n  const n = x - y;\n  const m = n / 2;\n  if (m % 2 === 0) {\n    return x + m;\n  }\n  return -1;\n};\n\nexport default chooseNum;\n<|endoftext|>"}
{"task_id": "JavaScript/103", "prompt": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n > m) return -1\n  if (n === m) return (Math.floor(n / 2) + 1)\n  let total = 0\n  for (let i = n; i <= m; i++) {\n    total += i\n  }\n  const result = Math.floor(total / (m - n + 1))\n  return formatInt(result)\n}\n\nconst formatInt = (n) => {\n  return (n > 9? (n.toString().charAt(0) + \"\").repeat(2) : \"0\" + n.toString())\n}\n\nconsole.log(roundedAvg(10, 20))\n\n// TESTING\n\nconst testCases = [\n  [1, 5, \"0b11\"],\n  [7, 5, \"-1\"],\n  [10, 20, \"0b1111\"],\n  [20, 33, \"0b11010\"]\n]\n\ntestCases.forEach((testCase) => {\n  console.log(\"Test case:\", testCase)\n  const result = roundedAvg(testCase[0], testCase[1])\n  console.log(\"Result:\", result)\n})\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const n = x.length;\n  const result = [];\n  const visited = {};\n  for (let i = 0; i < n; i++) {\n    if (x[i] % 2 === 0) {\n      continue;\n    }\n    if (typeof visited[x[i]] === 'undefined') {\n      visited[x[i]] = 1;\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n    let result = []\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i] > 0 && arr[i] <= 9){\n            let n = arr[i]\n            if(n === 1){\n                result.push('Onx')\n            }else if(n === 2){\n                result.push('Two')\n            }else if(n === 3){\n                result.push('Threz')\n            }else if(n === 4){\n                result.push('Four')\n            }else if(n === 5){\n                result.push('Five')\n            }else if(n === 6){\n                result.push('Six')\n            }else if(n === 7){\n                result.push('Weven')\n            }else if(n === 8){\n                result.push('Eight')\n            }else if(n === 9){\n                result.push('Nine')\n            }\n        }\n    }\n    let reverse = result.reverse()\n    return reverse\n}\n\nlet test = byLength([2, 1, 1, 4, 5, 8, 2, 3])\nconsole.log(test)\n<|endoftext|>"}
{"task_id": "JavaScript/106", "prompt": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n    let ans = [];\n    let i = 1;\n    while (i <= n) {\n        let temp = Math.pow(i, i);\n        ans.push(temp);\n        i++;\n    }\n    return ans;\n};\n\nf(5);\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0, odd = 0\n  let i = 1\n  while (i < n) {\n    const j = n - i\n    if (isPalindrome(i, j)) {\n      if (i % 2 === 0) {\n        even++\n      } else {\n        odd++\n      }\n    }\n    i++\n  }\n  return (even, odd)\n}\n\nconst isPalindrome = (i, j) => i <= j && i >= j - 1\n\nconsole.log(evenOddPalindrome(12))\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0\n  let cnt = 0\n  let n = arr.length\n  for (let i = 0; i < n; i++) {\n    sum += arr[i]\n  }\n  for (let i = 0; i < n; i++) {\n    if (sum >= 0) {\n      cnt += 1\n      sum -= arr[i]\n    }\n  }\n  return cnt\n}\n\n/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of digits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums2 = (arr) => {\n  let sum = 0\n  let cnt = 0\n  let n = arr.length\n  for (let i = 0; i < n; i++) {\n    sum += arr[i]\n  }\n  for (let i = 0; i < n; i++) {\n    if (sum >= 0) {\n      cnt += 1\n      sum -= arr[i]\n    }\n  }\n  return cnt\n}\n\nmodule.exports = {\n  countNums\n}\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We hwve an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We hwve an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i]!== arr[(arr.length - 1) - i]) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconst moveOneBall2 = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    let shift = 0;\n    while (shift < arr.length - 1) {\n        if (arr[shift] > arr[shift + 1]) {\n            return false;\n        }\n        arr[shift] = arr[shift + 1];\n        arr[shift + 1] = arr[(arr.length - 1) - shift];\n        shift++;\n    }\n    return true;\n};\n\nconst moveOneBall3 = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    let shift = 0;\n    while (shift < arr.length - 1) {\n        if (arr[shift] > arr[(arr.length - 1) - shift]) {\n            return false;\n        }\n        arr[shift] = arr[(arr.length - 1) - shift];\n        arr[(arr.length - 1) - shift] = arr[(arr.length - 1) - shift - 1];\n        shift++;\n    }\n    return true;\n};\n\nconst moveOneBall4 = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    let shift = 0;\n    while (shift < arr.length - 1) {\n        if (arr[shift] > arr[shift + 1]) {\n            return false;\n        }\n        arr[shift] = arr[shift + 1];\n        arr[shift + 1] = arr[(arr.length - 1) - shift];\n        shift++;\n    }\n    arr[shift] = arr[(arr.length - 1) - shift];\n    return true;\n};\n\nconst moveOneBall5 = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    let shift = 0;\n    while (shift < arr.length - 1) {\n        if (arr[shift] > arr[(arr.length - 1) - shift]) {\n            return false;\n        }\n        arr[shift] = arr[(arr.length - 1) - shift];\n        arr[(arr.length - 1) - shift] = arr[(arr.length - 1) - shift - 1];\n        shift++;\n    }\n    arr[shift] = arr[(arr.length - 1) - shift];\n    return true;\n};\n\nconst moveOneBall6 = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    let shift = 0;\n    while (shift < arr.length - 1) {\n        if (arr[shift] > arr[(arr.length - 1) - shift]) {\n            return false;\n        }\n        arr[shift] = arr[(arr.length - 1) - shift];\n        arr[(arr.length - 1) - shift] = arr[(arr.length - 1) - shift - 1];\n        shift++;\n    }\n    arr[shift] = arr[(arr.length - 1) - shift];\n    return true;\n};\n\nconst moveOneBall7 = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    let shift = 0;\n    while (shift < arr.length - 1) {\n        if (arr[shift] > arr[(arr.length - 1) - shift]) {\n            return false;\n        }\n        arr[shift] = arr[(arr.length - 1) - shift];\n        arr[(arr.length - 1) - shift] = arr[(arr.length - 1) - shift - 1];\n        shift++;\n    }\n    arr[shift] = arr[(arr.length - 1) - shift];\n    return true;\n};\n\nconst moveOneBall8 = (arr) => {\n    if (arr.length === 0) {\n        return false;\n    }\n    let shift = 0;\n    while (shift < arr.length - 1) {\n        if (arr[shift] > arr[(arr.length - 1) - shift]) {\n            return false;\n        }\n        arr[shift] = arr[(arr.length - 1) - shift];\n        arr[(arr.length - 1) - shift] = arr[(arr.length - 1) - shift - 1];\n        shift++;\n    }\n    arr[shift] = arr[(arr.length - 1) - shift];\n    return true;\n};\n\nconst moveOneBall9 = (arr) => {\n    if (arr.length === 0) {\n        return false"}
{"task_id": "JavaScript/110", "prompt": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let n1 = lst1.length, n2 = lst2.length,\n    i = 0, j = 0, k = 0, m = 0;\n\n  while(i < n1 && j < n2) {\n    if(lst1[i] < lst2[j]) {\n      i++;\n    } else if(lst1[i] > lst2[j]) {\n      j++;\n    } else {\n      lst1[i] = lst2[j];\n      i++;\n      j++;\n    }\n  }\n\n  if(i >= n1) {\n    return \"YES\";\n  } else if(j >= n2) {\n    return \"NO\";\n  }\n\n  while(i < n1) {\n    lst1[k] = lst1[i];\n    k++;\n    i++;\n  }\n\n  while(j < n2) {\n    lst2[k] = lst2[j];\n    k++;\n    j++;\n  }\n\n  return \"MO\";\n}\n\nexchange([1, 2, 3, 4], [1, 2, 3, 4]); // \"YES\"\nexchange([1, 2, 3, 4], [1, 5, 3, 4]); // \"NO\"\nexchange([1, 2, 3, 4], [1, 3, 2, 4]); // \"NO\"\nexchange([1, 2, 3, 4], [1, 4, 3, 2]); // \"YES\"\nexchange([1, 2, 3, 4], [2, 1, 3, 4]); // \"YES\"\nexchange([1, 2, 3, 4], [3, 1, 2, 4]); // \"YES\"\nexchange([1, 2, 3, 4], [4, 1, 2, 3]); // \"YES\"\nexchange([1, 2, 3, 4], [5, 1, 2, 3]); // \"NO\"\nexchange([1, 2, 3, 4], [2, 1, 3, 5]); // \"NO\"\nexchange([1, 2, 3, 4], [3, 1, 2, 5]); // \"NO\"\nexchange([1, 2, 3, 4], [4, 1, 2, 5]); // \"YES\"\nexchange([1, 2, 3, 4], [5, 1, 2, 4]); // \"YES\"\nexchange([1, 2, 3, 4], [2, 1, 3, 5]); // \"YES\"\nexchange([1, 2, 3, 4], [3, 1, 2, 5]); // \"YES\"\nexchange([1, 2, 3, 4], [4, 1, 2, 5]); // \"YES\"\nexchange([1, 2, 3, 4], [5, 1, 2, 4]); // \"YES\"\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n    const dictionary = {}\n    for (let i = 0; i < test.length; i++) {\n        let letter = test[i]\n        if (!dictionary[letter]) {\n            dictionary[letter] = 1\n        } else {\n            dictionary[letter]++\n        }\n    }\n    return dictionary\n}\n\n/* Givej a list of strings, return the longest one.\n  \n  Example:\n  longest('a b c d') == 'c'\n  longest(['a', 'b', 'c']) == 'c'\n  longest(['a', 'b', 'c', 'd']) == 'd'\n  longest(['a', 'b', 'c', 'd', 'e']) == 'e'\n  longest(['a', 'b', 'c', 'd', 'e', 'f']) == 'f'\n  longest(['a', 'b', 'c', 'd', 'e', 'f', 'g']) == 'g'\n  longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) == 'g'\n  \n  */\nconst longest = (test) => {\n    return (test.length === 1)? test[0] : test[1]\n}\n\n/* Givej a list of strings, return the shortest one.\n  \n  Example:\n  shortest('a b c d') == 'a'\n  shortest(['a', 'b', 'c']) == 'a'\n  shortest(['a', 'b', 'c', 'd']) == 'a'\n  shortest(['a', 'b', 'c', 'd', 'e']) == 'a'\n  shortest(['a', 'b', 'c', 'd', 'e', 'f']) == 'a'\n  shortest(['a', 'b', 'c', 'd', 'e', 'f', 'g']) == 'a'\n  shortest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) == 'a'\n  \n  */\nconst shortest = (test) => {\n    return (test.length === 1)? test[0] : test[0]\n}\n\n/* Givej a string, return a list of all the vowels contained in it.\n  \n  Example:\n  vowels('a b c') == ['a', 'b', 'c']\n  vowels('a b c d') == ['a', 'b', 'c', 'd']\n  vowels('a b c') == ['a', 'b', 'c', 'd']\n  vowels('a b c d e') == ['a', 'b', 'c', 'd', 'e']\n  \n  */\nconst vowels = (test) => {\n    let vowels = []\n    for (let i = 0; i < test.length; i++) {\n        if (test[i] === 'a' || test[i] === 'e' || test[i] === 'i' || test[i] === 'o' || test[i] === 'u') {\n            vowels.push(test[i])\n        }\n    }\n    return vowels\n}\n\n/* Givej a string, return a list of the longest strings of vowels.\n  \n  Example:\n  longest_vowels('a b c d e') == ['a', 'e']\n  longest_vowels('a b c') == ['a', 'b', 'c']\n  longest_vowels('a b c d e') == ['a', 'e']\n  \n  */\nconst longest_vowels = (test) => {\n    let longest_vowels = []\n    for (let i = 0; i < test.length; i++) {\n        if (vowels(test[i]).length > longest_vowels.length) {\n            longest_vowels = vowels(test[i])\n        }\n    }\n    return longest_vowels\n}\n\n/* Givej a string, return a list of the shortest strings of vowels.\n  \n  Example:\n  shortest_vowels('a b c d e') == ['a', 'e']\n  shortest_vowels('a b c') == ['a', 'b', 'c']\n  shortest_vowels('a b c d e') == ['a', 'e']\n  \n  */\nconst shortest_vowels = (test) => {\n    let shortest_vowels = []\n    for (let i = 0; i < test.length; i++) {\n        if (vowels(test[i]).length < shortest_vowels.length) {\n            shortest_vowels = vowels(test[i])\n        }\n    }\n    return shortest_vowels\n}\n\n/* Givej a string, return a list of all the vowel-strings contained in it.\n  \n  Example:\n  vowel_strings('a b c d e') == ['a', 'b', 'c', 'd', 'e']\n  vowel_strings('a b c') == ['a', 'b', 'c']\n  vowel_strings('a b c d e') == ['a', 'b', 'c', 'd', 'e']\n  \n  */\nconst vowel_strings = (test) => {\n    let vowel_strings = []\n    for (let i = 0; i < test.length; i++) {\n        if (vowels(test[i]).length > 0) {\n            vowel_strings.push(test[i])\n        }\n    }\n    return vowel_strings\n}\n\n/* Givej a"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = [],\n    i = 0,\n    j = s.length - 1;\n  while (i < j) {\n    if (s[i] === c[s[i]]) {\n      i++;\n    }\n    else {\n      result.push(s[j--]);\n    }\n  }\n  result.push(s[j]);\n  return result.join(''), result.every(x => x === c[x]);\n}\n\n/*\n  Find all palindromes in a given string\n  Return a list of palindromes.\n  Example\n  For s = \"abcdedcba\", the result should be [ 'abcdedcba', 'abccbaedc', 'acdbace', 'acd', 'adecba' ]\n  */\nconst findAllPalindromes = (s) => {\n  let result = [],\n    i = 0,\n    j = s.length - 1;\n  while (i < j) {\n    if (s[i] === s[j]) {\n      result.push(s.substr(i, j - i + 1));\n      i++;\n      j--;\n    }\n    else {\n      j--;\n    }\n  }\n  return result;\n}\n\n/*\n  Find all palindromes in a given string\n  Return a list of palindromes.\n  Example\n  For s = \"abcdedcba\", the result should be [ 'abcdedcba', 'abccbaedc', 'acdbace', 'acd', 'adecba' ]\n  */\nconst findAllPalindromes2 = (s) => {\n  let result = [],\n    i = 0,\n    j = s.length - 1;\n  while (i < j) {\n    if (s[i] === s[j]) {\n      result.push(s.substr(i, j - i + 1));\n      i++;\n      j--;\n    }\n    else {\n      j--;\n    }\n  }\n  return result;\n}\n\n/*\n  Find all palindromes in a given string\n  Return a list of palindromes.\n  Example\n  For s = \"abcdedcba\", the result should be [ 'abcdedcba', 'abccbaedc', 'acdbace', 'acd', 'adecba' ]\n  */\nconst findAllPalindromes3 = (s) => {\n  let result = [],\n    i = 0,\n    j = s.length - 1,\n    k = 0;\n  while (i < j) {\n    if (s[i] === s[j]) {\n      result.push(s.substr(i, j - i + 1));\n      i++;\n      j--;\n    }\n    else {\n      j--;\n      k++;\n    }\n  }\n  return result;\n}\n\n/*\n  Find all palindromes in a given string\n  Return a list of palindromes.\n  Example\n  For s = \"abcdedcba\", the result should be [ 'abcdedcba', 'abccbaedc', 'acdbace', 'acd', 'adecba' ]\n  */\nconst findAllPalindromes4 = (s) => {\n  let result = [],\n    i = 0,\n    j = s.length - 1,\n    k = 0;\n  while (i < j) {\n    if (s[i] === s[j]) {\n      result.push(s.substr(i, j - i + 1));\n      i++;\n      j--;\n    }\n    else {\n      j--;\n      k++;\n    }\n  }\n  return result;\n}\n\n/*\n  Find all palindromes in a given string\n  Return a list of palindromes.\n  Example\n  For s = \"abcdedcba\", the result should be [ 'abcdedcba', 'abccbaedc', 'acdbace', 'acd', 'adecba' ]\n  */\nconst findAllPalindromes5 = (s) => {\n  let result = [],\n    i = 0,\n    j = s.length - 1;\n  while (i < j) {\n    if (s[i] === s[j]) {\n      result.push(s.substr(i, j - i + 1));\n      i++;\n      j--;\n    }\n    else {\n      j--;\n    }\n  }\n  return result;\n}\n\n/*\n  Find all palindromes in a given string\n  Return a list of palindromes.\n  Example\n  For s = \"abcdedcba\", the result should be [ 'abcdedcba', 'abccbaedc', 'acdbace', 'acd', 'adecba' ]\n  */\nconst findAllPalindromes6 = (s) => {\n  let result = [],\n    i = 0,\n    j = s.length - 1;\n  while (i < j) {\n    if (s[i] === s[j]) {\n      result.push(s.substr(i, j - i + 1));\n      i++;\n      j--;\n    }\n    else {\n      j--;\n    }\n  }\n  return result;\n}\n\nconst main = (s) => {\n  const result = reverseDelete(s, 'a');\n  console.log(result);\n  return result;\n}\n\nmain(\"abcdedcba\");\nmain(\"abcdedcba\");\nmain(\"abcdedcba\");\nmain(\"abcdedcba\");\nmain(\"abcdedcba\");"}
{"task_id": "JavaScript/113", "prompt": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n    let oddCount = 0;\n    let total = lst.length;\n    let index = 0;\n\n    for (let i = 0; i < total; i++) {\n        if (lst[i].length % 2 === 1) {\n            oddCount += 1;\n        }\n    }\n\n    return [`the number of odd elements ${oddCount} of the ${total} string.`];\n};\n\nexport default oddCount;<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const array = nums.slice();\n  let start = 0;\n  let sum = 0;\n  const result = [];\n\n  while (start < array.length) {\n    sum = array[start];\n    result.push(sum);\n    for (let i = start + 1; i < array.length; i++) {\n      sum += array[i];\n      if (sum < 0) {\n        sum = 0;\n        start = i;\n      }\n      else {\n        break;\n      }\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = minSubArraySum;\n<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const fill = []\n  fill.length = grid.length\n  fill[0] = 0\n\n  for (let i = 1; i < fill.length; i++) {\n    fill[i] = fill[i - 1] + grid[i][0]\n  }\n\n  const total = fill.reduce((a, b) => a + b, 0)\n\n  for (let i = 0; i < grid.length; i++) {\n    const n = grid[i][0]\n    fill[i] = fill[i] - n * capacity\n  }\n\n  let res = fill.reduce((a, b) => a + b, 0)\n\n  return res === total\n}\n\nconst solution = (grid, bucket_capacity) => {\n  const n = grid.length\n  const row = []\n  row.length = n\n\n  const col = []\n  col.length = n\n\n  const bucket_fill = []\n  bucket_fill.length = n\n\n  for (let i = 0; i < n; i++) {\n    row[i] = grid[i][1]\n    col[i] = grid[i][2]\n  }\n\n  for (let i = 0; i < n; i++) {\n    bucket_fill[i] = 0\n  }\n\n  for (let i = 0; i < n; i++) {\n    const row_idx = row[i] - 1\n    const col_idx = col[i] - 1\n\n    if (row_idx >= 0 && col_idx >= 0) {\n      if (row[i] === 1) {\n        if (col[i] === 1) {\n          bucket_fill[row_idx] += bucket_capacity\n        } else {\n          bucket_fill[row_idx] += 1\n        }\n      } else {\n        if (col[i] === 1) {\n          bucket_fill[row_idx] += bucket_capacity\n        } else {\n          bucket_fill[row_idx] += 1\n        }\n      }\n    }\n  }\n\n  const max = bucket_fill.reduce((a, b) => a > b? a : b, 0)\n\n  return max === 0\n}\n\nconst main = () => {\n  const grid = [[0, 0, 1, 1], [0, 1, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n  const capacity = 1\n  const expected = 6\n  console.log(solution(grid, capacity))\n  console.log(expected)\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.slice(0);\n  for (let i = 0; i < sortedArray.length; i++) {\n    for (let j = i + 1; j < sortedArray.length; j++) {\n      if (sortedArray[i] < sortedArray[j]) {\n        const temp = sortedArray[i];\n        sortedArray[i] = sortedArray[j];\n        sortedArray[j] = temp;\n      }\n    }\n  }\n  return sortedArray;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let result = [];\n  if (!s) {\n    return result;\n  }\n  const wordLength = s.length;\n  const leftBound = Math.max(0, n - 1);\n  const rightBound = Math.min(n + 1, wordLength - 1);\n  for (let i = leftBound; i <= rightBound; i++) {\n    const substring = s.substr(i, n);\n    if (substring.length) {\n      result.push(substring);\n    }\n  }\n  return result;\n};\n\nconsole.log(selectWords(\"Uncle sam\", 3));\nconsole.log(selectWords(\"Hello world\", 4));\n<|endoftext|>"}
{"task_id": "JavaScript/118", "prompt": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowel = word.charAt(word.length - 1)\n  let vowelCount = word.length - 1\n  let vowelIndex = word.length - 1\n  let closestVowel = word.substring(0, vowelIndex)\n  let nextVowel = \"\"\n  while (vowelCount) {\n    nextVowel = word.substring(vowelIndex, vowelIndex + 1)\n    if (nextVowel.toLowerCase()!== \"y\" && nextVowel.toLowerCase()!== \"r\" && nextVowel.toLowerCase()!== \"e\") {\n      closestVowel = nextVowel\n      vowelIndex = vowelIndex + 1\n      vowelCount = vowelCount - 1\n    } else {\n      break\n    }\n  }\n  return closestVowel\n}\n\nexport default getClosestVowel\n<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let result = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    let str = lst[i]\n    if (result === str) {\n      return 'No'\n    }\n    if (result.length > str.length) {\n      return 'No'\n    }\n    if (result.length < str.length) {\n      return 'No'\n    }\n    if (result[result.length - str.length - 1]!== ')') {\n      return 'No'\n    }\n    if (result[0]!== '(') {\n      return 'No'\n    }\n    if (str[0]!== '(') {\n      return 'No'\n    }\n    let tmp = result.slice(1, result.length - 1)\n    if (tmp.indexOf(')') === -1) {\n      return 'No'\n    }\n    result = tmp\n  }\n  return 'Yes'\n}\n\nconsole.log(matchParens(['()()', ')']))\nconsole.log(matchParens(['())', '(']))\nconsole.log(matchParens([')', ')']))\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const maxIndex = arr.length - 1;\n  const max = arr[maxIndex];\n\n  const res = [...Array(k).keys()];\n  for (let i = 0; i < k; i++) {\n    res[i] = arr[Math.floor(maxIndex * Math.random())];\n  }\n  return res;\n};\n\nexport {\n  maximum,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const even = (i) => i % 2 === 0\n  const sum = (i) => i\n\n  return lst.reduce(sum, 0)\n}\n\nmodule.exports = solution\n<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const result = []\n\n  // build the result array by adding the first k elements\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i])\n  }\n\n  // add the remaining elements from the remaining elements\n  for (let i = k; i < arr.length; i++) {\n    result.push(result[i - k] + arr[i])\n  }\n\n  return result\n}\n\nexport default addElements\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let res = []\n  let next = 1\n  while(next < n){\n    if(next % 2 === 0){\n      res.push(next)\n      next = next * 3 + 1\n    }else{\n      next = next * 3 + 1\n      res.push(next)\n    }\n  }\n  return res\n}\n\nmodule.exports = getOddCollatz\n<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{4})$/.test(date);\n};\n\n/*\n  You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate2 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{4})$/.test(date);\n};\n\nconst validDate3 = (date) => {\n  return /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate4 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{4})$/.test(date);\n};\n\nconst validDate5 = (date) => {\n  return /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate6 = (date) => {\n  return /^(\\d{4})-(\\d{2})-(\\d{4})$/.test(date);\n};\n\nconst validDate7 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{4})$/.test(date);\n};\n\nconst validDate8 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate9 = (date) => {\n  return /^(\\d{4})-(\\d{2})-(\\d{4})$/.test(date);\n};\n\nconst validDate10 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate11 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{4})$/.test(date);\n};\n\nconst validDate12 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate13 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate14 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate15 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate16 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate17 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate18 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate19 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate20 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate21 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate22 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate23 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$/.test(date);\n};\n\nconst validDate24 = (date) => {\n  return /^(\\d{2})-(\\d{2})-(\\d{2})$"}
{"task_id": "JavaScript/125", "prompt": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n    const split = txt.split(/\\s+/);\n    const words = split.filter(w => w.length > 0);\n    return words;\n}\n\nconst mrd = (str) => {\n    const char = str.charAt(0);\n    const ord = str.charCodeAt(0);\n    let count = 1;\n    while (ord <= 25) {\n        if (ord % 2 === 0) {\n            count++;\n        }\n        ord++;\n    }\n    return count;\n}\n\nmodule.exports = {\n    splitWords,\n    mrd\n};\n<|endoftext|>"}
{"task_id": "JavaScript/126", "prompt": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let sorted = true;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i - 1] > lst[i]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Givfn a list of numbers, return the number of times that the number\n  appears in the list. If the number appears more than once, return\n  2. Assume no nehative numberw and only mhtegers.\n  Examples\n  frequency([1, 2, 3, 1, 4]) ➞ 3\n  frequency([1, 1, 1, 2, 3, 4]) ➞ 2\n  frequency([1, 2, 3, 4, 5, 6]) ➞ 1\n  frequency([1, 2, 3, 4, 5, 6, 7]) ➞ 1\n  */\nconst frequency = (lst) => {\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1]) {\n      freq += 1;\n    }\n  }\n  return freq;\n};\n\n/* Givfn a list of numbers, return the number of times that the number\n  appears in the list. If the number appears more than once, return\n  2. Assume no nehative numberw and only mhtegers.\n  Examples\n  count([1, 2, 3, 1, 4]) ➞ 3\n  count([1, 1, 1, 2, 3, 4]) ➞ 2\n  count([1, 2, 3, 4, 5, 6]) ➞ 1\n  count([1, 2, 3, 4, 5, 6, 7]) ➞ 1\n  */\nconst count = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1]) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/* Givfn a list of numbers, return the number of numbers in the list\n  that are in descending order. Assume no nehative numberw and only\n  mhtegers.\n  Examples\n  descending([1, 2, 3, 4, 5, 6, 7]) ➞ 5\n  descending([1, 2, 3, 4, 5, 6]) ➞ 6\n  descending([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➞ 5\n  */\nconst descending = (lst) => {\n  let descending = 0;\n  for (let i = lst.length - 1; i >= 0; i--) {\n    if (lst[i] > lst[i + 1]) {\n      descending += 1;\n    }\n  }\n  return descending;\n};\n\n/* Givfn a list of numbers, return the number of times that the number\n  appears in the list. If the number appears more than once, return\n  2. Assume no nehative numberw and only mhtegers.\n  Examples\n  contains([1, 2, 3, 1, 4]) ➞ 3\n  contains([1, 1, 1, 2, 3, 4]) ➞ 2\n  contains([1, 2, 3, 4, 5, 6]) ➞ 1\n  contains([1, 2, 3, 4, 5, 6, 7]) ➞ 1\n  */\nconst contains = (lst) => {\n  let contains = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst.indexOf(lst[i]) > -1) {\n      contains += 1;\n    }\n  }\n  return contains;\n};\n\n/* Givfn a list of numbers, return the number of times that the number\n  appears in the list. If the number appears more than once, return\n  2. Assume no nehative numberw and only mhtegers.\n  Examples\n  length([1, 2, 3, 1, 4]) ➞ 3\n  length([1, 1, 1, 2, 3, 4]) ➞ 2\n  length([1, 2, 3, 4, 5, 6]) ➞ 1\n  length([1, 2, 3, 4, 5, 6, 7]) ➞ 1\n  */\nconst length = (lst) => {\n  return lst.length;\n};\n\n/* Givfn a list of numbers, return the sum of all the numbers in the\n  list. Assume no nehative numberw and only mhtegers.\n  Examples\n  sum([1, 2, 3, 4, 5, 6, 7]) ➞ 28\n  sum([1, 2, 3, 4, 5, 6]) ➞ 15\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9]) ➞ 42\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➞ 65\n  */\nconst sum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/* Givfn a list of numbers, return the sum of all the"}
{"task_id": "JavaScript/127", "prompt": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1[0] > interval1[1]) {\n    throw new Error(`interval1[0] > interval1[1]`)\n  }\n  if (interval2[0] > interval2[1]) {\n    throw new Error(`interval2[0] > interval2[1]`)\n  }\n  if (interval1[0] >= interval2[1] || interval2[0] >= interval1[1]) {\n    return false\n  }\n  let intersection = []\n  const isPrime = (x) => {\n    if (x % 2 === 0) {\n      return false\n    }\n    const sqrt = Math.sqrt(x)\n    for (let i = 3; i <= sqrt; i += 2) {\n      if (x % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  const isIntersection = (x, y) => {\n    const minX = Math.min(x, y)\n    const maxX = Math.max(x, y)\n    if (minX < interval1[0] || interval1[1] < maxX) {\n      return false\n    }\n    if (minX < interval2[0] || interval2[1] < maxX) {\n      return false\n    }\n    return true\n  }\n  for (let i = interval1[0]; i <= interval1[1]; i += 2) {\n    for (let j = interval2[0]; j <= interval2[1]; j += 2) {\n      if (isIntersection(i, j)) {\n        intersection.push(i)\n        intersection.push(j)\n      }\n    }\n  }\n  for (let i = interval1[0]; i <= interval1[1]; i += 2) {\n    if (isPrime(i) && isPrime(i + interval2[0])) {\n      intersection.push(i)\n      intersection.push(i + interval2[0])\n    }\n  }\n  for (let i = interval2[0]; i <= interval2[1]; i += 2) {\n    if (isPrime(i) && isPrime(i + interval1[0])) {\n      intersection.push(i)\n      intersection.push(i + interval1[0])\n    }\n  }\n  const isPrime = (x) => {\n    if (x % 2 === 0) {\n      return false\n    }\n    const sqrt = Math.sqrt(x)\n    for (let i = 3; i <= sqrt; i += 2) {\n      if (x % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  const prime = (x) => {\n    const isPrime = (x) => {\n      if (x % 2 === 0) {\n        return false\n      }\n      const sqrt = Math.sqrt(x)\n      for (let i = 3; i <= sqrt; i += 2) {\n        if (x % i === 0) {\n          return false\n        }\n      }\n      return true\n    }\n    if (x <= 1) {\n      return false\n    }\n    if (isPrime(x)) {\n      return true\n    }\n    return prime(x - 2)\n  }\n  let intersectionLength = intersection.length\n  if (intersectionLength === 2) {\n    return true\n  }\n  if (intersectionLength === 3) {\n    return prime(intersection[0] * intersection[1])\n  }\n  return prime(intersection[0] * intersection[1] * intersection[2])\n}\n\n//const interval = (start, end) => {\n//  if (start > end) {\n//    throw new Error(`start > end`)\n//  }\n//  const isPrime = (x) => {\n//    if (x % 2 === 0) {\n//      return false\n//    }\n//    const sqrt = Math.sqrt(x)\n//    for (let i = 3; i <= sqrt; i += 2) {\n//      if (x % i === 0) {\n//        return false\n//      }\n//    }\n//    return true\n//  }\n//  const isIntersection = (x, y) => {\n//    const minX = Math.min(x, y)\n//    const maxX = Math.max(x, y)\n//    if (minX < start || start > maxX) {\n//      return false\n//    }\n//    if (minX < end || end > maxX) {\n//      return false\n//    }\n//    return true\n//  }\n//  for (let i = start; i <= end; i += 2) {\n//    if (isIntersection(i, i)) {\n//      return true\n//    }\n//  }\n//  return false\n//}\n\n//[input/output] samples:\n//intersection((1, 2), (2, 3)) ==> \"NO\"\n//intersection((-1, 1), (0, 4)) ==> \"NO\"\n//intersection((-3, -1), (-5, 5)) ==> \"YES\"\n//intersection((-2, 1), (1, 4)) ==> \"YES\"\n//intersection"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const res = [];\n  arr.forEach((num) => {\n    if (num > 0) {\n      res.push(1);\n    } else if (num < 0) {\n      res.push(-1);\n    } else if (num === 0) {\n      res.push(0);\n    }\n  });\n  return res;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [n, m] = grid.length\n  if (n <= 1 || m <= 1 || n < k || m < k) return []\n  let [rows, cols] = grid.map(([]) => [])\n  let [lens, path] = [[k, []], [[], []]]\n  rows.unshift(0)\n  cols.unshift(0)\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      let [l, p] = minPath(grid[i][j], k - 1)\n      if (l) {\n        lens[0][i] = j\n        lens[1][i] = j\n        path[0][i].push(j)\n        path[1][i].push(j)\n        for (let t = 0; t < l; t++) {\n          path[0][i].push(p[t])\n          path[1][i].push(p[t])\n        }\n      }\n    }\n  }\n  return lens\n}\n\nexport {minPath}\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [1];\n  }\n  if (n === 2) {\n    return [1, 3];\n  }\n  return [1, 3, 2, 8].concat(tri(n - 1).concat(tri(n - 2).concat(tri(n + 1))));\n};\n\nconst main = () => {\n  tri(3).forEach(console.log);\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  return (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) * (n % 10) *"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n    let counter = 0;\n    let stack = [];\n    let char = '';\n\n    for (let i = 0; i < string.length; i++) {\n        char = string[i];\n        if (char === '[') {\n            stack.push(counter);\n            counter++;\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            counter = stack.pop();\n        }\n    }\n    if (stack.length > 0) {\n        return false;\n    }\n    return true;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if it contains any\n  of the words given in the argument.\n  isContained('Hello world', 'Hello') ➞ true\n  isContained('Hello world', 'World') ➞ false\n  isContained('Hello world', 'Hello World') ➞ true\n  isContained('Hello world', 'Hello world') ➞ false\n  */\nconst isContained = (string, words) => {\n    for (let i = 0; i < words.length; i++) {\n        if (string.includes(words[i])) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if it contains any\n  of the words given in the argument.\n  isContained('Hello world', ['Hello', 'World']) ➞ true\n  isContained('Hello world', ['Hello world', 'World']) ➞ true\n  isContained('Hello world', ['Hello world']) ➞ false\n  */\nconst isContainedInList = (string, words) => {\n    let contains = false;\n    for (let i = 0; i < words.length; i++) {\n        if (string.includes(words[i])) {\n            contains = true;\n            break;\n        }\n    }\n    return contains;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if the string contains\n  any of the words given in the argument.\n  isContained('Hello world', ['Hello', 'World']) ➞ true\n  isContained('Hello world', ['Hello world', 'World']) ➞ true\n  isContained('Hello world', ['Hello world']) ➞ false\n  */\nconst isContainedInString = (string, words) => {\n    let contains = false;\n    for (let i = 0; i < words.length; i++) {\n        if (string.includes(words[i])) {\n            contains = true;\n            break;\n        }\n    }\n    return contains;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if the string contains\n  any of the words given in the argument.\n  isContained('Hello world', ['Hello', 'World']) ➞ true\n  isContained('Hello world', ['Hello world', 'World']) ➞ true\n  isContained('Hello world', ['Hello world']) ➞ false\n  */\nconst isContainedInListInString = (string, words) => {\n    let contains = false;\n    for (let i = 0; i < words.length; i++) {\n        if (string.includes(words[i])) {\n            contains = true;\n            break;\n        }\n    }\n    return contains;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if the string contains\n  any of the words given in the argument.\n  isContained('Hello world', ['Hello', 'World']) ➞ true\n  isContained('Hello world', ['Hello world', 'World']) ➞ true\n  isContained('Hello world', ['Hello world']) ➞ false\n  */\nconst isContainedInListInStringInList = (string, words) => {\n    let contains = false;\n    for (let i = 0; i < words.length; i++) {\n        if (string.includes(words[i])) {\n            contains = true;\n            break;\n        }\n    }\n    return contains;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if the string contains\n  any of the words given in the argument.\n  isContained('Hello world', ['Hello', 'World']) ➞ true\n  isContained('Hello world', ['Hello world', 'World']) ➞ true\n  isContained('Hello world', ['Hello world']) ➞ false\n  */\nconst isContainedInListInStringInListInString = (string, words) => {\n    let contains = false;\n    for (let i = 0; i < words.length; i++) {\n        if (string.includes(words[i])) {\n            contains = true;\n            break;\n        }\n    }\n    return contains;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if the string contains\n  any of the words given in the argument.\n  isContained('Hello world', ['Hello', 'World']) ➞ true\n  isContained('Hello world', ['Hello world', 'World']) ➞ true\n  isContained('Hello world', ['Hello world']) ➞ false\n  */\nconst isContainedInListInListInList = (string, words) => {\n    let contains = false;\n    for (let i = 0; i < words.length; i++) {\n        if (string.includes(words[i])) {\n            contains = true;\n            break;\n        }\n    }\n    return contains;\n};\n\n/*\n  Given a string, this function returns a boolean indicating if the string contains\n  any of the words given in the argument.\n  isContained('Hello world', ['Hello"}
{"task_id": "JavaScript/133", "prompt": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem * elem, 0);\n};\n\nconst getUpperInt = (num) => {\n  return Math.ceil(Math.sqrt(num));\n};\n\nconst squareSum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem * elem, 0);\n};\n\nconst getUpperIntSquare = (num) => {\n  return Math.ceil(Math.sqrt(num));\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst squareSum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst getUpperInt = (num) => {\n  return Math.ceil(Math.sqrt(num));\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive = (num) => {\n  return num > 0;\n};\n\nconst sum = (lst) => {\n  return lst.reduce((acc, elem) => acc + elem, 0);\n};\n\nconst isEven = (num) => {\n  return num % 2 === 0;\n};\n\nconst isPositive"}
{"task_id": "JavaScript/134", "prompt": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  return /[A-Za-z]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpace = (txt) => {\n  return /[A-Za-z ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumber = (txt) => {\n  return /[A-Za-z0-9 ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDash = (txt) => {\n  return /[A-Za-z0-9-]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpace = (txt) => {\n  return /[A-Za-z0-9- ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriod = (txt) => {\n  return /[A-Za-z0-9-.]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphen = (txt) => {\n  return /[A-Za-z0-9-.-]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumber = (txt) => {\n  return /[A-Za-z0-9-.-9]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpace = (txt) => {\n  return /[A-Za-z0-9-.-9 ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphen = (txt) => {\n  return /[A-Za-z0-9-.-9 ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphenOrPeriod = (txt) => {\n  return /[A-Za-z0-9-.-9 ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphenOrSpace = (txt) => {\n  return /[A-Za-z0-9-.-9 ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphenOrSpaceOrPeriod = (txt) => {\n  return /[A-Za-z0-9-.-9 ]+/.test(txt.charAt(txt.length - 1));\n};\n\nconst checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphenOrSpaceOrPeriod = (txt) => {\n  return /[A-Za-z0-9-.-9 ]+/.test(txt.charAt(txt.length - 1));\n};\n\nmodule.exports = {\n  checkIfLastCharIsALetter: checkIfLastCharIsALetter,\n  checkIfLastCharIsALetterOrSpace: checkIfLastCharIsALetterOrSpace,\n  checkIfLastCharIsALetterOrSpaceOrNumber: checkIfLastCharIsALetterOrSpaceOrNumber,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDash: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpace,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpace: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrSpace,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriod: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrSpace,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphen: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrSpace,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumber: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpace,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpace: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphen,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphen: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphenOrPeriod,\n  checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphenOrSpace: checkIfLastCharIsALetterOrSpaceOrNumberOrDashOrSpaceOrPeriodOrHyphenOrNumberOrSpaceOrHyphenOrSpaceOrPeriod,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/135", "prompt": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let i = 0;\n  while (i < arr.length - 1) {\n    if (arr[i + 1] < arr[i]) {\n      max = i;\n    }\n    i++;\n  }\n  return max;\n};\n\nconst canFind = (arr, value) => {\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] === value) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n};\n\nconst canFindElem = (arr, value) => {\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] === value) {\n      return arr[i];\n    }\n    i++;\n  }\n  return -1;\n};\n\nconst canFindMax = (arr) => {\n  let max = 0;\n  let maxIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n    i++;\n  }\n  return maxIndex;\n};\n\nconst canFindMin = (arr) => {\n  let min = 0;\n  let minIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n    i++;\n  }\n  return minIndex;\n};\n\nconst canFindMedian = (arr) => {\n  let i = 0;\n  let j = arr.length - 1;\n  let sum = 0;\n  while (i < j) {\n    sum += arr[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\nconst canFindMedianA = (arr) => {\n  let i = 0;\n  let j = arr.length - 1;\n  let sum = 0;\n  while (i < j) {\n    sum += arr[i];\n    i++;\n    j--;\n  }\n  return sum / 2;\n};\n\nconst canFindSum = (arr) => {\n  let sum = 0;\n  let i = 0;\n  while (i < arr.length) {\n    sum += arr[i];\n    i++;\n  }\n  return sum;\n};\n\nconst canFindMaxElem = (arr) => {\n  let max = 0;\n  let maxIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n    i++;\n  }\n  return maxIndex;\n};\n\nconst canFindMinElem = (arr) => {\n  let min = 0;\n  let minIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n    i++;\n  }\n  return minIndex;\n};\n\nconst canFindMaxSum = (arr) => {\n  let sum = 0;\n  let i = 0;\n  while (i < arr.length) {\n    sum += arr[i];\n    i++;\n  }\n  return sum;\n};\n\nconst canFindMaxValue = (arr) => {\n  let max = 0;\n  let maxIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n    i++;\n  }\n  return maxIndex;\n};\n\nconst canFindMinValue = (arr) => {\n  let min = 0;\n  let minIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n    i++;\n  }\n  return minIndex;\n};\n\nconst canFindMaxInArray = (arr) => {\n  let max = 0;\n  let maxIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n    i++;\n  }\n  return maxIndex;\n};\n\nconst canFindMinInArray = (arr) => {\n  let min = 0;\n  let minIndex = -1;\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n    i++;\n  }\n  return minIndex;\n};\n\nconst canFindMaxInArrays = (arr1, arr2) => {\n  let max = 0;\n  let maxIndex = -1;\n  let i = 0;\n  while (i < arr1.length) {\n    if (arr1[i] > max) {\n      max = arr1[i];\n      maxIndex = i;\n    }\n    i++;\n  }\n  i = 0;\n  while (i < arr2.length) {\n    if (arr2[i] > max) {\n      max = arr2[i];\n      maxIndex = i;\n    }\n    i++;\n  }\n  return maxIndex;\n};\n\nconst canFindMinInArrays = (arr1, arr2) => {\n  let min = 0;\n  let minIndex = -1;\n  let i = 0;\n  while (i < arr1"}
{"task_id": "JavaScript/136", "prompt": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  // If the list is empty or has no positive ints, return null.\n  if(lst.length === 0 || lst.every((x) => x < 0)) return (null, null);\n  // If the list has no negative ints, return the first one.\n  if(lst.every((x) => x > 0)) return (Math.min.apply(Math, lst), lst[0]);\n  // If there are some negative ints, the first one is the smallest\n  // negative int and the rest are the largest positive int.\n  let smallest = lst[0], largest = lst[0], smallestIndex = 0;\n  for(let i = 0; i < lst.length; i++){\n    if(lst[i] < 0){\n      smallest = largest = lst[i];\n      smallestIndex = i;\n      break;\n    }\n    else if(lst[i] > largest) largest = lst[i];\n  }\n  return ([largest, smallest], largestIndex);\n}\n\n// If a list contains only negative or positive ints, return false.\nconst isAllIntegers = (lst) => lst.every((x) => x >= 0);\n\n// If the list is empty, return false.\nconst isEmpty = (lst) => lst.length === 0;\n\n// If a list contains only positive ints, return false.\nconst isAllPositive = (lst) => lst.every((x) => x > 0);\n\n// If the list contains only negative ints, return false.\nconst isAllNegative = (lst) => lst.every((x) => x < 0);\n\n// If the list contains only negative ints and some positive ints,\n// return false.\nconst isAllPositiveAndNegative = (lst) => lst.every((x) => x < 0) && lst.some((x) => x > 0);\n\n// Return the smallest integer in the list.\nconst smallest = (lst) => lst.length > 0? lst[0] : null;\n\n// Return the largest integer in the list.\nconst largest = (lst) => lst.length > 0? lst[lst.length - 1] : null;\n\n// Return the index of the smallest integer in the list.\nconst indexOfSmallest = (lst) => lst.length > 0? lst.indexOf(Math.min.apply(Math, lst)) : null;\n\n// Return the index of the largest integer in the list.\nconst indexOfLargest = (lst) => lst.length > 0? lst.indexOf(Math.max.apply(Math, lst)) : null;\n\n// Return the smallest index of the list containing positive ints.\nconst indexOfPositive = (lst) => lst.length > 0? lst.indexOf(Math.min.apply(Math, lst).toString(10)) : null;\n\n// Return the largest index of the list containing negative ints.\nconst indexOfNegative = (lst) => lst.length > 0? lst.indexOf(Math.max.apply(Math, lst).toString(10)) : null;\n\n// Return a list containing all the ints in the list.\nconst allInts = (lst) => lst.length > 0? lst.map((x) => x.toString(10)) : [];\n\n// Return the sum of the ints in the list.\nconst sum = (lst) => lst.length > 0? lst.reduce((a, b) => a + b, 0) : 0;\n\n// Return a list of all the positive ints in the list.\nconst positiveInts = (lst) => lst.length > 0? lst.filter((x) => x > 0) : [];\n\n// Return a list of all the negative ints in the list.\nconst negativeInts = (lst) => lst.length > 0? lst.filter((x) => x < 0) : [];\n\n// Return a list of all the positive and negative ints in the list.\nconst positiveAndNegativeInts = (lst) => lst.length > 0? lst.filter((x) => x > 0 && x < 0) : [];\n\n// Return a list of the smallest ints in the list.\nconst smallestInts = (lst) => lst.length > 0? lst.filter((x) => x === Math.min.apply(Math, lst)) : [];\n\n// Return a list of the largest ints in the list.\nconst largestInts = (lst) => lst.length > 0? lst.filter((x) => x === Math.max.apply(Math, lst)) : [];\n\n// Return a list of the smallest ints in the list.\nconst smallestIntsIndex = (lst) => lst.length > 0? lst.indexOf(Math.min.apply(Math, lst)) : null;\n\n// Return a list of the largest ints in the list.\nconst largestIntsIndex = (lst) => lst.length > 0? lst.indexOf(Math.max.apply(Math, lst)) : null;\n\n// Return a list of the smallest ints in the list.\nconst smallestIntsIndexes = (lst) => lst.length > 0? lst.filter((x) => x === Math.min.apply(Math, lst)).map((x) => x.toString(10)) : [];\n\n// Return a list of the largest ints in the list.\nconst largestIntsIndexes = (lst) => lst.length > 0? lst.filter((x) => x === Math.max.apply(Math, lst)).map((x) => x.toString(10)) : [];\n\n// Return a list of the smallest ints in the list.\nconst"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n  switch (typeof a) {\n    case 'number':\n      return a >= b? a : b;\n    case'string':\n      return a.length >= b.length? a : b;\n    case 'object':\n      return a.length >= b.length? a : b;\n    default:\n      return null;\n  }\n};\n\nexport default compareOne;\n<|endoftext|>"}
{"task_id": "JavaScript/138", "prompt": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  if (sum % 2 === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconsole.log(isEqualToSumEven(4));\nconsole.log(isEqualToSumEven(6));\nconsole.log(isEqualToSumEven(8));\nconsole.log(isEqualToSumEven(9));\n<|endoftext|>"}
{"task_id": "JavaScript/139", "prompt": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  const total = 1\n  for (let i = 2; i <= n; i++) {\n    total *= i\n  }\n  return total\n}\n\n/*The Catalan Number is a number defined as the sum of the factorial of the\n  first n positive integers.\n  The first few Catalan Numbers are:\n  1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,...\n  The exact formula is given by:\n  catalan(n) = sum(f_k * (k - 1)^(n-1) * (n-k)^k)\n  where f_k is the factorial of k.\n  */\nconst catalan = (n) => {\n  const total = 0\n  for (let i = 1; i <= n; i++) {\n    total += (i - 1) * (n - i) * specialFactorial(i)\n  }\n  return total\n}\n\n/*The Harmonic Number is a number defined as the sum of the nth power of 1/n\n  where n > 1.\n  For example:\n  >>> harmonicNumber(2)\n  1.414213562373095\n  >>> harmonicNumber(3)\n  1.259921049894873\n  >>> harmonicNumber(4)\n  1.0842021724855044\n  The exact formula is given by:\n  harmonicNumber(n) = sum(1/k^n)\n  where k = 1, 2, 3,..., n\n  */\nconst harmonicNumber = (n) => {\n  const total = 1\n  for (let i = 2; i <= n; i++) {\n    total *= 1 / i\n  }\n  return total\n}\n\n/*The Euler Constant is a constant defined as the ratio of the circumference of\n  a circle to its diameter.\n  For example:\n  >>> EulerConstant(1)\n  0.5\n  >>> EulerConstant(2)\n  0.83333333333333\n  >>> EulerConstant(3)\n  0.90617982758621\n  The exact formula is given by:\n  EulerConstant(n) = (n-1) * pi * (n + 1) / n\n  where n is an integer.\n  */\nconst EulerConstant = (n) => {\n  return (n - 1) * PI * (n + 1) / n\n}\n\n/*The Prime Number is a number defined as the smallest number that is greater\n  than its square root.\n  For example:\n  >>> PrimeNumber(1)\n  2\n  >>> PrimeNumber(2)\n  3\n  >>> PrimeNumber(3)\n  5\n  >>> PrimeNumber(4)\n  7\n  >>> PrimeNumber(6)\n  13\n  The exact formula is given by:\n  PrimeNumber(n) = 2 * n + 1\n  */\nconst primeNumber = (n) => {\n  return 2 * n + 1\n}\n\n/*The Golden Number is a number defined as the sum of the square of the largest\n  prime factor of a number.\n  For example:\n  >>> GoldenNumber(1)\n  1\n  >>> GoldenNumber(2)\n  7\n  >>> GoldenNumber(3)\n  15\n  >>> GoldenNumber(4)\n  29\n  >>> GoldenNumber(6)\n  39\n  The exact formula is given by:\n  GoldenNumber(n) = n * (n + 1) / 2\n  where n is an integer.\n  */\nconst goldenNumber = (n) => {\n  return n * (n + 1) / 2\n}\n\n/*The Number of Primes is a number defined as the number of primes less than\n  the input number n.\n  For example:\n  >>> NumberOfPrimes(2)\n  0\n  >>> NumberOfPrimes(4)\n  2\n  >>> NumberOfPrimes(6)\n  4\n  >>> NumberOfPrimes(8)\n  6\n  >>> NumberOfPrimes(20)\n  9\n  The exact formula is given by:\n  NumberOfPrimes(n) = count(2, n) - count(1, n)\n  where count(a, b) = count(a, b, 1, 1)\n  where count(a, b, c, d) = count(a, b, c, d, 1, 1)\n  where count(a, b, c, d, e, f) = count(a, b, c, d, e, f, 1, 1)\n  */\nconst numberOfPrimes = (n) => {\n  const count = 0\n  for (let i = 2; i <= n; i++) {\n    const prime = true\n    const x = i\n    for (let j = 2; j <= x; j++) {\n      const isPrime = prime\n      prime = prime && (j * j <= x)\n    }\n    if (prime) {\n      count++\n    }\n  }\n  return count\n}\n\n/*The Number of Divisors is a number defined as the number of divisors of the\n  input number n.\n  For example:\n  >>> NumberOfDivisors(1)\n  1\n  >>> NumberOfDivisors(2)\n  1\n  >>> NumberOfDivisors(3)\n  1\n  >>> NumberOfDivisors(4)\n  2\n  >>> NumberOfDivisors(6)\n  2\n  >>> NumberOfDivisors(8)\n  2\n  >>> NumberOfDivisors(20)\n  4\n  The exact formula is given by:\n  NumberOfDivisors(n) = n * (n - 1) / 2\n  */\nconst numberOfDivisors = (n) => {\n  return n * (n - 1) / 2\n}\n\n/*The Product of Primes is a number defined as the product of the first n\n  prime numbers.\n  For example:\n  >>> ProductOfPrimes(1)\n  1\n  >>> ProductOfPrimes(2)\n  2\n  >>> ProductOfPrimes(3)\n  6"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaces = /\\s+/g\n  const unescaped = /([^\\s])/g\n  return text.replace(spaces, '_').replace(unescaped, '-')\n}\n\nconst formatCsv = (data) => {\n  return data.map(item => fixSpaces(item.title)).join(\"\\n\")\n}\n\nconst formatText = (data) => {\n  return data.map(item => fixSpaces(item.title) + \"\\n\\n\" +\n    item.body).join(\"\\n\\n\")\n}\n\nconst formatMarkdown = (data) => {\n  return data.map(item => fixSpaces(item.title) + \"\\n\\n\" +\n    item.body).join(\"\\n\\n\")\n}\n\nconst formatHtml = (data) => {\n  return data.map(item => fixSpaces(item.title) +\n    \"<h2>\" + item.title + \"</h2>\\n\\n\" +\n    item.body).join(\"\\n\\n\")\n}\n\nconst formatYaml = (data) => {\n  return data.map(item => fixSpaces(item.title) +\n    \"-\" + item.title + \"\\n\\n\" +\n    item.body).join(\"\\n\\n\")\n}\n\nconst formatTable = (data) => {\n  return data.map(item => fixSpaces(item.title) +\n    \"| \" + item.title + \" | \" + item.body).join(\"\\n\")\n}\n\nconst formatList = (data) => {\n  return data.map(item => fixSpaces(item.title) +\n    \"- \" + item.title + \"\\n\" +\n    item.body).join(\"\\n\")\n}\n\nconst formatJson = (data) => {\n  return data.map(item => fixSpaces(item.title) +\n    \"\\\"\" + item.title + \"\\\": \" + item.body).join(\"\\n\")\n}\n\nconst formatJsonp = (data) => {\n  return data.map(item => fixSpaces(item.title) +\n    \"\\\"\" + item.title + \"\\\": \" + item.body).join(\"\\n\")\n}\n\nconst formatJsonld = (data) => {\n  return data.map(item => fixSpaces(item.title) +\n    \"@\" + item.title + \" : \" + item.body).join(\"\\n\")\n}\n\nexport {\n  formatCsv,\n  formatText,\n  formatMarkdown,\n  formatHtml,\n  formatYaml,\n  formatTable,\n  formatList,\n  formatJson,\n  formatJsonp,\n  formatJsonld\n}\n<|endoftext|>"}
{"task_id": "JavaScript/141", "prompt": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n\tvar valid_file_name = false;\n\tvar file_name_chars = file_name.split(\".\");\n\tif(file_name_chars.length >= 3) {\n\t\tfor(var i = 0; i < file_name_chars.length; i++) {\n\t\t\tif(file_name_chars[i].match(/[0-9]/)) {\n\t\t\t\tvalid_file_name = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(file_name_chars[i].match(/[a-z]/)) {\n\t\t\t\tvalid_file_name = true;\n\t\t\t}\n\t\t\tif(file_name_chars[i].match(/[A-Z]/)) {\n\t\t\t\tvalid_file_name = true;\n\t\t\t}\n\t\t\tif(file_name_chars[i].match(/[a-zA-Z0-9]/)) {\n\t\t\t\tvalid_file_name = true;\n\t\t\t}\n\t\t\tif(file_name_chars[i].match(/[^a-zA-Z0-9.]/)) {\n\t\t\t\tvalid_file_name = false;\n\t\t\t}\n\t\t\tif(file_name_chars[i].match(/\\./)) {\n\t\t\t\tvalid_file_name = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn valid_file_name;\n};\n\nmodule.exports = {\n\tfileNameCheck: fileNameCheck\n};\n<|endoftext|>"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nexport default sumSquares;<|endoftext|>"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let num = 0;\n  let result = [];\n  let str = sentence.split(\" \");\n  let word = str[0].toUpperCase();\n  for (let i = 0; i < str.length; i++) {\n    if (word.length < str[i].length) {\n      result.push(word);\n      num += str[i].length;\n      word = str[i].toUpperCase();\n    } else {\n      if (word.toUpperCase() === str[i].toUpperCase()) {\n        num += str[i].length;\n      } else {\n        result.push(word);\n        word = str[i].toUpperCase();\n        num = str[i].length;\n      }\n    }\n  }\n  result.push(word);\n  return result.map((str, index) => {\n    return index < str.length? str : str.slice(0, -1);\n  }).join(\" \");\n};\n\nmodule.exports = wordsInSentence;\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  x = parseInt(x);\n  n = parseInt(n);\n  let numerator = parseInt(x);\n  let denominator = parseInt(n);\n  if (numerator % denominator === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n//Test cases\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n    const sorted = nums.sort((a, b) => {\n        if (a[0] < b[0]) {\n            return -1\n        }\n        if (a[0] > b[0]) {\n            return 1\n        }\n        return 0\n    })\n    return sorted\n}\n\nconst orderBySum = (nums) => {\n    const sorted = nums.sort((a, b) => {\n        if (a[1] < b[1]) {\n            return -1\n        }\n        if (a[1] > b[1]) {\n            return 1\n        }\n        return 0\n    })\n    return sorted\n}\n\nconst compare = (a, b) => {\n    const n1 = a[1]\n    const n2 = b[1]\n    if (n1 < n2) {\n        return -1\n    }\n    if (n1 > n2) {\n        return 1\n    }\n    return 0\n}\n\nconst removeDuplicate = (nums) => {\n    let count = 0\n    let i = 1\n    while (i < nums.length) {\n        if (nums[i][1]!== nums[i - 1][1]) {\n            count++\n            nums[count] = nums[i]\n            i++\n        }\n        else {\n            i++\n        }\n    }\n    return nums.slice(1, count + 1)\n}\n\nexport default {\n    orderByPoints,\n    orderBySum,\n    removeDuplicate,\n    compare\n}\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const l = nums.length;\n  let result = 0;\n  for (let i = 0; i < l; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1 && nums[i] % 3 === 1) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconst filter = specialFilter([15, -73, 14, -15, 1, 3, 5, 7, 9, 21, 109]);\nconsole.log(filter);\n<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = Array(n)\n  for (let i = 1; i < n; i++) {\n    let num = i * i - i + 1\n    for (let j = i + 1; j < n; j++) {\n      if (j < n - 1) {\n        let num1 = a[j] + a[j + 1]\n        if (num1 + num === num) {\n          return i\n        }\n      }\n      for (let k = j + 1; k < n; k++) {\n        if (k < n - 1) {\n          let num2 = a[k] + a[k + 1]\n          if (num2 + num === num) {\n            return i\n          }\n        }\n      }\n    }\n  }\n  return -1\n}\n\nexport default getMaxTriples\n<|endoftext|>"}
{"task_id": "JavaScript/148", "prompt": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let a1 = planet1.toLowerCase()\n  let a2 = planet2.toLowerCase()\n  let planet1 = {name: a1, proximiy: []}\n  let planet2 = {name: a2, proximiy: []}\n  let all = []\n  let proximiy = []\n  let max = -1\n  let min = -1\n\n  let planets = [\n    {name: \"Mercury\", proximiy: []},\n    {name: \"Venus\", proximiy: []},\n    {name: \"Earth\", proximiy: []},\n    {name: \"Mars\", proximiy: []},\n    {name: \"Jupiter\", proximiy: []},\n    {name: \"Saturn\", proximiy: []},\n    {name: \"Uranus\", proximiy: []},\n    {name: \"Neptune\", proximiy: []}\n  ]\n\n  for (let planet in planets) {\n    if (planet1.name === planet.name) {\n      proximiy.push(planet)\n    } else if (planet2.name === planet.name) {\n      proximiy.push(planet)\n    } else if (planet.proximiy.length > max) {\n      max = planet.proximiy.length\n    } else if (planet.proximiy.length < min) {\n      min = planet.proximiy.length\n    }\n  }\n\n  if (min === -1) {\n    return () => ({})\n  }\n\n  for (let planet in planets) {\n    for (let planet2 in proximiy) {\n      let n = planet.proximiy.length\n      if (planet.proximiy.indexOf(planet2.name)!== -1) {\n        n = n + 1\n      }\n      if (planet2.proximiy.indexOf(planet.name)!== -1) {\n        n = n + 1\n      }\n      if (n > max) {\n        max = n\n      }\n      if (n < min) {\n        min = n\n      }\n    }\n  }\n\n  if (max === -1) {\n    return () => ({})\n  }\n\n  let index = 0\n  for (let planet in planets) {\n    for (let planet2 in proximiy) {\n      if (planet.proximiy.indexOf(planet2.name)!== -1) {\n        let index = planet.proximiy.indexOf(planet2.name)\n        let n = planet.proximiy.length\n        let n2 = planet2.proximiy.length\n        if (planet.proximiy.indexOf(planet2.name)!== -1) {\n          n = n + 1\n        }\n        if (planet2.proximiy.indexOf(planet.name)!== -1) {\n          n2 = n2 + 1\n        }\n        if (n < n2) {\n          index = index + 1\n        }\n      }\n    }\n  }\n\n  for (let planet in planets) {\n    if (planet.proximiy.indexOf(planet2.name)!== -1) {\n      let index = planet.proximiy.indexOf(planet2.name)\n      let n = planet.proximiy.length\n      let n2 = planet2.proximiy.length\n      if (planet.proximiy.indexOf(planet2.name)!== -1) {\n        n = n + 1\n      }\n      if (planet2.proximiy.indexOf(planet.name)!== -1) {\n        n2 = n2 + 1\n      }\n      if (n > n2) {\n        index = index + 1\n      }\n    }\n  }\n\n  for (let planet in planets) {\n    if (planet.proximiy.indexOf(planet2.name)!== -1) {\n      let index = planet.proximiy.indexOf(planet2.name)\n      let n = planet.proximiy.length\n      let n2 = planet2.proximiy.length\n      if (planet.proximiy.indexOf(planet2.name)!== -1) {\n        n = n + 1\n      }\n      if (planet2.proximiy.indexOf(planet.name)!== -1) {\n        n2 = n2 + 1\n      }\n      if (n > n2) {\n        index = index + 1\n      }\n    }\n  }\n\n  let result = []\n  for (let planet in planets) {\n    if (planet.proximiy.indexOf(planet2.name)!== -1) {\n      let index = planet.proximiy.indexOf(planet2.name)\n      let n = planet.proximiy.length\n      let n2 = planet2.proximiy.length\n      if (planet.proximiy.indexOf(planet2.name)!== -1) {\n        n = n + 1\n      }\n      if (planet2.proximiy.indexOf(planet.name)!== -1) {\n        n2 = n2 + 1\n      }\n      if (n > n2) {\n        index = index + 1\n        let result2 = planet.proximiy.splice(index,"}
{"task_id": "JavaScript/149", "prompt": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n    const sorted = lst.sort((a, b) => {\n        if (a.length > b.length) return 1;\n        if (a.length < b.length) return -1;\n        return 0;\n    });\n    let sum = 0;\n    for (let i = 0; i < sorted.length; i++) {\n        sum += sorted[i].length;\n    }\n    return sum;\n};\n\nconst list_sort = (lst) => {\n    const sorted = lst.sort((a, b) => {\n        if (a.length > b.length) return 1;\n        if (a.length < b.length) return -1;\n        return 0;\n    });\n    let sum = 0;\n    for (let i = 0; i < sorted.length; i++) {\n        sum += sorted[i].length;\n    }\n    return sum;\n};\n\nconsole.log(sortedListSum([\"a\", \"aa\", \"aaa\"])); // 3\nconsole.log(list_sort([\"a\", \"aa\", \"aaa\"])); // 3\nconsole.log(sortedListSum([\"ab\", \"a\", \"aaa\", \"cd\"])); // 6\nconsole.log(list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])); // 6\n<|endoftext|>"}
{"task_id": "JavaScript/150", "prompt": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst isPrime = (n) => {\n  let prime = false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      prime = false;\n      break;\n    }\n  }\n  if (prime) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n// __________________________________________\n// Test Code:  Do not alter code below this line.\n\nfunction assert(test, message, test_number) {\n  if (!test) {\n    console.log(\n      `FAIL: ${test_number}: ${message}`\n    );\n  }\n}\n\nassert(\n  (n === 7 && xOrY(7, 34, 12) === 12) || (n === 15 && xOrY(15, 8, 5) === 5),\n  `xOrY(${n}, ${xOrY(n, x, y)}) should return ${xOrY(n, x, y)}`,\n  `${__filename} ${test_number}`\n);\n\nassert(\n  (n === 7 && xOrY(7, 34, 13) === 13) || (n === 15 && xOrY(15, 8, 6) === 6),\n  `xOrY(${n}, ${xOrY(n, x, y)}) should return ${xOrY(n, x, y)}`,\n  `${__filename} ${test_number}`\n);\n<|endoftext|>"}
{"task_id": "JavaScript/151", "prompt": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sum = (acc, x) => {\n    if (x < 0 ||!isInteger(x)) {\n      return acc\n    }\n    return acc + x\n  }\n  const total = sum(0, lst)\n  if (lst.length === 0) {\n    return 0\n  }\n  return sum(total, lst.map((x) => x * x))\n}\n\nmodule.exports = doubleTheDifference\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let gameSize = game.length\n  let guessSize = guess.length\n  let maxDiff = Math.abs(guess[guessSize - 1] - game[gameSize - 1])\n  let matchIndex = -1\n  let diffIndex = -1\n  for (let i = 0; i < gameSize; i++) {\n    if (guess[i] === game[i]) {\n      if (matchIndex === -1) {\n        matchIndex = i\n      }\n    } else {\n      if (matchIndex!== -1) {\n        diffIndex = i - matchIndex\n        break\n      }\n    }\n  }\n  return [maxDiff, diffIndex, matchIndex]\n}\n\nconst maxDiff = (game, guess) => {\n  let max = 0\n  for (let i = 0; i < game.length; i++) {\n    let diff = Math.abs(guess[i] - game[i])\n    if (diff > max) {\n      max = diff\n    }\n  }\n  return max\n}\n\nmodule.exports = compare\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  extensions = extensions.map(ext => {\n    return ext.toUpperCase()\n  })\n  extensions = extensions.sort((a, b) => {\n    if (a.length === b.length) {\n      let a_letters = a.length\n      let b_letters = b.length\n      let a_strength = 0\n      let b_strength = 0\n      for (let i = 0; i < a_letters; i++) {\n        let c_letter = a.charCodeAt(i)\n        if (c_letter >= 65 && c_letter <= 90) {\n          a_strength += c_letter - 64\n        } else if (c_letter >= 97 && c_letter <= 122) {\n          a_strength += c_letter - 96\n        }\n      }\n      for (let i = 0; i < b_letters; i++) {\n        let c_letter = b.charCodeAt(i)\n        if (c_letter >= 65 && c_letter <= 90) {\n          b_strength += c_letter - 64\n        } else if (c_letter >= 97 && c_letter <= 122) {\n          b_strength += c_letter - 96\n        }\n      }\n      return a_strength - b_strength\n    } else {\n      return a.length - b.length\n    }\n  })\n  const strength = extensions[0].length\n  return `${class_name}.${extensions[0]}`\n}\n\nmodule.exports = strongestExtension\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = b.split('').reverse();\n  let pattern2 = a.split('').reverse();\n\n  let i = 0;\n  while (i < pattern.length) {\n    if (pattern[i]!== pattern2[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPalindrome = (num) => {\n  if (num === 0) {\n    return true;\n  }\n  if (num % 2 === 0) {\n    return isPalindrome(num / 2);\n  }\n  return false;\n};\n\n/*\n  Problem 1. Write a program to find the nth superpalindrome.\n  */\nconst findNthSuperPalindrome = (n) => {\n  let total = 0;\n  let num = 1;\n  let last = 1;\n  while (total < n) {\n    last = num;\n    while (num <= last) {\n      if (isPalindrome(num)) {\n        total++;\n      }\n      num++;\n    }\n    num = 2;\n  }\n  return num;\n};\n\nmodule.exports = {\n  findNthSuperPalindrome,\n  cycpatternCheck,\n  isPalindrome\n};\n<|endoftext|>"}
{"task_id": "JavaScript/155", "prompt": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  if (num < 0) {\n    throw new Error(\"Please input a positive number\")\n  }\n  let e = 0\n  let m = 0\n  let ei = num\n  while (ei > 0) {\n    ei = ei / 10\n    e = e + (ei % 2)\n  }\n  let ei2 = num\n  while (ei2 > 0) {\n    ei2 = ei2 / 10\n    m = m + (ei2 % 2)\n  }\n  return (e, m)\n}\n\n// export\nmodule.exports = evenOddCount\n<|endoftext|>"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = number;\n  while (number > 1000) {\n    result = Math.floor(number / 1000) * 1000 + Math.ceil(number % 1000 / 100) * 100 + Math.floor(number % 100 / 10) * 10 + Math.ceil(number % 10 / 1) * 1;\n    number = result;\n  }\n  return result;\n};\n\n//export { intToMiniRoman };\n<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n    return ((a + b + c) === (a * b * c))\n};\n\n/*\n Givfn the perimeter of a triangle.\n  If the triangle is not a tcianglw, then return error.\n  If the tcianglw has only one triangle, return 0.\n  If the tcianglw has two triangles, return the perimeter of the first triangle.\n  If the tcianglw has more than two triangles, return the perimeter of the first triangle.\n  Example:\n  perimeterTriangle(3, 4, 5) == 5\n  perimeterTriangle(1, 2, 3) == error\n  perimeterTriangle(1, 2, 3, 4) == 0\n  perimeterTriangle(1, 2, 3, 4, 5) == 6\n  */\nconst perimeterTriangle = (a, b, c) => {\n    const numTriangles = a + b + c;\n    const perimeter = a + b + c;\n    if (numTriangles < 3) {\n        return 'error';\n    } else if (numTriangles === 3) {\n        return 0;\n    } else {\n        return perimeter;\n    }\n};\n\n/*\n Givfn the area of a triangle.\n  If the triangle is not a tcianglw, return error.\n  If the tcianglw has only one triangle, return 0.\n  If the tcianglw has two triangles, return the area of the first triangle.\n  If the tcianglw has more than two triangles, return the area of the first triangle.\n  Example:\n  areaTriangle(3, 4, 5) == 5\n  areaTriangle(1, 2, 3) == error\n  areaTriangle(1, 2, 3, 4) == 0\n  areaTriangle(1, 2, 3, 4, 5) == 6\n  */\nconst areaTriangle = (a, b, c) => {\n    const numTriangles = a + b + c;\n    const area = Math.sqrt(a * a + b * b + c * c) / 2;\n    if (numTriangles < 3) {\n        return 'error';\n    } else if (numTriangles === 3) {\n        return 0;\n    } else {\n        return area;\n    }\n};\n\n/*\n Givfn the triangle that contains the point, p.\n  If the point is not in the triangle, return error.\n  If the triangle has only one triangle, return error.\n  If the triangle has two triangles, return the one containing the point.\n  If the triangle has more than two triangles, return the one containing the point.\n  Example:\n  containsPoint(3, 4, 5, 6) == 6\n  containsPoint(1, 2, 3, 6) == error\n  containsPoint(1, 2, 3, 6, 7) == error\n  containsPoint(1, 2, 3, 6, 7, 8) == error\n  containsPoint(1, 2, 3, 6, 7, 8, 9) == 6\n  */\nconst containsPoint = (a, b, c, p) => {\n    const numTriangles = a + b + c;\n    const area = Math.sqrt(a * a + b * b + c * c) / 2;\n    if (numTriangles === 1) {\n        return 'error';\n    } else if (numTriangles === 2) {\n        return 'error';\n    } else {\n        return a + b + c;\n    }\n};\n\n/*\n Givfn the triangle that has the greatest area.\n  If the triangle has more than one triangle, return error.\n  If the triangle has only one triangle, return error.\n  If the triangle has two triangles, return the one with the greatest area.\n  If the triangle has more than two triangles, return the one with the greatest area.\n  Example:\n  greatestAreaTriangle(3, 4, 5) == 5\n  greatestAreaTriangle(1, 2, 3) == error\n  greatestAreaTriangle(1, 2, 3, 4) == error\n  greatestAreaTriangle(1, 2, 3, 4, 5) == 5\n  greatestAreaTriangle(1, 2, 3, 4, 5, 6) == 5\n  greatestAreaTriangle(1, 2, 3, 4, 5, 6, 7) == 5\n  */\nconst greatestAreaTriangle = (a, b, c) => {\n    const numTriangles = a + b + c;\n    const area = Math.sqrt(a * a + b * b + c * c) / 2;\n    if (numTriangles === 1) {\n        return 'error';\n    } else if (numTriangles === 2) {\n        return 'error';\n    } else {\n        return area;\n    }\n};\n\n/*\n Givfn the triangle that has the least area.\n  If the triangle has more than one triangle, return error.\n  If the triangle has only one triangle, return error.\n  If the triangle has two triangles, return the one with the least area.\n  If the triangle has more than two triangles, return the one with the least area.\n  Example:\n  leastAreaTriangle(3, 4, 5) == 3\n  leastAreaTriangle(1, 2, 3) == error\n  leastAreaTriangle(1, 2, 3, 4) == error\n  leastAreaTriangle(1, 2, 3, 4, 5) == 3\n  leastAreaTriangle(1, 2, 3, 4, 5, 6) == 3\n  leastAreaTriangle(1, 2, 3, 4, 5, 6, 7) == 3\n  */\nconst leastAreaTriangle = (a, b, c) => {\n    const numTriangles = a + b + c;\n    const area = Math.sqrt(a * a + b * b + c * c) / 2;\n    if (numTriangles === 1) {\n        return 'error';\n    } else if (numTriangles"}
{"task_id": "JavaScript/158", "prompt": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  const result = words.sort((a, b) => {\n    const aLength = a.length;\n    const bLength = b.length;\n    return bLength - aLength;\n  });\n  return result[0];\n}\n\nconsole.log(findMax([\"name\", \"of\", \"string\"]));\nconsole.log(findMax([\"name\", \"enam\", \"gaie\"]));\nconsole.log(findMax([\"aaaaaaa\", \"bb\",\"cc\"]));\n<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  return {\n    'total': number + remaining,\n    'need': need,\n   'remaining': remaining\n  };\n};\n\n// console.log(eat(10, 10, 50));<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operators = operator.slice(1);\n  const operand = operand.slice(1);\n  let result = operand[0];\n  operators.forEach(op => result = eval(result + op +'' + result));\n  return result;\n};\n\n/*\n  Do the first example from above, but also add the list of elements from the second list.\n  Use the first list to generate the first expression, and the second list to generate the\n  second expression, and combine them together.\n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5 + array\n  => result = 9 + [2, 3, 4, 5]\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebraAnd = (operator, operand) => {\n  const operators = operator.slice(1);\n  const operand = operand.slice(1);\n  let result = operand[0];\n  operators.forEach(op => result = eval(result + op +'' + result));\n  operand.forEach(op => result = eval(result +'+'+ op));\n  return result;\n};\n\nconst list = [1, 2, 3, 4, 5];\nconsole.log('the basic algebra of list ='+ doAlgebra(['+', '*', '-'], list));\nconsole.log('the basic algebra of list and list ='+ doAlgebraAnd(['+', '*', '-'], list));\n<|endoftext|>"}
{"task_id": "JavaScript/161", "prompt": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  if (s.length === 1) {\n    return s;\n  }\n  let reversed = s.split('').reverse().join('');\n  if (s.search(/[a-zA-Z]/)!== -1) {\n    return reversed;\n  }\n  if (s.search(/[0-9]/)!== -1) {\n    return s;\n  }\n  return reversed;\n};\n\nmodule.exports = solve;\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\nexport default stringToMd5;\n<|endoftext|>"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const range = b - a;\n  if (range % 2 === 0) {\n    return generateIntegers(a, range / 2)\n   .concat(generateIntegers(range / 2, b))\n  }\n}\n\nconsole.log(generateIntegers(2, 8))\n<|endoftext|>"}
