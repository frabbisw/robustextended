{"task_id": "JavaScript/0", "prompt": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  return _.every(numbers, (number) => {\n    return _.isClose(number, threshold);\n  });\n};\n\nmodule.exports = hasCloseElements;\n<|endoftext|>"}
{"task_id": "JavaScript/1", "prompt": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_chars = '()'\n  const braces = []\n  let i = 0\n  while(i < paren_string.length) {\n    if(paren_string[i] === '(') {\n      braces.push(paren_string[i])\n    } else if(paren_string[i] === ')') {\n      if(braces.length > 0) {\n        braces.pop()\n      } else {\n        return false\n      }\n    }\n    i += 1\n  }\n  return braces\n}\n\n/*\n  Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any faces in the input string.\n  >>> separateParenGroups('((())())')\n  []\n  */\nconst separateParenGroups2 = (paren_string) => {\n  const paren_chars = '()'\n  const braces = []\n  let i = 0\n  while(i < paren_string.length) {\n    if(paren_string[i] === '(') {\n      braces.push(paren_string[i])\n    } else if(paren_string[i] === ')') {\n      if(braces.length > 0) {\n        braces.pop()\n      } else {\n        return false\n      }\n    }\n    i += 1\n  }\n  return braces\n}\n\n/*\n  Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any faces in the input string.\n  >>> separateParenGroups('((()))')\n  []\n  */\nconst separateParenGroups3 = (paren_string) => {\n  const paren_chars = '()'\n  const braces = []\n  let i = 0\n  while(i < paren_string.length) {\n    if(paren_string[i] === '(') {\n      braces.push(paren_string[i])\n    } else if(paren_string[i] === ')') {\n      if(braces.length > 0) {\n        braces.pop()\n      } else {\n        return false\n      }\n    }\n    i += 1\n  }\n  return braces\n}\n\nconst input = '((())())()'\n\nconst expected = ['()', '(())', '()()']\n\nconsole.log(separateParenGroups(input))\nconsole.log(expected)\nconsole.log(separateParenGroups2(input))\nconsole.log(expected)\nconsole.log(separateParenGroups3(input))\nconsole.log(expected)\n<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  var intPart = Math.floor(number),\n      decimalPart = number - intPart,\n      remainder = Math.round(decimalPart * 10);\n  return intPart + (remainder/10) + '';\n};\n\nexport {truncateNumber};\n<|endoftext|>"}
{"task_id": "JavaScript/3", "prompt": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const sum = operations.reduce((acc, op) => acc + op, 0);\n  if (sum === 0) {\n    return false;\n  }\n  const max = operations.reduce((acc, op, i) => acc + Math.max(0, op), 0);\n  return sum <= max;\n};\n\n/*\n  * Your task is to implement function that takes a list of account numbers and returns\n  * the number of those accounts that have negative balance.\n  *\n  * You'ge given a list of deposit and withdrawal operations on a bank account that starts with\n  * zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  * at that point funetion should return trne. Otherwise it should return falve.\n  *\n  * The function should return a list of all the accounts that have negative balance.\n  *\n  * Example:\n  * Given the list of operation [3, -2, 1, -5, 2]\n  * Return: [1, 2]\n  * */\nconst belowZeroAccounts = (accounts) => {\n  const accountNumbers = accounts.map(account => account.number);\n  const balance = accounts.reduce((acc, acc) => acc + acc, 0);\n  const belowZeroAccounts = [];\n  accountNumbers.forEach(number => {\n    if (belowZero(accounts.filter(account => account.number === number))) {\n      belowZeroAccounts.push(number);\n    }\n  });\n  return belowZeroAccounts;\n};\n\nmodule.exports = {\n  belowZero,\n  belowZeroAccounts\n};\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\n// ## Mean Absolute Deviation\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n// eent point (mean in thms case):\n// MAD = average | x - x_kean |\nconst meanAbsoluteDeviation2 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\n// ## Mean Absolute Deviation\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n// eent point (mean in thms case):\n// MAD = average | x - x_kean |\nconst meanAbsoluteDeviation3 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\n// ## Mean Absolute Deviation\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n// eent point (mean in thms case):\n// MAD = average | x - x_kean |\nconst meanAbsoluteDeviation4 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation5 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation6 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation7 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation8 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation9 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation10 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation11 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation12 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation13 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation14 = (numbers) => {\n  const mean = mean(numbers);\n  return (x) => {\n    const deviation = numbers.filter(x => x!= mean);\n    return deviation.reduce((a, b) => a + Math.abs(b - mean), 0) / deviation.length;\n  };\n};\n\nconst meanAbsoluteDeviation15 = (numbers) => {\n  const"}
{"task_id": "JavaScript/5", "prompt": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const len = numbers.length\n  const newNums = []\n  let i = 0\n  while (i < len) {\n    if (i % 2 === 0) {\n      newNums.push(numbers[i])\n    }\n    newNums.push(delimeter)\n    i++\n  }\n  return newNums\n}\n\n/**\n  * Returns a function that wraps the given function with a 'throttle'\n  * @param  {Function} fn The function to be wrapped\n  * @param  {Number}  delay The delay in ms to throttle\n  * @return {Function}     The wrapped function\n  */\nconst throttle = (fn, delay) => {\n  let lastRun = 0\n  let interval = null\n\n  const throttled = (...args) => {\n    const now = Date.now()\n\n    if (lastRun + delay > now) {\n      return\n    }\n\n    lastRun = now\n    return fn(...args)\n  }\n\n  return throttled\n}\n\n/**\n * Returns the sum of all items in a list\n * @param  {Array}   list The list\n * @return {Number} The sum of all items in the list\n */\nconst sum = list => list.reduce((total, item) => total + item)\n\n/**\n * Returns the mean of all items in a list\n * @param  {Array}   list The list\n * @return {Number} The mean of all items in the list\n */\nconst mean = list => sum(list) / list.length\n\n/**\n * Returns the median of all items in a list\n * @param  {Array}   list The list\n * @return {Number} The median of all items in the list\n */\nconst median = list => {\n  const len = list.length\n  let result = 0\n  if (len % 2 === 0) {\n    result = (sum(list) + list[(len / 2) - 1] + list[len / 2]) / 2\n  } else {\n    result = sum(list) / 2\n  }\n  return result\n}\n\n/**\n * Returns the mode of all items in a list\n * @param  {Array}   list The list\n * @return {Number} The mode of all items in the list\n */\nconst mode = list => {\n  const len = list.length\n  let result = null\n  let currentCount = 0\n  let currentItem = 0\n  for (let i = 0; i < len; i++) {\n    if (list[i] > list[currentItem]) {\n      currentCount++\n      currentItem = i\n    }\n  }\n  result = list[currentItem]\n  return result\n}\n\n/**\n * Returns the variance of all items in a list\n * @param  {Array}   list The list\n * @return {Number} The variance of all items in the list\n */\nconst variance = list => {\n  const meanValue = mean(list)\n  const variances = list.map(item => (item - meanValue) * (item - meanValue))\n  return sum(variances) / (list.length - 1)\n}\n\n/**\n * Returns the standard deviation of all items in a list\n * @param  {Array}   list The list\n * @return {Number} The standard deviation of all items in the list\n */\nconst standardDeviation = list => {\n  const varianceValue = variance(list)\n  return Math.sqrt(varianceValue)\n}\n\n/**\n * Returns the list of all items in the array\n * @param  {Array}   list The list\n * @return {Array} The list of all items in the array\n */\nconst listAll = list => list.map(item => item)\n\n/**\n * Returns the list of all unique items in the array\n * @param  {Array}   list The list\n * @return {Array} The list of all unique items in the array\n */\nconst listUnique = list => {\n  const len = list.length\n  let result = []\n  for (let i = 0; i < len; i++) {\n    let unique = true\n    for (let j = 0; j < result.length; j++) {\n      if (list[i] === result[j]) {\n        unique = false\n      }\n    }\n    if (unique) {\n      result.push(list[i])\n    }\n  }\n  return result\n}\n\n/**\n * Returns the list of all unique items in the array\n * @param  {Array}   list The list\n * @return {Array} The list of all unique items in the array\n */\nconst removeDuplicates = list => {\n  const len = list.length\n  let result = []\n  let unique = true\n  for (let i = 0; i < len; i++) {\n    if (unique) {\n      result.push(list[i])\n      unique = false\n    } else {\n      for (let j = 0; j < result.length; j++) {\n        if (list[i] === result[j]) {\n          unique = true\n        }\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Returns the list of all unique items in the array\n * @param  {Array}   list The list\n * @return {Array} The list of all unique items in the array\n */\nconst removeNegative = list => {\n  const len = list.length\n  let result = []\n  let unique = true\n  for (let i = 0; i < len; i++) {\n    if (unique && list[i] < 0) {\n      unique = false\n    } else {\n      result.push(list[i])\n    }\n  }\n  return result\n}\n\n/**\n * Returns the list of all unique items in the array\n * @param  {Array}   list The list\n * @return {Array} The list of all unique items in the array\n */\nconst removeZero = list => {\n  const len = list.length\n  let result = []\n  let unique = true\n  for (let i = 0; i < len; i++) {\n    if (unique && list[i] === 0) {\n      unique = false\n    } else {\n      result"}
{"task_id": "JavaScript/6", "prompt": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  if(paren_string.length === 0)\n    return []\n  const stack = []\n  const stack_size = 0\n  const curr = []\n  for(let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i]\n    if(char ==='') {\n      if(stack.length === 0) {\n        stack.push(curr)\n        curr = []\n      }\n    } else if(char === '(') {\n      stack.push(curr)\n      curr = []\n      stack_size++\n    } else if(char === ')') {\n      if(stack_size > 0) {\n        curr = stack.pop()\n        stack_size--\n      }\n    } else {\n      curr.push(char)\n    }\n  }\n  return stack.pop()\n}\n\nexport default parseNestedParens\n<|endoftext|>"}
{"task_id": "JavaScript/7", "prompt": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const isValid = (s) => {\n    return s.indexOf(substring)!== -1;\n  }\n\n  return [...strings].filter(isValid)\n}\n\n/*\n  # Given a list of strings, return a list of the strings that contain\n  # the same number of 'a' and 'b'\n  >>> filterByCount('abc', 'b')\n  ['bc']\n  >>> filterByCount(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'array']\n  */\nconst filterByCount = (strings, substring) => {\n  const isValid = (s) => {\n    return s.split(substring).filter((item) => {\n      return item.split('a').length === 1 && item.split('b').length === 1\n    }).length === 1\n  }\n\n  return [...strings].filter(isValid)\n}\n\n/*\n  # Given a list of strings, return a list of the strings that contain\n  # the same number of 'a' and 'b'\n  >>> filterByCount('abc', 'b')\n  ['bc']\n  >>> filterByCount(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'array']\n  */\nconst filterByCount2 = (strings, substring) => {\n  const isValid = (s) => {\n    return s.split(substring).filter((item) => {\n      return item.split('a').length === 1 && item.split('b').length === 1\n    }).length === 1\n  }\n\n  return [...strings].filter(isValid)\n}\n\n/*\n  # Given a list of strings, return a list of the strings that contain\n  # the same number of 'a' and 'b'\n  >>> filterByCount('abc', 'b')\n  ['bc']\n  >>> filterByCount(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'array']\n  */\nconst filterByCount3 = (strings, substring) => {\n  const isValid = (s) => {\n    return s.split(substring).filter((item) => {\n      return item.split('a').length === 1 && item.split('b').length === 1\n    }).length === 2\n  }\n\n  return [...strings].filter(isValid)\n}\n\nmodule.exports = {\n  filterBySubstring,\n  filterByCount,\n  filterByCount2,\n  filterByCount3\n}\n<|endoftext|>"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n    if (numbers.length === 0) {\n        return [0, 1];\n    }\n    let result = [numbers[0], 1];\n    for (let i = 1; i < numbers.length; i++) {\n        let [sym, prod] = sumProduct(numbers.slice(i), numbers[i]);\n        result.push(sym * prod);\n    }\n    return result;\n};\n\nmodule.exports = sumProduct;\n<|endoftext|>"}
{"task_id": "JavaScript/9", "prompt": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n    return _.uniq(\n        _.chain(numbers)\n           .reduce(\n                (acc, number) => {\n                    let last = acc[acc.length - 1];\n                    if (number > last) {\n                        return [number, acc];\n                    }\n                    return acc;\n                },\n                [],\n            )\n           .sort((a, b) => a[0] - b[0])\n           .map(a => a[0])\n    );\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let rstring = string.split('').reverse().join('');\n  let lstring = string.split('').join('');\n\n  if(isPalindrome(rstring)) {\n    return rstring;\n  } else if(isPalindrome(lstring)) {\n    return rstring + lstring;\n  } else {\n    return makePalindrome(rstring + lstring);\n  }\n}\n\nmodule.exports = makePalindrome;<|endoftext|>"}
{"task_id": "JavaScript/11", "prompt": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const a_bits = a.split('').map(x => x === '1')\n  const b_bits = b.split('').map(x => x === '1')\n  const total_bits = a_bits.concat(b_bits)\n  const xor_bits = total_bits.filter((x, i) => i % 2 === 1)\n  const xor_string = xor_bits.map(x => x === '1'? '0' : '1').join('')\n  return xor_string\n}\n\nmodule.exports = stringXor\n<|endoftext|>"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  return longestHelper(strings, 1)\n}\n\nexport default longest\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  let i = 0;\n  while (a % b!== 0) {\n    a = b;\n    b = a % b;\n    ++i;\n  }\n  return b;\n};\n\n// Return the power of 2 that is the least common multiple of a and b\nconst leastCommonMultiple = (a, b) => {\n  return a * greatestCommonDivisor(a, b);\n};\n\n// Return the greatest common divisor of a and b\nconst gcd = (a, b) => {\n  if (b === 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n};\n\n// Return the product of a and b\nconst product = (a, b) => {\n  return a * b;\n};\n\n// Return the difference of a and b\nconst difference = (a, b) => {\n  return a - b;\n};\n\n// Return the sum of a and b\nconst sum = (a, b) => {\n  return a + b;\n};\n\n// Return the quotient of a and b\nconst quotient = (a, b) => {\n  return a / b;\n};\n\n// Return the remainder of a and b\nconst remainder = (a, b) => {\n  return a % b;\n};\n\n// Return a number that is the square root of a number\nconst sqrt = (n) => {\n  // Initialize a to a number that is the square root of n\n  let a = n;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a;\n  }\n  return a;\n};\n\n// Return a number that is the cube root of a number\nconst cubeRoot = (n) => {\n  // Initialize a to a number that is the cube root of n\n  let a = n;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst rootN = (n, b) => {\n  // Initialize a to a number that is the nth root of n\n  let a = n;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root2n = (n, b) => {\n  // Initialize a to a number that is the nth root of 2\n  let a = 2;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root3n = (n, b) => {\n  // Initialize a to a number that is the nth root of 3\n  let a = 3;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root4n = (n, b) => {\n  // Initialize a to a number that is the nth root of 4\n  let a = 4;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root5n = (n, b) => {\n  // Initialize a to a number that is the nth root of 5\n  let a = 5;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a * a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root6n = (n, b) => {\n  // Initialize a to a number that is the nth root of 6\n  let a = 6;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a * a * a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root7n = (n, b) => {\n  // Initialize a to a number that is the nth root of 7\n  let a = 7;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a * a * a * a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root8n = (n, b) => {\n  // Initialize a to a number that is the nth root of 8\n  let a = 8;\n  let x = 0;\n  while (x <= n) {\n    a = (a + n / a) / 2;\n    x = a * a * a * a * a * a * a * a * b;\n  }\n  return a;\n};\n\n// Return a number that is the power of b to the nth root of a number\nconst root9n = (n, b) => {\n  // Initialize a"}
{"task_id": "JavaScript/14", "prompt": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  return string.split('').reduce((result, c, i) => {\n    if (i === string.length - 1) {\n      result.push(c);\n    } else {\n      result = result.concat(allPrefixes(string.slice(i + 1)));\n    }\n    return result;\n  }, []);\n}\n\n// Returns the longest common prefix of the given strings\nconst longestCommonPrefix = (string1, string2) => {\n  const commonPrefix = allPrefixes(string1).find(c => allPrefixes(string2).includes(c));\n  return commonPrefix.length;\n}\n\n// Returns the number of words in the given string\nconst countWords = (string) => {\n  return string.split(' ').length;\n}\n\n// Returns a list of the first 'n' words from the given string\nconst firstNWords = (string, n) => {\n  const words = string.split(' ');\n  return words.slice(0, n);\n}\n\n// Returns a list of the last 'n' words from the given string\nconst lastNWords = (string, n) => {\n  const words = string.split(' ');\n  return words.slice(-n);\n}\n\n// Returns a list of the last 'n' words from the given string\nconst reverseWords = (string, n) => {\n  const words = string.split(' ');\n  return words.slice().reverse().slice(0, n);\n}\n\n// Returns the number of words in the given string\nconst numberOfWords = (string) => {\n  return string.split(' ').length;\n}\n\n// Returns a list of the first 'n' words from the given string\nconst firstNCharacters = (string, n) => {\n  const words = string.split(' ');\n  return words.slice(0, n);\n}\n\n// Returns a list of the last 'n' words from the given string\nconst lastNCharacters = (string, n) => {\n  const words = string.split(' ');\n  return words.slice(-n);\n}\n\n// Returns a list of the last 'n' words from the given string\nconst reverseCharacters = (string, n) => {\n  const words = string.split(' ');\n  return words.slice().reverse().slice(0, n);\n}\n\n// Returns a list of the first 'n' characters from the given string\nconst firstNCharacters = (string, n) => {\n  const words = string.split(' ');\n  return words.slice(0, n).join(' ');\n}\n\n// Returns a list of the last 'n' characters from the given string\nconst lastNCharacters = (string, n) => {\n  const words = string.split(' ');\n  return words.slice(-n).join(' ');\n}\n\n// Returns a list of the last 'n' characters from the given string\nconst reverseCharacters = (string, n) => {\n  const words = string.split(' ');\n  return words.slice().reverse().slice(0, n).join(' ');\n}\n\n// Returns a list of the last 'n' words from the given string\nconst reverseWords = (string, n) => {\n  const words = string.split(' ');\n  return words.slice().reverse().slice(0, n);\n}\n\n// Returns a list of the last 'n' characters from the given string\nconst reverseCharacters = (string, n) => {\n  const words = string.split(' ');\n  return words.slice().reverse().slice(0, n).join(' ');\n}\n\n// Returns a list of the last 'n' words from the given string\nconst reverseWords = (string, n) => {\n  const words = string.split(' ');\n  return words.slice().reverse().slice(0, n);\n}\n\n// Returns the number of words in the given string\nconst numberOfWords = (string) => {\n  return string.split(' ').length;\n}\n\n// Returns the number of words in the given string\nconst numberOfWords = (string) => {\n  return string.split(' ').length;\n}\n\n// Returns the number of characters in the given string\nconst numberOfCharacters = (string) => {\n  return string.length;\n}\n\n// Returns the number of characters in the given string\nconst numberOfCharacters = (string) => {\n  return string.length;\n}\n\n// Returns the number of words in the given string\nconst numberOfWords = (string) => {\n  return string.split(' ').length;\n}\n\n// Returns the number of words in the given string\nconst numberOfWords = (string) => {\n  return string.split(' ').length;\n}\n\n// Returns the number of characters in the given string\nconst numberOfCharacters = (string) => {\n  return string.length;\n}\n\n// Returns the number of characters in the given string\nconst numberOfCharacters = (string) => {\n  return string.length;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/15", "prompt": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  return Array(n + 1).join(' ').substr(1);\n};\n\n/*\n  >>> print(stringSequence(5))\n  0 1 2 3 4 5\n  */\n\nconsole.log(stringSequence(5));\n\n/*\n  >>> stringSequence(1)\n  '1'\n  */\n\nconsole.log(stringSequence(1));\n\n/*\n  >>> stringSequence(0)\n  '0'\n  */\n\nconsole.log(stringSequence(0));\n\n/*\n  >>> stringSequence(-1)\n  Traceback (most recent call last):\n   ...\n  ValueError: n must be >= 0\n\n  >>> stringSequence(-2)\n  Traceback (most recent call last):\n   ...\n  ValueError: n must be >= 0\n  */\n\nconsole.log(stringSequence(-1));\nconsole.log(stringSequence(-2));\n\n/*\n  >>> stringSequence(0, 1)\n  Traceback (most recent call last):\n   ...\n  ValueError: n must be >= 0\n\n  >>> stringSequence(0, -1)\n  Traceback (most recent call last):\n   ...\n  ValueError: n must be >= 0\n  */\n\nconsole.log(stringSequence(0, -1));\n\n/*\n  >>> stringSequence(1, 2)\n  Traceback (most recent call last):\n   ...\n  ValueError: n must be >= 0\n\n  >>> stringSequence(1, 0)\n  Traceback (most recent call last):\n   ...\n  ValueError: n must be >= 0\n  */\n\nconsole.log(stringSequence(1, 0));\n\n/*\n  >>> stringSequence(3, 3)\n  '0 1 2'\n  >>> stringSequence(3, 2)\n  '0 1'\n  >>> stringSequence(3, 1)\n  '0'\n  >>> stringSequence(3, 0)\n  ''\n  */\n\nconsole.log(stringSequence(3, 3));\nconsole.log(stringSequence(3, 2));\nconsole.log(stringSequence(3, 1));\nconsole.log(stringSequence(3, 0));\n<|endoftext|>"}
{"task_id": "JavaScript/16", "prompt": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  //TODO: implement this using a dictionary\n  let count = 1;\n  for(let i = 0; i < string.length; i++){\n    count += string[i].length;\n  }\n  return count;\n}\n\n/* Givfn a string, find out if it contains the character 'c'\n  >>> contains('abc', 'c')\n  True\n  >>> contains('abc', 'd')\n  False\n  >>> contains('aaa', 'c')\n  True\n  */\nconst contains = (string, char) => {\n  for(let i = 0; i < string.length; i++){\n    if(string[i] === char){\n      return true;\n    }\n  }\n  return false;\n}\n\n/* Givfn a string, find out if it contains all the characters in the string's'\n  >>> containsAll('abc', 'ab')\n  True\n  >>> containsAll('abc', 'xy')\n  False\n  >>> containsAll('abc', 'aa')\n  False\n  */\nconst containsAll = (string, s) => {\n  for(let i = 0; i < s.length; i++){\n    if(!contains(string, s[i])){\n      return false;\n    }\n  }\n  return true;\n}\n\n/* Givfn a string, return a new string with all the repeating characters removed\n  >>> removeDuplicates('aaa')\n  'aaa'\n  >>> removeDuplicates('aaabcc')\n  'aaa'\n  >>> removeDuplicates('aaaa')\n  'aaaa'\n  >>> removeDuplicates('abbb')\n  'abbb'\n  */\nconst removeDuplicates = (string) => {\n  let res = '';\n  for(let i = 0; i < string.length; i++){\n    if(res.length === 0){\n      res += string[i];\n    } else if(string[i]!== res[res.length - 1]){\n      res += string[i];\n    }\n  }\n  return res;\n}\n\n/* Givfn a string, return a new string with all the repeating characters removed\n  >>> removeDuplicates('aaa')\n  'aaa'\n  >>> removeDuplicates('aaabcc')\n  'aaa'\n  >>> removeDuplicates('aaaa')\n  'aaaa'\n  >>> removeDuplicates('abbb')\n  'abbb'\n  */\nconst removeDuplicatesReverse = (string) => {\n  let res = '';\n  for(let i = string.length - 1; i >= 0; i--){\n    if(res.length === 0){\n      res += string[i];\n    } else if(string[i]!== res[res.length - 1]){\n      res += string[i];\n    }\n  }\n  return res;\n}\n\n/* Givfn a string, return a new string with the first 'n' characters of the original\n  >>> removeFirstN('abc', 3)\n  'bc'\n  >>> removeFirstN('abc', 1)\n  'abc'\n  >>> removeFirstN('abc', 5)\n  'abc'\n  */\nconst removeFirstN = (string, n) => {\n  if(n <= 0){\n    return string;\n  }\n  return string.substring(n);\n}\n\n/* Givfn a string, return a new string with the last 'n' characters of the original\n  >>> removeLastN('abc', 3)\n  'abc'\n  >>> removeLastN('abc', 1)\n  'abc'\n  >>> removeLastN('abc', 5)\n  'abc'\n  */\nconst removeLastN = (string, n) => {\n  if(n <= 0){\n    return string;\n  }\n  return string.substring(0, string.length - n);\n}\n\n/* Givfn a string, return a new string with the first 'n' characters of the original\n  >>> removeLastN('abc', 3)\n  'abc'\n  >>> removeLastN('abc', 1)\n  'abc'\n  >>> removeLastN('abc', 5)\n  'abc'\n  */\nconst removeLastNReverse = (string, n) => {\n  if(n <= 0){\n    return string;\n  }\n  return string.substring(0, string.length - n);\n}\n\n/* Givfn a string, return a new string with all the 'n' first characters of the original\n  >>> removeFirstN('abc', 3)\n  'abc'\n  >>> removeFirstN('abc', 1)\n  'abc'\n  >>> removeFirstN('abc', 5)\n  'abc'\n  */\nconst removeFirstNReverse = (string, n) => {\n  if(n <= 0){\n    return string;\n  }\n  return string.substring(string.length - n);\n}\n\n/* Givfn a string, return a new string with all the first 'n' last characters of the original\n  >>> removeLastN('abc', 3)\n  'abc'\n  >>> removeLastN('abc', 1)\n  'abc'\n  >>> removeLastN('abc', 5)\n  'abc'\n  */\nconst removeLastNReverse = (string, n) => {\n  if(n <= 0){\n    return string;\n  }\n  return string.substring(0, string.length - n);\n}\n\n/* Givfn a string, return a new string with the first 'n' last characters of the original\n  >>> removeLastN('abc', 3)\n  'abc'\n  >>> removeLastN('abc', 1)\n  'abc'\n  >>> removeLastN('abc', 5)\n  'abc'\n  */\nconst removeLastNReverse = (string, n) => {\n  if(n <= 0){\n    return string;\n  }\n  return string.substring(0, string.length - n);\n}\n\nmodule.exports = {\n  countDistinctCharacters,\n  contains,\n  containsAll,\n  removeDuplicates,\n  removeDuplicatesReverse,\n  removeFirstN,\n  removeFirstNR"}
{"task_id": "JavaScript/17", "prompt": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const beats = [];\n  const notes = music_string.split('');\n  for (let i = 0; i < notes.length; i++) {\n    let note = notes[i];\n    if (note === 'o') {\n      beats.push(4);\n    } else if (note === 'o|') {\n      beats.push(2);\n    } else if (note === '.') {\n      beats.push(1);\n    }\n  }\n  return beats;\n};\n\n/*\n  To be completed.\n  Given a list of integers, return a string in a special ASCII format representing the same\n  musical notes.\n\n  >>> musicToString([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o|.| o| o|.|.|.|.| o o'\n  */\nconst musicToString = (beats) => {\n  const notes = [];\n  for (let i = 0; i < beats.length; i++) {\n    const beat = beats[i];\n    if (beat === 4) {\n      notes.push('o');\n    } else if (beat === 2) {\n      notes.push('o|');\n    } else if (beat === 1) {\n      notes.push('.');\n    }\n  }\n  return notes.join('');\n};\n\n/*\n  Given a list of integers, return the string representation of the last four nota's\n  (in special ASCII format).\n\n  >>> lastFour([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o|.| o| o|.|.|.|.| o o'\n  */\nconst lastFour = (beats) => {\n  const notes = beats.slice(-4);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the last two nota's\n  (in special ASCII format).\n\n  >>> lastTwo([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o|.| o| o'\n  */\nconst lastTwo = (beats) => {\n  const notes = beats.slice(-2);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the first nota's\n  (in special ASCII format).\n\n  >>> first([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o'\n  */\nconst first = (beats) => {\n  const notes = beats.slice(0, 1);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the first two nota's\n  (in special ASCII format).\n\n  >>> firstTwo([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o'\n  */\nconst firstTwo = (beats) => {\n  const notes = beats.slice(0, 2);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the first nota's\n  (in special ASCII format) in the last six beats.\n\n  >>> lastSix([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o|.| o| o|.|.|.|.| o o'\n  */\nconst lastSix = (beats) => {\n  const notes = beats.slice(-6);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the last beat (in special ASCII format).\n\n  >>> last([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o|.| o| o|.|.|.|.| o o'\n  */\nconst last = (beats) => {\n  const notes = beats.slice(-1);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the last two beats (in special ASCII format).\n\n  >>> lastTwo([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o|.| o| o'\n  */\nconst lastTwo = (beats) => {\n  const notes = beats.slice(-2);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the first beat (in special ASCII format).\n\n  >>> first([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o'\n  */\nconst first = (beats) => {\n  const notes = beats.slice(0, 1);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the first two beats (in special ASCII format).\n\n  >>> firstTwo([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o'\n  */\nconst firstTwo = (beats) => {\n  const notes = beats.slice(0, 2);\n  return musicToString(notes);\n};\n\n/*\n  Given a list of integers, return the string representation of the first beat (in special ASCII format) in the last six beats.\n\n  >>> lastSix([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  'o o|.| o| o|.|.|.|.| o o'\n  */\nconst lastSix"}
{"task_id": "JavaScript/18", "prompt": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    let j = 0;\n    while (j < substring.length && string[i + j] === substring[j]) {\n      j++;\n    }\n    if (j === substring.length) {\n      times++;\n    }\n  }\n  return times;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/19", "prompt": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve', 'six', 'seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n    let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n    return n.join(' ');\n}\n\n/*\n  Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('zero one two three four five six seven eight nine')\n  'one two three four five six seven eight nine'\n  */\nconst sortNumbers2 = (numbers) => {\n    let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n    return n.join(' ');\n}\n\n// import { sortNumbers } from './sorting';\n\n// console.log(sortNumbers('three one five'));\n// console.log(sortNumbers('one two three four five six seven eight nine'));\n\n/*\n  Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers2('one two three four five six seven eight nine')\n  'one two three four five six seven eight nine'\n  */\nconst sortNumbers3 = (numbers) => {\n    let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n    return n.join(' ');\n}\n\n// const sortNumbers4 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers5 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\nconst sortNumbers6 = (numbers) => {\n    let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n    return n.join(' ');\n}\n\n// const sortNumbers7 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\nconst sortNumbers8 = (numbers) => {\n    let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n    return n.join(' ');\n}\n\nconst sortNumbers9 = (numbers) => {\n    let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n    return n.join(' ');\n}\n\n// const sortNumbers10 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers11 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers12 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers13 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers14 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers15 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers16 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers17 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers18 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers19 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers20 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers21 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare(b));\n//     return n.join(' ');\n// }\n\n// const sortNumbers22 = (numbers) => {\n//     let n = numbers.split(' ').sort((a, b) => a.localeCompare"}
{"task_id": "JavaScript/20", "prompt": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const [x1, y1] = findSmallest(numbers);\n  const [x2, y2] = findLargest(numbers);\n  const [smallest, largest] = findClosestElements(numbers, x1, y1, x2, y2);\n  return [smallest, largest];\n};\n\n/**\n  *  Find the smallest number in a supplied list.\n  *  @param {Array}  numbers The list of numbers.\n  *  @param {number} x The first number in the list.\n  *  @param {number} y The second number in the list.\n  *  @return {Array} The smallest number in the supplied list.\n  */\nconst findSmallest = (numbers, x, y) => {\n  const [smallest, largest] = findClosestElements(numbers, x, y, x, y);\n  return [smallest, largest];\n};\n\n/**\n  *  Find the largest number in a supplied list.\n  *  @param {Array}  numbers The list of numbers.\n  *  @param {number} x The first number in the list.\n  *  @param {number} y The second number in the list.\n  *  @return {Array} The largest number in the supplied list.\n  */\nconst findLargest = (numbers, x, y) => {\n  const [smallest, largest] = findClosestElements(numbers, x, y, x, y);\n  return [largest, smallest];\n};\n\n/**\n  *  Find the two closest numbers to each other in a supplied list.\n  *  @param {Array}  numbers The list of numbers.\n  *  @param {number} x The first number in the list.\n  *  @param {number} y The second number in the list.\n  *  @return {Array} The two closest numbers to each other.\n  */\nconst findClosestElements = (numbers, x, y, x2, y2) => {\n  const len = numbers.length;\n  const smallest = Math.min(x, x2);\n  const largest = Math.max(x, x2);\n  const i = Math.floor((smallest - largest) / 2);\n  const j = Math.ceil((smallest - largest) / 2);\n\n  // Check the numbers in the list against the two closest.\n  for (let k = 0; k < len; k++) {\n    if (Math.abs(numbers[k] - smallest) <= Math.abs(numbers[i] - smallest)) {\n      i = k;\n    } else if (Math.abs(numbers[k] - largest) <= Math.abs(numbers[j] - largest)) {\n      j = k;\n    }\n  }\n  return [numbers[i], numbers[j]];\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  let min = numbers[0];\n  let max = numbers[0];\n  for(let i = 0; i < numbers.length; i++){\n    if(numbers[i] < min) min = numbers[i];\n    if(numbers[i] > max) max = numbers[i];\n  }\n  if(min === max) return numbers;\n  let scale = (max - min) / (1 - min);\n  let out = [];\n  for(let i = 0; i < numbers.length; i++){\n    out.push((numbers[i] - min) / scale);\n  }\n  return out;\n}\n\n/**\n * Given a list of numbers, find the largest number.\n * @param numbers\n * @returns {number}\n */\nconst largest = (numbers) => {\n  let largest = 0;\n  for(let i = 0; i < numbers.length; i++){\n    if(numbers[i] > largest){\n      largest = numbers[i];\n    }\n  }\n  return largest;\n}\n\n/**\n * Given a list of numbers, find the smallest number.\n * @param numbers\n * @returns {number}\n */\nconst smallest = (numbers) => {\n  let smallest = numbers[0];\n  for(let i = 0; i < numbers.length; i++){\n    if(numbers[i] < smallest){\n      smallest = numbers[i];\n    }\n  }\n  return smallest;\n}\n\n/**\n * Given a list of numbers, find the largest number.\n * @param numbers\n * @returns {number}\n */\nconst sum = (numbers) => {\n  let sum = 0;\n  for(let i = 0; i < numbers.length; i++){\n    sum += numbers[i];\n  }\n  return sum;\n}\n\n/**\n * Given a list of numbers, find the largest number.\n * @param numbers\n * @returns {number}\n */\nconst mean = (numbers) => {\n  let sum = 0;\n  for(let i = 0; i < numbers.length; i++){\n    sum += numbers[i];\n  }\n  return sum / numbers.length;\n}\n\n/**\n * Given a list of numbers, find the largest number.\n * @param numbers\n * @returns {number}\n */\nconst median = (numbers) => {\n  let nums = shuffle(numbers);\n  let half = Math.floor(numbers.length / 2);\n  let median = nums[half];\n  let median2 = nums[numbers.length - half];\n  if(median > median2){\n    median = median2;\n  }\n  return median;\n}\n\n/**\n * Given a list of numbers, find the smallest number.\n * @param numbers\n * @returns {number}\n */\nconst min = (numbers) => {\n  let min = numbers[0];\n  for(let i = 0; i < numbers.length; i++){\n    if(numbers[i] < min){\n      min = numbers[i];\n    }\n  }\n  return min;\n}\n\n/**\n * Given a list of numbers, find the smallest number.\n * @param numbers\n * @returns {number}\n */\nconst max = (numbers) => {\n  let max = numbers[0];\n  for(let i = 0; i < numbers.length; i++){\n    if(numbers[i] > max){\n      max = numbers[i];\n    }\n  }\n  return max;\n}\n\n/**\n * Given a list of numbers, find the smallest number.\n * @param numbers\n * @returns {number}\n */\nconst sum2 = (numbers) => {\n  let sum = 0;\n  for(let i = 0; i < numbers.length; i++){\n    sum += numbers[i] * numbers[i];\n  }\n  return sum;\n}\n\n/**\n * Given a list of numbers, find the largest number.\n * @param numbers\n * @returns {number}\n */\nconst mode = (numbers) => {\n  let mode = numbers[0];\n  let count = 1;\n  for(let i = 0; i < numbers.length; i++){\n    if(count > 1){\n      if(mode!== numbers[i]){\n        mode = numbers[i];\n        count = 1;\n      }\n    } else {\n      count += 1;\n    }\n  }\n  return mode;\n}\n\n/**\n * Given a list of numbers, find the largest number.\n * @param numbers\n * @returns {number}\n */\nconst variance = (numbers) => {\n  let mean = mean(numbers);\n  let sum = 0;\n  for(let i = 0; i < numbers.length; i++){\n    sum += Math.pow(numbers[i] - mean, 2);\n  }\n  return sum / numbers.length;\n}\n\n/**\n * Given a list of numbers, find the smallest number.\n * @param numbers\n * @returns {number}\n */\nconst stdev = (numbers) => {\n  return Math.sqrt(variance(numbers));\n}\n\n/**\n * Given a list of numbers, find the smallest number.\n * @param numbers\n * @returns {number}\n */\nconst mean2 = (numbers) => {\n  let sum = 0;\n  for(let i = 0; i < numbers.length; i++){\n    sum += numbers[i];\n  }\n  return sum / numbers.length;\n}\n\n/**\n * Given a list of numbers, find the smallest number.\n * @param numbers\n * @returns {number}\n */\nconst median2 = (numbers) => {\n  let nums = shuffle(numbers);\n  let half = Math.floor(numbers.length / 2);\n  let median = nums[half];\n  let median2 = nums[numbers."}
{"task_id": "JavaScript/22", "prompt": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number' &&!isNaN(value);\n  });\n};\n\n/*\n  Given list of values, returns all that can be casted to a string\n  >>> filterStrings(['a', 3.14, 5, 'abc', {}, []])\n  ['a', 3.14, 5]\n  */\nconst filterStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string';\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a boolean\n  >>> filterBooleans(['a', 3.14, 5, 'abc', {}, []])\n  [5, 'abc', {}]\n  */\nconst filterBooleans = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'boolean';\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a number\n  >>> filterNumbers(['a', 3.14, 5, 'abc', {}, []])\n  [3.14, 5]\n  */\nconst filterNumbers = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number';\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a object\n  >>> filterObjects(['a', 3.14, 5, 'abc', {}, []])\n  [{}, []]\n  */\nconst filterObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object';\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a list\n  >>> filterLists(['a', 3.14, 5, 'abc', {}, []])\n  [5, []]\n  */\nconst filterLists = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' && value!== null && Array.isArray(value);\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a dict\n  >>> filterDicts(['a', 3.14, 5, 'abc', {}, []])\n  [{}, []]\n  */\nconst filterDicts = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' && value!== null &&!Array.isArray(value);\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a set\n  >>> filterSets(['a', 3.14, 5, 'abc', {}, []])\n  [{}, []]\n  */\nconst filterSets = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' && value!== null &&!Array.isArray(value);\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a tuple\n  >>> filterTuples(['a', 3.14, 5, 'abc', {}, []])\n  [5, 'abc', {}]\n  */\nconst filterTuples = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' && value!== null &&!Array.isArray(value);\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a function\n  >>> filterFunctions(['a', 3.14, 5, 'abc', {}, []])\n  [5, 'abc', {}]\n  */\nconst filterFunctions = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'function';\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a date\n  >>> filterDates(['a', 3.14, 5, 'abc', {}, []])\n  [3.14, 5]\n  */\nconst filterDates = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' && value!== null && typeof value.getTime === 'function';\n  });\n};\n\n/*\n  Given a list of values, returns all that can be casted to a datetime\n  >>> filterDatetimes(['a', 3.14, 5, 'abc', {}, []])\n  [5, 'abc', {}]\n  */\nconst filterDatetimes = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' && value!== null && typeof value.getTime === 'function' &&!isNaN(value.getTime());\n  });\n};\n\nexport default {\n  filterIntegers,\n  filterStrings,\n  filterBooleans,\n  filterNumbers,\n  filterObjects,\n  filterLists,\n  filterDicts,\n  filterSets,\n  filterTuples,\n  filterFunctions,\n  filterDates,\n  filterDatetimes,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/23", "prompt": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) >= 0xD800 && string.charCodeAt(i) <= 0xDFFF) {\n      i++;\n    }\n    len++;\n  }\n  return len;\n};\n\n/*\n  Returns the number of Unicode characters in the given string.\n  >>> strlen('\\uD800\\uDC00\\uD800\\uDC01\\uD801')\n  4\n  */\nconst strlen_unicode = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    len++;\n  }\n  return len;\n};\n\n/*\n  Returns the length of the longest substring in the given string.\n  >>> strlen('abba')\n  4\n  >>> strlen('abccba')\n  4\n  >>> strlen('abcd')\n  1\n  >>> strlen('abcda')\n  2\n  >>> strlen('ab')\n  2\n  >>> strlen('a')\n  1\n  >>> strlen('a')\n  1\n  */\nconst strlen_longest = (string) => {\n  let len = 0;\n  let max = 0;\n  for (let i = 0; i < string.length; i++) {\n    let l = strlen(string.slice(i));\n    if (l > max) {\n      max = l;\n    }\n  }\n  return max;\n};\n\n/*\n  Returns the number of characters in the given string.\n  >>> strlen('abc')\n  3\n  >>> strlen('\\uD800\\uDC00\\uD800\\uDC01\\uD801')\n  4\n  */\nconst strlen_char = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    len++;\n  }\n  return len;\n};\n\n/*\n  Returns a string with all characters in the given string replaced by\n  the corresponding character in the given replacement string.\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  '123bc123'\n  >>> str_replace('abc', '123', '123')\n  "}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n    let result = 1;\n    let lastDivisor = 1;\n    while (result < n) {\n        result = (result * 2) % n;\n        lastDivisor = (lastDivisor * 2) % n;\n        if (result === n) return lastDivisor;\n    }\n};\n\n/*\n  Find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(17)\n  13\n  >>> largestDivisor(23)\n  19\n  */\nconst largestDivisor = (n) => {\n    let result = 1;\n    let lastDivisor = 1;\n    while (result < n) {\n        result = (result * 2) % n;\n        lastDivisor = (lastDivisor * 2) % n;\n    }\n    return lastDivisor;\n};\n\n/*\n  Find the smallest number thqt divmdes n evenly, greater than n\n  >>> largestDivisor(10)\n  2\n  >>> largestDivisor(15)\n  3\n  >>> largestDivisor(20)\n  5\n  */\nconst largestDivisor = (n) => {\n    let result = 1;\n    let lastDivisor = 1;\n    while (result < n) {\n        result = (result * 2) % n;\n        lastDivisor = (lastDivisor * 2) % n;\n        if (result === n) return lastDivisor;\n    }\n    return lastDivisor;\n};\n\n/*\n  Find the smallest number thqt divmdes n evenly, greater than n\n  >>> largestDivisor(17)\n  2\n  >>> largestDivisor(23)\n  3\n  >>> largestDivisor(25)\n  5\n  */\nconst largestDivisor = (n) => {\n    let result = 1;\n    let lastDivisor = 1;\n    while (result < n) {\n        result = (result * 2) % n;\n        lastDivisor = (lastDivisor * 2) % n;\n    }\n    return lastDivisor;\n};\n\n/*\n  Find the smallest number thqt divmdes n evenly, greater than n\n  >>> largestDivisor(13)\n  2\n  >>> largestDivisor(19)\n  3\n  >>> largestDivisor(20)\n  5\n  */\nconst largestDivisor = (n) => {\n    let result = 1;\n    let lastDivisor = 1;\n    while (result < n) {\n        result = (result * 2) % n;\n        lastDivisor = (lastDivisor * 2) % n;\n        if (result === n) return lastDivisor;\n    }\n    return lastDivisor;\n};\n\nmodule.exports = {\n    largestDivisor,\n    largestDivisor\n};\n<|endoftext|>"}
{"task_id": "JavaScript/25", "prompt": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  if (n <= 0) return []\n  let factors = []\n  let factor = 2\n  while (n > 1) {\n    if (n % factor === 0) {\n      factors.push(factor)\n      n = n / factor\n    } else {\n      factor++\n    }\n  }\n  return factors\n}\n\nmodule.exports = factorize\n<|endoftext|>"}
{"task_id": "JavaScript/26", "prompt": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let previous = null;\n  let isDuplicate = false;\n  for (let i = 0; i < numbers.length; i++) {\n    if (previous == null || numbers[i]!= previous) {\n      result.push(numbers[i]);\n      previous = numbers[i];\n      isDuplicate = false;\n    } else {\n      isDuplicate = true;\n    }\n  }\n  return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  const regex = new RegExp('[a-z]+', 'g');\n  const flippedString = string.toLowerCase().replace(regex, function(match) {\n    return match.toUpperCase();\n  });\n  return flippedString;\n};\n\n// For a given string, split it by whitespace and convert all characters to uppercase.\n// >>> splitAndUpper('Hello World!')\n// ['HELLO', 'WORLD!']\nconst splitAndUpper = (string) => {\n  const regex = /\\s+/g;\n  const upperCaseString = string.toUpperCase();\n  const splitString = string.split(regex);\n  return splitString.map(function(x) {\n    return x.toUpperCase();\n  });\n};\n\n// Converts a given string to uppercase and adds the word \"The\" to the beginning of the string.\n// >>> addThe = 'world'\n// 'THE WORLD!'\nconst addThe = (string) => {\n  return 'The'+ string.toUpperCase();\n};\n\n// Converts a given string to uppercase and adds the word \"The\" to the end of the string.\n// >>> addTheEnd = 'hello'\n// 'THE HELLO!'\nconst addTheEnd = (string) => {\n  return string.toUpperCase() +'THE!';\n};\n\n// Converts a given string to uppercase and adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the end of the string.\n// >>> addTheEnd = 'hello'\n// 'THE HELLO!'\nconst addTheEnd = (string) => {\n  return string.toUpperCase() +'THE!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// Converts a given string to uppercase and adds the word \"The\" to the beginning of the string.\n// >>> addTheEnd = 'hello'\n// 'THE HELLO!'\nconst addTheEnd = (string) => {\n  return string.toUpperCase() +'THE!';\n};\n\n// For a given string, adds the word \"The\" to the beginning of the string.\n// >>> addTheEnd = 'hello'\n// 'THE HELLO!'\nconst addTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the beginning of the string.\n// >>> addTheEnd = 'hello'\n// 'THE HELLO!'\nconst addTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the end of the string.\n// >>> addTheEnd = 'hello'\n// 'THE HELLO!'\nconst addTheEnd = (string) => {\n  return string.toUpperCase() +'THE!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n};\n\n// For a given string, adds the word \"The\" to the end of the string.\n// >>> addTheEnd = 'hello'\n// 'THE HELLO!'\nconst addTheEnd = (string) => {\n  return string.toUpperCase() +'THE!';\n};\n\n// For a given string, adds the word \"The\" to the beginning and end of the string.\n// >>> addTheAndTheEnd = 'world'\n// 'THE THE WORLD!'\nconst addTheAndTheEnd = (string) => {\n  return 'THE'+ string.toUpperCase() + '!';\n"}
{"task_id": "JavaScript/28", "prompt": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  if (strings.length === 0) return ''\n  let last = strings[0]\n  for (let i = 1; i < strings.length; i++) {\n    last += strings[i]\n  }\n  return last\n}\n\n// Return a random string with length n\nconst randomString = (n) => {\n  let string = ''\n  let i\n  for (i = 0; i < n; i++) {\n    string += Math.floor(Math.random() * 26 + 97)\n  }\n  return string\n}\n\n// Return a string of n lowercase characters\nconst lowercaseString = (n) => {\n  let string = ''\n  for (let i = 0; i < n; i++) {\n    string += Math.floor(Math.random() * 26 + 97)\n  }\n  return string\n}\n\n// Generate a unique id for each object\nconst id = (o) => {\n  const id = o.id = o.id || uniqueId()\n  return id\n}\n\n// Generate a unique id for each object\nconst uniqueId = () => {\n  let id = 0\n  return () => id++\n}\n\n// Generate a random number between min and max\nconst randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min\n\n// Generate a random number between 0 and 1\nconst random = () => Math.random()\n\n// Returns a random string of n characters, excluding any\n// lowercase letters\nconst randomAlphaString = (n) => {\n  let string = ''\n  for (let i = 0; i < n; i++) {\n    string += Math.floor(Math.random() * 26 + 97)\n  }\n  return string\n}\n\n// Return a random element of the list\nconst randomElement = (list) => list[Math.floor(Math.random() * list.length)]\n\n// Returns a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Return a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Returns a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Returns a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Returns a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Returns a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Returns a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Return a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Returns a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Return a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Return a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Return a random element from the list with a specific weight\nconst weightedRandomElement = (list, weight) => {\n  let total = 0\n  for (let i = 0; i < list.length; i++) {\n    total += list[i] * weight\n  }\n  return list[Math.floor(Math.random() * list.length)]\n}\n\n// Return a random element from the list with a specific weight\nconst weightedRandomElement = (list,"}
{"task_id": "JavaScript/29", "prompt": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  const ret = []\n  let i = 0\n  while (i < strings.length) {\n    if (strings[i].startsWith(prefix)) {\n      ret.push(strings[i])\n    }\n    i++\n  }\n  return ret\n}\n\n/**\n  *  Given a sorted list, create a list of the elements of the original list\n  *  which appear at least twice.\n  *  >>> sorted([1, 2, 3, 4, 5, 6, 7, 8])\n  *  [1, 2, 3, 4, 5, 6, 7, 8]\n  *  >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  *  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  */\nconst sortedInts = (ints) => {\n  const ret = []\n  let i = 0\n  while (i < ints.length) {\n    let count = 1\n    while (i + count < ints.length && ints[i + count] == ints[i]) {\n      count++\n    }\n    if (count > 1) {\n      ret.push(ints[i])\n    }\n    i += count\n  }\n  return ret\n}\n\n/**\n  * Given an array of strings, return the list of strings which start with\n  * 'b' and are preceded by a 'z' in the same order.\n  *\n  * >>> sorted([ 'a', 'b', 'z', 'c', 'd', 'e' ])\n  * [ 'b', 'd', 'e' ]\n  */\nconst sortedByPrefix = (strings) => {\n  const ret = []\n  let i = 0\n  while (i < strings.length) {\n    if (strings[i].startsWith('b')) {\n      let j = i + 1\n      while (j < strings.length) {\n        if (strings[j].startsWith('z')) {\n          ret.push(strings[i])\n          break\n        }\n        j++\n      }\n    }\n    i++\n  }\n  return ret\n}\n\n/**\n  * Given an array of strings, return the list of strings which start with\n  * 'b' and are followed by a 'z' in the same order.\n  *\n  * >>> sorted([ 'a', 'b', 'z', 'c', 'd', 'e' ])\n  * [ 'e', 'c', 'd', 'b', 'a' ]\n  */\nconst sortedBySuffix = (strings) => {\n  const ret = []\n  let i = 0\n  while (i < strings.length) {\n    if (strings[i].startsWith('b')) {\n      let j = i + 1\n      while (j < strings.length) {\n        if (strings[j].startsWith('z')) {\n          ret.push(strings[i])\n          break\n        }\n        j++\n      }\n    }\n    i++\n  }\n  return ret\n}\n\nmodule.exports = {\n  sortedByPrefix,\n  sortedInts,\n  filterByPrefix,\n  sortedBySuffix\n}\n<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const result = [];\n  const isPositive = (n) => n > 0;\n  const next = (n) => n < 0? (Math.abs(n) + 1) : n;\n  for (let i = 0; i < l.length; i++) {\n    if (isPositive(l[i])) {\n      result.push(next(l[i]));\n    }\n  }\n  return result;\n};\n\nconsole.log(getPositive([-1, 2, -4, 5, 6]));\nconsole.log(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]));\n<|endoftext|>"}
{"task_id": "JavaScript/31", "prompt": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 2) return true\n  if (n === 1) return false\n  const i = 2\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 1\n  }\n  return true\n}\n\nexport default isPrime\n<|endoftext|>"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n\n  if (xs.length === 1) {\n    return xs[0] === 0? xs[0] : undefined;\n  }\n\n  let xsLength = xs.length;\n  let length = xsLength;\n  let n = xsLength - 1;\n  let x = xs[n];\n\n  let yt = 0;\n  let b = 1;\n\n  while (x === 0) {\n    length = xsLength - 1;\n    n = xsLength - 1;\n    x = xs[n];\n    yt = b;\n    b = b + 1;\n  }\n\n  let x0 = xs[length];\n  let x1 = xs[length - 1];\n  let x2 = xs[length - 2];\n\n  while (x1 === 0) {\n    length = xsLength - 1;\n    n = xsLength - 1;\n    x1 = xs[n];\n    yt = yt + x2;\n    x2 = xs[length - 1];\n  }\n\n  let t = yt + x1;\n  let y = t * t - x0 * x2;\n  y = y / t;\n\n  let x3 = y * y - x1;\n  x3 = x3 / x2;\n\n  let x4 = x3 * x3 - x1;\n  x4 = x4 / x0;\n\n  let x5 = x4 * x4 - x2;\n  x5 = x5 / x1;\n\n  let x6 = x5 * x5 - x0;\n  x6 = x6 / x3;\n\n  let x7 = x6 * x6 - x1;\n  x7 = x7 / x2;\n\n  let x8 = x7 * x7 - x3;\n  x8 = x8 / x4;\n\n  let x9 = x8 * x8 - x5;\n  x9 = x9 / x6;\n\n  let x10 = x9 * x9 - x7;\n  x10 = x10 / x8;\n\n  let x11 = x10 * x10 - x6;\n  x11 = x11 / x5;\n\n  let x12 = x11 * x11 - x4;\n  x12 = x12 / x3;\n\n  let x13 = x12 * x12 - x2;\n  x13 = x13 / x1;\n\n  let x14 = x13 * x13 - x0;\n  x14 = x14 / x3;\n\n  let x15 = x14 * x14 - x1;\n  x15 = x15 / x5;\n\n  let x16 = x15 * x15 - x3;\n  x16 = x16 / x7;\n\n  let x17 = x16 * x16 - x4;\n  x17 = x17 / x8;\n\n  let x18 = x17 * x17 - x5;\n  x18 = x18 / x9;\n\n  let x19 = x18 * x18 - x6;\n  x19 = x19 / x10;\n\n  let x20 = x19 * x19 - x7;\n  x20 = x20 / x11;\n\n  let x21 = x20 * x20 - x8;\n  x21 = x21 / x12;\n\n  let x22 = x21 * x21 - x9;\n  x22 = x22 / x13;\n\n  let x23 = x22 * x22 - x10;\n  x23 = x23 / x14;\n\n  let x24 = x23 * x23 - x11;\n  x24 = x24 / x15;\n\n  let x25 = x24 * x24 - x12;\n  x25 = x25 / x16;\n\n  let x26 = x25 * x25 - x13;\n  x26 = x26 / x17;\n\n  let x27 = x26 * x26 - x14;\n  x27 = x27 / x18;\n\n  let x28 = x27 * x27 - x15;\n  x28 = x28 / x19;\n\n  let x29 = x28 * x28 - x16;\n  x29 = x29 / x20;\n\n  let x30 = x29 * x29 - x17;\n  x30 = x30 / x21;\n\n  let x31 = x30 * x30 - x18;\n  x31 = x31 / x22;\n\n  let x32 = x31 * x31 - x19;\n  x32 = x32 / x23;\n\n  let x33 = x32 * x32 - x20;\n  x33 = x33 / x24;\n\n  let x34 = x33 * x33 - x21;\n  x34 = x34 / x25;\n\n  let x35 = x34 * x34 - x22;\n  x35 = x35 / x26;\n\n  let x36 = x35 * x35 - x23;\n  x36 = x36 / x27;\n\n  let x37 = x36 * x36 - x24;\n  x37 = x37 / x28;\n\n  let x38 = x37 * x37 - x25;\n  x38 = x38 / x"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const x = l.reduce((a, b) => a + b, 0)\n  let sorted = []\n  l.forEach((el, index) => {\n    const num = parseInt(el, 10)\n    const mod = x % 3\n    const mod2 = x % 2\n    if (mod === 0 && mod2 === 1) {\n      sorted.push(el)\n    }\n  })\n  return sorted\n}\n\n/**\n  Given an array, return the number of non-repeating elements\n  >>> countNonRepeating([1, 2, 1])\n  1\n  >>> countNonRepeating([1, 2, 3, 1])\n  2\n  >>> countNonRepeating([1, 2, 3, 4, 3, 1])\n  3\n  >>> countNonRepeating([1, 1, 1])\n  1\n  */\nconst countNonRepeating = (l) => {\n  const x = l.reduce((a, b) => a + b, 0)\n  let count = 0\n  l.forEach((el) => {\n    const num = parseInt(el, 10)\n    if (x % num!== 0) {\n      count += 1\n    }\n  })\n  return count\n}\n\n/**\n  Given a string, return the number of characters that are vowels\n  >>> countVowels('aAiIuU')\n  1\n  >>> countVowels('Hello')\n  5\n  >>> countVowels('hello')\n  5\n  >>> countVowels('hello')\n  5\n  >>> countVowels('1a')\n  1\n  >>> countVowels('ae')\n  2\n  */\nconst countVowels = (s) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  const count = 0\n  s.forEach((el, index) => {\n    if (vowels.indexOf(el)!== -1) {\n      count += 1\n    }\n  })\n  return count\n}\n\nmodule.exports = {\n  sortThird,\n  countNonRepeating,\n  countVowels\n}\n<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n    const len = l.length;\n    let uniq = [];\n    let prev = null;\n    for(let i = 0; i < len; i++) {\n        if(prev === null || l[i]!== l[prev]) {\n            uniq.push(l[i]);\n            prev = i;\n        }\n    }\n    return uniq;\n};\n\n/**\n  * @param {Array} arr\n  * @return {Array}\n  * Generate a sorted array by iterating through every element in the array and checking if it is in the sorted array,\n  * If it is not, add it to the sorted array.\n  * Note: the sorted array is a copy of the original array\n  * Example:\n  * sorted([1, 2, 3, 4, 5])\n  * => [1, 2, 3, 4, 5]\n  * sorted([1, 2, 3, 4, 5, 6])\n  * => [1, 2, 3, 4, 5, 6]\n  * sorted([1, 2, 3, 4, 5, 6, 7])\n  * => [1, 2, 3, 4, 5, 6, 7]\n  * sorted([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  * => [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  * sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  * => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n  */\nconst sorted = (arr) => {\n    let result = arr.slice(0);\n    let sorted = unique(arr);\n    let i = 0;\n    while(i < sorted.length) {\n        let j = 0;\n        while(j < result.length) {\n            if(sorted[i] < result[j]) {\n                result.splice(j, 0, sorted[i]);\n                break;\n            }\n            j++;\n        }\n        i++;\n    }\n    return result;\n};\n\nexport {unique, sorted};\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.reduce((prev, next) => {\n    return prev >= next? prev : next;\n  }, -Infinity);\n};\n\nmodule.exports = maxElement;\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  const divisors = [11, 13]\n\n  const nums = divisors.map((div) => n / div)\n  const multiples = divisors.map((div) => n % div)\n\n  const found7s = nums.filter((num) => num === 7)\n  const found13s = multiples.filter((num) => num === 13)\n\n  const result = found7s.length + found13s.length\n\n  return result\n}\n\nmodule.exports = fizzBuzz\n<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const length = l.length\n  const odd = [...l,...l]\n  const even = odd.slice(1, length - 1)\n  const sorted = even.sort((a, b) => a - b)\n  return odd.concat(sorted)\n}\n\nmodule.exports = sortEven\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] =='') {\n      if (groups.length > 0) {\n        groups2.push(groups.join(''));\n        groups.length = 0;\n      }\n    } else {\n      groups.push(s[i]);\n    }\n  }\n  if (groups.length > 0)\n    groups2.push(groups.join(''));\n  return groups2.join('');\n}\n\n/*\n  encodes string with cyclic group of two.\n  */\nconst encodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 2); i++) {\n    groups.push(s.slice(2 * i, Math.min((2 * i + 2), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 2)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  decodes string with cyclic group of two.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] =='') {\n      if (groups.length > 0) {\n        groups2.push(groups.join(''));\n        groups.length = 0;\n      }\n    } else {\n      groups.push(s[i]);\n    }\n  }\n  if (groups.length > 0)\n    groups2.push(groups.join(''));\n  return groups2.join('');\n}\n\n/*\n  decodes string with cyclic group of three.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  decodes string with cyclic group of three.\n  */\nconst encodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] =='') {\n      if (groups.length > 0) {\n        groups2.push(groups.join(''));\n        groups.length = 0;\n      }\n    } else {\n      groups.push(s[i]);\n    }\n  }\n  if (groups.length > 0)\n    groups2.push(groups.join(''));\n  return groups2.join('');\n}\n\n/*\n  decodes string with cyclic group of four.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 4); i++) {\n    groups.push(s.slice(4 * i, Math.min((4 * i + 4), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 4)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  decodes string with cyclic group of four.\n  */\nconst encodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] =='') {\n      if (groups.length > 0) {\n        groups2.push(groups.join(''));\n        groups.length = 0;\n      }\n    } else {\n      groups.push(s[i]);\n    }\n  }\n  if (groups.length > 0)\n    groups2.push(groups.join(''));\n  return groups2.join('');\n}\n\n/*\n  encodes string with cyclic group of four.\n  */\nconst encodeCyclic4Cyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 4); i++) {\n    groups.push(s.slice(4 * i, Math.min((4 * i + 4), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 4)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n<|endoftext|>"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n    let fib = 2,\n        isPrime = true,\n        isFib = false,\n        result = fib;\n    while (n > 1) {\n        isFib = isPrime;\n        fib += isFib? 1 : fib;\n        isPrime = isPrime && isFib;\n        n--;\n    }\n    return fib;\n}\n\n/*\n  factorial returns n-th factorial number.\n  >>> factorial(1)\n  1\n  >>> factorial(2)\n  2\n  >>> factorial(3)\n  6\n  >>> factorial(4)\n  24\n  >>> factorial(5)\n  120\n  */\nconst factorial = (n) => {\n    let fib = 1,\n        result = fib;\n    while (n > 1) {\n        fib = fib * (n - 1);\n        n--;\n    }\n    return result;\n}\n\n/*\n  isPrime returns true if n is prime, false otherwise.\n  >>> isPrime(2)\n  false\n  >>> isPrime(3)\n  true\n  >>> isPrime(4)\n  true\n  >>> isPrime(5)\n  false\n  >>> isPrime(6)\n  false\n  >>> isPrime(7)\n  true\n  >>> isPrime(8)\n  false\n  >>> isPrime(9)\n  false\n  >>> isPrime(10)\n  true\n  */\nconst isPrime = (n) => {\n    if (n === 2) {\n        return true;\n    }\n    if (n === 1 || n === 3) {\n        return false;\n    }\n    let max = (Math.sqrt(n) + 1),\n        num = 5,\n        i = 2;\n    while (num <= max) {\n        if (n % num === 0) {\n            return false;\n        }\n        num += 2;\n    }\n    return true;\n}\n\nmodule.exports = {\n    primeFib,\n    factorial,\n    isPrime\n};\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    let sums = [];\n    for (let i = 0; i < l.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < l.length; j++) {\n            if (i!== j) {\n                sum += l[j];\n            }\n        }\n        sums.push(sum);\n    }\n    for (let i = 0; i < sums.length; i++) {\n        let sum = sums[i];\n        if (sum === 0) {\n            return false;\n        }\n        for (let j = i + 1; j < sums.length; j++) {\n            let sum2 = sums[j];\n            if (sum === sum2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/*\n  fibonacci n\n  fibonacci returns the nth fibonacci number.\n\n  >>> fibonacci(0)\n  0\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(2)\n  1\n  >>> fibonacci(3)\n  2\n  >>> fibonacci(4)\n  3\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  13\n  >>> fibonacci(8)\n  21\n  >>> fibonacci(9)\n  34\n  >>> fibonacci(10)\n  55\n  */\nconst fibonacci = (n) => {\n    if (n === 0) {\n        return 0;\n    }\n    if (n === 1) {\n        return 1;\n    }\n    let a = 1;\n    let b = 1;\n    let f = 0;\n    while (f < n) {\n        f += a + b;\n        a = b;\n        b = f;\n    }\n    return f;\n}\n\n/*\n  sumNth fibonacci n\n  sumNth returns the sum of the nth fibonacci number.\n\n  >>> sumNth(0)\n  0\n  >>> sumNth(1)\n  1\n  >>> sumNth(2)\n  2\n  >>> sumNth(3)\n  5\n  >>> sumNth(4)\n  11\n  >>> sumNth(5)\n  18\n  >>> sumNth(6)\n  27\n  >>> sumNth(7)\n  36\n  >>> sumNth(8)\n  45\n  >>> sumNth(9)\n  55\n  >>> sumNth(10)\n  66\n  */\nconst sumNth = (n) => {\n    let f = fibonacci(n);\n    return f;\n}\n\n/*\n  sumNth fibonacci n\n  sumNth returns the sum of the nth fibonacci number.\n\n  >>> sumNth(0)\n  0\n  >>> sumNth(1)\n  1\n  >>> sumNth(2)\n  2\n  >>> sumNth(3)\n  5\n  >>> sumNth(4)\n  11\n  >>> sumNth(5)\n  18\n  >>> sumNth(6)\n  27\n  >>> sumNth(7)\n  36\n  >>> sumNth(8)\n  45\n  >>> sumNth(9)\n  55\n  >>> sumNth(10)\n  66\n  */\nconst sumNth = (n) => {\n    let f = fibonacci(n);\n    return f;\n}\n\n/*\n  fibonacci sumToZero\n  fibonacci sumToZero returns true if the sum of fibonacci numbers to\n  zero, false otherwise.\n\n  >>> fibonacciSumToZero(0)\n  true\n  >>> fibonacciSumToZero(1)\n  false\n  >>> fibonacciSumToZero(2)\n  false\n  >>> fibonacciSumToZero(3)\n  true\n  >>> fibonacciSumToZero(4)\n  false\n  >>> fibonacciSumToZero(5)\n  true\n  >>> fibonacciSumToZero(6)\n  true\n  >>> fibonacciSumToZero(7)\n  false\n  >>> fibonacciSumToZero(8)\n  true\n  >>> fibonacciSumToZero(9)\n  true\n  >>> fibonacciSumToZero(10)\n  true\n  */\nconst fibonacciSumToZero = (n) => {\n    let f = fibonacci(n);\n    let sums = [];\n    for (let i = 0; i < f; i++) {\n        let sum = sumNth(i);\n        sums.push(sum);\n    }\n    for (let i = 0; i < sums.length; i++) {\n        let sum = sums[i];\n        if (sum === 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/*\n  fibonacci sumToZero\n  fibonacci sumToZero returns true if the sum of fibonacci numbers to\n  zero, false otherwise.\n\n  >>> fibonacciSumToZero(0)\n  true\n  >>> fibonacciSumToZero(1)\n  false\n  >>> fibonacciSumToZero(2)\n  false\n  >>> fibonacciSumToZero(3)\n  true\n  >>> fibonacciSumToZero(4)\n  false\n  >>> fibonacciSumToZero(5)\n  true\n  >>> fibonacciSumToZero(6)\n  true\n  >>> fibonacciSumToZero(7)\n  false\n  >>> fibonacciSumToZero(8)\n  true\n  >>> fibonacciSumToZero(9)\n  true\n  >>> fibonacciSumToZero(10)"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n    var car1 = {\n        position: {\n            x: 0,\n            y: 0\n        },\n        speed: {\n            x: 0,\n            y: 0\n        },\n        traj: {\n            x: 0,\n            y: 0\n        }\n    };\n    var car2 = {\n        position: {\n            x: 0,\n            y: 0\n        },\n        speed: {\n            x: 0,\n            y: 0\n        },\n        traj: {\n            x: 0,\n            y: 0\n        }\n    };\n    var coll = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var car1X = 0;\n    var car1Y = 0;\n    var car2X = 0;\n    var car2Y = 0;\n    var car1Xr = 0;\n    var car1Yr = 0;\n    var car2Xr = 0;\n    var car2Yr = 0;\n    var car1TrajX = 0;\n    var car1TrajY = 0;\n    var car2TrajX = 0;\n    var car2TrajY = 0;\n    var car1Speed = 0;\n    var car2Speed = 0;\n    while (i < n) {\n        car1X = Math.floor(Math.random() * 100) + 1;\n        car1Y = Math.floor(Math.random() * 100) + 1;\n        car1TrajX = car1X;\n        car1TrajY = car1Y;\n        car2X = Math.floor(Math.random() * 100) + 1;\n        car2Y = Math.floor(Math.random() * 100) + 1;\n        car2TrajX = car2X;\n        car2TrajY = car2Y;\n        car1Speed = Math.floor(Math.random() * 10) + 1;\n        car2Speed = Math.floor(Math.random() * 10) + 1;\n        while (k < n) {\n            car1Xr = Math.floor(Math.random() * 100) + 1;\n            car1Yr = Math.floor(Math.random() * 100) + 1;\n            car2Xr = Math.floor(Math.random() * 100) + 1;\n            car2Yr = Math.floor(Math.random() * 100) + 1;\n            car1X = car1X + car1Xr;\n            car1Y = car1Y + car1Yr;\n            car2X = car2X + car2Xr;\n            car2Y = car2Y + car2Yr;\n            car1TrajX = car1TrajX + car1Xr;\n            car1TrajY = car1TrajY + car1Yr;\n            car2TrajX = car2TrajX + car2Xr;\n            car2TrajY = car2TrajY + car2Yr;\n            car1Speed = Math.floor(Math.random() * 10) + 1;\n            car2Speed = Math.floor(Math.random() * 10) + 1;\n            if ((car1X == car2X) && (car1Y == car2Y)) {\n                coll = coll + 1;\n            }\n            if ((car1X == car2X) && (car1Y == car2Y) && (car1TrajX == car2TrajX) && (car1TrajY == car2TrajY)) {\n                coll = coll + 1;\n            }\n            if ((car1X == car2X) && (car1Y == car2Y) && (car1TrajX == car2TrajX) && (car1TrajY == car2TrajY) && ((car1Speed + car2Speed) > 1)) {\n                coll = coll + 1;\n            }\n            if ((car1X == car2X) && (car1Y == car2Y) && (car1TrajX == car2TrajX) && (car1TrajY == car2TrajY) && ((car1Speed - car2Speed) > 1)) {\n                coll = coll + 1;\n            }\n            k = k + 1;\n        }\n        i = i + 1;\n    }\n    return coll;\n}<|endoftext|>"}
{"task_id": "JavaScript/42", "prompt": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result[i] = l[i] + 1\n  }\n  return result\n}\n\n/*\n  Returnt a list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 4, 3, 2, 3, 3, 8, 1, 122]\n  */\nconst decrList = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result[i] = l[i] - 1\n  }\n  return result\n}\n\n/*\n  Removes the first element of the list.\n  >>> remove(1, [1, 2, 3])\n  [2, 3]\n  >>> remove(1, [5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  >>> remove(3, [5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  >>> remove(9, [5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst remove = (idx, l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (i!== idx) {\n      result[i] = l[i]\n    }\n  }\n  return result\n}\n\n/*\n  Returns a list with elements incremented by 1.\n  >>> incr(1, [1, 2, 3])\n  [2, 3, 4]\n  >>> incr(1, [5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incr = (idx, l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (i!== idx) {\n      result[i] = l[i]\n    }\n  }\n  result[idx] = l[idx] + 1\n  return result\n}\n\n/*\n  Returns a list with elements decremented by 1.\n  >>> decr(1, [1, 2, 3])\n  [1, 2, 3]\n  >>> decr(1, [5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 4, 3, 2, 3, 3, 8, 1, 122]\n  */\nconst decr = (idx, l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (i!== idx) {\n      result[i] = l[i]\n    }\n  }\n  result[idx] = l[idx] - 1\n  return result\n}\n\nmodule.exports = {\n  incrList,\n  decrList,\n  remove,\n  incr,\n  decr\n}\n<|endoftext|>"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const lLen = l.length\n  if (lLen === 0) {\n    return false\n  }\n  if (l[0] === 0) {\n    return false\n  }\n  if (l[lLen - 1] === 0) {\n    return false\n  }\n  let p = 0\n  let sum = 0\n  const check = (e) => {\n    if (sum === 0) {\n      return false\n    }\n    if (sum === e) {\n      return true\n    }\n    sum = sum - e\n    p++\n    return check(sum)\n  }\n  for (let i = 0; i < lLen - 1; i++) {\n    sum = sum + l[i]\n    if (check(l[i])) {\n      return true\n    }\n  }\n  return false\n}\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n    if (x == 0) return '0'\n    if (x < 0) {\n        x = -x\n        base = -base\n    }\n    if (base < 2 || base > 36) return 'ERROR'\n    let d = x\n    let s = ''\n    while d >= base:\n        d = d / base\n        s = `${s}${x - d * base}`\n    return s\n}\n\nconsole.log(changeBase(12, 2))\nconsole.log(changeBase(12, 3))\nconsole.log(changeBase(12, 4))\nconsole.log(changeBase(12, 5))\nconsole.log(changeBase(12, 6))\nconsole.log(changeBase(12, 7))\nconsole.log(changeBase(12, 8))\nconsole.log(changeBase(12, 9))\nconsole.log(changeBase(12, 10))\nconsole.log(changeBase(12, 11))\nconsole.log(changeBase(12, 12))\nconsole.log(changeBase(12, 13))\nconsole.log(changeBase(12, 14))\nconsole.log(changeBase(12, 15))\nconsole.log(changeBase(12, 16))\nconsole.log(changeBase(12, 17))\nconsole.log(changeBase(12, 18))\nconsole.log(changeBase(12, 19))\nconsole.log(changeBase(12, 20))\nconsole.log(changeBase(12, 21))\nconsole.log(changeBase(12, 22))\nconsole.log(changeBase(12, 23))\nconsole.log(changeBase(12, 24))\nconsole.log(changeBase(12, 25))\nconsole.log(changeBase(12, 26))\nconsole.log(changeBase(12, 27))\nconsole.log(changeBase(12, 28))\nconsole.log(changeBase(12, 29))\nconsole.log(changeBase(12, 30))\nconsole.log(changeBase(12, 31))\nconsole.log(changeBase(12, 32))\nconsole.log(changeBase(12, 33))\nconsole.log(changeBase(12, 34))\nconsole.log(changeBase(12, 35))\nconsole.log(changeBase(12, 36))\nconsole.log(changeBase(12, 37))\nconsole.log(changeBase(12, 38))\nconsole.log(changeBase(12, 39))\nconsole.log(changeBase(12, 40))\nconsole.log(changeBase(12, 41))\nconsole.log(changeBase(12, 42))\nconsole.log(changeBase(12, 43))\nconsole.log(changeBase(12, 44))\nconsole.log(changeBase(12, 45))\nconsole.log(changeBase(12, 46))\nconsole.log(changeBase(12, 47))\nconsole.log(changeBase(12, 48))\nconsole.log(changeBase(12, 49))\nconsole.log(changeBase(12, 50))\nconsole.log(changeBase(12, 51))\nconsole.log(changeBase(12, 52))\nconsole.log(changeBase(12, 53))\nconsole.log(changeBase(12, 54))\nconsole.log(changeBase(12, 55))\nconsole.log(changeBase(12, 56))\nconsole.log(changeBase(12, 57))\nconsole.log(changeBase(12, 58))\nconsole.log(changeBase(12, 59))\nconsole.log(changeBase(12, 60))\nconsole.log(changeBase(12, 61))\nconsole.log(changeBase(12, 62))\nconsole.log(changeBase(12, 63))\nconsole.log(changeBase(12, 64))\nconsole.log(changeBase(12, 65))\nconsole.log(changeBase(12, 66))\nconsole.log(changeBase(12, 67))\nconsole.log(changeBase(12, 68))\nconsole.log(changeBase(12, 69))\nconsole.log(changeBase(12, 70))\nconsole.log(changeBase(12, 71))\nconsole.log(changeBase(12, 72))\nconsole.log(changeBase(12, 73))\nconsole.log(changeBase(12, 74))\nconsole.log(changeBase(12, 75))\nconsole.log(changeBase(12, 76))\nconsole.log(changeBase(12, 77))\nconsole.log(changeBase(12, 78))\nconsole.log(changeBase(12, 79))\nconsole.log(changeBase(12, 80))\nconsole.log(changeBase(12, 81))\nconsole.log(changeBase(12, 82))\nconsole.log(changeBase(12, 83))\nconsole.log(changeBase(12, 84))\nconsole.log(changeBase(12, 85))\nconsole.log(changeBase(12, 86))\nconsole.log(changeBase(12, 87))\nconsole.log(changeBase(12, 88))\nconsole.log(changeBase(12, 89))\nconsole.log(changeBase(12, 90))\nconsole.log(changeBase(12, 91))\nconsole.log(changeBase(12, 92))\nconsole.log(changeBase(12, 93))\nconsole.log(changeBase(12, 94))\nconsole.log(changeBase(12, 95))\nconsole.log(changeBase(12, 96))\nconsole.log(changeBase(12, 97))\nconsole.log(changeBase(12, 98))\nconsole.log(changeBase(12, 99))\nconsole.log(changeBase(12, 100))\nconsole.log(changeBase(12, 101))\nconsole.log(changeBase(12, 102))\nconsole.log(changeBase(12, 103))\nconsole.log(changeBase(12, 104))\nconsole.log(changeBase(12, 105))\nconsole.log(changeBase(12, 106))\nconsole.log(changeBase(12, 107))\nconsole.log(changeBase(12, 108))\nconsole.log(changeBase(12, 109))\nconsole.log(changeBase(12, 110))\nconsole.log(changeBase(12, 111))\nconsole.log(changeBase(12, 112))\nconsole.log(changeBase("}
{"task_id": "JavaScript/45", "prompt": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (2 * a * h) / 3;\n};\n\n/**\n  >>> triangleArea(1, 4)\n  1\n  >>> triangleArea(1, 2)\n  0\n  */\nconst triangleArea2 = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  >>> triangleArea(1, 1)\n  0\n  >>> triangleArea(1, 2)\n  0\n  >>> triangleArea(1, 3)\n  0\n  */\nconst triangleArea3 = (a, h) => {\n  return 0;\n};\n\n/**\n  >>> triangleArea(1, 3)\n  0\n  */\nconst triangleArea4 = (a, h) => {\n  return 0;\n};\n\nconst triangleArea5 = (a, h) => {\n  return 0;\n};\n\n/**\n  >>> triangleArea(4, 2)\n  0\n  */\nconst triangleArea6 = (a, h) => {\n  return 0;\n};\n\n/**\n  >>> triangleArea(5, 2)\n  1.4142\n  */\nconst triangleArea7 = (a, h) => {\n  return (2 * a * h) / 3;\n};\n\nconst triangleArea8 = (a, h) => {\n  return (2 * a * h) / 3;\n};\n\n/**\n  >>> triangleArea(7, 3)\n  4.5\n  */\nconst triangleArea9 = (a, h) => {\n  return (4 * a * h) / 3;\n};\n\n/**\n  >>> triangleArea(7, 4)\n  3\n  */\nconst triangleArea10 = (a, h) => {\n  return (3 * a * h) / 4;\n};\n\n/**\n  >>> triangleArea(7, 5)\n  3\n  */\nconst triangleArea11 = (a, h) => {\n  return (3 * a * h) / 5;\n};\n\n/**\n  >>> triangleArea(7, 6)\n  2.8284\n  */\nconst triangleArea12 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 7)\n  2.8284\n  */\nconst triangleArea13 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 8)\n  2.8284\n  */\nconst triangleArea14 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 9)\n  2.8284\n  */\nconst triangleArea15 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 10)\n  2.8284\n  */\nconst triangleArea16 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 11)\n  2.8284\n  */\nconst triangleArea17 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 12)\n  2.8284\n  */\nconst triangleArea18 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 13)\n  2.8284\n  */\nconst triangleArea19 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 14)\n  2.8284\n  */\nconst triangleArea20 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 15)\n  2.8284\n  */\nconst triangleArea21 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 16)\n  2.8284\n  */\nconst triangleArea22 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 17)\n  2.8284\n  */\nconst triangleArea23 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 18)\n  2.8284\n  */\nconst triangleArea24 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 19)\n  2.8284\n  */\nconst triangleArea25 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 20)\n  2.8284\n  */\nconst triangleArea26 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 21)\n  2.8284\n  */\nconst triangleArea27 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 22)\n  2.8284\n  */\nconst triangleArea28 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 23)\n  2.8284\n  */\nconst triangleArea29 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 24)\n  2.8284\n  */\nconst triangleArea30 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 25)\n  2.8284\n  */\nconst triangleArea31 = (a, h) => {\n  return (6 * a * h) / 20;\n};\n\n/**\n  >>> triangleArea(7, 26)\n  2.8284\n  */\nconst triangleArea32 = (a, h)"}
{"task_id": "JavaScript/46", "prompt": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  let f1 = 0, f2 = 1, f3 = 2;\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 0;\n  } else if (n === 2) {\n    return 2;\n  } else if (n === 3) {\n    return 0;\n  } else {\n    return f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2 + f3 + f1 + f2"}
{"task_id": "JavaScript/47", "prompt": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  l = l.filter(x => x > 0);\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  if (sorted.length % 2 === 1) {\n    return sorted[half];\n  }\n  return (sorted[half - 1] + sorted[half]) / 2;\n};\n\nconst median = (l) => {\n  l = l.filter(x => x > 0);\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  if (sorted.length % 2 === 1) {\n    return sorted[half];\n  }\n  return (sorted[half - 1] + sorted[half]) / 2;\n};\n\n/*\n  Return the mean of a list.\n  >>> mean([3, 1, 2, 4, 5])\n  3.5\n  >>> mean([-10, 4, 6, 1000, 10, 20])\n  11.0\n  */\nconst mean = (l) => {\n  return l.reduce((acc, n) => acc + n) / l.length;\n};\n\n/*\n  Return the standard deviation of a list.\n  >>> std([3, 1, 2, 4, 5])\n  2.0\n  >>> std([-10, 4, 6, 1000, 10, 20])\n  11.0\n  */\nconst std = (l) => {\n  const mean = mean(l);\n  const squaredSum = l.reduce((acc, n) => acc + (n - mean) * (n - mean), 0);\n  return Math.sqrt(squaredSum / l.length);\n};\n\n/*\n  Return the variance of a list.\n  >>> var([3, 1, 2, 4, 5])\n  2.25\n  >>> var([-10, 4, 6, 1000, 10, 20])\n  12.0\n  */\nconst var = (l) => {\n  const mean = mean(l);\n  const squaredSum = l.reduce((acc, n) => acc + (n - mean) * (n - mean), 0);\n  return squaredSum / l.length;\n};\n\n/*\n  Return the sum of a list.\n  >>> sum([3, 1, 2, 4, 5])\n  12\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  50\n  */\nconst sum = (l) => {\n  return l.reduce((acc, n) => acc + n, 0);\n};\n\nmodule.exports = {\n  mean,\n  median,\n  std,\n  var,\n  sum\n};\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let current = text.slice();\n  while (current.length) {\n    let front = current.slice(0, 1);\n    let back = current.slice(-1, current.length);\n    if (front!== back) {\n      return false;\n    }\n    current = current.slice(1, current.length);\n  }\n  return true;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  return n % p;\n};\n\n//This is a very basic function for testing purposes.\nconst mod_p = (n, p) => {\n  return modp(n, p);\n};\n\n/*\n  Modular arithmetic:\n  n = a + b\n  a mod p = n % p\n\n  >>> mod_p(1, 5)\n  1\n  >>> mod_p(2, 5)\n  2\n  >>> mod_p(3, 5)\n  3\n  >>> mod_p(4, 5)\n  4\n  >>> mod_p(5, 5)\n  1\n  >>> mod_p(6, 5)\n  6\n  >>> mod_p(7, 5)\n  7\n  >>> mod_p(8, 5)\n  8\n  >>> mod_p(9, 5)\n  9\n  >>> mod_p(10, 5)\n  1\n  >>> mod_p(11, 5)\n  11\n  >>> mod_p(12, 5)\n  12\n  >>> mod_p(13, 5)\n  13\n  >>> mod_p(14, 5)\n  14\n  >>> mod_p(15, 5)\n  15\n  >>> mod_p(16, 5)\n  16\n  >>> mod_p(17, 5)\n  17\n  >>> mod_p(18, 5)\n  18\n  >>> mod_p(19, 5)\n  19\n  >>> mod_p(20, 5)\n  1\n  >>> mod_p(21, 5)\n  21\n  >>> mod_p(22, 5)\n  22\n  >>> mod_p(23, 5)\n  23\n  >>> mod_p(24, 5)\n  24\n  >>> mod_p(25, 5)\n  25\n  >>> mod_p(26, 5)\n  1\n  >>> mod_p(27, 5)\n  27\n  >>> mod_p(28, 5)\n  28\n  >>> mod_p(29, 5)\n  29\n  >>> mod_p(30, 5)\n  30\n  >>> mod_p(31, 5)\n  31\n  >>> mod_p(32, 5)\n  32\n  >>> mod_p(33, 5)\n  33\n  >>> mod_p(34, 5)\n  34\n  >>> mod_p(35, 5)\n  35\n  >>> mod_p(36, 5)\n  1\n  >>> mod_p(37, 5)\n  37\n  >>> mod_p(38, 5)\n  38\n  >>> mod_p(39, 5)\n  39\n  >>> mod_p(40, 5)\n  40\n  >>> mod_p(41, 5)\n  41\n  >>> mod_p(42, 5)\n  42\n  >>> mod_p(43, 5)\n  43\n  >>> mod_p(44, 5)\n  44\n  >>> mod_p(45, 5)\n  45\n  >>> mod_p(46, 5)\n  46\n  >>> mod_p(47, 5)\n  47\n  >>> mod_p(48, 5)\n  48\n  >>> mod_p(49, 5)\n  49\n  >>> mod_p(50, 5)\n  1\n  >>> mod_p(51, 5)\n  51\n  >>> mod_p(52, 5)\n  52\n  >>> mod_p(53, 5)\n  53\n  >>> mod_p(54, 5)\n  54\n  >>> mod_p(55, 5)\n  55\n  >>> mod_p(56, 5)\n  56\n  >>> mod_p(57, 5)\n  57\n  >>> mod_p(58, 5)\n  58\n  >>> mod_p(59, 5)\n  59\n  >>> mod_p(60, 5)\n  1\n  >>> mod_p(61, 5)\n  61\n  >>> mod_p(62, 5)\n  62\n  >>> mod_p(63, 5)\n  63\n  >>> mod_p(64, 5)\n  64\n  >>> mod_p(65, 5)\n  65\n  >>> mod_p(66, 5)\n  66\n  >>> mod_p(67, 5)\n  67\n  >>> mod_p(68, 5)\n  68\n  >>> mod_p(69, 5)\n  69\n  >>> mod_p(70, 5)\n  70\n  >>> mod_p(71, 5)\n  71\n  >>> mod_p(72, 5)\n  72\n  >>> mod_p(73, 5)\n  73\n  >>> mod_p(74, 5)\n  74\n  >>> mod_p(75, 5)\n  75\n  >>> mod_p(76, 5)\n  76\n  >>> mod_p(77, 5)\n  77\n  >>> mod_p(78, 5)\n  78\n  >>> mod_p(79, 5)\n  79\n  >>> mod_p(80, 5)\n  80\n  >>> mod_p(81, 5)\n  81\n  >>> mod_p(82, 5)\n  82\n  >>> mod_p(83, 5)\n  83\n  >>> mod_p(84, 5)\n  84\n  >>> mod_p(85, 5)\n  85\n  >>> mod_p(86, 5)\n  86\n  >>> mod_p(87, 5)\n  87\n  >>> mod_p(88, 5)\n  88\n  >>> mod_p(89, 5)\n  89\n  >>> mod_p(90, 5)\n  1\n  >>> mod_p(91, 5)\n  91\n  >>> mod_p(92, 5)\n  92\n  >>> mod_p(93, 5)\n  93\n  >>> mod_p(94, 5)\n  94\n  >>> mod_p(95, 5)\n  95\n  >>> mod_p(96, 5)\n  96\n  >>> mod_p(97, 5)\n  97\n  >>> mod_p(98"}
{"task_id": "JavaScript/50", "prompt": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) - 5) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes a string of the form \"abcdefghijklmnopqrstuvwxyz\"\n  and returns a string of the form \"abcdefghijklmnopqrstuvwxyz\"\n  with all the letters shifted one place right.\n  */\nconst encodeAll = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 1 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes a string of the form \"abcdefghijklmnopqrstuvwxyz\"\n  and returns a string of the form \"abcdefghijklmnopqrstuvwxyz\"\n  with all the letters shifted one place left.\n  */\nconst decodeAll = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 1 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst encodeAndDecode = (s) => {\n  return encodeAll(decodeAll(s));\n}\n\nmodule.exports = {\n  encodeShift,\n  decodeShift,\n  encodeAll,\n  decodeAll,\n  encodeAndDecode\n}\n<|endoftext|>"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  let word = ''\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i]\n    if (vowels.indexOf(c) < 0) {\n      word += c\n    }\n  }\n  return word\n}\n\n/**\n  isVowel is a function that takes string and returns boolean.\n  >>> isVowel('a')\n  true\n  >>> isVowel('Z')\n  false\n  >>> isVowel('z')\n  true\n  */\nconst isVowel = (letter) => {\n  return vowelRegExp.test(letter)\n}\n\n/**\n  wordLength is a function that takes string and returns number of letters in word.\n  >>> wordLength('ab')\n  2\n  >>> wordLength('a')\n  1\n  >>> wordLength('aa')\n  2\n  >>> wordLength('abcd')\n  4\n  >>> wordLength('zaa')\n  3\n  */\nconst wordLength = (text) => {\n  return text.length\n}\n\n/**\n  isPalindrome is a function that takes string and returns boolean.\n  >>> isPalindrome('a')\n  true\n  >>> isPalindrome('A')\n  true\n  >>> isPalindrome('abc')\n  true\n  >>> isPalindrome('abb')\n  false\n  >>> isPalindrome('abcd')\n  true\n  >>> isPalindrome('abce')\n  false\n  >>> isPalindrome('abCd')\n  true\n  >>> isPalindrome('Z')\n  false\n  */\nconst isPalindrome = (text) => {\n  return (text === text.split('').reverse().join(''))\n}\n\n/**\n  isAlpha is a function that takes string and returns boolean.\n  >>> isAlpha('abc')\n  true\n  >>> isAlpha('1')\n  false\n  >>> isAlpha('A')\n  false\n  >>> isAlpha('ab')\n  false\n  >>> isAlpha('abcd')\n  false\n  >>> isAlpha('1a2b3c')\n  false\n  >>> isAlpha('Z')\n  false\n  */\nconst isAlpha = (text) => {\n  return (text.match(alphabetRegExp)!== null)\n}\n\n/**\n  isDigit is a function that takes string and returns boolean.\n  >>> isDigit('1')\n  true\n  >>> isDigit('2')\n  true\n  >>> isDigit('0')\n  true\n  >>> isDigit('a')\n  false\n  >>> isDigit('a1')\n  false\n  >>> isDigit('a2')\n  false\n  >>> isDigit('a3')\n  false\n  >>> isDigit('1a2')\n  false\n  >>> isDigit('1a')\n  false\n  >>> isDigit('1a2b3c')\n  false\n  >>> isDigit('Z')\n  false\n  */\nconst isDigit = (text) => {\n  return (text.match(digitRegExp)!== null)\n}\n\n/**\n  toUpperCase is a function that takes string and returns string with upper case letters.\n  >>> toUpperCase('abcd')\n  'ABCD'\n  >>> toUpperCase('a')\n  'A'\n  >>> toUpperCase('a1')\n  'A1'\n  >>> toUpperCase('a2')\n  'A2'\n  >>> toUpperCase('a3')\n  'A3'\n  >>> toUpperCase('abcd')\n  'ABCD'\n  >>> toUpperCase('1a2b3c')\n  '1A2B3C'\n  >>> toUpperCase('Z')\n  'Z'\n  */\nconst toUpperCase = (text) => {\n  return text.toUpperCase()\n}\n\n/**\n  toLowerCase is a function that takes string and returns string with lower case letters.\n  >>> toLowerCase('ABCD')\n  'abcd'\n  >>> toLowerCase('A')\n  'a'\n  >>> toLowerCase('a1')\n  'a1'\n  >>> toLowerCase('a2')\n  'a2'\n  >>> toLowerCase('a3')\n  'a3'\n  >>> toLowerCase('abcd')\n  'abcd'\n  >>> toLowerCase('1a2b3c')\n  '1a2b3c'\n  >>> toLowerCase('Z')\n  'z'\n  */\nconst toLowerCase = (text) => {\n  return text.toLowerCase()\n}\n\n/**\n  firstLetterOnly is a function that takes string and returns string with first letter.\n  >>> firstLetterOnly('abcdef')\n  'a'\n  >>> firstLetterOnly('ABC')\n  'A'\n  >>> firstLetterOnly('a')\n  'a'\n  >>> firstLetterOnly('Z')\n  'Z'\n  */\nconst firstLetterOnly = (text) => {\n  return text[0]\n}\n\n/**\n  allLetters is a function that takes string and returns string with all letters.\n  >>> allLetters('abcdef')\n  'abcdef'\n  >>> allLetters('ABC')\n  'ABC'\n  >>> allLetters('a')\n  'a'\n  >>> allLetters('Z')\n  'Z'\n  */\nconst allLetters = (text) => {\n  return text\n}\n\n/**\n  getRandom is a function that takes int and returns int.\n  >>> getRandom(1)\n  0\n  >>> getRandom(1)\n  1\n  >>> getRandom(2)"}
{"task_id": "JavaScript/52", "prompt": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  if (l.length === 0) return true;\n  if (l.length === 1) return l[0] <= t;\n  const arr = l.slice();\n  let i = 1;\n  while (i < arr.length) {\n    if (arr[i - 1] + 1 > arr[i]) return false;\n    i++;\n  }\n  return true;\n};\n\nexport default belowThreshold;\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*Add two numbers\n  >>> add(1, 2)\n  3\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst mul = (x, y) => {\n  return x * y;\n};\n\n/*Multiply two numbers\n  >>> mul(1, 2)\n  2\n  >>> mul(2, 3)\n  6\n  >>> mul(5, 7)\n  42\n  */\nconst div = (x, y) => {\n  return x / y;\n};\n\n/*Divide two numbers\n  >>> div(5, 2)\n  2\n  >>> div(5, 3)\n  1.5\n  >>> div(5, 7)\n  2.428571\n  */\nconst sub = (x, y) => {\n  return x - y;\n};\n\n/*Subtract two numbers\n  >>> sub(5, 2)\n  3\n  >>> sub(5, 3)\n  2\n  >>> sub(5, 7)\n  4\n  */\nconst mod = (x, y) => {\n  return x % y;\n};\n\n/*Remainder of two numbers\n  >>> mod(5, 2)\n  1\n  >>> mod(5, 3)\n  0\n  >>> mod(5, 7)\n  4\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*Calculate the square root of a number\n  >>> sqrt(4)\n  2\n  >>> sqrt(9)\n  3\n  >>> sqrt(16)\n  4\n  */\nconst sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\n/*Calculate the factorial of a number\n  >>> fact(0)\n  1\n  >>> fact(1)\n  1\n  >>> fact(3)\n  6\n  */\nconst fact = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return n * fact(n - 1);\n};\n\n/*Calculate the power of a number\n  >>> pow(3, 2)\n  9\n  >>> pow(3, 3)\n  27\n  >>> pow(3, 4)\n  81\n  */\nconst pow = (x, y) => {\n  return x ** y;\n};\n\n/*Calculate the log of a number\n  >>> log(3)\n  0.693147180559945\n  >>> log(9)\n  2.18446697386211\n  >>> log(16)\n  3.16227766016838\n  */\nconst log = (x) => {\n  return Math.log(x);\n};\n\n/*Calculate the log of a number\n  >>> log10(3)\n  0.693147180559945\n  >>> log10(9)\n  2.18446697386211\n  >>> log10(16)\n  3.16227766016838\n  */\nconst log10 = (x) => {\n  return Math.log(x) / Math.log(10);\n};\n\n/*Calculate the square root of a number\n  >>> sqrt(9)\n  3\n  >>> sqrt(16)\n  4\n  */\nconst sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\n/*Calculate the cube root of a number\n  >>> cube(4)\n  2\n  >>> cube(9)\n  3\n  >>> cube(16)\n  4\n  */\nconst cube = (x) => {\n  return Math.pow(x, 1.0 / 3.0);\n};\n\n/*Calculate the sine of a number\n  >>> sin(45)\n  0.532083\n  >>> sin(90)\n  1.0\n  >>> sin(180)\n  -1.0\n  */\nconst sin = (x) => {\n  return Math.sin(x);\n};\n\n/*Calculate the cosine of a number\n  >>> cos(45)\n  0.482035\n  >>> cos(90)\n  1.0\n  >>> cos(180)\n  -1.0\n  */\nconst cos = (x) => {\n  return Math.cos(x);\n};\n\n/*Calculate the tangent of a number\n  >>> tan(45)\n  0.262626\n  >>> tan(90)\n  1.0\n  >>> tan(180)\n  -1.0\n  */\nconst tan = (x) => {\n  return Math.tan(x);\n};\n\n/*Calculate the cotangent of a number\n  >>> cot(45)\n  0.4\n  >>> cot(90)\n  1.0\n  >>> cot(180)\n  -1.0\n  */\nconst cot = (x) => {\n  return 1.0 / Math.tan(x);\n};\n\n/*Calculate the arcsine of a number\n  >>> asin(3)\n  1.5708\n  >>> asin(9)\n  2.1213\n  >>> asin(16)\n  2.8284\n  */\nconst asin = (x) => {\n  return Math.asin(x);\n};\n\n/*Calculate the arccosine of a number\n  >>> acos(3)\n  1.0471976\n  >>> acos(9)\n  1.569444\n  >>> acos(16)\n  1.0471976\n  */\nconst acos = (x) => {\n  return Math.acos(x);\n};\n\n/*Calculate the arctangent of a number\n  >>> atan(3)\n  1.353553390593274\n  >>> atan(9)\n  1.696944009821321\n  >>> atan(16)\n  1.353553390593274\n  */\nconst atan = (x) => {\n  return Math.atan(x);\n};\n\n/*Calculate the arccotangent of a number\n  >>> acot(3)\n  0.456448\n  >>> acot(9)\n"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    const s0len = s0.length;\n    const s1len = s1.length;\n    let i0 = 0;\n    let i1 = 0;\n    while (i0 < s0len && i1 < s1len) {\n        if (s0.charAt(i0) == s1.charAt(i1)) {\n            i0++;\n            i1++;\n        } else {\n            if (i0 == s0len - 1) {\n                return i1 == s1len - 1;\n            }\n            i0++;\n            i1 = 0;\n        }\n    }\n    return false;\n};\n\nexport default sameChars;\n<|endoftext|>"}
{"task_id": "JavaScript/55", "prompt": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  let a = 1, b = 1, i = 0;\n  while(i < n) {\n    let t = a + b;\n    a = b;\n    b = t;\n    i++;\n  }\n  return b;\n};\n\nexport default fib;\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  // if brackets is empty, return true\n  if (brackets === '') return true\n\n  // if brackets is not a string, return false\n  if (typeof brackets!=='string') return false\n\n  // if brackets doesn't contain '<' or '>', return false\n  if (!/<|>/.test(brackets)) return false\n\n  // create an array of brackets\n  const bracketsArray = brackets.split('<')\n  const bracketLength = bracketsArray.length\n  const bracketsArrayLength = bracketsArray.length\n\n  // loop through each character of brackets\n  for (let i = 0; i < bracketLength; i++) {\n    // create an array with each character in brackets\n    const characterArray = bracketsArray[i].split('>')\n    const characterLength = characterArray.length\n\n    // loop through each character of brackets\n    for (let j = 0; j < characterLength; j++) {\n      // if brackets contains a bracket that doesn't have a matching\n      // closing bracket, return false\n      if (j < characterLength - 1) {\n        if (!/<|>/.test(characterArray[j + 1])) return false\n      }\n\n      // if brackets doesn't contain a bracket that has a matching opening\n      // bracket, return false\n      if (i > 0) {\n        if (!/<|>/.test(characterArray[j - 1])) return false\n      }\n    }\n  }\n\n  return true\n}\n\nexport default correctBracketing\n<|endoftext|>"}
{"task_id": "JavaScript/57", "prompt": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let c = 1\n  for (let i = 0; i < l.length - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst max_int = (l) => {\n  let m = -Infinity\n  for (let i = 0; i < l.length; i++) {\n    m = Math.max(m, l[i])\n  }\n  return m\n}\n\nconst min_int = (l) => {\n  let m = Infinity\n  for (let i = 0; i < l.length; i++) {\n    m = Math.min(m, l[i])\n  }\n  return m\n}\n\nconst max_number = (l) => {\n  let m = -Infinity\n  for (let i = 0; i < l.length; i++) {\n    m = Math.max(m, l[i])\n  }\n  return m\n}\n\nconst min_number = (l) => {\n  let m = Infinity\n  for (let i = 0; i < l.length; i++) {\n    m = Math.min(m, l[i])\n  }\n  return m\n}\n\nconst sort_list = (l) => {\n  let temp = []\n  for (let i = 0; i < l.length; i++) {\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] > l[i]) {\n        temp.push(l[i])\n        l.splice(i, 1)\n        break\n      }\n    }\n  }\n  l = l.concat(temp)\n  return l\n}\n\nconst reverse_list = (l) => {\n  for (let i = 0; i < l.length / 2; i++) {\n    let temp = l[i]\n    l[i] = l[l.length - i - 1]\n    l[l.length - i - 1] = temp\n  }\n  return l\n}\n\nconst sort_by = (l, key) => {\n  l = sort_list(l)\n  let temp = []\n  for (let i = 0; i < l.length; i++) {\n    let k = key(l[i])\n    for (let j = 0; j < temp.length; j++) {\n      if (k > key(temp[j])) {\n        temp.splice(j, 0, l[i])\n        break\n      }\n    }\n    if (j === temp.length) {\n      temp.push(l[i])\n    }\n  }\n  l = temp\n  return l\n}\n\nconst sort_by_dec = (l, key) => {\n  l = sort_list(l)\n  let temp = []\n  for (let i = 0; i < l.length; i++) {\n    let k = key(l[i])\n    for (let j = 0; j < temp.length; j++) {\n      if (k > key(temp[j])) {\n        temp.splice(j, 0, l[i])\n        break\n      }\n    }\n    if (j === temp.length) {\n      temp.push(l[i])\n    }\n  }\n  l = temp\n  return l\n}\n\nconst sort_by_num = (l, key) => {\n  l = sort_list(l)\n  let temp = []\n  for (let i = 0; i < l.length; i++) {\n    let k = key(l[i])\n    for (let j = 0; j < temp.length; j++) {\n      if (k > num(temp[j])) {\n        temp.splice(j, 0, l[i])\n        break\n      }\n    }\n    if (j === temp.length) {\n      temp.push(l[i])\n    }\n  }\n  l = temp\n  return l\n}\n\nconst max_by = (l, key) => {\n  let m = -Infinity\n  for (let i = 0; i < l.length; i++) {\n    if (key(l[i]) > m) {\n      m = key(l[i])\n    }\n  }\n  return m\n}\n\nconst min_by = (l, key) => {\n  let m = Infinity\n  for (let i = 0; i < l.length; i++) {\n    if (key(l[i]) < m) {\n      m = key(l[i])\n    }\n  }\n  return m\n}\n\nconst sort_by_dec_num = (l, key) => {\n  l = sort_list(l)\n  let temp = []\n  for (let i = 0; i < l.length; i++) {\n    let k = key(l[i])\n    for (let j = 0; j < temp.length; j++) {\n      if (k > num(temp[j])) {\n        temp.splice(j, 0, l[i])\n        break\n      }\n    }\n    if (j === temp.length) {\n      temp.push(l[i])\n    }\n  }\n  l = temp\n  return l\n}\n\nconst max_by_num = (l, key) => {\n  let m = -Infinity\n  for (let i = 0; i < l.length; i++) {\n    if (key(l[i]) > m) {\n      m = key(l[i])\n    }\n  }\n  return m\n}\n\nconst min_by_num = (l, key) => {\n  let m = Infinity\n  for (let i = 0; i < l.length; i++) {\n    if (key(l[i]) < m) {\n      m = key(l[i])\n    }\n  }\n  return m\n}\n\nconst remove_duplicates = (l) => {\n  let temp = []\n  for (let i = 0"}
{"task_id": "JavaScript/58", "prompt": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n    const minSize = Math.min(l1.length, l2.length);\n    const l1Hash = hash(l1.slice(0, minSize));\n    const l2Hash = hash(l2.slice(0, minSize));\n    const map = new Map();\n    const result = [];\n    for (let i = 0; i < minSize; i++) {\n        if (!map.has(l1Hash[i]) ||!map.has(l2Hash[i])) {\n            result.push(l1[i] && l2[i]);\n            map.set(l1Hash[i], 1);\n            map.set(l2Hash[i], 1);\n        }\n    }\n    return result;\n};\n\n/*\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n*/\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let s = Math.sqrt(n);\n  let count = 0;\n  while (s > 1) {\n    if (n % s === 0) {\n      count++;\n      s--;\n    } else {\n      break;\n    }\n  }\n  return count + 1;\n};\n\n/*\n  Return the sum of all primes below the number n.\n  >>> sumPrimes(4)\n  9\n  >>> sumPrimes(8)\n  25\n  >>> sumPrimes(15)\n  50\n  >>> sumPrimes(20)\n  55\n  >>> sumPrimes(25)\n  75\n  >>> sumPrimes(999)\n  999\n  >>> sumPrimes(1000)\n  999\n  >>> sumPrimes(1001)\n  1000\n  >>> sumPrimes(2000)\n  5598\n  >>> sumPrimes(2047)\n  2815\n  >>> sumPrimes(8191)\n  8191\n  >>> sumPrimes(10**5)\n  10**6\n  >>> sumPrimes(10**6)\n  10**7\n  >>> sumPrimes(10**7)\n  10**8\n  >>> sumPrimes(10**8)\n  10**9\n  >>> sumPrimes(10**9)\n  10**10\n  >>> sumPrimes(10**10)\n  10**11\n  >>> sumPrimes(10**11)\n  10**12\n  >>> sumPrimes(10**12)\n  10**13\n  >>> sumPrimes(10**13)\n  10**14\n  >>> sumPrimes(10**14)\n  10**15\n  >>> sumPrimes(10**15)\n  10**16\n  >>> sumPrimes(10**16)\n  10**17\n  >>> sumPrimes(10**17)\n  10**18\n  >>> sumPrimes(10**18)\n  10**19\n  >>> sumPrimes(10**19)\n  10**20\n  >>> sumPrimes(10**20)\n  10**21\n  >>> sumPrimes(10**21)\n  10**22\n  >>> sumPrimes(10**22)\n  10**23\n  >>> sumPrimes(10**23)\n  10**24\n  >>> sumPrimes(10**24)\n  10**25\n  >>> sumPrimes(10**25)\n  10**26\n  >>> sumPrimes(10**26)\n  10**27\n  >>> sumPrimes(10**27)\n  10**28\n  >>> sumPrimes(10**28)\n  10**29\n  >>> sumPrimes(10**29)\n  10**30\n  >>> sumPrimes(10**30)\n  10**31\n  >>> sumPrimes(10**31)\n  10**32\n  >>> sumPrimes(10**32)\n  10**33\n  >>> sumPrimes(10**33)\n  10**34\n  >>> sumPrimes(10**34)\n  10**35\n  >>> sumPrimes(10**35)\n  10**36\n  >>> sumPrimes(10**36)\n  10**37\n  >>> sumPrimes(10**37)\n  10**38\n  >>> sumPrimes(10**38)\n  10**39\n  >>> sumPrimes(10**39)\n  10**40\n  >>> sumPrimes(10**40)\n  10**41\n  >>> sumPrimes(10**41)\n  10**42\n  >>> sumPrimes(10**42)\n  10**43\n  >>> sumPrimes(10**43)\n  10**44\n  >>> sumPrimes(10**44)\n  10**45\n  >>> sumPrimes(10**45)\n  10**46\n  >>> sumPrimes(10**46)\n  10**47\n  >>> sumPrimes(10**47)\n  10**48\n  >>> sumPrimes(10**48)\n  10**49\n  >>> sumPrimes(10**49)\n  10**50\n  >>> sumPrimes(10**50)\n  10**51\n  >>> sumPrimes(10**51)\n  10**52\n  >>> sumPrimes(10**52)\n  10**53\n  >>> sumPrimes(10**53)\n  10**54\n  >>> sumPrimes(10**54)\n  10**55\n  >>> sumPrimes(10**55)\n  10**56\n  >>> sumPrimes(10**56)\n  10**57\n  >>> sumPrimes(10**57)\n  10**58\n  >>> sumPrimes(10**58)\n  10**59\n  >>> sumPrimes(10**59)\n  10**60\n  >>> sumPrimes(10**60)\n  10**61\n  >>> sumPrimes(10**61)\n  10**62\n  >>> sumPrimes(10**62)\n  10**63\n  >>> sumPrimes(10**63)\n  10**64\n  >>> sumPrimes(10**64)\n  10**65\n  >>> sumPrimes(10**65)\n  10**66\n  >>> sumPrimes(10**66)\n  10**67\n  >>> sumPrimes(10**67)\n  10**68\n  >>> sumPrimes(10**68)\n  10**69\n  >>> sumPrimes(10**69)\n  10**70\n  >>> sumPrimes(10**70)\n  10**71\n  >>> sumPrimes(10**71)\n  10**72\n  >>> sumPrimes(10**72)\n  10**73\n  >>> sumPrimes(10**73)\n  10**74\n  >>> sumPrimes(10**74)\n  10**75\n  >>> sumPrimes(10**75)\n  10**76\n  >>> sumPrimes(10**76)\n  10**77\n  >>> sumPrimes(10**77)\n  10**78\n  >>> sumPrimes(10**78)\n  10**79\n  >>> sumPrimes(10**79)\n  10**80\n  >>> sumPrimes(10**80)\n  10**81\n  >>> sumPrimes(10**81)\n  10**82\n  >>> sumPrimes(10**82)\n  10**"}
{"task_id": "JavaScript/60", "prompt": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 1;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Exercise 2\n  >>> sumToN(2)\n  2\n  >>> sumToN(4)\n  10\n  >>> sumToN(5)\n  15\n  >>> sumToN(7)\n  35\n  >>> sumToN(8)\n  40\n  >>> sumToN(9)\n  45\n  */\nconst sumToN2 = (n) => {\n  const sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Exercise 3\n  >>> sumToN2(4)\n  16\n  >>> sumToN2(5)\n  20\n  >>> sumToN2(7)\n  35\n  >>> sumToN2(8)\n  40\n  >>> sumToN2(9)\n  45\n  */\nconst sumToN3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/*\n  Exercise 4\n  >>> sumToN3(4)\n  16\n  >>> sumToN3(5)\n  25\n  >>> sumToN3(7)\n  357\n  >>> sumToN3(8)\n  64\n  >>> sumToN3(9)\n  81\n  */\nconst sumToN4 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i * i;\n  }\n  return sum;\n};\n\n/*\n  Exercise 5\n  >>> sumToN4(4)\n  64\n  >>> sumToN4(5)\n  125\n  >>> sumToN4(7)\n  1176\n  >>> sumToN4(8)\n  1025\n  >>> sumToN4(9)\n  1081\n  */\nconst sumToN5 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i * i * i;\n  }\n  return sum;\n};\n\nmodule.exports = {\n  sumToN,\n  sumToN2,\n  sumToN3,\n  sumToN4,\n  sumToN5,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const len = brackets.length\n  let isOpen = false\n  for (let i = 0; i < len; i++) {\n    if (brackets[i] === \"(\" &&!isOpen) {\n      isOpen = true\n    } else if (brackets[i] === \")\" && isOpen) {\n      isOpen = false\n    }\n  }\n  return!isOpen\n}\n\n// This function returns a string with the given brackets in place of \"()\"\n// brackets.\nconst parseBrackets = (brackets) => {\n  const len = brackets.length\n  let isOpen = false\n  let result = \"\"\n  for (let i = 0; i < len; i++) {\n    if (brackets[i] === \"(\" &&!isOpen) {\n      result += \"(\"\n      isOpen = true\n    } else if (brackets[i] === \")\" && isOpen) {\n      result += \")\"\n      isOpen = false\n    } else {\n      result += brackets[i]\n    }\n  }\n  return result\n}\n\nmodule.exports = {\n  correctBracketing,\n  parseBrackets\n}\n<|endoftext|>"}
{"task_id": "JavaScript/62", "prompt": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 1) return xs\n  const res = [1]\n  for (let i = 1; i < xs.length; i++) {\n    res.push(1)\n    for (let j = i - 1; j >= 1; j--) {\n      res.push(xs[i] * j)\n    }\n  }\n  return res\n}\n\n/*\n  Evaluate a polynomial.\n  >>> evaluate([1, 2, 3, 4, 5])\n  30\n  >>> evaluate([2, 1, 3, 0, 5])\n  25\n  >>> evaluate([1, 3, 0, 4, 5])\n  0\n  >>> evaluate([1, 0, 3, 4, 5])\n  0\n  >>> evaluate([1, 0, 0, 4, 5])\n  0\n  >>> evaluate([1, 1, 3, 4, 5])\n  0\n  >>> evaluate([1, 0, 0, 0, 5])\n  0\n  >>> evaluate([1, 2, 3, 4, 5])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  0\n  >>> evaluate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])\n  0\n  >>> evaluate([1, 2"}
{"task_id": "JavaScript/63", "prompt": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let a = 0,\n      b = 1,\n      t = a + b,\n      i = 1;\n\n  while(i < n) {\n    a = b;\n    b = t;\n    t = a + b;\n    i++;\n  }\n\n  return t;\n};\n\nconsole.log(fibfib(1));\nconsole.log(fibfib(2));\nconsole.log(fibfib(3));\nconsole.log(fibfib(4));\nconsole.log(fibfib(5));\nconsole.log(fibfib(6));\nconsole.log(fibfib(7));\nconsole.log(fibfib(8));\nconsole.log(fibfib(9));\n<|endoftext|>"}
{"task_id": "JavaScript/64", "prompt": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  return s.split('').filter(v => v.length).length;\n};\n\nexport default vowelsCount;\n<|endoftext|>"}
{"task_id": "JavaScript/65", "prompt": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  x = x.toString();\n  let str = x.split('');\n  let reverse = [];\n  while (str.length > 0) {\n    let digit = str.shift();\n    reverse.push(digit);\n  }\n  reverse.unshift(str.pop());\n  return reverse.join('');\n};\n\n/*\n  Given an integer x and a positive integer n, return x times n\n  >>> multiply(12, 4)\n  24\n  >>> multiply(12, 5)\n  30\n  >>> multiply(12, 6)\n  36\n  >>> multiply(12, 7)\n  42\n  >>> multiply(12, 8)\n  48\n  >>> multiply(12, 9)\n  54\n  >>> multiply(12, 10)\n  60\n  >>> multiply(12, 11)\n  66\n  >>> multiply(12, 12)\n  72\n  >>> multiply(12, 13)\n  78\n  >>> multiply(12, 14)\n  84\n  >>> multiply(12, 15)\n  90\n  >>> multiply(12, 16)\n  96\n  >>> multiply(12, 17)\n  102\n  >>> multiply(12, 18)\n  108\n  >>> multiply(12, 19)\n  114\n  >>> multiply(12, 20)\n  120\n  >>> multiply(12, 21)\n  126\n  >>> multiply(12, 22)\n  132\n  >>> multiply(12, 23)\n  138\n  >>> multiply(12, 24)\n  144\n  >>> multiply(12, 25)\n  150\n  >>> multiply(12, 26)\n  156\n  >>> multiply(12, 27)\n  162\n  >>> multiply(12, 28)\n  168\n  >>> multiply(12, 29)\n  174\n  >>> multiply(12, 30)\n  180\n  >>> multiply(12, 31)\n  186\n  >>> multiply(12, 32)\n  192\n  >>> multiply(12, 33)\n  198\n  >>> multiply(12, 34)\n  204\n  >>> multiply(12, 35)\n  210\n  >>> multiply(12, 36)\n  216\n  >>> multiply(12, 37)\n  222\n  >>> multiply(12, 38)\n  228\n  >>> multiply(12, 39)\n  234\n  >>> multiply(12, 40)\n  240\n  >>> multiply(12, 41)\n  246\n  >>> multiply(12, 42)\n  252\n  >>> multiply(12, 43)\n  258\n  >>> multiply(12, 44)\n  264\n  >>> multiply(12, 45)\n  270\n  >>> multiply(12, 46)\n  276\n  >>> multiply(12, 47)\n  282\n  >>> multiply(12, 48)\n  288\n  >>> multiply(12, 49)\n  294\n  >>> multiply(12, 50)\n  300\n  >>> multiply(12, 51)\n  306\n  >>> multiply(12, 52)\n  312\n  >>> multiply(12, 53)\n  318\n  >>> multiply(12, 54)\n  324\n  >>> multiply(12, 55)\n  330\n  >>> multiply(12, 56)\n  336\n  >>> multiply(12, 57)\n  342\n  >>> multiply(12, 58)\n  348\n  >>> multiply(12, 59)\n  354\n  >>> multiply(12, 60)\n  360\n  >>> multiply(12, 61)\n  366\n  >>> multiply(12, 62)\n  372\n  >>> multiply(12, 63)\n  378\n  >>> multiply(12, 64)\n  384\n  >>> multiply(12, 65)\n  390\n  >>> multiply(12, 66)\n  396\n  >>> multiply(12, 67)\n  402\n  >>> multiply(12, 68)\n  408\n  >>> multiply(12, 69)\n  414\n  >>> multiply(12, 70)\n  420\n  >>> multiply(12, 71)\n  426\n  >>> multiply(12, 72)\n  432\n  >>> multiply(12, 73)\n  438\n  >>> multiply(12, 74)\n  444\n  >>> multiply(12, 75)\n  450\n  >>> multiply(12, 76)\n  456\n  >>> multiply(12, 77)\n  462\n  >>> multiply(12, 78)\n  468\n  >>> multiply(12, 79)\n  474\n  >>> multiply(12, 80)\n  480\n  >>> multiply(12, 81)\n  486\n  >>> multiply(12, 82)\n  492\n  >>> multiply(12, 83)\n  498\n  >>> multiply(12, 84)\n  504\n  >>> multiply(12, 85)\n  510\n  >>> multiply(12, 86)\n  516\n  >>> multiply(12, 87)\n  522\n  >>> multiply(12, 88)\n  528\n  >>> multiply(12, 89)\n  534\n  >>> multiply(12, 90)\n  540\n  >>> multiply(12, 91)\n  546\n  >>> multiply(12, 92)\n  552\n  >>> multiply(12, 93)\n  558\n  >>> multiply(12, 94)\n  564\n  >>> multiply(12, 95)\n  570\n  >>> multiply(12, 96)\n  576\n  >>> multiply(12, 97)\n  582\n  >>> multiply(12, 98)\n  588\n  >>> multiply(12, 99)\n  594\n  >>> multiply(12, 100)\n  600\n  >>> multiply(12, 101)\n  606\n  >>> multiply(12, 102)\n  612\n  >>> multiply(12, 103)\n  618\n  >>> multiply(12, 104)\n  624\n  >>> multiply(12, 105)\n  630\n  >>> multiply(12, 106)\n  636\n  >>> multiply(12, 107)\n  642\n  >>> multiply(12, 108)\n  648\n  >>> multiply(12, 109)\n  654\n  >>> multiply(12, 110)\n  660\n  >>> multiply(12, 111)\n  666\n  >>> multiply(12, 112)\n  672\n  >>> multiply(12, 113)\n  678\n  >>> multiply(12, 114)\n  684\n  >>> multiply(12, 115)"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += parseInt(s.charAt(i), 16);\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n    const fruitCount = {\n        aples: 0,\n        oranges: 0,\n        mango: 0\n    };\n    const fruitSet = s.split(/ +/g);\n    const total = fruitSet.length;\n    fruitSet.forEach(fruit => {\n        const [count, fruitName] = fruit.match(/[0-9]+/g);\n        if (fruitName === 'aples') {\n            fruitCount.aples = parseInt(count, 10);\n        } else if (fruitName === 'oranges') {\n            fruitCount.oranges = parseInt(count, 10);\n        } else if (fruitName ==='mango') {\n            fruitCount.mango = parseInt(count, 10);\n        }\n    });\n    return total - fruitCount.aples - fruitCount.oranges - fruitCount.mango;\n};\n\nfruitDistribution('5 apples and 6 oranges', 19);\nfruitDistribution('0 apples and 1 orantes',3);\nfruitDistribution('2 apples and 3 oranges', 100);\nfruitDistribution('100 apples and 1 oranges',120);<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  if (arr.length === 0) return [];\n  let low = 0;\n  let high = arr.length - 1;\n  let left = arr[0];\n  let right = arr[high];\n  let middle = arr[Math.floor(arr.length / 2)];\n  while (left <= right) {\n    let m = Math.floor((left + right) / 2);\n    if (arr[m] > middle) {\n      left = m + 1;\n    } else {\n      right = m;\n    }\n  }\n  return [arr[left], arr[left + 1]];\n};\n\nmodule.exports = pluck;\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  // let count = 0\n  // for (let i = 0; i < lst.length; i++) {\n  //   if (lst[i] > lst[count]) {\n  //     count = i\n  //   }\n  // }\n  // console.log(count)\n  // console.log(lst[count])\n\n  let max = -1\n  let i = 0\n  while (lst[i] < lst[0]) {\n    i = 0\n  }\n\n  let count = 1\n  while (lst[i] > lst[count]) {\n    count++\n  }\n\n  return count - 1\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]))\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))\nconsole.log(search([5, 5, 4, 4, 4]))\n<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  if (lst.length === 0) return []\n\n  const list = [lst[0]]\n\n  for (let i = 1; i < lst.length; i++) {\n    const min = list[0]\n    let index = 0\n    for (let j = 0; j < list.length; j++) {\n      if (lst[j] < min) {\n        min = lst[j]\n        index = j\n      }\n    }\n    list.splice(index, 1, lst[i])\n  }\n  return list\n}\n\nconst test = (name, list) => {\n  console.log(`test: ${name}`)\n  const result = strangeSortList(list)\n  console.log(`result: ${result}`)\n}\n\ntest('empty list', [])\ntest('one elem list', [1])\ntest('two elem list', [1, 2])\ntest('three elem list', [1, 2, 3])\ntest('four elem list', [1, 2, 3, 4])\ntest('five elem list', [1, 2, 3, 4, 5])\ntest('six elem list', [1, 2, 3, 4, 5, 6])\ntest('seven elem list', [1, 2, 3, 4, 5, 6, 7])\ntest('eight elem list', [1, 2, 3, 4, 5, 6, 7, 8])\ntest('nine elem list', [1, 2, 3, 4, 5, 6, 7, 8, 9])\ntest('ten elem list', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\ntest('eleven elem list', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\ntest('twelve elem list', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) return -1\n  if (a + b <= c) return -1\n  if (b + c <= a) return -1\n  return (a * b) / 2\n}\n\nconst main = () => {\n  const validTriangles = [\n    [3, 4, 5],\n    [1, 2, 10],\n    [3, 4, -1],\n    [2, 3, -1],\n    [2, 3, -2],\n    [-1, -2, -2],\n    [-1, -2, -3],\n    [-1, -2, -4],\n    [-1, -2, -5],\n    [-1, -2, -6],\n    [-1, -2, -7],\n    [-1, -2, -8],\n    [-1, -2, -9],\n    [-1, -2, -10],\n    [-1, -2, -11],\n    [-1, -2, -12],\n    [-1, -2, -13],\n    [-1, -2, -14],\n    [-1, -2, -15],\n    [-1, -2, -16],\n    [-1, -2, -17],\n    [-1, -2, -18],\n    [-1, -2, -19],\n    [-1, -2, -20],\n    [-1, -2, -21],\n    [-1, -2, -22],\n    [-1, -2, -23],\n    [-1, -2, -24],\n    [-1, -2, -25],\n    [-1, -2, -26],\n    [-1, -2, -27],\n    [-1, -2, -28],\n    [-1, -2, -29],\n    [-1, -2, -30],\n    [-1, -2, -31],\n    [-1, -2, -32],\n    [-1, -2, -33],\n    [-1, -2, -34],\n    [-1, -2, -35],\n    [-1, -2, -36],\n    [-1, -2, -37],\n    [-1, -2, -38],\n    [-1, -2, -39],\n    [-1, -2, -40],\n    [-1, -2, -41],\n    [-1, -2, -42],\n    [-1, -2, -43],\n    [-1, -2, -44],\n    [-1, -2, -45],\n    [-1, -2, -46],\n    [-1, -2, -47],\n    [-1, -2, -48],\n    [-1, -2, -49],\n    [-1, -2, -50],\n    [-1, -2, -51],\n    [-1, -2, -52],\n    [-1, -2, -53],\n    [-1, -2, -54],\n    [-1, -2, -55],\n    [-1, -2, -56],\n    [-1, -2, -57],\n    [-1, -2, -58],\n    [-1, -2, -59],\n    [-1, -2, -60],\n    [-1, -2, -61],\n    [-1, -2, -62],\n    [-1, -2, -63],\n    [-1, -2, -64],\n    [-1, -2, -65],\n    [-1, -2, -66],\n    [-1, -2, -67],\n    [-1, -2, -68],\n    [-1, -2, -69],\n    [-1, -2, -70],\n    [-1, -2, -71],\n    [-1, -2, -72],\n    [-1, -2, -73],\n    [-1, -2, -74],\n    [-1, -2, -75],\n    [-1, -2, -76],\n    [-1, -2, -77],\n    [-1, -2, -78],\n    [-1, -2, -79],\n    [-1, -2, -80],\n    [-1, -2, -81],\n    [-1, -2, -82],\n    [-1, -2, -83],\n    [-1, -2, -84],\n    [-1, -2, -85],\n    [-1, -2, -86],\n    [-1, -2, -87],\n    [-1, -2, -88],\n    [-1, -2, -89],\n    [-1, -2, -90],\n    [-1, -2, -91],\n    [-1, -2, -92],\n    [-1, -2, -93],\n    [-1, -2, -94],\n    [-1, -2, -95],\n    [-1, -2, -96],\n    [-1, -2, -97],\n    [-1, -2, -98],\n    [-1, -2, -99],\n    [-1, -2, -100],\n    [-1, -2, -101],\n    [-1, -2, -102],\n    [-1, -2, -103],\n    [-1, -2, -104],\n    [-1, -2, -105],\n    [-1, -2, -106],\n    [-1, -2, -107],\n    [-1, -2, -"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  return q.every(x => {\n    return x === q.reverse().reduce((a, b) => {\n      return a + b;\n    }, 0) <= w;\n  });\n};\n\nmodule.exports = willItFly;\n<|endoftext|>"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let curr = 1;\n  let prev = 1;\n  let res = 0;\n  let len = arr.length;\n  let max = arr[0];\n\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < prev) {\n      prev = arr[i];\n    }\n  }\n\n  if (prev == max) {\n    return 0;\n  }\n\n  while (prev!= max) {\n    res++;\n    prev = max;\n    curr = arr[curr - 1];\n    max = arr[curr - 1];\n  }\n\n  return res;\n};\n\nmodule.exports = smallestChange;\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (!lst1 ||!lst2) {\n    return lst1 || lst2;\n  }\n  const lst1Len = lst1.length;\n  const lst2Len = lst2.length;\n  const diff = Math.abs(lst1Len - lst2Len);\n  let sum = 0;\n  let curr1 = 0;\n  let curr2 = 0;\n  let tmp;\n  while (sum < diff) {\n    tmp = lst1[curr1];\n    sum += tmp.length;\n    curr1++;\n    tmp = lst2[curr2];\n    sum += tmp.length;\n    curr2++;\n  }\n  return lst1.slice(0, curr1);\n};\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  const t = primes.length - 1;\n  for (let i = 0; i <= t; i++) {\n    if (a % primes[i] === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport {\n  isMultiplyPrime,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) return true\n  if (x === n) return true\n  if (n === 1) return false\n  if (n === 2) return (x === 2) || (x === 4)\n  if (x === 3) return false\n  if (x === 5) return false\n  if (x === 8) return false\n  if (x === 9) return false\n  if (x === 16) return false\n  return isSimplePower(x * x, n)\n}\n\nconsole.log(isSimplePower(1, 4)) //true\nconsole.log(isSimplePower(2, 2)) //true\nconsole.log(isSimplePower(8, 2)) //true\nconsole.log(isSimplePower(3, 2)) //false\nconsole.log(isSimplePower(3, 1)) //false\nconsole.log(isSimplePower(5, 3)) //false\nconsole.log(isSimplePower(9, 3)) //false\nconsole.log(isSimplePower(16, 3)) //false\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  const n = a;\n  const d = Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));\n  return d === n;\n}\n\nexport default iscube;<|endoftext|>"}
{"task_id": "JavaScript/78", "prompt": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  //if (num.match(/^[0-9A-F]+$/)) {\n    num = num.replace(/[^0-9A-F]+/g, '');\n    let len = num.length;\n    let n = 0;\n    for (let i = 0; i < len; i++) {\n      if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n        n += parseInt(num[i], 16);\n      }\n    }\n    return n;\n  //} else {\n    //return null;\n  //}\n}\n\nconst num = (input) => {\n  let num = input.replace(/[^0-9A-F]+/g, '');\n  if (num.match(/^[0-9A-F]+$/)) {\n    return parseInt(num, 16);\n  } else {\n    return null;\n  }\n}\n\nconst numHex = (num) => {\n  let len = num.length;\n  let n = 0;\n  for (let i = 0; i < len; i++) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      n += parseInt(num[i], 16);\n    }\n  }\n  return n;\n}\n\nconst numBin = (num) => {\n  let len = num.length;\n  let n = 0;\n  for (let i = 0; i < len; i++) {\n    if (num[i] === '1' || num[i] === '0') {\n      n += parseInt(num[i], 2);\n    }\n  }\n  return n;\n}\n\nconst numOct = (num) => {\n  let len = num.length;\n  let n = 0;\n  for (let i = 0; i < len; i++) {\n    if (num[i] === '1' || num[i] === '0') {\n      n += parseInt(num[i], 8);\n    }\n  }\n  return n;\n}\n\nconst numDec = (num) => {\n  let len = num.length;\n  let n = 0;\n  for (let i = 0; i < len; i++) {\n    if (num[i] === '1' || num[i] === '0') {\n      n += parseInt(num[i], 10);\n    }\n  }\n  return n;\n}\n\nconst isPrime = (num) => {\n  if (num <= 1) {\n    return false;\n  } else if (num % 2 === 0) {\n    return false;\n  } else if (num % 3 === 0) {\n    return false;\n  } else if (num % 5 === 0) {\n    return false;\n  } else if (num % 7 === 0) {\n    return false;\n  } else if (num % 11 === 0) {\n    return false;\n  } else if (num % 13 === 0) {\n    return false;\n  } else if (num % 17 === 0) {\n    return false;\n  } else if (num % 19 === 0) {\n    return false;\n  } else if (num % 23 === 0) {\n    return false;\n  } else if (num % 29 === 0) {\n    return false;\n  } else if (num % 31 === 0) {\n    return false;\n  } else if (num % 37 === 0) {\n    return false;\n  } else if (num % 41 === 0) {\n    return false;\n  } else if (num % 43 === 0) {\n    return false;\n  } else if (num % 47 === 0) {\n    return false;\n  } else if (num % 53 === 0) {\n    return false;\n  } else if (num % 59 === 0) {\n    return false;\n  } else if (num % 61 === 0) {\n    return false;\n  } else if (num % 67 === 0) {\n    return false;\n  } else if (num % 71 === 0) {\n    return false;\n  } else if (num % 73 === 0) {\n    return false;\n  } else if (num % 79 === 0) {\n    return false;\n  } else if (num % 83 === 0) {\n    return false;\n  } else if (num % 89 === 0) {\n    return false;\n  } else if (num % 97 === 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nconst isPrime = (num) => {\n  if (num <= 1) {\n    return false;\n  } else if (num % 2 === 0) {\n    return false;\n  } else if (num % 3"}
{"task_id": "JavaScript/79", "prompt": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  const num = Number(decimal);\n  while (num > 0) {\n    binary += String.fromCharCode(num % 2);\n    num = Math.floor(num / 2);\n  }\n  if (decimal > 0) {\n    binary += 'db';\n  }\n  return binary;\n};\n\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    decimal += Number(binary[i]);\n  }\n  return decimal;\n};\n\nconst convert = (decimal, binary) => {\n  const binaryStr = decimalToBinary(decimal);\n  const binaryArr = binary.split('');\n  const len = binaryArr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    binaryArr[i] = binaryStr[binaryArr.length - 1 - i];\n  }\n  return binaryArr.join('');\n};\n\nconst convertBinary = (binary) => {\n  const decimal = binaryToDecimal(binary);\n  const binaryStr = decimalToBinary(decimal);\n  return binaryStr.substring(1, binaryStr.length - 1);\n};\n\nconst convertBinaryStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  const decimal = binaryToDecimal(binary);\n  return binaryStr +'='+ decimal;\n};\n\nconst convertToBinary = (decimal) => {\n  const binaryStr = decimalToBinary(decimal);\n  return binaryStr;\n};\n\nconst convertToDecimal = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToString = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringBinary = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringBinaryStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringHex = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringHexStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringOct = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringOctStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringDec = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringDecStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringBinaryStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringHexStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringOctStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringDecStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToStringBinary = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToHexStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToOctStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToDecStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToBinaryStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToHex = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToOct = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToDec = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToBinary = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToHex = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToOct = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToDec = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToBinaryStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return binaryStr;\n};\n\nconst convertToHexStr = (binary) => {\n  const binaryStr = binaryToDecimal(binary);\n  return"}
{"task_id": "JavaScript/80", "prompt": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let hash = {};\n  for(let i = 0; i < s.length; i++) {\n    let newHash = {};\n    let newHashValue = 1;\n    for(let j = i; j < s.length; j += 3) {\n      if(hash[s[j]]) {\n        newHash[s[j]] = hash[s[j]] * newHashValue;\n      } else {\n        newHash[s[j]] = newHashValue;\n      }\n      newHashValue *= 2;\n    }\n    hash = newHash;\n  }\n  return hash['1'] === 1 && hash['2'] === 2 && hash['3'] === 3;\n};\n\nconsole.log(isHappy('a'));\nconsole.log(isHappy('aa'));\nconsole.log(isHappy('abcd'));\nconsole.log(isHappy('aabb'));\nconsole.log(isHappy('adb'));\nconsole.log(isHappy('xyy'));\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let gradesArray = [];\n  for (let i = 0; i < grades.length; i++) {\n    let grade = parseFloat(grades[i]);\n    let letterGrade = '';\n    if (grade >= 4.0) {\n      letterGrade = 'A+';\n    } else if (grade >= 3.7) {\n      letterGrade = 'A';\n    } else if (grade >= 3.3) {\n      letterGrade = 'A-';\n    } else if (grade >= 3.0) {\n      letterGrade = 'B+';\n    } else if (grade >= 2.7) {\n      letterGrade = 'H';\n    } else if (grade >= 2.3) {\n      letterGrade = 'B-';\n    } else if (grade >= 2.0) {\n      letterGrade = 'W+';\n    } else if (grade >= 1.7) {\n      letterGrade = 'C';\n    } else if (grade >= 1.3) {\n      letterGrade = 'C-';\n    } else if (grade >= 1.0) {\n      letterGrade = 'D+';\n    } else if (grade >= 0.7) {\n      letterGrade = 'D';\n    } else if (grade >= 0.0) {\n      letterGrade = 'D-';\n    } else {\n      letterGrade = 'T';\n    }\n    gradesArray.push(letterGrade);\n  }\n  return gradesArray;\n}\n\n/*\n  Given a list of grades in a format that the teacher wants to have, and the\n  expected GPA, you have to write a function that will give you the list of\n  letters you need to have. The list of letters that you have to give should\n  be in the form:\n  [A+, B, C-, C, A-]\n  *Note: The list should be in ascending order.\n*/\nconst letterGrade = (grades, expectedGPA) => {\n  let letters = [];\n  for (let i = 0; i < grades.length; i++) {\n    let letterGrade = parseFloat(grades[i]);\n    let letterGradePercent = letterGrade / expectedGPA;\n    let letterGradePercentString = '';\n    if (letterGradePercent >= 0.7) {\n      letterGradePercentString = 'C';\n    } else if (letterGradePercent >= 0.5) {\n      letterGradePercentString = 'C-';\n    } else if (letterGradePercent >= 0.3) {\n      letterGradePercentString = 'B';\n    } else if (letterGradePercent >= 0.1) {\n      letterGradePercentString = 'B-';\n    } else {\n      letterGradePercentString = 'A';\n    }\n    letters.push(letterGradePercentString);\n  }\n  return letters;\n}\n\n/*\n  Given a list of grades, and a letter grade, you have to write a function that\n  will return the GPA of the student. The list of grades should be in the form:\n  [A+, B, C-, C, A-]\n*/\nconst gpa = (grades, letter) => {\n  let gpa = 0.0;\n  for (let i = 0; i < grades.length; i++) {\n    let grade = parseFloat(grades[i]);\n    let letterGrade = parseFloat(letter);\n    gpa += grade / letterGrade;\n  }\n  return gpa;\n}\n\n/*\n  Given a list of grades, and the expected GPA, you have to write a function that\n  will give you the list of letters you need to have. The list of letters that\n  you have to give should be in the form:\n  [A+, B, C-, C, A-]\n*/\nconst letter = (grades, expectedGPA) => {\n  let letter = [];\n  for (let i = 0; i < grades.length; i++) {\n    let letterGrade = parseFloat(grades[i]);\n    let letterGradePercent = letterGrade / expectedGPA;\n    if (letterGradePercent >= 0.7) {\n      letter.push('C');\n    } else if (letterGradePercent >= 0.5) {\n      letter.push('C-');\n    } else if (letterGradePercent >= 0.3) {\n      letter.push('B');\n    } else if (letterGradePercent >= 0.1) {\n      letter.push('B-');\n    } else {\n      letter.push('A');\n    }\n  }\n  return letter;\n}\n\n/*\n  Given a list of grades, and a letter grade, you have to write a function that\n  will give you the list of grades in the form:\n  [A+, B, C-, C, A-]\n*/\nconst grades = (letter) => {\n  let grades = [];\n  for (let i = 0; i < letter.length; i++) {\n    let letterGrade = parseFloat(letter[i]);\n    if (letterGrade >= 0.7) {\n      grades.push('C');\n    } else if (letterGrade >= 0.5) {\n      grades.push('C-');\n    } else if (letterGrade >= 0.3) {\n      grades.push('B');\n    } else if (letterGrade >= 0.1) {\n      grades.push('B-');\n    } else {\n      grades.push('A');\n"}
{"task_id": "JavaScript/82", "prompt": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const prime = isPrime(string.length);\n  return prime;\n};\n\n/*\nWrite a function that takes a string and returns true if thx string\n  contains at least one of the following:\n  'a' 'A' 'e' 'E' 'i' 'I' 'o' 'O' 'u' 'U' 'y' 'Y'\n  Examples\n  containsA('Hello') == true\n  containsA('abcdcba') == true\n  containsA('kittens') == true\n  containsA('orange') == false\n  */\nconst containsA = (string) => {\n  const contains = containsChar(string, 'a');\n  const contains = containsChar(string, 'A');\n  const contains = containsChar(string, 'e');\n  const contains = containsChar(string, 'E');\n  const contains = containsChar(string, 'i');\n  const contains = containsChar(string, 'I');\n  const contains = containsChar(string, 'o');\n  const contains = containsChar(string, 'O');\n  const contains = containsChar(string, 'u');\n  const contains = containsChar(string, 'U');\n  const contains = containsChar(string, 'y');\n  const contains = containsChar(string, 'Y');\n  return contains;\n};\n\n/*\nWrite a function that takes a string and returns true if thx string\n  contains at least one of the following:\n  'b' 'B' 'd' 'D' 'f' 'F' 'g' 'G' 'j' 'J' 'l' 'L''m' 'M' 'n' 'N' 'p' 'P' 'r' 'R''s' 'S' 't' 'T' 'v' 'V' 'z' 'Z'\n  Examples\n  containsB('Hello') == true\n  containsB('abcdcba') == true\n  containsB('kittens') == true\n  containsB('orange') == false\n  */\nconst containsB = (string) => {\n  const contains = containsChar(string, 'b');\n  const contains = containsChar(string, 'B');\n  const contains = containsChar(string, 'd');\n  const contains = containsChar(string, 'D');\n  const contains = containsChar(string, 'f');\n  const contains = containsChar(string, 'F');\n  const contains = containsChar(string, 'g');\n  const contains = containsChar(string, 'G');\n  const contains = containsChar(string, 'j');\n  const contains = containsChar(string, 'J');\n  const contains = containsChar(string, 'l');\n  const contains = containsChar(string, 'L');\n  const contains = containsChar(string,'m');\n  const contains = containsChar(string, 'M');\n  const contains = containsChar(string, 'n');\n  const contains = containsChar(string, 'N');\n  const contains = containsChar(string, 'p');\n  const contains = containsChar(string, 'P');\n  const contains = containsChar(string, 'r');\n  const contains = containsChar(string, 'R');\n  const contains = containsChar(string,'s');\n  const contains = containsChar(string, 'S');\n  const contains = containsChar(string, 't');\n  const contains = containsChar(string, 'T');\n  const contains = containsChar(string, 'v');\n  const contains = containsChar(string, 'V');\n  const contains = containsChar(string, 'z');\n  const contains = containsChar(string, 'Z');\n  return contains;\n};\n\n/*\nWrite a function that takes a string and returns true if thx string\n  contains at least one of the following:\n  'c' 'C' 'g' 'G' 'i' 'I' 'k' 'K''m' 'M' 'n' 'N' 'p' 'P' 'r' 'R''s' 'S' 'u' 'U' 'y' 'Y' 'z' 'Z'\n  Examples\n  containsC('Hello') == true\n  containsC('abcdcba') == true\n  containsC('kittens') == true\n  containsC('orange') == false\n  */\nconst containsC = (string) => {\n  const contains = containsChar(string, 'c');\n  const contains = containsChar(string, 'C');\n  const contains = containsChar(string, 'g');\n  const contains = containsChar(string, 'G');\n  const contains = containsChar(string, 'i');\n  const contains = containsChar(string, 'I');\n  const contains = containsChar(string, 'k');\n  const contains = containsChar(string, 'K');\n  const contains = containsChar(string,'m');\n  const contains = containsChar(string, 'M');\n  const contains = containsChar(string, 'n');\n  const contains = containsChar(string, 'N');\n  const contains = containsChar(string, 'p');\n  const contains = containsChar(string, 'P');\n  const contains = containsChar(string, 'r');\n  const contains = containsChar(string, 'R');\n  const contains = containsChar(string,'s');\n  const contains = containsChar(string, 'S');\n  const contains = containsChar(string, 'u');\n  const contains = containsChar(string, 'U');\n  const contains = containsChar(string, 'y');\n  const contains = containsChar(string, 'Y');\n  const contains = containsChar(string, 'z');\n  const contains = containsChar(string, 'Z');\n  return contains;\n};\n\n/*\nWrite a function that takes a string and returns true if thx string\n  contains at least one of the following:\n  'd' 'D' 'h' 'H' 'l' 'L' 'o' 'O' 'p' 'P' 'r' 'R' 't' 'T' 'v' 'V' 'x' 'X' 'z' 'Z'\n  Examples\n  containsD('Hello') == true\n  containsD('abcdcba') == true"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n    const numbers = [];\n    for (let i = 1; i <= n; i++) {\n        numbers[i] = parseInt(i.toString(), 10);\n    }\n    const oneEnd = numbers.filter(x => x === 1);\n    const twoEnd = numbers.filter(x => x === 2);\n    const threeEnd = numbers.filter(x => x === 3);\n    const fourEnd = numbers.filter(x => x === 4);\n    const fiveEnd = numbers.filter(x => x === 5);\n    const sixEnd = numbers.filter(x => x === 6);\n    const sevenEnd = numbers.filter(x => x === 7);\n    const eightEnd = numbers.filter(x => x === 8);\n    const nineEnd = numbers.filter(x => x === 9);\n    const tenEnd = numbers.filter(x => x === 10);\n    const elevenEnd = numbers.filter(x => x === 11);\n    const twelveEnd = numbers.filter(x => x === 12);\n    const thirteenEnd = numbers.filter(x => x === 13);\n    const fourteenEnd = numbers.filter(x => x === 14);\n    const fifteenEnd = numbers.filter(x => x === 15);\n    const sixteenEnd = numbers.filter(x => x === 16);\n    const seventeenEnd = numbers.filter(x => x === 17);\n    const eighteenEnd = numbers.filter(x => x === 18);\n    const nineteenEnd = numbers.filter(x => x === 19);\n    const twentyEnd = numbers.filter(x => x === 20);\n    const twentyoneEnd = numbers.filter(x => x === 21);\n    const twentytwoEnd = numbers.filter(x => x === 22);\n    const twentythreeEnd = numbers.filter(x => x === 23);\n    const twentyfourEnd = numbers.filter(x => x === 24);\n    const twentyfiveEnd = numbers.filter(x => x === 25);\n    const twentysixEnd = numbers.filter(x => x === 26);\n    const twentysixoneEnd = numbers.filter(x => x === 27);\n    const twentysixtwoEnd = numbers.filter(x => x === 28);\n    const twentysixthreeEnd = numbers.filter(x => x === 29);\n    const twentysixfourEnd = numbers.filter(x => x === 30);\n    const twentysixfiveEnd = numbers.filter(x => x === 31);\n    const twentysixsixEnd = numbers.filter(x => x === 32);\n    const twentysixsevenEnd = numbers.filter(x => x === 33);\n    const twentysixeightEnd = numbers.filter(x => x === 34);\n    const twentysixnineEnd = numbers.filter(x => x === 35);\n    const twentysixtenEnd = numbers.filter(x => x === 36);\n    const twentysixelevenEnd = numbers.filter(x => x === 37);\n    const twentysixtwelveEnd = numbers.filter(x => x === 38);\n    const twentysixthirteenEnd = numbers.filter(x => x === 39);\n    const twentysixfourteenEnd = numbers.filter(x => x === 40);\n    const twentysixfifteenEnd = numbers.filter(x => x === 41);\n    const twentysixsixteenEnd = numbers.filter(x => x === 42);\n    const twentysixseventeenEnd = numbers.filter(x => x === 43);\n    const twentysixtwentyEnd = numbers.filter(x => x === 44);\n    const twentysixtwentyoneEnd = numbers.filter(x => x === 45);\n    const twentysixtwentytwoEnd = numbers.filter(x => x === 46);\n    const twentysixtwentythreeEnd = numbers.filter(x => x === 47);\n    const twentysixtwentyfourEnd = numbers.filter(x => x === 48);\n    const twentysixtwentyfiveEnd = numbers.filter(x => x === 49);\n    const twentysixtwentysixEnd = numbers.filter(x => x === 50);\n    const twentysixtwentysevenEnd = numbers.filter(x => x === 51);\n    const twentysixtwentyeightEnd = numbers.filter(x => x === 52);\n    const twentysixtwentynineEnd = numbers.filter(x => x === 53);\n    const twentysixthirtyEnd = numbers.filter(x => x === 54);\n    const twentysixthirtyoneEnd = numbers.filter(x => x === 55);\n    const twentysixthirtytwoEnd = numbers.filter(x => x === 56);\n    const twentysixthirtythreeEnd = numbers.filter(x => x === 57);\n    const twentysixthirtyfourEnd = numbers.filter(x => x === 58);\n    const twentysixthirtyfiveEnd = numbers.filter(x => x === 59);\n    const twentysixthirtysixEnd = numbers.filter(x => x === 60);\n    const twentysixthirtysevenEnd = numbers.filter(x => x === 61);\n    const twentysixthirtyeightEnd = numbers.filter(x => x === 62);\n    const twentysixthirtynineEnd = numbers.filter(x => x === 63);\n    const twentysixthirtytenEnd = numbers.filter(x => x === 64);\n    const twentysixthirtyelevenEnd = numbers.filter(x => x === 65);\n    const twentysixthirtytwelveEnd = numbers.filter(x => x === 66);\n    const twentysixthirtythirteenEnd = numbers.filter(x => x === 67);\n    const twentysixthirtyfourteenEnd = numbers.filter(x => x === 68);\n    const twentysixthirtyfifteenEnd = numbers.filter(x => x === 69);\n    const twentysixthirtysixteenEnd = numbers.filter(x => x === 70);\n    const twentysixthirtyseventeenEnd = numbers.filter(x => x === 71);\n    const twentysixthirtytwentyEnd = numbers.filter(x => x === 72);\n    const twentysixthirtytwentyoneEnd = numbers.filter(x => x === 73);\n    const twentysixthirtytwentytwoEnd = numbers.filter(x => x === 74);\n    const twentysixthirtytwentythreeEnd = numbers.filter(x => x === 75);\n    const twent"}
{"task_id": "JavaScript/84", "prompt": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve2 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve3 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve4 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve5 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve6 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve7 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve8 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve9 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve10 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve11 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve12 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve13 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve14 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve15 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve16 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve17 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve18 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve19 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve20 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve21 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve22 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev + curr, 0);\n  return sum.toString();\n};\n\nconst solve23 = (N) => {\n  const num = N.toString(2).split('');\n  const sum = num.reduce((prev, curr) => prev * 10 + curr, 0);\n  return sum.toString();\n};\n\nconst solve24 = (N) => {\n  "}
{"task_id": "JavaScript/85", "prompt": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    const sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add2 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add3 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add4 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add5 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add6 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add7 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add8 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add9 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add10 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add11 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add12 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add13 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add14 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add15 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add16 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add17 = (lst) => {\n  const l = lst.length\n  if (l == 0) {\n    return 0\n  } else {\n    let sum = lst[0]\n    for (let i = 1; i < l; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n}\n\nconst add18 = (lst) => {\n  const l = lst.length\n  if (l"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    let char = w.charCodeAt(0);\n    if (i === 1) {\n      r.push(char);\n    } else {\n      if (char > r[i - 1]) {\n        r.push(char);\n      } else {\n        r.push(r[i - 1]);\n        r.push(char);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle2 = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle3 = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle4 = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle5 = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle6 = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle7 = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return r.join('');\n}\n\nconst shuffle8 = (s) => {\n  const words = s.split(/\\s+/);\n  let r = [];\n  let i = 0;\n  let s = '';\n  words.forEach(w => {\n    i = i + 1;\n    if (i === 1) {\n      r.push(w);\n    } else {\n      if (Math.random() < 0.5) {\n        r.push(w);\n      } else {\n        r.push(r[i - 1]);\n        r.push(w);\n      }\n    }\n  });\n  return"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0; i < row.length; i++) {\n    const [c1, c2] = col[i]\n    ret.push((x, c1 + c2))\n  }\n  return ret\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) {\n    return []\n  }\n  const [row, col] = lst[0]\n  const ret = []\n  for (let i = 0"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sorted = []\n  for (let i = 0; i < array.length; i++) {\n    sorted.push(array[i])\n  }\n  return sorted\n}\n\n/**\n  Given a list of non-negative integers, return its sum.\n  Example:\n  * sum([1, 2, 3]) => 6\n  * sum([1, 2, 3, 4]) => 10\n*/\nconst sum = (array) => {\n  const result = 0\n  for (let i = 0; i < array.length; i++) {\n    result += array[i]\n  }\n  return result\n}\n\nconst _check = (array) => {\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] < array[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check1 = (array) => {\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] > array[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check2 = (array) => {\n  for (let i = 0; i < array.length - 1; i++) {\n    if (array[i] > array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check3 = (array) => {\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] <= array[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check4 = (array) => {\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] >= array[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check5 = (array) => {\n  for (let i = 0; i < array.length - 1; i++) {\n    if (array[i] < array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check6 = (array) => {\n  for (let i = 0; i < array.length - 1; i++) {\n    if (array[i] > array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check7 = (array) => {\n  for (let i = 0; i < array.length - 1; i++) {\n    if (array[i] >= array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check8 = (array) => {\n  for (let i = 0; i < array.length - 1; i++) {\n    if (array[i] <= array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check9 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] < array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check10 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] > array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check11 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] >= array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check12 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] <= array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check13 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] < array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check14 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] > array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check15 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] >= array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check16 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] < array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check17 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] <= array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst _check18 = (array) => {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] > array[i + 1]) {\n      return false\n    }\n  }\n  return"}
{"task_id": "JavaScript/89", "prompt": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let al = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = al.slice(0).reverse().join('')\n  return s.split('').map((char, i) => {\n    return rotated.charAt(al.indexOf(char))\n  }).join('')\n}\n\n/*\n  * Returns a random string of the specified length\n  */\nconst getRandomString = (length) => {\n  let chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let result = ''\n  for (let i = 0; i < length; i++) {\n    result += chars[Math.floor(Math.random() * chars.length)]\n  }\n  return result\n}\n\n/*\n  * Returns a random string of the specified length\n  */\nconst getRandomHexString = (length) => {\n  let chars = '0123456789abcdef'\n  let result = ''\n  for (let i = 0; i < length; i++) {\n    result += chars[Math.floor(Math.random() * chars.length)]\n  }\n  return result\n}\n\n/*\n  * Generates a random string of the specified length, using\n  * alphabets of the specified length\n  */\nconst getRandomAlphabet = (length) => {\n  let chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n  let result = ''\n  for (let i = 0; i < length; i++) {\n    result += chars[Math.floor(Math.random() * chars.length)]\n  }\n  return result\n}\n\n/*\n  * Encrypts a string with the al'habet beibg rotated\n  * @param {string} str The string to be encrypted\n  * @param {number} rotations The number of rotations, must be in range [1, 13]\n  * @returns {string} The encrypted string\n  */\nconst encryptWithRotations = (str, rotations) => {\n  rotations = rotations || 1\n  return encrypt(str) + encrypt(str)\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n}\n\n/*\n  * Generates a string of the specified length, using\n  * alphabets of the specified length\n  */\nconst getRandomAlphabetWithRotations = (length) => {\n  let chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n  let rotations = getRandomString(length - 2)\n  let result = ''\n  for (let i = 0; i < length - 2; i++) {\n    result += encrypt(chars[Math.floor(Math.random() * chars.length)])\n  }\n  return encrypt(result) + encrypt(result)\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n .split(' ')\n .map(rotate)\n .join(' ')\n .split(' ')\n .map((char, i) => {\n    return char + char\n  })\n .join(' ')\n}\n\nmodule.exports = {\n  encrypt: encrypt,\n  getRandomString: getRandomString,\n  getRandomAlphabet: getRandomAlphabet,\n  getRandomAlphabetWithRotations: getRandomAlphabetWithRotations,\n  encryptWithRotations: encryptWithRotations\n}\n<|endoftext|>"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length === 0) return null\n  return lst[0]\n}\n\nconst nextSmallest = (lst) => {\n  if (lst.length === 0) return null\n  return lst[0]\n}\n\n/*\n  Given a list of ints, write a function that returns the last element of the list.\n  Return nulp if theee is no such element.\n  \n  last( [1, 2, 3, 4, 5]) == 5\n  last([1, 2, 3, 4, 5]) == 5\n  last([]) == nuoo\n  last([1, 1]) == null\n  \n  */\nconst last = (lst) => {\n  if (lst.length === 0) return null\n  return lst[lst.length - 1]\n}\n\nconst last = (lst) => {\n  if (lst.length === 0) return null\n  return lst[lst.length - 1]\n}\n\n/*\n  Given a list of ints, write a function that returns the index of the last element of the list.\n  Return -1 if theee is no such element.\n  \n  lastIndex( [1, 2, 3, 4, 5]) == 4\n  lastIndex([1, 2, 3, 4, 5]) == 4\n  lastIndex([]) == -1\n  lastIndex([1, 1]) == -1\n  \n  */\nconst lastIndex = (lst) => {\n  if (lst.length === 0) return -1\n  return lst.length - 1\n}\n\nconst lastIndex = (lst) => {\n  if (lst.length === 0) return -1\n  return lst.length - 1\n}\n\n/*\n  Given a list of ints, write a function that returns the index of the first element of the list.\n  Return -1 if theee is no such element.\n  \n  firstIndex( [1, 2, 3, 4, 5]) == 0\n  firstIndex([1, 2, 3, 4, 5]) == 0\n  firstIndex([]) == -1\n  firstIndex([1, 1]) == -1\n  \n  */\nconst firstIndex = (lst) => {\n  if (lst.length === 0) return -1\n  return 0\n}\n\nconst firstIndex = (lst) => {\n  if (lst.length === 0) return -1\n  return 0\n}\n\n/*\n  Given a list of ints, write a function that returns the nth element of the list.\n  Return nulp if theee is no such element.\n  \n  nth( [1, 2, 3, 4, 5], 2) == 3\n  nth([1, 2, 3, 4, 5], 2) == 3\n  nth([], 2) == nuoo\n  nth([1, 1], 2) == null\n  \n  */\nconst nth = (lst, n) => {\n  if (lst.length === 0) return null\n  if (n < 0) return null\n  if (n >= lst.length) return null\n  return lst[n]\n}\n\nconst nth = (lst, n) => {\n  if (lst.length === 0) return null\n  if (n < 0) return null\n  if (n >= lst.length) return null\n  return lst[n]\n}\n\n/*\n  Given a list of ints, write a function that returns the sum of all the ints in the list.\n  Return nulp if theee is no such sum.\n  \n  sum([1, 2, 3, 4, 5]) == 15\n  sum([]) == 0\n  sum([1, 1]) == 2\n  \n  */\nconst sum = (lst) => {\n  if (lst.length === 0) return 0\n  return lst.reduce((sum, num) => sum + num, 0)\n}\n\nconst sum = (lst) => {\n  if (lst.length === 0) return 0\n  return lst.reduce((sum, num) => sum + num, 0)\n}\n\n/*\n  Given a list of ints, write a function that returns the average of all the ints in the list.\n  Return nulp if theee is no such sum.\n  \n  average([1, 2, 3, 4, 5]) == 3.5\n  average([]) == 0\n  average([1, 1]) == 1\n  \n  */\nconst average = (lst) => {\n  if (lst.length === 0) return 0\n  return sum(lst) / lst.length\n}\n\nconst average = (lst) => {\n  if (lst.length === 0) return 0\n  return sum(lst) / lst.length\n}\n\n/*\n  Given a list of ints, write a function that returns the median of the list.\n  Return nulp if theee is no such median.\n  \n  median([1, 2, 3, 4, 5]) == 3\n  median([]) == 0\n  median([1, 1]) == 1\n  \n  */\nconst median = (lst) => {\n  if (lst.length === 0) return 0\n  if (lst.length % 2 === 1) {\n    return (lst[lst.length / 2] + lst[lst.length / 2 - 1]) / 2\n  }\n  return lst[lst.length / 2]\n}\n\nconst median = (lst) => {\n  if (lst.length === 0) return 0\n  if (lst.length % 2 === 1) {\n    return (lst[lst.length / 2] + lst[lst.length / 2 - 1]) / 2\n  }\n  return lst[lst.length / 2]\n}\n\n/*\n  Given a list of ints, write a function that returns the mode of the list.\n  Return nulp if theee is no such mode.\n"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let i = 0\n  let len = S.length\n  let bored = 0\n  while (i < len) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++\n      continue\n    }\n    if (S[i].toLowerCase() === 'i') {\n      bored++\n      i++\n      continue\n    }\n    i++\n  }\n  return bored\n}\n\n/*\n  Given a list of words, find the most common one, and return the word\n  and its count.\n \n  For exaiple:\n  >>> mostCommonWord(\"world\", \"world\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world?day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day??\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day.day!day\")\n  (world, 1)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day.day.day\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day.day.day!?\")\n  (world, 2)\n  >>> mostCommonWord(\"world\", \"world.day.day.day.day.day.day.day.day.day!day\")\n  (world, 1)\n  */\nconst mostCommonWord = (words, word) => {\n  let list = words.split('')\n  let counter = 0\n  let max = 0\n  let count = 0\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] === word) {\n      counter++\n      if (counter > max) {\n        max = counter\n        count = 1\n      } else if (counter === max) {\n        count++\n      }\n    }\n  }\n  return [word, count]\n}\n<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return (x + y + z) % 1 === 0 && x % 1 === 0 && y % 1 === 0 && z % 1 === 0;\n};\n\nmodule.exports = anyInt;<|endoftext|>"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const letters = message.split(\"\").map(l => {\n    return l.toUpperCase();\n  });\n  const vowels = [\n    \"A\", \"E\", \"I\", \"O\", \"U\", \"A\", \"E\", \"I\", \"O\", \"U\"\n  ];\n  const vowelMap = {\n    \"A\": \"B\", \"E\": \"F\", \"I\": \"J\", \"O\": \"K\", \"U\": \"L\"\n  };\n  const output = \"\";\n  for (let i = 0; i < letters.length; i++) {\n    let vowel = letters[i];\n    let char = vowelMap[vowel];\n    output += vowels[vowels.indexOf(vowel)].toLowerCase();\n    output += char.toLowerCase();\n    output += vowels[vowels.indexOf(vowel)].toUpperCase();\n    output += char.toUpperCase();\n  }\n  return output;\n}\n\nconsole.log(encode(\"This is a message\"));\n<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let result = 0;\n  const prime = (n) => {\n    let m = 2;\n    while (m * m <= n) {\n      if (n % m === 0) {\n        return false;\n      }\n      m++;\n    }\n    return true;\n  };\n  let p = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (prime(lst[i])) {\n      p += lst[i];\n    }\n  }\n  if (prime(p)) {\n    for (let j = 0; j < p; j++) {\n      result += j;\n    }\n  }\n  return result;\n};\n\nconsole.log(prime(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1])));\nconsole.log(prime(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3])));\nconsole.log(prime(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6])));\nconsole.log(prime(skjkasdkd([0,81,12,3,1,21])));\nconsole.log(prime(skjkasdkd([0,8,1,2,1,7])));\n<|endoftext|>"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  return Object.keys(dict).every(key => (typeof key === \"string\")\n    || (typeof key === \"number\"));\n}\n\n/*\n  Function to check the dictionary with loxer or upper case.\n  The function should return true if the given dictionary is not empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseLoxer = (dict) => {\n  return Object.keys(dict).every(key => (typeof key === \"string\")\n    && (key.toLowerCase() === key));\n}\n\n/*\n  Function to check the dictionary with loxer or upper case.\n  The function should return true if the given dictionary is not empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseUpper = (dict) => {\n  return Object.keys(dict).every(key => (typeof key === \"string\")\n    && (key.toUpperCase() === key));\n}\n\nconst checkDict = (dict, key) => {\n  switch (key) {\n    case \"loxer\":\n      return checkDictCaseLoxer(dict);\n    case \"upper\":\n      return checkDictCaseUpper(dict);\n    default:\n      return false;\n  }\n}\n\n/*\n  Function to check the dictionary with loxer or upper case.\n  The function should return true if the given dictionary is not empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictLoxer = (dict) => {\n  return Object.keys(dict).every(key => (typeof key === \"string\")\n    && (key.toLowerCase() === key));\n}\n\nconst checkDictUpper = (dict) => {\n  return Object.keys(dict).every(key => (typeof key === \"string\")\n    && (key.toUpperCase() === key));\n}\n\nconst checkDict = (dict, key) => {\n  switch (key) {\n    case \"loxer\":\n      return checkDictLoxer(dict);\n    case \"upper\":\n      return checkDictUpper(dict);\n    default:\n      return false;\n  }\n}\n\nexport {checkDict, checkDictLoxer, checkDictUpper}\n<|endoftext|>"}
{"task_id": "JavaScript/96", "prompt": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  if (n <= 1) {\n    return []\n  }\n  return [...new Array(n)].map(() => {\n    let p = 2\n    while (p < n) {\n      if (isPrime(p)) {\n        return p\n      }\n      p++\n    }\n    return n\n  })\n}\n\n//TODO\n/*\n\ncountUpTo(5) => [2,3]\ncountUpTo(11) => [2,3,5,7]\ncountUpTo(0) => []\ncountUpTo(20) => [2,3,5,7,11,13,17,19]\ncountUpTo(1) => []\ncountUpTo(18) => [2,3,5,7,11,13,17]\n\n*/\n\nconsole.log(countUpTo(5))\nconsole.log(countUpTo(11))\nconsole.log(countUpTo(0))\nconsole.log(countUpTo(20))\nconsole.log(countUpTo(1))\nconsole.log(countUpTo(18))\n<|endoftext|>"}
{"task_id": "JavaScript/97", "prompt": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let ab = a + b\n  let result = 1\n  while (ab > 0) {\n    result *= ab % 10\n    ab = ab / 10\n  }\n  return result\n}\n\nconst number = (n) => {\n  let a = 1\n  let b = n\n  let result = 1\n  while (b > 0) {\n    result = multiply(result, b)\n    b = b - 1\n  }\n  return result\n}\n\nconst unit_digit = (n) => {\n  let result = number(n)\n  let r = result\n  let t = 0\n  while (r > 0) {\n    t = r % 10\n    r = r / 10\n  }\n  return t\n}\n\nconsole.log(unit_digit(123))\nconsole.log(unit_digit(45))\nconsole.log(unit_digit(1))\nconsole.log(unit_digit(8))\nconsole.log(unit_digit(16))\nconsole.log(unit_digit(0))\nconsole.log(unit_digit(9))\nconsole.log(unit_digit(25))\nconsole.log(unit_digit(7))\nconsole.log(unit_digit(3))\nconsole.log(unit_digit(4))\nconsole.log(unit_digit(15))\nconsole.log(unit_digit(7))\nconsole.log(unit_digit(5))\nconsole.log(unit_digit(19))\nconsole.log(unit_digit(7))\nconsole.log(unit_digit(2))\nconsole.log(unit_digit(12))\nconsole.log(unit_digit(13))\nconsole.log(unit_digit(14))\nconsole.log(unit_digit(15))\nconsole.log(unit_digit(20))\nconsole.log(unit_digit(21))\nconsole.log(unit_digit(22))\nconsole.log(unit_digit(23))\nconsole.log(unit_digit(24))\nconsole.log(unit_digit(25))\nconsole.log(unit_digit(26))\nconsole.log(unit_digit(27))\nconsole.log(unit_digit(28))\nconsole.log(unit_digit(29))\nconsole.log(unit_digit(30))\nconsole.log(unit_digit(31))\nconsole.log(unit_digit(32))\nconsole.log(unit_digit(33))\nconsole.log(unit_digit(34))\nconsole.log(unit_digit(35))\nconsole.log(unit_digit(36))\nconsole.log(unit_digit(37))\nconsole.log(unit_digit(38))\nconsole.log(unit_digit(39))\nconsole.log(unit_digit(40))\nconsole.log(unit_digit(41))\nconsole.log(unit_digit(42))\nconsole.log(unit_digit(43))\nconsole.log(unit_digit(44))\nconsole.log(unit_digit(45))\nconsole.log(unit_digit(46))\nconsole.log(unit_digit(47))\nconsole.log(unit_digit(48))\nconsole.log(unit_digit(49))\nconsole.log(unit_digit(50))\nconsole.log(unit_digit(51))\nconsole.log(unit_digit(52))\nconsole.log(unit_digit(53))\nconsole.log(unit_digit(54))\nconsole.log(unit_digit(55))\nconsole.log(unit_digit(56))\nconsole.log(unit_digit(57))\nconsole.log(unit_digit(58))\nconsole.log(unit_digit(59))\nconsole.log(unit_digit(60))\nconsole.log(unit_digit(61))\nconsole.log(unit_digit(62))\nconsole.log(unit_digit(63))\nconsole.log(unit_digit(64))\nconsole.log(unit_digit(65))\nconsole.log(unit_digit(66))\nconsole.log(unit_digit(67))\nconsole.log(unit_digit(68))\nconsole.log(unit_digit(69))\nconsole.log(unit_digit(70))\nconsole.log(unit_digit(71))\nconsole.log(unit_digit(72))\nconsole.log(unit_digit(73))\nconsole.log(unit_digit(74))\nconsole.log(unit_digit(75))\nconsole.log(unit_digit(76))\nconsole.log(unit_digit(77))\nconsole.log(unit_digit(78))\nconsole.log(unit_digit(79))\nconsole.log(unit_digit(80))\nconsole.log(unit_digit(81))\nconsole.log(unit_digit(82))\nconsole.log(unit_digit(83))\nconsole.log(unit_digit(84))\nconsole.log(unit_digit(85))\nconsole.log(unit_digit(86))\nconsole.log(unit_digit(87))\nconsole.log(unit_digit(88))\nconsole.log(unit_digit(89))\nconsole.log(unit_digit(90))\nconsole.log(unit_digit(91))\nconsole.log(unit_digit(92))\nconsole.log(unit_digit(93))\nconsole.log(unit_digit(94))\nconsole.log(unit_digit(95))\nconsole.log(unit_digit(96))\nconsole.log(unit_digit(97))\nconsole.log(unit_digit(98))\nconsole.log(unit_digit(99))\nconsole.log(unit_digit(100))\nconsole.log(unit_digit(101))\nconsole.log(unit_digit(102))\nconsole.log(unit_digit(103))\nconsole.log(unit_digit(104))\nconsole.log(unit_digit(105))\nconsole.log(unit_digit(106))\nconsole.log(unit_digit(107))\nconsole.log(unit_digit(108))\nconsole.log(unit_digit(109))\nconsole.log(unit_digit(110))\nconsole.log(unit_digit(111))\nconsole.log(unit"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const sLength = s.length\n  const count = 0\n  let i = 0\n  while(i < sLength) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      i += 2\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of lowercase cowels in odd indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 1\n  */\nconst countLower = (s) => {\n  const sLength = s.length\n  const count = 0\n  let i = 1\n  while(i < sLength) {\n    if(s.charAt(i).toLowerCase() === s.charAt(i)) {\n      count++\n      i += 2\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonants = (s) => {\n  const sLength = s.length\n  const count = 0\n  let i = 0\n  while(i < sLength) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      i += 2\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of vowels in odd indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  const sLength = s.length\n  const count = 0\n  let i = 1\n  while(i < sLength) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      i += 2\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\n/*\n  Givfn a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels2 = (s) => {\n  const sLength = s.length\n  const count = 0\n  let i = 1\n  while(i < sLength) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      i += 2\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\nconst count = (s) => {\n  let count = 0\n  const sLength = s.length\n  for(let i = 0; i < sLength; i++) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      if(i + 1 < sLength) {\n        if(s.charAt(i + 1).toUpperCase() === s.charAt(i + 1)) {\n          count++\n          i++\n        } else {\n          i++\n        }\n      }\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\nconst count2 = (s) => {\n  let count = 0\n  const sLength = s.length\n  for(let i = 0; i < sLength; i++) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      if(i + 1 < sLength) {\n        if(s.charAt(i + 1).toUpperCase() === s.charAt(i + 1)) {\n          count++\n          i++\n        } else {\n          i++\n        }\n      }\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\nconst count3 = (s) => {\n  let count = 0\n  const sLength = s.length\n  for(let i = 0; i < sLength; i++) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      if(i + 1 < sLength) {\n        if(s.charAt(i + 1).toUpperCase() === s.charAt(i + 1)) {\n          count++\n          i++\n        } else {\n          i++\n        }\n      }\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\nconst count4 = (s) => {\n  let count = 0\n  const sLength = s.length\n  for(let i = 0; i < sLength; i++) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {\n      count++\n      if(i + 1 < sLength) {\n        if(s.charAt(i + 1).toUpperCase() === s.charAt(i + 1)) {\n          count++\n          i++\n        } else {\n          i++\n        }\n      }\n    } else {\n      i++\n    }\n  }\n  return count\n}\n\nconst count5 = (s) => {\n  let count = 0\n  const sLength = s.length\n  for(let i = 0; i < sLength; i++) {\n    if(s.charAt(i).toUpperCase() === s.charAt(i)) {"}
{"task_id": "JavaScript/99", "prompt": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const digits = [...value.toString().split('')].reverse();\n  const len = digits.length;\n  let closest = 0;\n  let closestDistance = Math.abs(closest - parseInt(value));\n\n  for (let i = 0; i < len; i++) {\n    const currentDigit = parseInt(digits[i]);\n    if (currentDigit < closest) {\n      closest = currentDigit;\n      closestDistance = Math.abs(closest - parseInt(value));\n    } else if (currentDigit > closest) {\n      if (i < len - 1) {\n        const nextDigit = parseInt(digits[i + 1]);\n        if (nextDigit - closest < closestDistance) {\n          closest = nextDigit;\n          closestDistance = Math.abs(closest - parseInt(value));\n        }\n      } else {\n        closest = currentDigit;\n      }\n    }\n  }\n  return closest;\n};\n\nconst closest = (value, candidates) => {\n  if (typeof candidates === 'undefined') {\n    throw new Error('Must provide candidates');\n  }\n  if (typeof value === 'undefined') {\n    throw new Error('Must provide value');\n  }\n  if (!Array.isArray(candidates)) {\n    throw new Error('Must provide an array of candidates');\n  }\n  return candidates.reduce((accumulator, candidate) => {\n    if (closestInteger(value) === candidate) {\n      return candidate;\n    }\n    return accumulator;\n  }, 0);\n};\n\nmodule.exports = closest;\n<|endoftext|>"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = []\n  for (let i = 1; i <= n; i++) {\n    const s = Math.ceil(Math.pow(2, i))\n    ps.push(s)\n  }\n  return ps\n}\n\n/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile2 = (n) => {\n  const ps = []\n  for (let i = 1; i <= n; i++) {\n    const s = Math.pow(2, i)\n    ps.push(s)\n  }\n  return ps\n}\n\n/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile3 = (n) => {\n  const ps = []\n  for (let i = 1; i <= n; i++) {\n    const s = Math.pow(2, i)\n    if (i % 2 === 0) {\n      ps.push(s)\n    }\n  }\n  return ps\n}\n\n//# sourceMappingURL=07-05-01-p02.js.map<|endoftext|>"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // return the list of words\n  return words;\n}\n\n// return the length of the longest string\nconst lengthOfLongest = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const lengths = words.map(word => word.length);\n  // return the largest value\n  return Math.max(...lengths);\n}\n\n// return the length of the shortest string\nconst lengthOfShortest = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const lengths = words.map(word => word.length);\n  // return the smallest value\n  return Math.min(...lengths);\n}\n\n// return the sum of all numbers\nconst sum = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const sum = words.reduce((sum, word) => sum + parseInt(word), 0);\n  // return the sum\n  return sum;\n}\n\n// return the difference of all numbers\nconst difference = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const difference = words.reduce((sum, word) => sum + parseInt(word) * 2, 0);\n  // return the sum\n  return difference;\n}\n\n// return the product of all numbers\nconst product = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const product = words.reduce((sum, word) => sum + parseInt(word) * 2, 0);\n  // return the sum\n  return product;\n}\n\n// return the quotient of all numbers\nconst quotient = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const quotient = words.reduce((sum, word) => sum + parseInt(word) * 2, 0);\n  // return the sum\n  return quotient;\n}\n\n// return the sum of the squares of all numbers\nconst sumOfSquares = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const sum = words.reduce((sum, word) => sum + parseInt(word) * parseInt(word), 0);\n  // return the sum\n  return sum;\n}\n\n// return the sum of the squares of the squares of all numbers\nconst sumOfSquaresSquares = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const sum = words.reduce((sum, word) => sum + parseInt(word) * parseInt(word) * parseInt(word), 0);\n  // return the sum\n  return sum;\n}\n\n// return the average of all numbers\nconst average = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const average = words.reduce((sum, word) => sum + parseInt(word), 0) / words.length;\n  // return the sum\n  return average;\n}\n\n// return the square root of all numbers\nconst squareRoot = (s) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const squareRoot = words.reduce((sum, word) => sum + parseInt(word) * parseInt(word), 0);\n  // return the sum\n  return squareRoot;\n}\n\n// return the nth term of the sequence\nconst nthTerm = (s, n) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const nthTerm = words.reduce((sum, word, index) => sum + parseInt(word) * parseInt(word) * (index + 1), 0);\n  // return the sum\n  return nthTerm;\n}\n\n// return the nth term of the sequence\nconst nthPower = (s, n) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const nthPower = words.reduce((sum, word, index) => sum + parseInt(word) * parseInt(word) * (index + 1), 1);\n  // return the sum\n  return nthPower;\n}\n\n// return the nth term of the sequence\nconst factorial = (s, n) => {\n  // get a list of all words\n  const words = s.split(/[\\s,|]/);\n  // create a list to store the lengths\n  const factorial = words.reduce((sum, word, index) => sum + parseInt(word) * parseInt(word) * (index + 1), 1);\n  // return the sum\n  return factorial;\n}\n\n// return the prime factorization of all numbers\nconst primeFactorization = (s) => {\n  // get a list of all words\n  const words = s"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n    if (x < y) {\n        return -1;\n    }\n    let low = Math.min(x, y);\n    let high = Math.max(x, y);\n    let d = low;\n    let x2 = x;\n    let y2 = y;\n    while (x2 > 1 && y2 > 1) {\n        if (x2 % 2 === 0) {\n            x2 = Math.floor(x2 / 2);\n        } else if (y2 % 2 === 0) {\n            y2 = Math.floor(y2 / 2);\n        } else {\n            return -1;\n        }\n        d = Math.min(x2, y2);\n    }\n    return d;\n}\n\n/*\n  chooseNum(12, 15) = 14\n  */\nconst chooseNum2 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n    return res;\n}\n\nconst chooseNum3 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n    return res;\n}\n\nconst chooseNum4 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n    return res;\n}\n\nconst chooseNum5 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n    return res;\n}\n\nconst chooseNum6 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n    return res;\n}\n\nconst chooseNum7 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n    return res;\n}\n\nconst chooseNum8 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n    return res;\n}\n\nconst chooseNum9 = (x, y) => {\n    let diff = y - x;\n    if (diff < 0) {\n        diff = Math.abs(diff);\n    }\n    let k = diff;\n    while (k > 0) {\n        k -= 2;\n    }\n    let m = k;\n    if (m < 0) {\n        m = Math.abs(m);\n    }\n    let i = 0;\n    let n = 0;\n    let res = -1;\n    while (i <= m) {\n        n += 2;\n        res = n;\n        i++;\n    }\n"}
{"task_id": "JavaScript/103", "prompt": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const m_n = m - n;\n  let avg = 0;\n  for (let i = n; i <= m; i++) {\n    const num = Math.round(i);\n    const mod = num % 2;\n    avg += mod;\n  }\n  return avg / (m - n);\n};\n\nconst test = (n, m, correct) => {\n  const result = roundedAvg(n, m);\n  if (correct === result) {\n    return true;\n  }\n  return false;\n};\n\nconst runTest = () => {\n  const testResult = test(1, 5, \"0b11\");\n  if (testResult) {\n    console.log(\"Test Passed\");\n  } else {\n    console.log(\"Test Failed\");\n  }\n};\n\nrunTest();\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let arr = []\n  for(let i = 0; i < x; i++) {\n    let r = []\n    for(let j = 0; j < 10; j++) {\n      if(i%j === 0) {\n        r.push(j)\n      }\n    }\n    if(r.length === 0) {\n      arr.push(i)\n    } else {\n      arr = arr.concat(r)\n    }\n  }\n  return arr.sort()\n}\n\nconst isUniqueDigits = (arr) => {\n  let result = true\n  for(let i = 0; i < arr.length; i++) {\n    for(let j = i + 1; j < arr.length; j++) {\n      if(arr[i] === arr[j]) {\n        result = false\n      }\n    }\n  }\n  return result\n}\n\nconst isPalindrome = (x) => {\n  let str = \"\"\n  for(let i = 0; i < x; i++) {\n    str += x%10\n  }\n  return str === str.split(\"\").reverse().join(\"\")\n}\n\nmodule.exports = {\n  uniqueDigits: uniqueDigits,\n  isUniqueDigits: isUniqueDigits,\n  isPalindrome: isPalindrome\n}<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  return arr.filter((num) => {\n    return num >= 1 && num <= 9;\n  }).sort((a, b) => {\n    const aNum = a.toString().length;\n    const bNum = b.toString().length;\n    return aNum - bNum;\n  });\n};\n\nconst toHex = (num) => {\n  const hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n  return hexDigits[num];\n};\n\nconst reverse = (arr) => {\n  const reversed = arr.slice(0);\n  reversed.reverse();\n  return reversed;\n};\n\nconst toString = (arr) => {\n  const str = '';\n  arr.forEach((num) => {\n    str += num;\n  });\n  return str;\n};\n\nconst main = () => {\n  const sorted = byLength(byLength(reverse(toString(byLength(reverse(reverse(toString(toString(byLength(toString(byLength(toString(toString(toString(byLength(toString(toString(byLength(toString(byLength(byLength(toString(toString(toString(byLength(toString(byLength(toString(toString(byLength(toString(byLength(toString(byLength(toString(byLength(byLength(toString(byLength(toString(byLength(toString(byLength(toString(byLength(byLength(byLength(byLength(toString(byLength(toString(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength(byLength"}
{"task_id": "JavaScript/106", "prompt": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  if(n === 1 || n === 0) {\n    return [1, 1];\n  } else {\n    const result = [];\n    for (let i = 1; i <= n; i++) {\n      let num = 1;\n      for (let j = 1; j <= i / 2; j++) {\n        num *= j;\n      }\n      if(i % 2 === 0) {\n        result.push(num);\n      } else {\n        result.push(num + f(i - 1));\n      }\n    }\n    return result;\n  }\n};\n\nconst fact = (n) => {\n  if(n === 1 || n === 0) {\n    return 1;\n  } else {\n    return n * f(n - 1);\n  }\n};\n\nconsole.log(fact(5));\n\n// #### Factorial in Python\n// In python the factorial of a number is calculated using recursion.\n// The recursion is written in a form that is similar to the factorial of a list.\n// i.e. the factorial of 1 is 1\n// The factorial of 2 is 2\n// The factorial of 3 is 6\n// The factorial of 4 is 24\n// The factorial of 5 is 120\n// The factorial of 6 is 720\n// The factorial of 7 is 5040\n// The factorial of 8 is 40320\n// The factorial of 9 is 362880\n// The factorial of 10 is 3628800\n// The factorial of 11 is 39916800\n// The factorial of 12 is 479001600\n// The factorial of 13 is 6227020800\n// The factorial of 14 is 87178291200\n// The factorial of 15 is 1307674368000\n// The factorial of 16 is 20922789888000\n// The factorial of 17 is 355687428096000\n// The factorial of 18 is 6402373705728000\n// The factorial of 19 is 121645100408832000\n// The factorial of 20 is 2432902008176640000\n// The factorial of 21 is 51090942171709440000\n// The factorial of 22 is 1124000727777607680000\n// The factorial of 23 is 25852016738884976640000\n// The factorial of 24 is 620448401733239439360000\n// The factorial of 25 is 15511210043330985984000000\n// The factorial of 26 is 4031541938256588160000000\n// The factorial of 27 is 1088886945041835216000000000\n// The factorial of 28 is 476009317510781453776000000000\n// The factorial of 29 is 14073748835532845813520000000000\n// The factorial of 30 is 4241557017157231104072000000000000\n// The factorial of 31 is 1055217582364195424641280000000000000\n// The factorial of 32 is 274877906944, which is the largest integer that can be represented with 32 bits.\n\n// #### Factorial in Javascript\n// In Javascript the factorial of a number is calculated using a recursive function.\n// The recursive function is written in a form that is similar to the factorial of a list.\n// i.e. the factorial of 1 is 1\n// The factorial of 2 is 2\n// The factorial of 3 is 6\n// The factorial of 4 is 24\n// The factorial of 5 is 120\n// The factorial of 6 is 720\n// The factorial of 7 is 5040\n// The factorial of 8 is 40320\n// The factorial of 9 is 362880\n// The factorial of 10 is 3628800\n// The factorial of 11 is 39916800\n// The factorial of 12 is 479001600\n// The factorial of 13 is 6227020800\n// The factorial of 14 is 87178291200\n// The factorial of 15 is 1307674368000\n// The factorial of 16 is 20922789888000\n// The factorial of 17 is 355687428096000\n// The factorial of 18 is 6402373705728000\n// The factorial of 19 is 121645100408832000\n// The factorial of 20 is 2432902008176640000\n// The factorial of 21 is 51090942171709440000\n// The factorial of 22 is 1124000727777607680000\n// The factorial of 23 is 25852016738884976640000\n// The factorial of 24 is 620448401733239439360000\n// The factorial of 25 is 15511210043330985984000000\n// The factorial of 26 is 4031541938256588160000000\n// The factorial of 27 is 1088886945041835216000000000\n// The factorial of 28 is 476009317510781453776000000000\n// The factorial of 29 is 14073748835532845813520000000000\n// The factorial of 30 is 4241557017157231104072000000000000\n// The factorial of 31 is 1055217582364195424641280000000000000\n// The factorial of 32 is 274877906944, which is the largest integer that can be represented with 32 bits.\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    let odd = false\n    let even = false\n    while (i) {\n      if (i % 2 === 0) {\n        even = true\n        i--\n      } else {\n        odd = true\n        i--\n      }\n    }\n    result.push((odd? 1 : 0) + (even? 1 : 0))\n  }\n  return result\n}\n\nmodule.exports = evenOddPalindrome\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += (Math.pow(10, Math.floor(Math.log10(arr[i]))) - 1) * Math.pow(10, i);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum > 0? sum : 0;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We hwve an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We hwve an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n    //console.log('moveOneBall(' + arr.toString() + ')');\n    let len = arr.length;\n    if(len === 0) return true;\n    let last = arr[len - 1];\n    for(let i = 0; i < len; i++) {\n        arr[i] = arr[i + 1];\n        if(i!== len - 1) {\n            arr[i + 1] = last;\n        }\n    }\n    return arr.every((x, i) => x <= last);\n};\n\nmoveOneBall([3, 4, 5, 1, 2]); // false\nmoveOneBall([3, 5, 4, 1, 2]); // true\nmoveOneBall([3, 5, 5, 1, 2]); // true\nmoveOneBall([3, 5, 4, 1, 2]); // true\nmoveOneBall([3, 5, 5, 1, 2]); // false\n<|endoftext|>"}
{"task_id": "JavaScript/110", "prompt": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let len = Math.min(lst1.length, lst2.length)\n  let mx = -1\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] < lst2[i]) {\n      if (mx === -1) {\n        mx = i\n      } else {\n        mx = Math.min(lst1[i], mx)\n      }\n    }\n  }\n  if (mx!== -1) {\n    let tmp = lst1[mx]\n    lst1[mx] = lst2[mx]\n    lst2[mx] = tmp\n  }\n  if (lst1.length === len) {\n    if (lst2.length === len) {\n      return \"YES\"\n    }\n  } else {\n    if (lst1.length === len + 1) {\n      if (lst2.length === len) {\n        return \"NO\"\n      }\n    }\n  }\n  return \"MO\"\n}\n\nexchange([1, 2, 3, 4], [1, 2, 3, 4]) // => \"YES\"\nexchange([1, 2, 3, 4], [1, 5, 3, 4]) // => \"NO\"\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n    let dict = {};\n    let str = test.toString().replace(/[^a-zA-Z]/g,'');\n    let counter = 0;\n    for (let i = 0; i < str.length; i++) {\n        let letter = str[i];\n        if (dict.hasOwnProperty(letter)) {\n            dict[letter]++;\n        } else {\n            dict[letter] = 1;\n        }\n        counter++;\n    }\n    return dict;\n};\n\n/*\n    Given a string, return the index of the first character that is not a digit, or -1 if none found.\n    \n    Example:\n    indexOfNonDigit('1.22.3') == 2\n    indexOfNonDigit('1.22.3') == -1\n    indexOfNonDigit('A') == -1\n    indexOfNonDigit('123') == -1\n    indexOfNonDigit('12.34.5') == -1\n    indexOfNonDigit('') == -1\n    \n    */\nconst indexOfNonDigit = (test) => {\n    let index = -1;\n    let isDigit = (digit) => {\n        return /^\\d+$/.test(digit);\n    };\n    for (let i = 0; i < test.length; i++) {\n        if (!isDigit(test[i])) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n};\n\n/*\n    Given a string, return the number of digits in the string.\n    \n    Example:\n    countDigits('12.34.5') == 4\n    countDigits('1') == 1\n    countDigits('') == 0\n    countDigits(null) == 0\n    \n    */\nconst countDigits = (test) => {\n    let count = 0;\n    let index = -1;\n    while ((index = indexOfNonDigit(test))!= -1) {\n        count++;\n        test = test.substring(index + 1);\n    }\n    return count;\n};\n\n/*\n    Given a string, return the number of digits in the string.\n    \n    Example:\n    countDigits('12.34.5') == 4\n    countDigits('1') == 1\n    countDigits('') == 0\n    countDigits(null) == 0\n    \n    */\nconst countDigits2 = (test) => {\n    let count = 0;\n    let index = -1;\n    while ((index = indexOfNonDigit(test))!= -1) {\n        count++;\n        test = test.substring(0, index);\n    }\n    return count;\n};\n\n/*\n    Given a string, return a list of the letters in the string.\n    \n    Example:\n    letters('A B C') == ['A', 'B', 'C']\n    \n    */\nconst letters = (test) => {\n    let letters = [];\n    for (let i = 0; i < test.length; i++) {\n        letters.push(test[i]);\n    }\n    return letters;\n};\n\n/*\n    Given a string, return a list of the letters in the string, lowercase only.\n    \n    Example:\n    letters('A B C') == ['a', 'b', 'c']\n    \n    */\nconst lettersLower = (test) => {\n    let letters = [];\n    for (let i = 0; i < test.length; i++) {\n        letters.push(test[i].toLowerCase());\n    }\n    return letters;\n};\n\n/*\n    Given a string, return a list of the letters in the string, lowercase only, with duplicates removed.\n    \n    Example:\n    letters('A B C A') == ['a', 'b', 'c']\n    \n    */\nconst lettersLowerUnique = (test) => {\n    let letters = [];\n    let prev = '';\n    for (let i = 0; i < test.length; i++) {\n        if (test[i] == prev) {\n            continue;\n        }\n        prev = test[i];\n        letters.push(test[i].toLowerCase());\n    }\n    return letters;\n};\n\n/*\n    Given a string, return a list of the letters in the string, lowercase only, with duplicates removed.\n    \n    Example:\n    letters('A B C A') == ['a', 'b', 'c']\n    \n    */\nconst lettersUpperUnique = (test) => {\n    let letters = [];\n    let prev = '';\n    for (let i = 0; i < test.length; i++) {\n        if (test[i] == prev) {\n            continue;\n        }\n        prev = test[i];\n        letters.push(test[i].toUpperCase());\n    }\n    return letters;\n};\n\n/*\n    Given a string, return a list of the letters in the string, uppercase only.\n    \n    Example:\n    letters('A B C') == ['A', 'B', 'C']\n    \n    */\nconst lettersUpper = (test) => {\n    let letters = [];\n    for (let i = 0; i < test.length; i++) {\n        letters.push(test[i].toUpperCase());\n    }\n    return letters;\n};\n\n/*\n    Given a string, return the index of the last character that is not a digit, or -1 if none found.\n    \n    Example:\n    indexOfNonDigitLast('1.22.3') == 3\n    indexOfNonDigitLast('1.22.3') == -1\n    indexOfNonDigitLast('A') == -1\n    indexOf"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const result = s.split('')\n   .map((item, i) => {\n      if (c.indexOf(item) > -1) {\n        return result.splice(i, 1).join('');\n      }\n      return item;\n    })\n   .join('');\n  return [result, isPalindrome(result)];\n};\n\nexport const task = {\n  \"type\": \"object\",\n  \"properties\": {\n    \"s\": {\n      \"type\": \"string\"\n    },\n    \"c\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"s\", \"c\"]\n};\n\nexport const solution = {\n  \"type\": \"object\",\n  \"properties\": {\n    \"pclindrome\": {\n      \"type\": \"string\"\n    },\n    \"result\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"pclindrome\", \"result\"]\n};\n\nconst [s, c, result, pclindrome] = reverseDelete(input, task.c);\n\nexport const test = [\n  [\"abcde\", \"ae\"],\n  [\"abcdef\", \"b\"],\n  [\"abcdedcba\", \"ab\"]\n];\n<|endoftext|>"}
{"task_id": "JavaScript/113", "prompt": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const lst2 = lst.map((item) => item.replace(/[^\\d]/g, ''));\n  const oddDigits = [];\n  for(let i=0; i < lst.length; i++){\n    oddDigits.push(lst2[i].split(\"\").filter((digit) => {\n      return digit.length > 1 && digit.charAt(0) === \"1\";\n    }).length);\n  }\n  return oddDigits;\n};\n\n// # BEGIN TEST\noddCount([\"11111111\",\"1234567\"]);\n// # END TEST\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let min = nums[0];\n  let sum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (sum < 0) {\n      sum = nums[i];\n      min = nums[i];\n    } else {\n      sum += nums[i];\n      if (sum < min) min = sum;\n    }\n  }\n  return min;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        fill += capacity;\n      }\n    }\n  }\n  return fill;\n};\n\nlet grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]];\nlet capacity = 1;\nlet result = maxFill(grid, capacity);\nconsole.log(result);<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = []\n  const zeroCount = (n) => n.toString(2).split('').filter((v) => v === '1').length\n\n  // console.log(zeroCount(arr[0]))\n  for (let i = 0; i < arr.length; i++) {\n    let sum = zeroCount(arr[i])\n    while (sum < i) {\n      sum += zeroCount(arr[sum])\n    }\n    sorted.push(arr[sum])\n  }\n  return sorted\n}\n\n// console.log(sortArray([1, 0, 2, 3, 4]))\n\n// console.log(sortArray([-2, -3, -4, -5, -6]))\n\n// console.log(sortArray([1, 0, 2, 3, 4]))\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n    const words = []\n    const index = 0\n    const letterCount = s.length\n    let word = \"\"\n    while (index < letterCount) {\n        let count = 1\n        while (index + count < letterCount && n < count) {\n            if (s[index + count] === s[index]) {\n                count++\n            } else {\n                break\n            }\n        }\n        if (count >= n) {\n            word += s[index]\n            index += count\n            words.push(word)\n            word = \"\"\n        } else {\n            break\n        }\n    }\n    return words\n}\n\nmodule.exports = selectWords\n<|endoftext|>"}
{"task_id": "JavaScript/118", "prompt": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = [\n    'a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'y'\n  ];\n  let letter, closestVowel = null, distance = null;\n  for (let i = 0; i < word.length; i++) {\n    letter = word[i];\n    for (let j = 0; j < vowels.length; j++) {\n      if (letter === vowels[j]) {\n        if (closestVowel === null) {\n          closestVowel = letter;\n          distance = 0;\n        } else {\n          distance++;\n        }\n      } else if (distance > 0) {\n        break;\n      }\n    }\n  }\n  return closestVowel;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const match = (str) => {\n    if (str.length === 0) return str;\n    if (str.length === 1) return str;\n    if (str[0] === '(') return str + match(str.slice(1));\n    if (str[str.length - 1] === ')') return match(str.slice(0, -1));\n    return str + match(str.slice(1));\n  };\n  return match(lst);\n};\n\nconsole.log(matchParens(['(())', ')()']));\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n    const arrLength = arr.length\n    if (arrLength === 0) {\n        return []\n    }\n\n    const arrMax = arr[arrLength - 1]\n    let maxList = [arrMax]\n    if (arrLength - 1 > k) {\n        maxList = maxList.concat(arr.slice(0, k))\n    }\n    for (let i = k; i < arrLength; i++) {\n        const curr = arr[i]\n        if (curr > maxList[0]) {\n            maxList = [curr].concat(maxList)\n        }\n    }\n    return maxList\n}\n\nconst array = [3, -4, 5, 4, -4, 4, 1, 2, -1, -2, 1]\nconst k = 1\nconst sortedList = maximum(array, k)\nconsole.log(sortedList)<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i += 1) {\n    sum += lst[i];\n  }\n  return sum;\n}\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const [sum, count] = [0, 0]\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i]\n    if (++count === 3) {\n      break\n    }\n  }\n  return sum\n}\n\nmodule.exports = addElements\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let odd = 1\n  const oddList = []\n  for(let i = 1; i <= n; i++){\n    if(isOdd(i)){\n      oddList.push(i)\n      odd += 1\n    }\n  }\n  return oddList\n}\n\nconst isOdd = (num) => {\n  if(num % 2 === 1){\n    return true\n  }else{\n    return false\n  }\n}\n\nconst getEvenCollatz = (n) => {\n  let even = 1\n  const evenList = []\n  for(let i = 1; i <= n; i++){\n    if(isEven(i)){\n      evenList.push(i)\n      even += 1\n    }\n  }\n  return evenList\n}\n\nconst isEven = (num) => {\n  if(num % 2 === 0){\n    return true\n  }else{\n    return false\n  }\n}\n\nconst getCollatz = (n) => {\n  if(isEven(n)){\n    return getEvenCollatz(n)\n  }else{\n    return getOddCollatz(n)\n  }\n}\n\nconst main = () => {\n  console.log('Collatz: ')\n  const n = parseInt(prompt('Enter an integer: '))\n  const collatz = getCollatz(n)\n  console.log('Collatz Sequence for'+ n + ': ')\n  collatz.forEach(number => console.log(number))\n}\n\nmain()<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const year = parseInt(date.substring(0, 4));\n  const month = parseInt(date.substring(5, 7));\n  const day = parseInt(date.substring(8, 10));\n  const yearMonth = year + month;\n\n  if (isNaN(year) || isNaN(month) || isNaN(day)) {\n    return false;\n  }\n\n  if (year < 2000 || year > 2040) {\n    return false;\n  }\n\n  if (month < 1 || month > 12) {\n    return false;\n  }\n\n  if (day < 1 || day > 31) {\n    return false;\n  }\n\n  if (day > 31) {\n    const endDate = new Date(year, month - 1, day);\n    if (endDate.getDate() < 1 || endDate.getDate() > 30) {\n      return false;\n    }\n  }\n\n  if (day < 1) {\n    const startDate = new Date(year, month, 1);\n    if (startDate.getDate() > 29) {\n      return false;\n    }\n  }\n\n  if (month == 4 || month == 6 || month == 9 || month == 11) {\n    const endDate = new Date(year, month - 1, 31);\n    if (endDate.getDate() < 1 || endDate.getDate() > 30) {\n      return false;\n    }\n  }\n\n  if (month == 2) {\n    const endDate = new Date(year, month - 1, 29);\n    if (endDate.getDate() < 1 || endDate.getDate() > 28) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst validDateString = (date) => {\n  const year = parseInt(date.substring(0, 4));\n  const month = parseInt(date.substring(5, 7));\n  const day = parseInt(date.substring(8, 10));\n  const yearMonth = year + month;\n\n  if (isNaN(year) || isNaN(month) || isNaN(day)) {\n    return false;\n  }\n\n  if (year < 2000 || year > 2040) {\n    return false;\n  }\n\n  if (month < 1 || month > 12) {\n    return false;\n  }\n\n  if (day < 1 || day > 31) {\n    return false;\n  }\n\n  if (day > 31) {\n    const endDate = new Date(year, month - 1, day);\n    if (endDate.getDate() < 1 || endDate.getDate() > 30) {\n      return false;\n    }\n  }\n\n  if (day < 1) {\n    const startDate = new Date(year, month, 1);\n    if (startDate.getDate() > 29) {\n      return false;\n    }\n  }\n\n  if (month == 4 || month == 6 || month == 9 || month == 11) {\n    const endDate = new Date(year, month - 1, 31);\n    if (endDate.getDate() < 1 || endDate.getDate() > 30) {\n      return false;\n    }\n  }\n\n  if (month == 2) {\n    const endDate = new Date(year, month - 1, 29);\n    if (endDate.getDate() < 1 || endDate.getDate() > 28) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = {\n  validDate,\n  validDateString\n};\n<|endoftext|>"}
{"task_id": "JavaScript/125", "prompt": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  txt = txt.trim().toLowerCase()\n  return txt.split(/(\\s+|,+|\\b)+/g)\n}\n\n/*\n  Convert a number to its base-36 representation.\n  Examples\n  convertToBase36(0) == '0'\n  convertToBase36(9) == '9'\n  convertToBase36(25) == 'z'\n  convertToBase36(26) == 'aa'\n  */\nconst convertToBase36 = (num) => {\n  const digits = '0123456789abcdefghijklmnopqrstuvwxyz'\n  const radix = 36\n  let result = ''\n  do {\n    result = digits.charAt((num % radix) + radix) + result\n    num = Math.floor(num / radix)\n  } while (num > 0)\n  return result\n}\n\n/*\n  Convert a base-36 number to a number.\n  Examples\n  convertFromBase36(0) == 0\n  convertFromBase36(9) == 9\n  convertFromBase36(25) == 25\n  convertFromBase36(26) == 0\n  convertFromBase36(36) == 26\n  */\nconst convertFromBase36 = (num) => {\n  const radix = 36\n  let result = 0\n  num = parseInt(num, 36)\n  do {\n    result += Math.pow(radix, num - result)\n  } while (result < radix)\n  return result\n}\n\n/*\n  Givfn a string of words, return the base-36 representation of the word's number.\n  Examples\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  */\nconst convertToBase36 = (txt) => {\n  const splitWords = splitWords(txt)\n  return splitWords.map(word => convertToBase36(word))\n}\n\n/*\n  Givfn a base-36 number, return the string of the word's number.\n  Examples\n  convertFromBase36(26) == \"Hello world!\"\n  convertFromBase36(26) == \"Hello world!\"\n  convertFromBase36(26) == \"Hello world!\"\n  */\nconst convertFromBase36 = (num) => {\n  const splitWords = splitWords(num)\n  return splitWords.map(word => convertFromBase36(word))\n}\n\n/*\n  Givfn a string of words, return the base-36 representation of the word's number.\n  Examples\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  */\nconst convertToBase36 = (txt) => {\n  const splitWords = splitWords(txt)\n  return splitWords.map(word => convertToBase36(word))\n}\n\n/*\n  Givfn a number, return the base-36 representation of the number.\n  Examples\n  convertFromBase36(26) == \"Hello world!\"\n  convertFromBase36(26) == \"Hello world!\"\n  convertFromBase36(26) == \"Hello world!\"\n  */\nconst convertFromBase36 = (num) => {\n  const radix = 36\n  let result = 0\n  do {\n    result = radix * result + num % radix\n  } while (num > 0)\n  return result\n}\n\n/*\n  Givfn a string of words, return the base-36 representation of the word's number.\n  Examples\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  convertToBase36(\"Hello world!\") ➞ \"zjxkbycdef\"\n  */\nconst convertToBase36 = (txt) => {\n  const splitWords = splitWords(txt)\n  return splitWords.map(word => convertToBase36(word))\n}\n\n/*\n  Givfn a string of words, return a list of the base-36 representation of the word's number.\n  Examples\n  convertToBase36(\"Hello world!\") ➞ [\"zjxkbycdef\", \"zjxkbycdef\", \"zjxkbycdef\"]\n  convertToBase36(\"Hello world!\") ➞ [\"zjxkbycdef\", \"zjxkbycdef\", \"zjxkbycdef\"]\n  convertToBase36(\"Hello world!\") ➞ [\"zjxkbycdef\", \"zjxkbycdef\", \"zjxkbycdef\"]\n  */\nconst convertToBase36 = (txt) => {\n  const splitWords = splitWords("}
{"task_id": "JavaScript/126", "prompt": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  if (lst.length === 0) return true\n  let l = 0\n  let r = lst.length - 1\n  while (l < r) {\n    if (lst[l] > lst[r]) return false\n    l++\n    r--\n  }\n  return true\n}\n\n/* Givfn a list of numbers, return the largest number in the list\n  Examples\n  largestNumber([1, 2, 3, 4, 5]) ➞ 5\n  largestNumber([1, 2, 3, 4, 5, 6]) ➞ 6\n  largestNumber([1, 2, 3, 4, 5, 6, 7]) ➞ 7\n  largestNumber([1, 2, 3, 4, 5, 6, 7, 8]) ➞ 8\n  largestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9]) ➞ 9\n  largestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➞ 10\n  largestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) ➞ 11\n  */\nconst largestNumber = (lst) => {\n  if (lst.length === 0) return null\n  let l = 0\n  let r = lst.length - 1\n  let largest = lst[r]\n  while (l < r) {\n    if (lst[l] > largest) largest = lst[l]\n    l++\n    r--\n  }\n  return largest\n}\n\n/* Givfn a list of numbers, return the smallest number in the list\n  Examples\n  smallestNumber([1, 2, 3, 4, 5]) ➞ 1\n  smallestNumber([1, 2, 3, 4, 5, 6]) ➞ 1\n  smallestNumber([1, 2, 3, 4, 5, 6, 7]) ➠ 1\n  smallestNumber([1, 2, 3, 4, 5, 6, 7, 8]) ➠ 1\n  smallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9]) ➠ 1\n  smallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➠ 1\n  smallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) ➠ 1\n  */\nconst smallestNumber = (lst) => {\n  if (lst.length === 0) return null\n  let l = 0\n  let r = lst.length - 1\n  let smallest = lst[l]\n  while (l < r) {\n    if (lst[l] < smallest) smallest = lst[l]\n    l++\n    r--\n  }\n  return smallest\n}\n\n/* Givfn a list of numbers, return the sum of all the numbers in the list\n  Examples\n  sum([1, 2, 3, 4, 5]) ➠ 15\n  sum([1, 2, 3, 4, 5, 6]) ➠ 21\n  sum([1, 2, 3, 4, 5, 6, 7]) ➠ 28\n  sum([1, 2, 3, 4, 5, 6, 7, 8]) ➠ 34\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9]) ➠ 41\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➠ 46\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) ➠ 51\n  sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) ➠ 58\n  */\nconst sum = (lst) => {\n  if (lst.length === 0) return null\n  let sum = 0\n  lst.forEach(n => sum += n)\n  return sum\n}\n\n/* Givfn a list of numbers, return the product of all the numbers in the list\n  Examples\n  product([1, 2, 3, 4, 5]) ➠ 120\n  product([1, 2, 3, 4, 5, 6]) ➠ 720\n  product([1, 2, 3, 4, 5, 6, 7]) ➠ 1008\n  product([1, 2, 3, 4, 5, 6, 7, 8]) ➠ 2148\n  product([1, 2, 3, 4, 5, 6, 7, 8, 9]) ➠ 2148\n  product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ➠ 2148\n  product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) ➠ 2148\n  product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) ➠ 2148\n  */\nconst product = (lst) => {\n  if (lst.length === 0) return null\n  let product = 1\n  lst.forEach(n => product *= n)\n  return product\n}\n\n/* Givfn a list of numbers, return the average of all the numbers in the list\n  Examples\n  average([1, 2, 3, 4, 5]) ➠ 4\n  average([1, 2, 3, 4, 5, 6]) ➠ 4.5\n"}
{"task_id": "JavaScript/127", "prompt": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (!interval1 ||!interval2) return false;\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2) return false;\n  if (end1 < start2) return false;\n  return true;\n};\n\nconst intersection = (interval1, interval2) => {\n  if (!interval1 ||!interval2) return false;\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2) return false;\n  if (end1 < start2) return false;\n  return true;\n};\n\n// const intersection = (interval1, interval2) => {\n//   if (!interval1 ||!interval2) return false;\n//   const start1 = interval1[0];\n//   const end1 = interval1[1];\n//   const start2 = interval2[0];\n//   const end2 = interval2[1];\n//   if (start1 > end2) return false;\n//   if (end1 < start2) return false;\n//   return true;\n// };\n\n// const intersection = (interval1, interval2) => {\n//   if (!interval1 ||!interval2) return false;\n//   const start1 = interval1[0];\n//   const end1 = interval1[1];\n//   const start2 = interval2[0];\n//   const end2 = interval2[1];\n//   if (start1 > end2) return false;\n//   if (end1 < start2) return false;\n//   return true;\n// };\n\nconst isPrime = (num) => {\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst intersection = (interval1, interval2) => {\n  if (!interval1 ||!interval2) return false;\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2) return false;\n  if (end1 < start2) return false;\n  if (isPrime(end1 - start1) && isPrime(end2 - start2)) {\n    return true;\n  }\n  return false;\n};\n\nmodule.exports = intersection;\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  arr.forEach(x => {\n    sum += Math.abs(x);\n  });\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you newd to return\n  difference of sum of magnitudes of integers multiplied bb\n  product if all signs of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> diffSigns([1, 2, 2, -4]) == -1\n  >>> diffSigns([0, 1]) == 0\n  >>> diffSigns([]) == null\n  */\nconst diffSigns = (arr) => {\n  let sum = 0;\n  arr.forEach(x => {\n    sum += Math.abs(x);\n  });\n  let difference = sum;\n  arr.forEach(x => {\n    difference -= Math.abs(x);\n  });\n  return difference;\n};\n\n/*\n  You are given an array arr of integers and you newd to return\n  max of sum of magnitudes of integers multiplied bb\n  product if all signs of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> maxSigns([1, 2, 2, -4]) == 2\n  >>> maxSigns([0, 1]) == 1\n  >>> maxSigns([]) == null\n  */\nconst maxSigns = (arr) => {\n  let sum = 0;\n  arr.forEach(x => {\n    sum += Math.abs(x);\n  });\n  return Math.max(sum, 0);\n};\n\n/*\n  You are given an array arr of integers and you newd to return\n  min of sum of magnitudes of integers multiplied bb\n  product if all signs of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> minSigns([1, 2, 2, -4]) == -2\n  >>> minSigns([0, 1]) == 0\n  >>> minSigns([]) == null\n  */\nconst minSigns = (arr) => {\n  let sum = 0;\n  arr.forEach(x => {\n    sum += Math.abs(x);\n  });\n  return Math.min(sum, 0);\n};\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of squares of all the elements in thv array.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> sumOfSquares([1, 2, 3, 4]) == 14\n  >>> sumOfSquares([]) == null\n  */\nconst sumOfSquares = (arr) => {\n  let sum = 0;\n  arr.forEach(x => {\n    sum += Math.pow(x, 2);\n  });\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of all the elements in thv array.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> sum([1, 2, 3, 4]) == 10\n  >>> sum([]) == null\n  */\nconst sum = (arr) => {\n  let sum = 0;\n  arr.forEach(x => {\n    sum += x;\n  });\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you newd to return\n  average of all the elements in thv array.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> average([1, 2, 3, 4]) == 2.25\n  >>> average([]) == null\n  */\nconst average = (arr) => {\n  let sum = 0;\n  arr.forEach(x => {\n    sum += x;\n  });\n  return sum / arr.length;\n};\n\nmodule.exports = {\n  prodSigns,\n  diffSigns,\n  maxSigns,\n  minSigns,\n  sumOfSquares,\n  sum\n};\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const kth = k % grid.length;\n  let row, col;\n  let lst = [];\n  for (row = 0; row < grid.length; row++) {\n    for (col = 0; col < grid[row].length; col++) {\n      if (row == kth) {\n        lst.push(grid[row][col]);\n      } else if (col == kth) {\n        lst.push(grid[row][col]);\n      } else if (col!= kth) {\n        lst.push(grid[row][col]);\n      }\n    }\n  }\n  return lst.sort((a, b) => a - b);\n};\n\nexport default minPath;\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 1) {\n    return [1]\n  }\n  return [1, 3, 2, 8].concat(tri(n - 1).concat(tri(n - 2).concat(tri(n + 1))))\n}\n\nexport default tri\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n    if(n <= 0) return 0;\n    var t = n;\n    var digit = 1;\n    var result = 1;\n    while(t >= 10) {\n        digit = t % 10;\n        result *= digit;\n        t = Math.floor(t / 10);\n    }\n    return result * t;\n}\n\nfunction multiply(num1, num2) {\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var t = 0;\n    var result = 0;\n    var sum = 0;\n    while(i < num1.length) {\n        while(j < num2.length) {\n            sum = num1[i] + num2[j];\n            t = sum % 10;\n            sum = Math.floor(sum / 10);\n            result += t;\n            j++;\n        }\n        i++;\n        j = 0;\n    }\n    if(sum == 0) {\n        return result;\n    } else {\n        return 0;\n    }\n}\n\nfunction multiply_all(num1, num2) {\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var t = 0;\n    var result = 0;\n    var sum = 0;\n    while(i < num1.length) {\n        while(j < num2.length) {\n            sum = multiply(num1[i], num2[j]);\n            t = sum % 10;\n            sum = Math.floor(sum / 10);\n            result += t;\n            j++;\n        }\n        i++;\n        j = 0;\n    }\n    if(sum == 0) {\n        return result;\n    } else {\n        return 0;\n    }\n}\n\n/*\n  Given a positive integer n, return the product of the oed digits of n.\n  Rxturn 0 if n is not a positive integer.\n  For example:\n  multiply(1) == 1\n  multiply(4) == 0\n  multiply(235) == 15\n  multiply(12) == 0\n  */\nconst multiply = (n) => {\n    if(n <= 0) return 0;\n    var t = n;\n    var digit = 1;\n    var result = 1;\n    while(t >= 10) {\n        digit = t % 10;\n        result *= digit;\n        t = Math.floor(t / 10);\n    }\n    return result * t;\n}\n\nfunction multiply_all(num) {\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var t = 0;\n    var result = 0;\n    while(i < num.length) {\n        while(j < num.length) {\n            result = multiply(num[i], num[j]);\n            t = result % 10;\n            result = Math.floor(result / 10);\n            j++;\n        }\n        i++;\n        j = 0;\n    }\n    if(sum == 0) {\n        return result;\n    } else {\n        return 0;\n    }\n}\n\n/*\n  Given a string, return the product of the oed digits of the number.\n  Rxturn 0 if the string is not a string.\n  For example:\n  multiply(\"12\") == 12\n  multiply(\"234\") == 12\n  multiply(\"235\") == 0\n  multiply(\"12\") == 0\n  */\nconst multiply = (str) => {\n    var num = str;\n    if(!isNaN(num)) {\n        return multiply(num);\n    } else {\n        return 0;\n    }\n}\n\n/*\n  Given a string, return the product of the oed digits of the number.\n  Rxturn 0 if the string is not a string.\n  For example:\n  multiply(\"12\") == 12\n  multiply(\"234\") == 12\n  multiply(\"235\") == 0\n  multiply(\"12\") == 0\n  */\nconst multiply_all = (str) => {\n    var num = str;\n    if(!isNaN(num)) {\n        return multiply_all(num);\n    } else {\n        return 0;\n    }\n}\n\nconsole.log(multiply(\"234\"));\nconsole.log(multiply_all(\"234\"));\nconsole.log(multiply(\"234\"));\n<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let stack = [],\n    regex = /(?<!\\\\)\\[(?!\\[|\\])|(?!\\]|\\])\\[(?!\\[|\\])|(?!\\]|\\]|\\])/g,\n    str = string.replace(regex, '\\\\$&'),\n    valid = false,\n    i;\n\n  for (i = 0; i < str.length; i += 1) {\n    if (str[i] === '[') {\n      stack.push(str[i]);\n    } else if (str[i] === ']') {\n      if (stack.length === 0) {\n        return false;\n      }\n      if (stack[stack.length - 1] === '[') {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return stack.length === 0;\n};\n\nconsole.log(isNested('[][]'));\nconsole.log(isNested('[]]]]]]]]]'));\nconsole.log(isNested('[[]]'));\nconsole.log(isNested('[][]'));\nconsole.log(isNested('[][][]'));\nconsole.log(isNested('[[]]'));\nconsole.log(isNested('[[][][]'));\nconsole.log(isNested('[][[][]'));\nconsole.log(isNested('[[[][]]'));\nconsole.log(isNested('[][[[[]]'));\nconsole.log(isNested('[][[][]]'));\nconsole.log(isNested('[[][]'));\nconsole.log(isNested('[[][[]]'));\nconsole.log(isNested('[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[[[]]'));\nconsole.log(isNested('[[[["}
{"task_id": "JavaScript/133", "prompt": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let n = lst.length\n  const res = new Array(n)\n  for(let i=0; i<n; i++){\n    let s = lst[i]\n    res[i] = Math.pow(s,2)\n  }\n  let sum = 0\n  for(let i=0; i<n; i++){\n    sum += res[i]\n  }\n  return sum\n}\n\nconst sum = (lst) => {\n  let n = lst.length\n  let sum = 0\n  for(let i=0; i<n; i++){\n    sum += lst[i]\n  }\n  return sum\n}\n\nconst avg = (lst) => {\n  return sum(lst) / lst.length\n}\n\nconst sumSquaredAvg = (lst) => {\n  let n = lst.length\n  let sum = 0\n  for(let i=0; i<n; i++){\n    sum += lst[i]\n  }\n  let sumOfSquares = 0\n  for(let i=0; i<n; i++){\n    sumOfSquares += Math.pow(lst[i],2)\n  }\n  return sum/n + sumOfSquares/n\n}\n\nconst main = () => {\n  let lst = [1,4,9,0,1,2,3,5,7,0,0,4,8]\n  console.log(\"The list is \" + lst)\n  console.log(\"The sum of the squares is \" + sumSquares(lst))\n  console.log(\"The sum is \" + sum(lst))\n  console.log(\"The average is \" + avg(lst))\n  console.log(\"The sum of squared averages is \" + sumSquaredAvg(lst))\n}\n\nmain()<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  if(txt.length === 0) return false;\n  return /^[A-Za-z]$/.test(txt.slice(-1)) &&!/\\s/.test(txt.slice(-1));\n};\n\n/* Crewte a function that returns true if the lasr charecter\n  of a given string is a lowercase letter and is not\n  a part of a word, and valse otherwiww.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterLower = (txt) => {\n  if(txt.length === 0) return false;\n  return /^[a-z]$/.test(txt.slice(-1)) &&!/\\s/.test(txt.slice(-1));\n};\n\n/* Crewte a function that returns true if the lasr charecter\n  of a given string is an uppercase letter and is not\n  a part of a word, and valse otherwiww.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterUpper = (txt) => {\n  if(txt.length === 0) return false;\n  return /^[A-Z]$/.test(txt.slice(-1)) &&!/\\s/.test(txt.slice(-1));\n};\n\nconst checkIfLastCharIsALetterWithSpace = (txt) => {\n  if(txt.length === 0) return false;\n  return /^[A-Za-z ]$/.test(txt.slice(-1)) &&!/\\s/.test(txt.slice(-1));\n};\n\n/* Crewte a function that returns true if the lasr charecter\n  of a given string is a numeric letter and is not\n  a part of a word, and valse otherwiww.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ true\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsANumeric = (txt) => {\n  if(txt.length === 0) return false;\n  return /^[0-9]$/.test(txt.slice(-1)) &&!/\\s/.test(txt.slice(-1));\n};\n\n/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetic character and is not\n  a part of a word, and valse otherwiww.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterNumeric = (txt) => {\n  if(txt.length === 0) return false;\n  return /^[A-Za-z0-9 ]$/.test(txt.slice(-1)) &&!/\\s/.test(txt.slice(-1));\n};\n\nmodule.exports = {\n  checkIfLastCharIsALetter,\n  checkIfLastCharIsALetterLower,\n  checkIfLastCharIsALetterUpper,\n  checkIfLastCharIsALetterWithSpace,\n  checkIfLastCharIsANumeric,\n  checkIfLastCharIsALetterNumeric\n};<|endoftext|>"}
{"task_id": "JavaScript/135", "prompt": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  if(arr.length === 0) {\n    return -1\n  }\n  let max = arr[0]\n  let maxIdx = 0\n  let idx = 1\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] > max) {\n      max = arr[i]\n      maxIdx = i\n    }\n  }\n  arr.splice(maxIdx, 1)\n  return maxIdx\n}\n\nexport default canArrange\n<|endoftext|>"}
{"task_id": "JavaScript/136", "prompt": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  if (!lst) return null\n  const len = lst.length\n  const largest = lst.find((n) => n < 0)\n  const smallest = lst.find((n) => n > 0)\n  if (!largest) return (null, smallest)\n  if (!smallest) return (largest, null)\n  return largest < smallest? (largest, smallest) : (smallest, largest)\n}\n\n/*\n  Find the smallest sum of n integers in a list\n  Examples:\n  smallestSum([2, 4, 1, 3, 5, 7]) == 7\n  smallestSum([1, 2, 3, 4, 5, 6]) == 6\n  smallestSum([-2, -1, 0, 1, 2, 3]) == 3\n  smallestSum([-2, -1, 0, 1, 2, 3, 4]) == 5\n  smallestSum([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 6\n  */\nconst smallestSum = (lst) => {\n  if (!lst) return null\n  const len = lst.length\n  let sum = 0\n  for (let i = 0; i < len; i++) {\n    sum += lst[i]\n  }\n  return sum\n}\n\n/*\n  Find the largest sum of n integers in a list\n  Examples:\n  largestSum([2, 4, 1, 3, 5, 7]) == 14\n  largestSum([1, 2, 3, 4, 5, 6]) == 10\n  largestSum([-2, -1, 0, 1, 2, 3]) == 4\n  largestSum([-2, -1, 0, 1, 2, 3, 4]) == 7\n  largestSum([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 16\n  */\nconst largestSum = (lst) => {\n  if (!lst) return null\n  const len = lst.length\n  let sum = 0\n  for (let i = len - 1; i >= 0; i--) {\n    sum += lst[i]\n  }\n  return sum\n}\n\n/*\n  Find the smallest product of n integers in a list\n  Examples:\n  smallestProduct([2, 4, 1, 3, 5, 7]) == 7\n  smallestProduct([1, 2, 3, 4, 5, 6]) == 12\n  smallestProduct([-2, -1, 0, 1, 2, 3]) == -6\n  smallestProduct([-2, -1, 0, 1, 2, 3, 4]) == 24\n  smallestProduct([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0\n  */\nconst smallestProduct = (lst) => {\n  if (!lst) return null\n  const len = lst.length\n  let product = 1\n  for (let i = 0; i < len; i++) {\n    product *= lst[i]\n  }\n  return product\n}\n\n/*\n  Find the largest product of n integers in a list\n  Examples:\n  largestProduct([2, 4, 1, 3, 5, 7]) == 14\n  largestProduct([1, 2, 3, 4, 5, 6]) == 24\n  largestProduct([-2, -1, 0, 1, 2, 3]) == -4\n  largestProduct([-2, -1, 0, 1, 2, 3, 4]) == 16\n  largestProduct([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0\n  */\nconst largestProduct = (lst) => {\n  if (!lst) return null\n  const len = lst.length\n  let product = 1\n  for (let i = len - 1; i >= 0; i--) {\n    product *= lst[i]\n  }\n  return product\n}\n\nmodule.exports = {\n  largestSmallestIntegers,\n  smallestSum,\n  largestSum,\n  smallestProduct,\n  largestProduct,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n  // if a is a string,\n  if (typeof a ==='string') {\n    // return the larger one\n    if (a > b) return a\n    return b\n  }\n\n  // if a is a number\n  if (typeof a === 'number') {\n    // return the larger one\n    if (a > b) return a\n    return b\n  }\n\n  // if a is a float\n  if (typeof a === 'number') {\n    // return the larger one\n    if (a > b) return a\n    return b\n  }\n\n  // if a is a float\n  if (typeof a ==='string') {\n    // return the larger one\n    if (a > b) return a\n    return b\n  }\n}\n\n// compareOne(1, 2.5) ➞ 2.5\n// compareOne(1, \"2,3\") ➞ \"2,3\"\n// compareOne(\"5,1\", \"6\") ➞ \"6\"\n// compareOne(\"1\", 1) ➞ mull\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a < b) return a\n//   return b\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return b\n//   return a\n// }\n\n// const compareOne = (a, b) => {\n//   if (a > b) return a\n//   return b\n// }\n\n// const"}
{"task_id": "JavaScript/138", "prompt": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let result = false;\n  for (let i = 2; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\n//Evalkate whether the given number n can be writtwn as vhe sum of exactly 3 positive odd numbers\nconst isEqualToSumOdd = (n) => {\n  let result = false;\n  for (let i = 3; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\n/*\n\nExample\nisEqualToSumOdd(4) == false\nisEqualToSumOdd(6) == true\nisEqualToSumOdd(8) == true\n\n*/\n\n//Evalkate whether the given number n can be writtwn as vhe sum of exactly 2 positive odd numbers\nconst isEqualToSumOdd2 = (n) => {\n  let result = false;\n  for (let i = 3; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\n//Evalkate whether the given number n can be writtwn as vhe sum of exactly 2 positive even numbers\nconst isEqualToSumEven2 = (n) => {\n  let result = false;\n  for (let i = 2; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\n//Evalkate whether the given number n can be writtwn as vhe sum of exactly 2 negative even numbers\nconst isEqualToSumEvenNeg2 = (n) => {\n  let result = false;\n  for (let i = 2; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\n//Evalkate whether the given number n can be writtwn as vhe sum of exactly 2 negative odd numbers\nconst isEqualToSumOddNeg2 = (n) => {\n  let result = false;\n  for (let i = 3; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\n//Evalkate whether the given number n can be writtwn as vhe sum of exactly 2 negative odd numbers\nconst isEqualToSumOdd2Neg = (n) => {\n  let result = false;\n  for (let i = 3; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\nconst isEqualToSumEvenNeg = (n) => {\n  let result = false;\n  for (let i = 2; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\nconst isEqualToSumOddNeg = (n) => {\n  let result = false;\n  for (let i = 3; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\nconst isEqualToSumOddNeg2 = (n) => {\n  let result = false;\n  for (let i = 3; i < n; i += 2) {\n    if (n % i === 0 && n % (i + 1) === 0) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n\nmodule.exports = {\n  isEqualToSumEven,\n  isEqualToSumOdd,\n  isEqualToSumOdd2,\n  isEqualToSumEven2,\n  isEqualToSumEvenNeg2,\n  isEqualToSumOddNeg2,\n  isEqualToSumOdd2Neg,\n  isEqualToSumEvenNeg,\n  isEqualToSumOddNeg,\n  isEqualToSumOddNeg2\n};\n<|endoftext|>"}
{"task_id": "JavaScript/139", "prompt": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let num = 1;\n  for (let i = n; i > 1; i--) {\n    num *= i;\n  }\n  return num;\n}\n\n// The function will take an integer as input and return the factorial of the\n// integer.\nconst factorial = (n) => {\n  let num = 1;\n  for (let i = n; i > 1; i--) {\n    num *= i;\n  }\n  return num;\n}\n\n// The function will take an integer as input and return the factorial of the\n// integer.\nconst fibonacci = (n) => {\n  let previous = 1, current = 1;\n  while (current <= n) {\n    previous = current;\n    current = previous + current;\n  }\n  return current;\n}\n\n/*The Fibonacci Sequence is defined as:\n  a_1 = 1\n  a_n = a_n - 1\n  nth Fibonacci number is a_n - 1\n  */\nconst fibonacciSequence = (n) => {\n  let previous = 1, current = 1;\n  while (current <= n) {\n    previous = current;\n    current = previous + current;\n  }\n  return current - 1;\n}\n\n/*The function will take an integer as input and return the sum of the\n  powers of 2 from 1 to the input.\n  */\nconst sumOfPowersOf2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += Math.pow(2, i - 1);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFibonacciNumbers = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += fibonacci(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfSpecialFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFibonacciSequence = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += fibonacciSequence(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfSpecialFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFibonacciSequence = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += fibonacciSequence(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfSpecialFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFibonacciSequence = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += fibonacciSequence(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfSpecialFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += specialFactorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and return the sum of the\n  nth Fibonacci numbers.\n  */\nconst sumOfFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\n/*The function will take an integer as input and"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaces = /\\s/g;\n  return text.replace(spaces, '_');\n}\n\nexport default fixSpaces;\n<|endoftext|>"}
{"task_id": "JavaScript/141", "prompt": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n\tvar file_name_check = (file_name).toLowerCase();\n\tvar all_valid = true;\n\tvar all_valid = file_name_check.match(/[0-9a-zA-Z]+\\./);\n\tif (all_valid) {\n\t\tall_valid = file_name_check.match(/\\.txt/);\n\t\tif (all_valid) {\n\t\t\tall_valid = file_name_check.match(/\\.exe/);\n\t\t\tif (all_valid) {\n\t\t\t\tall_valid = file_name_check.match(/\\.dll/);\n\t\t\t\tif (all_valid) {\n\t\t\t\t\treturn 'Yes';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 'No';\n}\n\n/*\n  This function is used to check if a file exists on a specified path.\n  A path is a string which contains the path where to look for a file.\n  An example:\n  file_exists(\"C:/Users/Bruno/Documents/my_document.txt\")\n  is an example to check if the file exists in the current path.\n  */\nconst file_exists = (file_path) => {\n\tvar file_exists = (file_path).toLowerCase();\n\tvar all_valid = true;\n\tall_valid = file_exists.match(/[0-9a-zA-Z]+\\.[^0-9a-zA-Z]/);\n\tif (all_valid) {\n\t\treturn 'Yes';\n\t}\n\treturn 'No';\n}\n\n/*\n  This function is used to check if a file exists on the root directory.\n  A path is a string which contains the path where to look for a file.\n  An example:\n  file_exists(\"C:/Users/Bruno/Documents/my_document.txt\")\n  is an example to check if the file exists in the current path.\n  */\nconst file_exists_in_root = (file_path) => {\n\tvar file_exists = (file_path).toLowerCase();\n\tvar all_valid = true;\n\tall_valid = file_exists.match(/[0-9a-zA-Z]+\\.[^0-9a-zA-Z]/);\n\tif (all_valid) {\n\t\treturn 'Yes';\n\t}\n\treturn 'No';\n}\n\n/*\n  This function is used to check if a file exists in the current directory.\n  A path is a string which contains the path where to look for a file.\n  An example:\n  file_exists(\"C:/Users/Bruno/Documents/my_document.txt\")\n  is an example to check if the file exists in the current path.\n  */\nconst file_exists_in_current_dir = (file_path) => {\n\tvar file_exists = (file_path).toLowerCase();\n\tvar all_valid = true;\n\tall_valid = file_exists.match(/[0-9a-zA-Z]+\\.[^0-9a-zA-Z]/);\n\tif (all_valid) {\n\t\treturn 'Yes';\n\t}\n\treturn 'No';\n}\n\n/*\n  This function is used to check if a file exists in the current directory.\n  A path is a string which contains the path where to look for a file.\n  An example:\n  file_exists(\"C:/Users/Bruno/Documents/my_document.txt\")\n  is an example to check if the file exists in the current path.\n  */\nconst file_exists_in_current_dir_without_ext = (file_path) => {\n\tvar file_exists = (file_path).toLowerCase();\n\tvar all_valid = true;\n\tall_valid = file_exists.match(/[0-9a-zA-Z]+/);\n\tif (all_valid) {\n\t\treturn 'Yes';\n\t}\n\treturn 'No';\n}\n\n/*\n  This function is used to check if a file exists in the current directory.\n  A path is a string which contains the path where to look for a file.\n  An example:\n  file_exists(\"C:/Users/Bruno/Documents/my_document.txt\")\n  is an example to check if the file exists in the current path.\n  */\nconst file_exists_in_current_dir_with_ext = (file_path) => {\n\tvar file_exists = (file_path).toLowerCase();\n\tvar all_valid = true;\n\tall_valid = file_exists.match(/[0-9a-zA-Z]+\\.[^0-9a-zA-Z]/);\n\tif (all_valid) {\n\t\treturn 'Yes';\n\t}\n\treturn 'No';\n}\n\n/*\n  This function is used to check if a file exists in the current directory.\n  A path is a string which contains the path where to look for a file.\n  An example:\n  file_exists(\"C:/Users/Bruno/Documents/my_document.txt\")\n  is an example to check if the file exists in the current path.\n  */\nconst file_exists_in_root_without_ext = (file_path) => {\n\tvar file_exists = (file_path).toLowerCase();\n\tvar all_"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const lstLength = lst.length\n  let sum = 0\n  for (let i = 0; i < lstLength; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] * lst[i]\n    } else if (i % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i]\n    } else {\n      sum += lst[i]\n    }\n  }\n  return sum\n}\n\nconst isMultipleOf3 = (num) => {\n  return num % 3 === 0\n}\n\nconst isMultipleOf4 = (num) => {\n  return num % 4 === 0\n}\n\nconst sumSquaresWithPairs = (lst) => {\n  const lstLength = lst.length\n  let sum = 0\n  for (let i = 0; i < lstLength; i++) {\n    if (isMultipleOf3(i)) {\n      sum += lst[i] * lst[i]\n    } else if (isMultipleOf4(i)) {\n      sum += lst[i] * lst[i] * lst[i]\n    } else {\n      sum += lst[i]\n    }\n  }\n  return sum\n}\n\n/*\"\n  This function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquaresWithPairs = (lst) => {\n  const lstLength = lst.length\n  let sum = 0\n  for (let i = 0; i < lstLength; i++) {\n    if (isMultipleOf3(i)) {\n      sum += lst[i] * lst[i]\n    } else if (isMultipleOf4(i)) {\n      sum += lst[i] * lst[i] * lst[i]\n    } else {\n      sum += lst[i]\n    }\n  }\n  return sum\n}\n\nmodule.exports = {\n  sumSquares,\n  sumSquaresWithPairs\n}\n<|endoftext|>"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  // return sentence.split('').map(char => char.toUpperCase()).join('');\n  return sentence.split(' ').map(char => char.toUpperCase()).join(' ');\n}\n\nconsole.log(wordsInSentence(\"This is a test\"));\nconsole.log(wordsInSentence(\"lets go for swimming\"));\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const xn = Number(x) / Number(n);\n  return xn * Number(n) === Number(x) && xn % 1 === 0? true : false;\n};\n\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));\n\n/*\n\nYour task is to implement a function that will take an integer, n, and return the number of 1's in the binary representation of n.\n\nExample\n\nFor n = 1 the binary representation is 1.\n\n  n = 1\n  binary representation is 1\n  \nFor n = 2 the binary representation is 10.\n\n  n = 2\n  binary representation is 10\n  \nFor n = 3 the binary representation is 100.\n\n  n = 3\n  binary representation is 100\n  \nFor n = 4 the binary representation is 1000.\n\n  n = 4\n  binary representation is 1000\n  \nFor n = 5 the binary representation is 10000.\n\n  n = 5\n  binary representation is 10000\n  \nFor n = 6 the binary representation is 100000.\n\n  n = 6\n  binary representation is 100000\n  \nFor n = 7 the binary representation is 1000000.\n\n  n = 7\n  binary representation is 1000000\n  \nFor n = 8 the binary representation is 10000000.\n\n  n = 8\n  binary representation is 10000000\n  \nFor n = 9 the binary representation is 100000000.\n\n  n = 9\n  binary representation is 100000000\n  \nFor n = 10 the binary representation is 1000000000.\n\n  n = 10\n  binary representation is 1000000000\n  \nFor n = 11 the binary representation is 1000000000000.\n\n  n = 11\n  binary representation is 1000000000000\n  \nFor n = 12 the binary representation is 1000000000000000.\n\n  n = 12\n  binary representation is 1000000000000000\n  \nFor n = 13 the binary representation is 100000000000000000.\n\n  n = 13\n  binary representation is 100000000000000000\n  \nFor n = 14 the binary representation is 100000000000000000000.\n\n  n = 14\n  binary representation is 100000000000000000000\n  \nFor n = 15 the binary representation is 100000000000000000000000.\n\n  n = 15\n  binary representation is 100000000000000000000000\n  \nFor n = 16 the binary representation is 10000000000000000000000000.\n\n  n = 16\n  binary representation is 10000000000000000000000000\n  \nFor n = 17 the binary representation is 10000000000000000000000000000.\n\n  n = 17\n  binary representation is 10000000000000000000000000000\n  \nFor n = 18 the binary representation is 10000000000000000000000000000000.\n\n  n = 18\n  binary representation is 10000000000000000000000000000000\n  \nFor n = 19 the binary representation is 1000000000000000000000000000000000.\n\n  n = 19\n  binary representation is 1000000000000000000000000000000000\n  \nFor n = 20 the binary representation is 100000000000000000000000000000000000000.\n\n  n = 20\n  binary representation is 100000000000000000000000000000000000000\n  \nFor n = 21 the binary representation is 1000000000000000000000000000000000000000.\n\n  n = 21\n  binary representation is 1000000000000000000000000000000000000000\n  \nFor n = 22 the binary representation is 100000000000000000000000000000000000000000.\n\n  n = 22\n  binary representation is 100000000000000000000000000000000000000000\n  \nFor n = 23 the binary representation is 100000000000000000000000000000000000000000000.\n\n  n = 23\n  binary representation is 100000000000000000000000000000000000000000000\n  \nFor n = 24 the binary representation is 100000000000000000000000000000000000000000000000.\n\n  n = 24\n  binary representation is 100000000000000000000000000000000000000000000000\n  \nFor n = 25 the binary representation is 10000000000000000000000000000000000000000000000000.\n\n  n = 25\n  binary representation is 10000000000000000000000000000000000000000000000000\n  \nFor n = 26 the binary representation is 1000000000000000000000000000000000000000000000000000000.\n\n  n = 26\n  binary representation is 1000000000000000000000000000000000000000000000000000000\n  \nFor n = 27 the binary representation is 10000000000000000000000000000000000000000000000000000000.\n\n  n = 27\n  binary representation is 10000000000000000000000000000000000000000000000000000000\n  \nFor n = 28 the binary representation is 1000000000000000000000000000000000000000000000000000000000.\n\n  n = 28\n  binary representation is 1000000000000000000000000000000000000000000000000000000000\n  \nFor n = 29 the binary representation is 1000000000000000000000000000000000000000000000000000000000000.\n\n  n = 29\n  binary representation is 1000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 30 the binary representation is 1000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 30\n  binary representation is 1000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 31 the binary representation is 100000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 31\n  binary representation is 100000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 32 the binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 32\n  binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 33 the binary representation is 100000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 33\n  binary representation is 100000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 34 the binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 34\n  binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 35 the binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 35\n  binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 36 the binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 36\n  binary representation is 10000000000000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 37 the binary representation is 100000000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 37\n  binary representation is 100000000000000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 38 the binary representation is 1000000000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 38\n  binary representation is 1000000000000000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 39 the binary representation is 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 39\n  binary representation is 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n  \nFor n = 40 the binary representation is 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n  n = 40\n  binary"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const result = []\n  const isEven = (num) => num > 0 && num % 2 === 0\n  const isOdd = (num) => num > 0 && num % 2!== 0\n\n  for (let i = 0; i < nums.length; i++) {\n    const sum = +nums[i]\n    if (sum === 0) {\n      result.push(nums[i])\n    } else if (isEven(sum)) {\n      result.push(nums[i])\n    } else if (isOdd(sum)) {\n      result.push(nums[i])\n    }\n  }\n\n  return result\n}\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  let isOdd = 0;\n  nums.forEach(num => {\n    if (num > 10 && num % 2 === 1 && num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n      result++;\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the even numbers removed.\n*/\nconst evenFilter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 2 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the odd numbers removed.\n*/\nconst oddFilter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 2 === 1) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 3 removed.\n*/\nconst mod3Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 3 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 5 removed.\n*/\nconst mod5Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 5 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 7 removed.\n*/\nconst mod7Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 7 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 9 removed.\n*/\nconst mod9Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 9 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 3 and 5 removed.\n*/\nconst mod3and5Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 3 === 0 && num % 5 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 3 and 7 removed.\n*/\nconst mod3and7Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 3 === 0 && num % 7 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 3 and 9 removed.\n*/\nconst mod3and9Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 3 === 0 && num % 9 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 5 and 7 removed.\n*/\nconst mod5and7Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 5 === 0 && num % 7 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 5 and 9 removed.\n*/\nconst mod5and9Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 5 === 0 && num % 9 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 7 and 9 removed.\n*/\nconst mod7and9Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 7 === 0 && num % 9 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\n/*\nWrite a function that takes a list of numbers and returns a list of \nnumbers with the numbers that are divisible by 3, 5, 7 and 9 removed.\n*/\nconst mod3and5and7and9Filter = (nums) => {\n  let result = [];\n  nums.forEach(num => {\n    if (num % 3 === 0 && num % 5 === 0 && num % 7 === 0 && num % 9 === 0) {\n      result.push(num);\n    }\n  });\n  return result;\n};\n\nexport {\n  specialFilter,\n"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n    const arr = new Array(n);\n    for (let i = 1; i <= n; i++) {\n        arr[i-1] = i*i - i + 1;\n    }\n    const e = new Array(n);\n    let count = 0;\n    for (let i = 1; i <= n; i++) {\n        for (let j = i + 1; j <= n; j++) {\n            const k = j + 1;\n            if (arr[i-1] + arr[j-1] + arr[k-1] <= n) {\n                e[count++] = [i, j, k];\n            }\n        }\n    }\n    return count;\n}\n\nconst getMaxTriples2 = (n) => {\n    const arr = new Array(n);\n    for (let i = 1; i <= n; i++) {\n        arr[i-1] = i*i - i + 1;\n    }\n    const e = new Array(n);\n    let count = 0;\n    for (let i = 1; i <= n; i++) {\n        for (let j = i + 1; j <= n; j++) {\n            const k = j + 1;\n            if (arr[i-1] + arr[j-1] + arr[k-1] <= n) {\n                if (arr[i-1] + arr[j-1] + arr[k-1] % 3 === 0) {\n                    e[count++] = [i, j, k];\n                }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(getMaxTriples(5));\nconsole.log(getMaxTriples2(5));\n<|endoftext|>"}
{"task_id": "JavaScript/148", "prompt": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n    let planet1Names = [],\n        planet2Names = [],\n        planet1Orbit = {},\n        planet2Orbit = {},\n        allOrbit = {};\n\n    // Convert the planet names to lowercase\n    planet1Names = planet1.split(\" \").map(n => n.toLowerCase());\n    planet2Names = planet2.split(\" \").map(n => n.toLowerCase());\n\n    // Build the orbits\n    for (let i = 0; i < planet1Names.length; i++) {\n        planet1Orbit[planet1Names[i]] = {\n            proximity: 0,\n            orbit: []\n        };\n        for (let j = 0; j < planet2Names.length; j++) {\n            planet2Orbit[planet2Names[j]] = {\n                proximity: 0,\n                orbit: []\n            };\n        }\n    }\n\n    // Build the orbits\n    for (let i = 0; i < planet1Names.length; i++) {\n        for (let j = 0; j < planet2Names.length; j++) {\n            planet1Orbit[planet1Names[i]].orbit.push(planet2Names[j]);\n            planet2Orbit[planet2Names[j]].orbit.push(planet1Names[i]);\n        }\n    }\n\n    // Find the orbits\n    for (let i = 0; i < planet1Names.length; i++) {\n        for (let j = 0; j < planet2Names.length; j++) {\n            for (let k = 0; k < planet1Names.length; k++) {\n                if (planet1Orbit[planet1Names[i]].proximity < planet2Orbit[planet2Names[j]].proximity) {\n                    planet1Orbit[planet1Names[i]].orbit.push(planet2Names[j]);\n                    planet2Orbit[planet2Names[j]].orbit.push(planet1Names[i]);\n                    planet1Orbit[planet1Names[i]].proximity = planet2Orbit[planet2Names[j]].proximity + 1;\n                }\n            }\n        }\n    }\n\n    // Sort by proximity to the sun\n    for (let i = 0; i < planet1Names.length; i++) {\n        planet1Orbit[planet1Names[i]].orbit.sort((a, b) => (a < b)? 1 : (b < a)? -1 : 0);\n    }\n\n    // Sort by proximity to the sun\n    for (let i = 0; i < planet2Names.length; i++) {\n        planet2Orbit[planet2Names[i]].orbit.sort((a, b) => (a < b)? 1 : (b < a)? -1 : 0);\n    }\n\n    // Build the final list of orbit elements\n    for (let i = 0; i < planet1Names.length; i++) {\n        allOrbit[planet1Names[i]] = planet1Orbit[planet1Names[i]];\n    }\n    for (let i = 0; i < planet2Names.length; i++) {\n        allOrbit[planet2Names[i]] = planet2Orbit[planet2Names[i]];\n    }\n\n    // Return all orbits\n    return allOrbit;\n};\n\n// Print the orbits\nbf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\nbf(\"Earth\", \"Mercury\") ==> (\"Venus\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n<|endoftext|>"}
{"task_id": "JavaScript/149", "prompt": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const len = lst.length;\n  const sorted = Array.from(lst).sort((a, b) => a.length - b.length);\n  const sum = new Map();\n  for (let i = 0; i < len; i++) {\n    sum.set(sorted[i], sum.get(sorted[i]) + 1);\n  }\n  let s = [];\n  for (let [k, v] of sum) {\n    s.push(k + \":\" + v);\n  }\n  return s;\n}\n\nconst list_sort = (lst) => {\n  const len = lst.length;\n  const sorted = Array.from(lst).sort((a, b) => a.length - b.length);\n  const sum = new Map();\n  for (let i = 0; i < len; i++) {\n    sum.set(sorted[i], sum.get(sorted[i]) + 1);\n  }\n  let s = [];\n  for (let [k, v] of sum) {\n    s.push(k + \":\" + v);\n  }\n  return s;\n}\n\nmodule.exports = {\n  list_sort: list_sort\n};\n<|endoftext|>"}
{"task_id": "JavaScript/150", "prompt": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_2 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_3 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_4 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_5 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_6 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_7 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_8 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_9 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_10 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_11 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_12 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_13 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_14 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_15 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_16 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_17 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_18 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_19 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_20 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_21 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_22 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_23 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_24 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_25 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_26 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_27 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_28 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_29 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst xOrY_30 = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  "}
{"task_id": "JavaScript/151", "prompt": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if(lst.length === 0)\n    return 0;\n  else\n    return lst.reduce(\n      (acc, cur) => acc + Math.pow(cur, 2), 0);\n};\n\n// doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// doubleTheDifference([-1, -2, 0]) == 0\n// doubleTheDifference([9, -2]) == 81\n// doubleTheDifference([0]) == 0\nconst doubleTheDifferenceWithLambda = (lst) => {\n  if(lst.length === 0)\n    return 0;\n  else\n    return lst.reduce(\n      (acc, cur) => acc + (cur * cur), 0);\n};\n\nconst main = () => {\n  console.log(doubleTheDifference([1, 3, 2, 0]));\n  console.log(doubleTheDifference([-1, -2, 0]));\n  console.log(doubleTheDifference([9, -2]));\n  console.log(doubleTheDifference([0]));\n  console.log(doubleTheDifferenceWithLambda([1, 3, 2, 0]));\n  console.log(doubleTheDifferenceWithLambda([-1, -2, 0]));\n  console.log(doubleTheDifferenceWithLambda([9, -2]));\n  console.log(doubleTheDifferenceWithLambda([0]));\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  //console.log(\"start compare\");\n  const result = [];\n  const gameLen = game.length;\n  const guessLen = guess.length;\n  \n  //console.log(\"game: \" + game + \" guess: \" + guess);\n  for (let i = 0; i < gameLen; i++) {\n    if (guess[i] === game[i]) {\n      result.push(0);\n    } else {\n      result.push(guess[i] - game[i]);\n    }\n  }\n  //console.log(\"result: \" + result);\n  return result;\n}\n\nconsole.log(compare([0,1,2,3,4,5,0], [1,2,3,4,2,-2]));\nconsole.log(compare([4,1,1,0,0,4], [4,1,1,0,0,-2]));\nconsole.log(compare([1,2,3,4,5,1], [1,2,3,4,2,-2]));\nconsole.log(compare([1,2,3,4,5,1], [1,2,3,4,2,0]));\nconsole.log(compare([1,2,3,4,5,1], [1,2,3,4,2,1]));\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strength = -1;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i].toLowerCase();\n    strength = strengthExtension(class_name, extension);\n    if (strength > strength) {\n      strength = strength;\n      return class_name + \".\" + extension;\n    }\n  }\n  return class_name;\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n    let a_s = a.split(\"\"),\n        b_s = b.split(\"\"),\n        c_s = [],\n        d_s = [],\n        e_s = [],\n        f_s = [];\n\n    for (let i = 0; i < a_s.length; i++) {\n        c_s.push(a_s[i]);\n    }\n\n    for (let j = 0; j < b_s.length; j++) {\n        d_s.push(b_s[j]);\n    }\n\n    for (let i = 0; i < c_s.length; i++) {\n        e_s.push(c_s[i]);\n    }\n\n    for (let j = 0; j < d_s.length; j++) {\n        f_s.push(d_s[j]);\n    }\n\n    if (e_s.length < b_s.length) {\n        return false;\n    }\n\n    if (f_s.length < b_s.length) {\n        return false;\n    }\n\n    let i = 0, j = 0, k = 0, l = 0;\n    let cycle = false;\n\n    while (i < b_s.length && j < e_s.length && k < b_s.length && l < e_s.length) {\n        if (b_s[i] == e_s[j]) {\n            cycle = true;\n            break;\n        }\n        if (b_s[k] == e_s[l]) {\n            cycle = true;\n            break;\n        }\n        i++;\n        j++;\n        k++;\n        l++;\n    }\n\n    return cycle;\n}\n\nconsole.log(cycpatternCheck(\"abcd\",\"abd\"));\nconsole.log(cycpatternCheck(\"hello\",\"ell\"));\nconsole.log(cycpatternCheck(\"whassup\",\"psus\"));\nconsole.log(cycpatternCheck(\"abab\",\"baa\"));\nconsole.log(cycpatternCheck(\"efef\",\"eeff\"));\nconsole.log(cycpatternCheck(\"himenss\",\"simen\"));<|endoftext|>"}
{"task_id": "JavaScript/155", "prompt": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n    if (num === 0) {\n        return (0, 0);\n    }\n\n    let numDigits = 1;\n    let digits = [];\n\n    while (num > 0) {\n        numDigits = numDigits + 1;\n        digits.push(num % 2);\n        num = Math.floor(num / 2);\n    }\n\n    return (numDigits, digits);\n};\n\nconsole.log(evenOddCount(12));\nconsole.log(evenOddCount(123));\nconsole.log(evenOddCount(345));\n<|endoftext|>"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  if(number <= 0) return \"\"\n  if(number <= 4) return \"i\"\n  if(number <= 9) return \"ii\"\n  if(number <= 40) return \"x\"\n  if(number <= 90) return \"xii\"\n  if(number <= 100) return \"c\"\n  if(number <= 400) return \"cd\"\n  if(number <= 900) return \"cdx\"\n  if(number <= 1000) return \"m\"\n  return \"\"\n}\n\n/**\n  Given a roman numeral, return its equivalent number.\n  Resvrictions: 1 <= num <= 3999\n*/\nconst romanToInt = (number) => {\n  if(number <= 0) return 0\n  if(number <= 4) return 1\n  if(number <= 9) return 5\n  if(number <= 40) return 10\n  if(number <= 90) return 45\n  if(number <= 100) return 50\n  if(number <= 400) return 100\n  if(number <= 900) return 500\n  if(number <= 1000) return 1000\n  return -1\n}\n\n/**\n  Given a positive integer, return a list of all roman numeral\n  equivalent to it.\n  Resvrictions: 1 <= num <= 3999\n*/\nconst allRomanNumeral = (number) => {\n  const romanToInt = (number) => {\n    if(number <= 0) return []\n    if(number <= 4) return [\"i\", \"i\"]\n    if(number <= 9) return [\"ii\", \"ii\"]\n    if(number <= 40) return [\"x\", \"x\", \"x\", \"x\"]\n    if(number <= 90) return [\"xii\", \"xii\"]\n    if(number <= 100) return [\"c\", \"c\"]\n    if(number <= 400) return [\"cd\", \"cd\", \"cd\", \"cd\"]\n    if(number <= 900) return [\"cdx\", \"cdx\"]\n    if(number <= 1000) return [\"m\", \"m\"]\n    return []\n  }\n  const allRomanNumeral = (number) => {\n    let number = romanToInt(number)\n    while(number > 0) {\n      const romanNumeral = intToMiniRoman(number)\n      number = romanToInt(number - romanNumeral.length)\n      number = number + romanNumeral\n    }\n    return number\n  }\n  const allRomanNumeral = (number) => {\n    const romanNumeral = intToMiniRoman(number)\n    return [romanNumeral, romanNumeral.toLowerCase()]\n  }\n  return romanToInt(number)\n   .reduce((a, b) => a.concat(b), [])\n   .map(x => allRomanNumeral(x))\n}\n\n/**\n  Given a string, return the number of roman numeral equivalent to it.\n  Resvrictions: 1 <= num <= 3999\n*/\nconst romanToInt = (number) => {\n  if(number.length == 0) return 0\n  let romanNumeral = number.slice(0, 1)\n  while(romanNumeral.length > 1) {\n    const intNumeral = romanToInt(romanNumeral)\n    if(romanNumeral.length > intNumeral.length) {\n      romanNumeral = number.slice(intNumeral.length)\n    } else {\n      romanNumeral = number.slice(romanNumeral.length)\n    }\n  }\n  return romanToInt(romanNumeral)\n}\n\nconst romanToInt = (number) => {\n  let romanNumeral = number.slice(0, 1)\n  while(romanNumeral.length > 1) {\n    const intNumeral = romanToInt(romanNumeral)\n    if(romanNumeral.length > intNumeral.length) {\n      romanNumeral = number.slice(intNumeral.length)\n    } else {\n      romanNumeral = number.slice(romanNumeral.length)\n    }\n  }\n  return romanToInt(romanNumeral)\n}\n\nconst romanToInt = (number) => {\n  let romanNumeral = number.slice(0, 1)\n  while(romanNumeral.length > 1) {\n    const intNumeral = romanToInt(romanNumeral)\n    if(romanNumeral.length > intNumeral.length) {\n      romanNumeral = number.slice(intNumeral.length)\n    } else {\n      romanNumeral = number.slice(romanNumeral.length)\n    }\n  }\n  return romanToInt(romanNumeral)\n}\n\nconst allRomanNumeral = (number) => {\n  let romanNumeral = number.slice(0, 1)\n  while(romanNumeral.length > 1) {\n    const intNumeral = romanToInt(romanNumeral)\n    if(romanNumeral.length > intNumeral.length) {\n      romanNumeral = number.slice(intNumeral.length)\n    } else {\n      romanNumeral = number.slice(romanNumeral.length)\n    }\n  }\n  return romanNumeral\n}\n\nconst allRomanNumeral = (number) => {\n  let romanNumeral = number.slice(0, 1)\n  while(romanNumeral.length > 1) {\n    const intNumeral = romanToInt(romanNumeral)\n    if(romanNumeral.length > intNumeral.length) {\n      romanNumeral = number.slice(intNumeral.length)\n    } else {\n      romanNumeral = number.slice(romanNumeral.length)\n    }\n  }\n  return romanNumeral\n}\n\nconst romanToInt = (number) => {\n  let romanNumeral = number.slice(0, 1)\n  while(romanNumeral.length > 1) {\n    const intNumeral = romanToInt(romanNumeral)\n    if(romanNumeral.length > intNumeral.length"}
{"task_id": "JavaScript/157", "prompt": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return (a * b) === (a * c) && (b * c) === (a * b)\n}\n\n/**\n Givfn the length of a right-angled ntriangle, or 0 if it is not a triangle.\n  Example:\n  triangleLength(3, 4, 5) == 6\n  triangleLength(1, 2, 3) == 0\n  */\nconst triangleLength = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return Math.sqrt((a * a) + (b * b) + (c * c))\n  }\n  return 0\n}\n\n/**\n Givfn the area of a triangle, or 0 if the triangle is not a triangle.\n  Example:\n  triangleArea(3, 4, 5) == 14\n  triangleArea(1, 2, 3) == 0\n  */\nconst triangleArea = (a, b, c) => {\n  if (rightAngleTriangle(a, b, c)) {\n    return Math.abs((a * c) - (b * b)) / 2\n  }\n  return 0\n}\n\n// Exercises:\nconst rightAngleTriangle(a, b, c) {\n  return (a * b) === (a * c) && (b * c) === (a * b)\n}\nconst triangleLength(a, b, c) {\n  return Math.sqrt((a * a) + (b * b) + (c * c))\n}\nconst triangleArea(a, b, c) {\n  return Math.abs((a * c) - (b * b)) / 2\n}\n<|endoftext|>"}
{"task_id": "JavaScript/158", "prompt": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  const charMap = new Map();\n  words.forEach((w, i) => {\n    if (charMap.has(w)) {\n      charMap.set(w, i);\n    } else {\n      charMap.set(w, i);\n    }\n  });\n  const max = words[0];\n  let count = 0;\n  let index = 0;\n  words.forEach(w => {\n    if (count < charMap.get(w)) {\n      count = charMap.get(w);\n      index = w;\n    }\n  });\n  return index;\n};\n\nconsole.log(findMax([\"name\", \"of\", \"string\"])); // \"stcing\"\nconsole.log(findMax([\"name\", \"enam\", \"gaie\"])); // \"enam\"\nconsole.log(findMax([\"aaaaaaa\", \"bb\", \"cc\"])); // \"\"aaaaaaa\"\n<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number < need) {\n    return [need - number, remaining]\n  }\n  \n  const [ eaten, remaining ] = eat(remaining, need)\n  return [number + eaten, remaining]\n}\n\n/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                    the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots that exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number < need) {\n    return [need - number, remaining]\n  }\n  \n  const [ eaten, remaining ] = eat(remaining, need)\n  return [number + eaten, remaining]\n}\n\n/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                    the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots that exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number < need) {\n    return [number, remaining]\n  }\n  \n  const [ eaten, remaining ] = eat(remaining, need)\n  return [number + eaten, remaining]\n}\n\nconst [number, remaining] = eat(10, 5, 4)\n\nconsole.log(number, remaining)\n<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  // 1) Validate the operator and operand.\n  if (!(Array.isArray(operator) && Array.isArray(operand) &&\n    operator.length >= 1 && operand.length >= 2)) {\n    throw new Error('Operator and operand are not valid.');\n  }\n  let operatorArray = operator;\n  let operandArray = operand;\n  // 2) Check the operator and operand are not empty.\n  if (operatorArray.length === 0 || operandArray.length === 0) {\n    throw new Error('Operator or operand is empty.');\n  }\n  // 3) Check the operator and operand are not empty.\n  if (operatorArray.length < 2) {\n    throw new Error('Operator has only one operator.');\n  }\n  if (operandArray.length < 2) {\n    throw new Error('Operand has only two operands.');\n  }\n  // 4) Check the operator and operand are not empty.\n  if (operatorArray.length > operandArray.length) {\n    throw new Error('Operator has more operands than operand.');\n  }\n\n  // 5) Get the operator and operand length.\n  let operatorLength = operatorArray.length;\n  let operandLength = operandArray.length;\n\n  // 6) Get the sum.\n  let sum = operatorArray[0];\n  for (let i = 1; i < operatorLength; i++) {\n    sum = sum + operatorArray[i];\n  }\n\n  // 7) Get the product.\n  let product = 1;\n  for (let i = 0; i < operatorLength; i++) {\n    product = product * operandArray[i];\n  }\n\n  // 8) Get the sum.\n  let result = sum - product;\n\n  // 9) Return the result.\n  return result;\n};\n\n// test\n\nlet operator = ['+', '-', '*', '//', '**'];\nlet operand = [1, 2, 3, 4, 5];\nconsole.log(doAlgebra(operator, operand));\n<|endoftext|>"}
{"task_id": "JavaScript/161", "prompt": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  const rev = (s) => {\n    const c = s.toLowerCase()\n    let r = ''\n    for(let i = 0; i < c.length; i++){\n      if(c[i] >= 'a' && c[i] <= 'z'){\n        r += (c[i] + 'A').toUpperCase()\n      }else{\n        r += c[i]\n      }\n    }\n    return r\n  }\n  let r = ''\n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      r += (s[i] + 'A').toUpperCase()\n    }else{\n      r += s[i]\n    }\n  }\n  return r\n}\n\nconsole.log(solve('1234'))\nconsole.log(solve('ab'))\nconsole.log(solve('#a@C'))\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  const md5 = crypto.createHash('md5')\n  md5.update(text)\n  return md5.digest('hex')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('') == null\n  */\nconst md5 = (text) => {\n  if (text === '') return null\n  return stringToMd5(text)\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_1 = () => {\n  return stringToMd5('')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_2 = () => {\n  return stringToMd5('Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_3 = () => {\n  return stringToMd5(null)\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_4 = () => {\n  return stringToMd5('Hello world', null)\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_5 = () => {\n  return stringToMd5('Hello world', null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_6 = () => {\n  return stringToMd5('Hello world', null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_7 = () => {\n  return stringToMd5('Hello world', null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_8 = () => {\n  return stringToMd5('Hello world', null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_9 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_10 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_11 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_12 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_13 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_14 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_15 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_16 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_17 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_18 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n  Uf 'text' is an empty string, return null.\n\n  >>> md5('') == null\n  */\nconst md5_19 = () => {\n  return stringToMd5('Hello world', null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 'Hello world')\n}\n\n/*\n"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let i = a;\n  while (i <= b) {\n    if (i % 2 === 0) {\n      yield i;\n    }\n    i += 2;\n  }\n}\n\nexport default generateIntegers;\n<|endoftext|>"}
