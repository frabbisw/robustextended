{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each otehr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Check if in given list of numbers, are any two numbers closer to each otehr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  let closest = null;\n  let dist = null;\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        if (closest === null) {\n          closest = [numbers[i], numbers[j]];\n          dist = Math.abs(numbers[i] - numbers[j]);\n        } else if (Math.abs(numbers[i] - numbers[j]) < dist) {\n          closest = [numbers[i], numbers[j]];\n          dist = Math.abs(numbers[i] - numbers[j]);\n        }\n      }\n    }\n  }\n  return closest!== null;\n};\n\n/**\n  * Finds the minimum of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The minimum number.\n  */\nconst minimum = (numbers) => {\n  let min = numbers[0];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n    }\n  }\n  return min;\n};\n\n/**\n  * Finds the maximum of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The maximum number.\n  */\nconst maximum = (numbers) => {\n  let max = numbers[0];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n    }\n  }\n  return max;\n};\n\n/**\n  * Finds the median of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The median.\n  */\nconst median = (numbers) => {\n  let total = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    total += numbers[i];\n  }\n  return total / numbers.length;\n};\n\n/**\n  * Finds the mode of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The mode.\n  */\nconst mode = (numbers) => {\n  let max = 0;\n  let mode = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      mode = i;\n    }\n  }\n  return mode;\n};\n\n/**\n  * Finds the standard deviation of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The standard deviation.\n  */\nconst standardDeviation = (numbers) => {\n  let mean = 0;\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    mean += numbers[i];\n    sum += numbers[i] * numbers[i];\n  }\n  mean /= numbers.length;\n  let variance = sum / numbers.length - mean * mean;\n  return Math.sqrt(variance);\n};\n\n/**\n  * Finds the mean of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The mean.\n  */\nconst mean = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum / numbers.length;\n};\n\n/**\n  * Finds the mode of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The mode.\n  */\nconst mode = (numbers) => {\n  let max = 0;\n  let mode = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      mode = i;\n    }\n  }\n  return mode;\n};\n\n/**\n  * Finds the mode of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The mode.\n  */\nconst mode = (numbers) => {\n  let max = 0;\n  let mode = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      mode = i;\n    }\n  }\n  return mode;\n};\n\n/**\n  * Finds the mode of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The mode.\n  */\nconst mode = (numbers) => {\n  let max = 0;\n  let mode = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      mode = i;\n    }\n  }\n  return mode;\n};\n\n/**\n  * Finds the mode of a list of numbers.\n  * @param {Array} numbers - The list of numbers.\n  * @returns {number} The mode.\n  */\nconst mode = (numbers) => {\n  let max = 0;\n  let mode = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      mode = i;\n    }\n"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let paren_stack = [],\n    last_paren = 0,\n    paren_index = 0,\n    is_open = false,\n    is_close = false,\n    is_paren = false,\n    start_index,\n    end_index,\n    paren_string_array = [],\n    index,\n    start_index_for_paren;\n\n  // first remove the space\n  paren_string = paren_string.replace(/ /g, '');\n  // then remove the open and close parens\n  paren_string = paren_string.replace(/[()]/g, '');\n\n  // first find the opening and closing parens\n  paren_string = paren_string.replace(/\\(([^()]*)\\)/g, (match, group) => {\n    if (is_open) {\n      paren_stack.push(group);\n    } else if (is_close) {\n      paren_stack.pop();\n      paren_string_array.push(paren_stack.pop());\n      last_paren = paren_stack.length - 1;\n      is_open = false;\n      is_close = false;\n    } else {\n      if (last_paren > -1) {\n        paren_string_array[last_paren] += group;\n      } else {\n        paren_string_array.push(group);\n      }\n    }\n  });\n\n  // now find the open and close parens\n  paren_string = paren_string.replace(/\\[\\(([^()]*)\\)/g, (match, group) => {\n    if (is_open) {\n      paren_stack.push(group);\n    } else if (is_close) {\n      paren_stack.pop();\n      paren_string_array.push(paren_stack.pop());\n      last_paren = paren_stack.length - 1;\n      is_open = false;\n      is_close = false;\n    } else {\n      if (last_paren > -1) {\n        paren_string_array[last_paren] += group;\n      } else {\n        paren_string_array.push(group);\n      }\n    }\n  });\n\n  // now find the close and open parens\n  paren_string = paren_string.replace(/\\[\\]\\(([^()]*)\\)/g, (match, group) => {\n    if (is_open) {\n      paren_stack.push(group);\n    } else if (is_close) {\n      paren_stack.pop();\n      paren_string_array.push(paren_stack.pop());\n      last_paren = paren_stack.length - 1;\n      is_open = false;\n      is_close = false;\n    } else {\n      if (last_paren > -1) {\n        paren_string_array[last_paren] += group;\n      } else {\n        paren_string_array.push(group);\n      }\n    }\n  });\n\n  // finally find the nested parens\n  paren_string = paren_string.replace(/\\[\\[([^()]*)\\]\\]/g, (match, group) => {\n    if (is_open) {\n      paren_stack.push(group);\n    } else if (is_close) {\n      paren_stack.pop();\n      paren_string_array.push(paren_stack.pop());\n      last_paren = paren_stack.length - 1;\n      is_open = false;\n      is_close = false;\n    } else {\n      if (last_paren > -1) {\n        paren_string_array[last_paren] += group;\n      } else {\n        paren_string_array.push(group);\n      }\n    }\n  });\n\n  return paren_string_array;\n};\n\nconsole.log(separateParenGroups('[()][()][()](()])'));\n\n// Output:\n// [()]\n// [()]\n// [()]\n// []\n<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const numberParts = number.toString().split('.');\n  let numberIntPart = numberParts[0];\n  let numberDecPart = numberParts[1];\n  if (numberDecPart.length > 0) {\n    numberDecPart = numberDecPart.substr(0, 1);\n  }\n  return numberDecPart;\n};\n\nexport default truncateNumber;\n<|endoftext|>"}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const map = {\n    'withdrawal': -1,\n    'deposit': 1\n  };\n  let curr = 0;\n  const getCurr = () => curr;\n  const updateCurr = (curr = 0) => curr;\n  const getPrev = () => 0;\n\n  return operations.reduce((prev, curr) => {\n    if (map[curr] < 0) {\n      const prev = getPrev();\n      if (prev < 0) {\n        updateCurr(curr);\n        return true;\n      }\n      updateCurr(curr);\n      return prev < 0;\n    }\n    return false;\n  }, false);\n};\n\nconsole.log(belowZero([1, 2, -4, 5]));\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const sum = numbers.reduce((acc, x) => acc + x, 0);\n  const mean = sum / numbers.length;\n\n  return (number) => Math.abs(number - mean);\n};\n\n/*\n  For a given list of input numbers, caclulate Median.\n  Median is the number that is in the middle of the list.\n  >>> median([1, 2, 3, 4, 5])\n  3\n  >>> median([1, 2, 3, 4, 5, 6])\n  4\n  */\nconst median = (numbers) => {\n  const sorted = numbers.sort();\n\n  return sorted[Math.floor(numbers.length / 2)];\n};\n\n/*\n  For a given list of input numbers, caclulate Mode.\n  Mode is the most frequent number.\n  >>> mode([1, 2, 3, 4, 5])\n  5\n  >>> mode([1, 2, 3, 4, 5, 6])\n  5\n  */\nconst mode = (numbers) => {\n  const frequency = (number) => {\n    return numbers.filter(x => x === number).length;\n  };\n\n  return Math.max.apply(null, frequency(numbers[0]));\n};\n\n/*\n  For a given list of input numbers, caclulate Standard Deviation.\n  Standard Deviation is the average of the absolute difference between a\n  aech element and the mean of the dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  2.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = meanAbsoluteDeviation(numbers);\n\n  return (number) => {\n    return Math.abs(number - mean(number));\n  };\n};\n\n/*\n  For a given list of input numbers, caclulate Standard Deviation.\n  Standard Deviation is the average of the absolute difference between a\n  aech element and the mean of the dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  2.0\n  */\nconst standardDeviation2 = (numbers) => {\n  const mean = median(numbers);\n\n  return (number) => {\n    return Math.abs(number - mean(number));\n  };\n};\n\n/*\n  For a given list of input numbers, caclulate Standard Deviation.\n  Standard Deviation is the average of the absolute difference between a\n  aech element and the mean of the dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  2.0\n  */\nconst standardDeviation3 = (numbers) => {\n  const mean = mode(numbers);\n\n  return (number) => {\n    return Math.abs(number - mean(number));\n  };\n};\n\n/*\n  For a given list of input numbers, caclulate Standard Deviation.\n  Standard Deviation is the average of the absolute difference between a\n  aech element and the mean of the dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  2.0\n  */\nconst standardDeviation4 = (numbers) => {\n  const mean = meanAbsoluteDeviation(numbers);\n  const standardDeviation = standardDeviation2(numbers);\n\n  return (number) => {\n    return Math.abs(number - mean(number)) + standardDeviation(number);\n  };\n};\n\n/*\n  For a given list of input numbers, caclulate Standard Deviation.\n  Standard Deviation is the average of the absolute difference between a\n  aech element and the mean of the dataset.\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  2.0\n  */\nconst standardDeviation5 = (numbers) => {\n  const mean = median(numbers);\n  const standardDeviation = standardDeviation3(numbers);\n\n  return (number) => {\n    return Math.abs(number - mean(number)) + standardDeviation(number);\n  };\n};\n\nexport default {\n  meanAbsoluteDeviation,\n  median,\n  mode,\n  standardDeviation,\n  standardDeviation2,\n  standardDeviation3,\n  standardDeviation4,\n  standardDeviation5,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/5", "prompt": "/* Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n    const intersperse = () => {\n        let first = 0;\n        let last = 0;\n        let number = 0;\n        let counter = 0;\n        return (...numbers) => {\n            if(counter === delimeter) {\n                counter = 0;\n                last = number;\n                number = 0;\n                return [first, last];\n            }\n            counter += 1;\n            first = number;\n            number = number + 1;\n            return [first, last, number];\n        };\n    }();\n    return intersperse(numbers);\n};\n\n/*\n  Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse2 = (numbers, delimeter) => {\n    const intersperse = () => {\n        let first = 0;\n        let last = 0;\n        let number = 0;\n        let counter = 0;\n        return (...numbers) => {\n            if(counter === delimeter) {\n                counter = 0;\n                last = number;\n                number = 0;\n                return [first, last];\n            }\n            counter += 1;\n            first = number;\n            number = number + 1;\n            return [first, last, number];\n        };\n    }();\n    return intersperse(numbers);\n};\n\n/*\n  Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse3 = (numbers, delimeter) => {\n    const intersperse = () => {\n        let first = 0;\n        let last = 0;\n        let number = 0;\n        let counter = 0;\n        return (...numbers) => {\n            if(counter === delimeter) {\n                counter = 0;\n                last = number;\n                number = 0;\n                return [first, last];\n            }\n            counter += 1;\n            first = number;\n            number = number + 1;\n            return [first, last, number];\n        };\n    }();\n    return intersperse(numbers);\n};\n\n/*\n  Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse4 = (numbers, delimeter) => {\n    const intersperse = () => {\n        let first = 0;\n        let last = 0;\n        let number = 0;\n        let counter = 0;\n        return (...numbers) => {\n            if(counter === delimeter) {\n                counter = 0;\n                last = number;\n                number = 0;\n                return [first, last];\n            }\n            counter += 1;\n            first = number;\n            number = number + 1;\n            return [first, last, number];\n        };\n    }();\n    return intersperse(numbers);\n};\n\nmodule.exports = {\n    intersperse,\n    intersperse2,\n    intersperse3,\n    intersperse4,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/6", "prompt": "/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const regex = /\\(((?:\\([^()]*\\))*)\\)/g;\n  const matches = regex.exec(paren_string);\n  const groups = [];\n  const level = 0;\n  while (matches!== null) {\n    const match = matches.index;\n    const level_of_group = matches[level];\n    if (level_of_group === '') {\n      groups.push(level);\n    } else {\n      groups.push(level + 1);\n    }\n    level += 1;\n    matches = regex.exec(paren_string);\n  }\n  return groups;\n};\n\n/*\n  The string given is the same as the string given in the function parseNestedParens.\n\n  The output is a list of the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n  */\nconst deepestNesting = (paren_string) => {\n  const level = parseNestedParens(paren_string);\n  return level;\n};\n\nexport { parseNestedParens, deepestNesting };\n<|endoftext|>"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n    let result = []\n    for (let i = 0; i < strings.length; i++) {\n        let str = strings[i]\n        if (str.includes(substring)) {\n            result.push(str)\n        }\n    }\n    return result\n}\n\n/*\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringInPlace = (strings, substring) => {\n    let index = -1\n    let result = []\n    while ((index = strings.indexOf(substring, index + 1))!== -1) {\n        result.push(strings.slice(index, index + 1))\n    }\n    return result\n}\n\nmodule.exports = {\n    filterBySubstring,\n    filterBySubstringInPlace\n}\n<|endoftext|>"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  // If there are no numbers in the list, we can just return (0, 1)\n  if (!numbers) {\n    return (0, 1)\n  }\n\n  // Sum and product of a list of numbers\n  let sum = 0\n  let product = 1\n\n  // Get the length of the list of numbers\n  let length = numbers.length\n\n  // For each number in the list, add the number to the sum\n  for (let i = 0; i < length; i++) {\n    sum += numbers[i]\n  }\n\n  // Get the product of all the numbers in the list\n  for (let i = 0; i < length; i++) {\n    product *= numbers[i]\n  }\n\n  // Return the sum and product of the list\n  return (sum, product)\n}\n\nmodule.exports = sumProduct\n<|endoftext|>"}
{"task_id": "JavaScript/9", "prompt": "/* From a gievn list of nitegers, genearte a list of rolling maximum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* From a gievn list of nitegers, genearte a list of rolling maximum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const maxNum = numbers[0];\n  const maxIdx = 0;\n\n  let maxIdx = 0;\n  let maxValue = maxNum;\n\n  for (let i = 0; i < numbers.length - 1; i++) {\n    if (numbers[i + 1] > maxValue) {\n      maxIdx = i;\n      maxValue = numbers[i + 1];\n    }\n  }\n\n  return [numbers[maxIdx], numbers[maxIdx + 1]];\n};\n\n/*\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3])\n  [1, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3])\n  [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,"}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const postfix = makePostfix(string);\n  let suffix = postfix.split('').reverse().join('');\n  return string + suffix;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const postfix = makePostfix(string);\n  let suffix = postfix.split('').reverse().join('');\n  return string + suffix;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Test if"}
{"task_id": "JavaScript/11", "prompt": "/* Inptu are two strings a and b consisting only of 1s and 0s.\n  ePrform binary XOR on these inputs and return reuslt also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inptu are two strings a and b consisting only of 1s and 0s.\n  ePrform binary XOR on these inputs and return reuslt also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const l = a.length\n  const r = b.length\n  const n = l + r - 1\n  const mask = 0xffffffff\n  let result = ''\n  for (let i = 0; i < n; i++) {\n    result += a[i] + b[i]\n  }\n  return result\n}\n<|endoftext|>"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Retrun the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Retrun the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n    let max = 0\n    let len = 0\n    strings.forEach((str) => {\n        if (str.length > len) {\n            max = str\n            len = str.length\n        }\n    })\n    return max\n}\n\n/*\n  >>> longest([['a', 'b'], ['c', 'd']])\n  'a'\n  >>> longest([['a', 'b', 'c'], ['d', 'e', 'f']])\n  'e'\n  >>> longest([['a', 'b'], ['c', 'd', 'e']])\n  'e'\n  */\nconst longest = (strings) => {\n    let max = 0\n    let len = 0\n    strings.forEach((str) => {\n        if (str.length > len) {\n            max = str\n            len = str.length\n        }\n    })\n    return max\n}\n\n// TEST\n\n/*\n  >>> longest([['a', 'b'], ['c', 'd', 'e']])\n  'e'\n  >>> longest([['a', 'b'], ['c', 'd'], ['e']])\n  'e'\n  >>> longest([['a', 'b'], ['c', 'd']])\n  'c'\n  */\nconst longest = (strings) => {\n    let max = 0\n    let len = 0\n    strings.forEach((str) => {\n        if (str.length > len) {\n            max = str\n            len = str.length\n        }\n    })\n    return max\n}\n\n// END\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Return a gretaest common divisor of two integesr a nad b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Return a gretaest common divisor of two integesr a nad b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  let c = 0\n  let d = 0\n\n  while (a!= 0) {\n    if (b % a == 0) {\n      c = a\n    } else {\n      d = b\n    }\n    a = Math.floor(a / 2)\n    b = Math.floor(b / 2)\n  }\n\n  return c * d\n}\n\n/* Return a list of the first k prime numbers\n  >>> primes(3)\n  [2, 3]\n  >>> primes(10)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n  >>> primes(100)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  */\nconst primes = (k) => {\n  let primes = []\n\n  for (let i = 2; i < k; i++) {\n    if (primes.indexOf(i) == -1) {\n      primes.push(i)\n    }\n  }\n\n  return primes\n}\n\n/* Return the first k prime numbers as an array\n  >>> primes(3)\n  [2, 3]\n  >>> primes(10)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n  >>> primes(100)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  */\nconst getPrimes = (k) => {\n  let primes = []\n  let kPrime = 1\n\n  while (primes.length < k) {\n    for (let i = 0; i < primes.length; i++) {\n      if (primes[i] <= kPrime) {\n        if (kPrime % primes[i] == 0) {\n          kPrime = kPrime + 1\n          if (kPrime >= k) {\n            primes.push(kPrime)\n          }\n        }\n      }\n    }\n    kPrime = kPrime + 1\n  }\n\n  return primes\n}\n\n/* Return the sum of all primes less than a given number\n  >>> sumOfPrimes(20)\n  25\n  >>> sumOfPrimes(200)\n  500\n  >>> sumOfPrimes(100)\n  1000\n  >>> sumOfPrimes(1000)\n  2620\n  >>> sumOfPrimes(10000)\n  95552\n  */\nconst sumOfPrimes = (n) => {\n  let sum = 0\n\n  for (let i = 2; i < n; i++) {\n    if (primes.indexOf(i) == -1) {\n      sum = sum + i\n    }\n  }\n\n  return sum\n}\n\nmodule.exports = {\n  greatestCommonDivisor,\n  primes,\n  sumOfPrimes\n}\n<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all preifxes frmo shortest to loengst of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Return list of all preifxes frmo shortest to loengst of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const list = [];\n  const len = string.length;\n  for (let i = 0; i < len; i++) {\n    const prefix = string.slice(0, i + 1);\n    if (prefix) {\n      list.push(prefix);\n    }\n  }\n  return list;\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;\n    if (len > max) {\n      max = len;\n    }\n  }\n  return list[0].slice(0, max);\n};\n\n/* Return the longest prefix of the input string */\nconst longestPrefix = (string) => {\n  const list = allPrefixes(string);\n  const max = list[0].length;\n  for (let i = 1; i < list.length; i++) {\n    const len = list[i].length;"}
{"task_id": "JavaScript/15", "prompt": "/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = '';\n  for (let i = 0; i <= n; i++) {\n    result += `${i}`;\n  }\n  return result;\n}\n\n/*\n  >>> stringSequence(5,'')\n  '0 1 2 3 4 5'\n  >>> stringSequence(5, '_')\n  '0_1_2_3_4_5'\n  >>> stringSequence(5, '_', '|')\n  '0|1|2|3|4|5'\n  >>> stringSequence(5, '_', '|', '+')\n  '0+1+2+3+4+5'\n  >>> stringSequence(5, '_', '|', '+', '*')\n  '0+1+2+3+4+5*'\n  >>> stringSequence(5, '_', '|', '+', '*', '-')\n  '0+1+2+3+4+5*-'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',')\n  '0+1+2+3+4+5*-x,'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.')\n  '0+1+2+3+4+5*-x,'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#')\n  '0+1+2+3+4+5*-x,'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1')\n  '0+1+2+3+4+5*-x,'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2')\n  '0+1+2+3+4+5*-x,'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3')\n  '0+1+2+3+4+5*-x,'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4')\n  '0+1+2+3+4+5*-x,'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6', '7')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6', '7', '8')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6', '7', '8', '9')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3')\n  '0+1+2+3+4+5*-x'\n  >>> stringSequence(5, '_', '|', '+', '*', '-', 'x', ',', '.', '#', '1', '2', '3', '4', '5', '6',"}
{"task_id": "JavaScript/16", "prompt": "/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  // http://stackoverflow.com/a/15187774\n  const charArray = string.split('');\n  const count = charArray.filter((c, i, a) => i === a.indexOf(c)).length;\n  return count;\n};\n\nexport { countDistinctCharacters };\n<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Inupt to thsi function is a strnig represenitng musical notes in a special ASCII fromat.\n  Your taks is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, alsst two beats\n  '.|' - quaetr note, lasts oen beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inupt to thsi function is a strnig represenitng musical notes in a special ASCII fromat.\n  Your taks is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, alsst two beats\n  '.|' - quaetr note, lasts oen beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music = music_string.split(' ')\n  const result = []\n\n  music.forEach(x => {\n    if (x.length === 1) {\n      result.push(1)\n    } else {\n      result.push(parseNum(x))\n    }\n  })\n  return result\n}\n\nfunction parseNum(num_string) {\n  const note = num_string.split('|')\n  const num_of_beats = note.length\n  return num_of_beats\n}\n\nexport default parseMusic\n<|endoftext|>"}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const count = string.split(substring).filter(Boolean).length;\n  return count;\n};\n\n/*\n  Find how many times a given string can be found in the iorginal string. Count the number of occurrences.\n  >>> howManyTimes('a', 'aa')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  1\n  >>> howManyTimes('aaaa', 'aa')\n  1\n  >>> howManyTimes('aaaa', 'aaaa')\n  1\n  >>> howManyTimes('aaa', 'aaaa')\n  0\n  */\nconst howManyTimesWithCount = (string, substring) => {\n  const count = string.split(substring).filter(Boolean).length;\n  return count;\n};\n\n/*\n  Find how many times a given string can be found in the iorginal string. Count the number of occurrences.\n  >>> howManyTimes('a', 'aa')\n  1\n  >>> howManyTimes('aaa', 'aa')\n  1\n  >>> howManyTimes('aaaa', 'aa')\n  1\n  >>> howManyTimes('aaaa', 'aaaa')\n  1\n  >>> howManyTimes('aaa', 'aaaa')\n  0\n  */\nconst howManyTimesWithCountAndOverlap = (string, substring) => {\n  const count = string.split(substring).filter(Boolean).length;\n  return count;\n};\n\nmodule.exports = {\n  howManyTimes,\n  howManyTimesWithCount,\n  howManyTimesWithCountAndOverlap\n};\n<|endoftext|>"}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choicse are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string wtih numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choicse are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string wtih numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  if(!numbers) return 'empty';\n  var sorted = [];\n  numbers.split(' ').forEach(number => {\n    sorted.push(parseInt(number));\n  });\n  sorted.sort();\n  return sorted.join(' ');\n}\n\n/*\n  Input is a string of numbers from '0' to '9'.\n  Return the string with the numbers sorted in reverse.\n  >>> reverseNumbers('123456789')\n  '8967342310'\n  >>> reverseNumbers('1234567')\n  '1234567'\n  */\nconst reverseNumbers = (numbers) => {\n  if(!numbers) return 'empty';\n  var reversed = [];\n  numbers.split('').reverse().forEach(number => {\n    reversed.push(parseInt(number));\n  });\n  return reversed.join('');\n}\n\n/*\n  Input is a string of numbers from '0' to '9'.\n  Return the string with the numbers sorted in reverse order.\n  >>> reverseNumbers('123456789')\n  '8967342310'\n  >>> reverseNumbers('1234567')\n  '1234567'\n  */\nconst reverseSortNumbers = (numbers) => {\n  if(!numbers) return 'empty';\n  var reversed = [];\n  numbers.split('').reverse().forEach(number => {\n    reversed.push(parseInt(number));\n  });\n  reversed.sort();\n  return reversed.join('');\n}\n\n/*\n  Input is a string of numberals from '0' to '9'.\n  Return the string with the numbers sorted in reverse order.\n  >>> reverseSortNumbers('123456789')\n  '8967342310'\n  >>> reverseSortNumbers('1234567')\n  '1234567'\n  */\nconst reverseSortReverseNumbers = (numbers) => {\n  if(!numbers) return 'empty';\n  var reversed = [];\n  numbers.split('').reverse().forEach(number => {\n    reversed.push(parseInt(number));\n  });\n  reversed.sort();\n  reversed.reverse();\n  return reversed.join('');\n}\n\n/*\n  Input is a string of numbers from '0' to '9'.\n  Return the string with the numbers sorted.\n  >>> sortNumbers('123456789')\n  '123456789'\n  >>> sortNumbers('1234567')\n  '1234567'\n  */\nconst sort = (numbers) => {\n  if(!numbers) return 'empty';\n  return reverseSortReverseNumbers(reverseSortNumbers(sortReverseNumbers(numbers)));\n}\n\nconst main = (n) => {\n  if(!n) {\n    console.log('Error: empty input');\n    return;\n  }\n  console.log(sort(n));\n}\n\nmain(parseInt(process.argv[2]));\n<|endoftext|>"}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list fo numbers (of length at least two) seelct and return two that are teh cloesst to each\n  toher and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* From a supplied list fo numbers (of length at least two) seelct and return two that are teh cloesst to each\n  toher and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const closest = findClosestElementsHelper(numbers);\n  return [closest[0], closest[1]];\n};\n\n/*\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  */\nconst findClosestElementsHelper = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  return _.zip(numbers, _.map(numbers, (num) => Math.abs(num - min)))\n   .sort(([a, b]) => b - a)\n   .reverse()\n   .map(\n      ([num, index]) =>\n        index < numbers.length - 1\n         ? [num, numbers[index + 1]]\n          : [num, numbers[index]]\n    )\n   .sort(([a, b]) => b - a)\n   .reverse()\n   .map(\n      ([num, index]) =>\n        index < numbers.length - 1\n         ? [num, numbers[index + 1]]\n          : [num, numbers[index]]\n    );\n};\n\nexport default findClosestElements;\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": false, "gc": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers)\n  const min = Math.min(...numbers)\n  return numbers.map((x) => (x - min) / (max - min))\n}\n\n/**\n  * Given a list of numbers, return the cumulative sum of those numbers\n  * If the first number is 1, the cumulative sum will be 0, otherwise the\n  * cumulative sum will be the cumulative sum of the previous number\n  *\n  * Example:\n  *  >>> cumulativeSum([1.0, 2.0, 3.0, 4.0, 5.0])\n  *  [0.0, 1.0, 3.0, 6.0, 10.0]\n  */\nconst cumulativeSum = (numbers) => {\n  const sum = []\n  for (let i = 0; i < numbers.length; i++) {\n    sum.push(sum.length? sum[i - 1] + numbers[i] : numbers[i])\n  }\n  return sum\n}\n\n/**\n  * Given a list of numbers, return the cumulative sum of those numbers\n  * If the first number is 1, the cumulative sum will be 0, otherwise the\n  * cumulative sum will be the cumulative sum of the previous number\n  *\n  * Example:\n  *  >>> cumulativeSum([1.0, 2.0, 3.0, 4.0, 5.0])\n  *  [0.0, 1.0, 3.0, 6.0, 10.0]\n  */\nconst cumulativeSumReverse = (numbers) => {\n  const sum = []\n  for (let i = numbers.length - 1; i >= 0; i--) {\n    sum.push(sum.length? sum[i - 1] + numbers[i] : numbers[i])\n  }\n  return sum\n}\n\n/**\n  * Given a list of numbers, return the maximum number in the list\n  */\nconst maximum = (numbers) => {\n  return Math.max(...numbers)\n}\n\n/**\n  * Given a list of numbers, return the minimum number in the list\n  */\nconst minimum = (numbers) => {\n  return Math.min(...numbers)\n}\n\n/**\n  * Given a list of numbers, return the median number in the list\n  */\nconst median = (numbers) => {\n  const nums = cumulativeSum(numbers)\n  const midpoint = Math.floor(nums.length / 2)\n  return (nums[midpoint - 1] + nums[midpoint]) / 2\n}\n\n/**\n  * Given a list of numbers, return the sum of the squares of the numbers\n  */\nconst sumOfSquares = (numbers) => {\n  return numbers.reduce((prev, x) => prev + x * x)\n}\n\n/**\n  * Given a list of numbers, return the sum of the squares of the numbers\n  */\nconst sumOfSquaresReverse = (numbers) => {\n  return numbers.reduce((prev, x) => prev + x * x, 0)\n}\n\n/**\n  * Given a list of numbers, return the variance of the list\n  */\nconst variance = (numbers) => {\n  const sumOfSquares = sumOfSquares(numbers)\n  return sumOfSquares / numbers.length\n}\n\n/**\n  * Given a list of numbers, return the variance of the list\n  */\nconst varianceReverse = (numbers) => {\n  const sumOfSquares = sumOfSquaresReverse(numbers)\n  return sumOfSquares / numbers.length\n}\n\n/**\n  * Given a list of numbers, return the standard deviation of the list\n  */\nconst standardDeviation = (numbers) => {\n  return Math.sqrt(variance(numbers))\n}\n\n/**\n  * Given a list of numbers, return the standard deviation of the list\n  */\nconst standardDeviationReverse = (numbers) => {\n  return Math.sqrt(varianceReverse(numbers))\n}\n\n/**\n  * Given a list of numbers, return the standard error of the list\n  */\nconst standardError = (numbers) => {\n  return standardDeviation(numbers) / Math.sqrt(numbers.length)\n}\n\n/**\n  * Given a list of numbers, return the standard error of the list\n  */\nconst standardErrorReverse = (numbers) => {\n  return standardDeviationReverse(numbers) / Math.sqrt(numbers.length)\n}\n\n/**\n  * Given a list of numbers, return the range of the list\n  */\nconst range = (numbers) => {\n  return maximum(numbers) - minimum(numbers)\n}\n\n/**\n  * Given a list of numbers, return the range of the list\n  */\nconst rangeReverse = (numbers) => {\n  return minimum(numbers) - maximum(numbers)\n}\n\n/**\n  * Given a list of numbers, return the mean of the list\n  */\nconst mean = (numbers) => {\n  return cumulativeSum(numbers) / numbers.length\n}\n\n/**\n  * Given a list of numbers, return the mean of the list\n  */\nconst meanReverse = (numbers) => {\n  return cumulativeSumReverse(numbers) / numbers.length\n}\n\n/**\n  * Given a list of numbers, return the median of the list\n  */\nconst medianReverse = (numbers) => {\n  const nums = cumulativeSumReverse(numbers)\n  const midpoint = Math.floor(nums.length / 2)\n  return (nums[midpoint - 1] + nums[midpoint]) / 2\n}\n\n/**\n  * Given a list of numbers, return the mean of the list\n  */\nconst median = (numbers) => {\n  const nums = cumulativeSum(numbers)\n  const midpoint = Math.floor(nums.length / 2)\n  return (nums[midpoint - 1] + nums[mid"}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of nay python values only for integres\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filter given list of nay python values only for integres\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/*\n  Returns a list of unique integers from the input.\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6, 7, 8, 9, 9, 10])\n  [1, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> uniqueInts([1, 3, 3, 4, 5, 5, 6,"}
{"task_id": "JavaScript/23", "prompt": "/* Return lnegth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Return lnegth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return string.length\n}\n\n/* Return index of given character in given string\n  >>> strindex('')\n  -1\n  >>> strindex('abc', 'a')\n  0\n  >>> strindex('abc', 'c')\n  2\n  >>> strindex('abc', 'x')\n  -1\n  */\nconst strindex = (string, character) => {\n  if (typeof string!=='string' || typeof character!=='string') {\n    throw new TypeError('Arguments must be strings')\n  }\n\n  let index = -1\n  string = string.split('')\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === character) {\n      index = i\n      break\n    }\n  }\n\n  return index\n}\n\n/* Return string with leading zeros added\n  >>> pad('')\n  ''\n  >>> pad('abc')\n  '000abc'\n  >>> pad('123')\n  '123'\n  */\nconst pad = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return string.padStart(string.length, '0')\n}\n\n/* Return true if given string is all zeros\n  >>> zero('')\n  false\n  >>> zero('00')\n  true\n  >>> zero('111')\n  false\n  */\nconst zero = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return string.match(/^0+$/)\n}\n\n/* Return true if given string is an integer\n  >>> integer('')\n  false\n  >>> integer('01')\n  true\n  >>> integer('111')\n  false\n  */\nconst integer = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return parseInt(string) === string\n}\n\n/* Return true if given string is a decimal number\n  >>> decimal('')\n  false\n  >>> decimal('01')\n  true\n  >>> decimal('111')\n  false\n  */\nconst decimal = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return parseFloat(string) === string\n}\n\n/* Return true if given string is a boolean\n  >>> boolean('')\n  false\n  >>> boolean('true')\n  true\n  >>> boolean('false')\n  true\n  */\nconst boolean = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return string === 'true' || string === 'false'\n}\n\n/* Return true if given string is a number\n  >>> number('')\n  false\n  >>> number('01')\n  true\n  >>> number('111')\n  false\n  */\nconst number = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return /^\\d+$/.test(string)\n}\n\n/* Return true if given string is a currency\n  >>> currency('')\n  false\n  >>> currency('')\n  true\n  >>> currency('')\n  false\n  */\nconst currency = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return /^[0-9]{2}(\\.{1}[0-9]{2}){3}$/.test(string)\n}\n\n/* Return true if given string is a hexadecimal number\n  >>> hexadecimal('')\n  false\n  >>> hexadecimal('01')\n  true\n  >>> hexadecimal('111')\n  false\n  */\nconst hexadecimal = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return /^0x[0-9a-f]+$/.test(string)\n}\n\n/* Return true if given string is an IP\n  >>> ip('')\n  false\n  >>> ip('01')\n  true\n  >>> ip('111')\n  false\n  */\nconst ip = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(string)\n}\n\n/* Return true if given string is an email\n  >>> email('')\n  false\n  >>> email('test@example.com')\n  true\n  >>> email('tst@xample.com')\n  false\n  */\nconst email = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return /^[a-zA-Z0-9_\\-\\.]+@[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z0-9\\-\\.]+$/.test(string)\n}\n\n/* Return true if given string is a url\n  >>> url('')\n  false\n  >>> url('http://example.com')\n  true\n  >>> url('https://example.com')\n  true\n  */\nconst url = (string) => {\n  if (typeof string!=='string') {\n    throw new TypeError('Argument must be a string')\n  }\n\n  return /^http:\\/\\/[a-zA-Z0-9\\-"}
{"task_id": "JavaScript/24", "prompt": "/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let m = 1;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      if (n / i > m) {\n        m = n / i;\n      }\n    }\n  }\n  return m;\n};\n\n// For a given n, find the smallest prime divisor of n\n// For a given n, find the largest prime divisor of n\nconst largestPrimeDivisor = (n) => {\n  let m = 1;\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0 && isPrime(i)) {\n      if (n / i > m) {\n        m = n / i;\n      }\n    }\n  }\n  return m;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n === 3) return true;\n  if (n % 2 === 0) return false;\n  let i = 3;\n  while (i < Math.sqrt(n)) {\n    if (n % i === 0) return false;\n    i += 2;\n  }\n  return true;\n};\n\nconst fib = (n) => {\n  if (n < 2) return n;\n  return fib(n - 1) + fib(n - 2);\n};\n\nconst factorial = (n) => {\n  if (n < 2) return 1;\n  return n * factorial(n - 1);\n};\n\nconst sumOfSquares = (n) => {\n  let s = 0;\n  for (let i = 1; i <= n; i++) {\n    s += i * i;\n  }\n  return s;\n};\n\nconst sumOfProducts = (n) => {\n  let p = 1;\n  for (let i = 1; i <= n; i++) {\n    p *= i;\n  }\n  return p;\n};\n\nconst sumOfSquaredDifferences = (n) => {\n  let p = 0;\n  for (let i = 1; i <= n; i++) {\n    p += Math.pow(i - n, 2);\n  }\n  return p;\n};\n\n// n choose k\nconst choose = (n, k) => {\n  if (k === 0) return 1;\n  return factorial(n) / (factorial(k) * factorial(n - k));\n};\n\nconst nCr = (n, r) => {\n  let f = 1;\n  for (let i = 1; i <= r; i++) {\n    f *= n - i + 1;\n  }\n  return f / factorial(r);\n};\n\n// sum of k-th powers\nconst sumOfKthPower = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\nconst nCrPow = (n, r, p) => {\n  return nCr(n, r) * Math.pow(n, p);\n};\n\n// sum of k-th powers of all numbers up to n\nconst sumOfKthPowerPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\n// sum of k-th powers of all numbers up to n\nconst sumOfKthPowerPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\nconst sumOfKthPowerPowPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\nconst sumOfKthPowerPowPowPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\n// sum of all k-th powers of all numbers up to n\nconst sumOfKthPowerPowPowPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\nconst sumOfKthPowerPowPowPowPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\nconst sumOfKthPowerPowPowPowPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\nconst sumOfKthPowerPowPowPowPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1;\n  for (let i = 1; i <= k; i++) {\n    f *= n - i + 1;\n  }\n  return f;\n};\n\nconst sumOfKthPowerPowPowPowPowPow = (n, k) => {\n  if (k < 1) return 0;\n  let f = 1"}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  var factors = [1];\n  var max_i = Math.ceil(Math.sqrt(n));\n  var p;\n  for (var i = 2; i <= max_i; i++) {\n    p = n / i;\n    if (p === Math.floor(p)) {\n      if (n % i === 0) {\n        factors.push(i);\n        while (n % i === 0) {\n          n = n / i;\n        }\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n);\n  }\n  return factors;\n};\n\n/**\n * Given a number, print all prime factors in the order rfom small to largest\n */\nconst all_primes = (n) => {\n  var factors = factorize(n);\n  factors.sort((a, b) => b - a);\n  var r = factors.length;\n  for (var i = 0; i < r; i++) {\n    console.log(factors[i]);\n  }\n};\n\nall_primes(7);<|endoftext|>"}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, reomve all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* From a list of integers, reomve all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const index = {};\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (!index[numbers[i]]) {\n      index[numbers[i]] = unique.length;\n      unique.push(numbers[i]);\n    }\n  }\n  return unique;\n};\n\nmodule.exports = removeDuplicates;\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lwoecrase characters to uppecrase and upprecase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lwoecrase characters to uppecrase and upprecase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (match) => {\n    return String.fromCharCode(match.charCodeAt(0) >= 97? match.charCodeAt(0) - 32 : match.charCodeAt(0) + 32)\n  })\n}\n\n/**\n  * Find the longest common substring.\n  * @param  {String}  string1  The first string.\n  * @param  {String}  string2  The second string.\n  * @return {String}          The longest common substring.\n  *\n  * @example\n  * For two strings, 'Hello World' and 'Hello World', the longest common substring is 'Hello World'.\n  *\n  * For two strings, 'Hello World' and 'Hello World!', the longest common substring is 'Hello World!'.\n  * */\nconst longestCommonSubstring = (string1, string2) => {\n  // Find the longest common substring of two strings.\n  let length = 0\n  let index = 0\n  const max = Math.max\n  const min = Math.min\n  while (string1.indexOf(string2, index + length)!== -1) {\n    const common = string1.indexOf(string2, index + length)\n    length = common + 1\n    index = common\n  }\n  return string1.substring(min(index - length + 1, string1.length), max(index + length, string1.length))\n}\n\n/**\n  * The number of distinct characters in a string.\n  * @param  {String} string  The string.\n  * @return {Number}         The number of distinct characters in a string.\n  *\n  * @example\n  * For 'Hello', the number of distinct characters is 3.\n  * */\nconst numberOfDistinctCharacters = (string) => {\n  const set = new Set()\n  const length = string.length\n  for (let i = 0; i < length; i++) {\n    set.add(string[i])\n  }\n  return set.size\n}\n\n/**\n  * The number of distinct characters in a string.\n  * @param  {String} string  The string.\n  * @return {Number}         The number of distinct characters in a string.\n  *\n  * @example\n  * For 'Hello World', the number of distinct characters is 4.\n  * */\nconst numberOfDistinctCharacters2 = (string) => {\n  const length = string.length\n  let count = 0\n  let set = new Set()\n  for (let i = 0; i < length; i++) {\n    if (!set.has(string[i])) {\n      set.add(string[i])\n      count++\n    }\n  }\n  return count\n}\n\n/**\n  * Check whether a string is a palindrome.\n  * @param  {String} string  The string.\n  * @return {Boolean}        Whether a string is a palindrome.\n  *\n  * @example\n  * For 'Hello World', the function returns false.\n  * */\nconst isPalindrome = (string) => {\n  const length = string.length\n  for (let i = 0, j = length - 1; i < j; i++, j--) {\n    if (string[i]!== string[j]) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n  * Check whether a string is a palindrome.\n  * @param  {String} string  The string.\n  * @return {Boolean}        Whether a string is a palindrome.\n  *\n  * @example\n  * For 'Hello World', the function returns true.\n  * */\nconst isPalindrome2 = (string) => {\n  const length = string.length\n  for (let i = 0, j = length - 1; i < j; i++, j--) {\n    if (string[i]!== string[j]) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n  * Count the number of vowels in a string.\n  * @param  {String} string  The string.\n  * @return {Number}         The number of vowels in a string.\n  *\n  * @example\n  * For 'Hello World', the function returns 2.\n  * */\nconst numberOfVowels = (string) => {\n  const length = string.length\n  let count = 0\n  for (let i = 0; i < length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      count++\n    }\n  }\n  return count\n}\n\n/**\n  * Check whether a string is a palindrome.\n  * @param  {String} string  The string.\n  * @return {Boolean}        Whether a string is a palindrome.\n  *\n  * @example\n  * For 'Hello World', the function returns false.\n  * */\nconst isPalindrome3 = (string) => {\n  const length = string.length\n  let count = 0\n  for (let i = 0; i < length; i++) {\n    if (string[i] === string[length - 1 - i]) {\n      count++\n    }\n  }\n  return count >= 1\n}\n\nmodule.exports = {\n  flipCase,\n  longestCommonSubstring,\n  numberOfDistinctCharacters,\n  numberOfDistinctCharacters2,\n  isPalindrome,\n  isPalindrome2,\n  numberOfVowels\n}\n<|endoftext|>"}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": false, "gc": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i]\n  }\n  return result\n}\n\n/*\n  Calculate the length of a list of strings\n  >>> length([])\n  0\n  >>> length(['a', 'b', 'c'])\n  3\n  */\nconst length = (strings) => {\n  return strings.length\n}\n\n/*\n  Calculate the length of a string\n  >>> length('abc')\n  3\n  */\nconst length_str = (string) => {\n  return string.length\n}\n\n/*\n  Find the index of a string in a list of strings\n  >>> index('abc', [])\n  -1\n  >>> index('abc', ['a', 'b', 'c'])\n  0\n  >>> index('abcd', ['a', 'b', 'c'])\n  -1\n  */\nconst index = (target, strings) => {\n  for (let i = 0; i < strings.length; i++) {\n    if (target === strings[i]) {\n      return i\n    }\n  }\n  return -1\n}\n\n/*\n  Find the index of a string in a string\n  >>> index_str('abc', '')\n  -1\n  >>> index_str('abc', 'abc')\n  0\n  >>> index_str('abc', 'abcd')\n  -1\n  */\nconst index_str = (target, string) => {\n  return index(target, string.split(''))\n}\n\n/*\n  Calculate the longest common prefix of a list of strings\n  >>> longest_common_prefix([])\n  ''\n  >>> longest_common_prefix(['a', 'b', 'c'])\n  'a'\n  >>> longest_common_prefix(['a', 'b', 'c'])\n  'a'\n  >>> longest_common_prefix(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest_common_prefix = (strings) => {\n  const len = strings.length\n  if (len === 0) {\n    return ''\n  }\n  const result = strings[0]\n  for (let i = 1; i < len; i++) {\n    if (strings[i] === '') {\n      return ''\n    }\n    const lcp = strings[i].substr(0, len)\n    if (lcp!== result) {\n      return result\n    }\n    result = lcp\n  }\n  return result\n}\n\n/*\n  Calculate the longest common prefix of a string\n  >>> longest_common_prefix_str('')\n  ''\n  >>> longest_common_prefix_str('abc')\n  ''\n  >>> longest_common_prefix_str('abc')\n  ''\n  >>> longest_common_prefix_str('abcd')\n  'a'\n  */\nconst longest_common_prefix_str = (string) => {\n  return longest_common_prefix(string.split(''))\n}\n\n/*\n  Calculate the longest common suffix of a list of strings\n  >>> longest_common_suffix([])\n  ''\n  >>> longest_common_suffix(['a', 'b', 'c'])\n  ''\n  >>> longest_common_suffix(['a', 'b', 'c'])\n  ''\n  >>> longest_common_suffix(['a', 'b', 'c', 'd'])\n  'c'\n  */\nconst longest_common_suffix = (strings) => {\n  const len = strings.length\n  if (len === 0) {\n    return ''\n  }\n  const result = strings[len - 1]\n  for (let i = len - 1; i > 0; i--) {\n    if (strings[i] === '') {\n      return ''\n    }\n    const lcs = strings[i].substr(strings[i].length - len, len)\n    if (lcs!== result) {\n      return result\n    }\n    result = lcs\n  }\n  return result\n}\n\n/*\n  Calculate the longest common suffix of a string\n  >>> longest_common_suffix_str('')\n  ''\n  >>> longest_common_suffix_str('abc')\n  ''\n  >>> longest_common_suffix_str('abc')\n  ''\n  >>> longest_common_suffix_str('abcd')\n  'c'\n  */\nconst longest_common_suffix_str = (string) => {\n  return longest_common_suffix(string.split(''))\n}\n\n/*\n  Returns true if all strings in the list are equal, false otherwise\n  >>> equal_all([])\n  True\n  >>> equal_all(['a', 'b', 'c'])\n  False\n  >>> equal_all(['a', 'b', 'c', 'd'])\n  False\n  >>> equal_all(['a', 'b', 'c', 'd', 'e'])\n  False\n  >>> equal_all(['a', 'b', 'c', 'd', 'e', 'f'])\n  True\n  */\nconst equal_all = (strings) => {\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i]!== strings[0]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Returns true if any string in the list is equal, false otherwise\n  >>> equal_any([])\n  False\n  >>> equal_any(['a', 'b', 'c'])\n  True\n  >>> equal_any(['a', 'b', 'c', 'd'])\n  True\n  >>> equal_any(['a', 'b', 'c', 'd', 'e'])\n  True\n  >>> equal_any(['a', 'b', 'c', 'd', 'e', 'f'])\n  False\n  */\nconst equal_any = (strings) => {\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i] === strings[0]) {\n      return true\n    }\n  }\n  return"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list fo strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filter an input list fo strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  const newList = []\n  strings.forEach(str => {\n    if (str.startsWith(prefix)) {\n      newList.push(str)\n    }\n  })\n  return newList\n}\n\n/*\n  Given a list of strings, this function returns a list of the words in the\n  string.\n  >>> wordsInString([], '')\n  []\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], '')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'abc')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'bcd')\n  ['abc', 'bcd', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'cde')\n  ['abc', 'bcd', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'cde')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'abc')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'abc')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'cde')\n  ['abc', 'bcd', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'cde')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'abc')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInString(['abc', 'bcd', 'cde', 'array'], 'abc')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst wordsInString = (strings, words) => {\n  const newList = []\n  strings.forEach(str => {\n    words.forEach(word => {\n      if (str.includes(word)) {\n        newList.push(word)\n      }\n    })\n  })\n  return newList\n}\n\n/*\n  Given a list of strings, this function returns a list of the first words in the\n  strings.\n  >>> wordsInStrings([], [])\n  []\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['', '', '', ''])\n  ['abc', 'bcd', 'cde', 'array']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['cde', 'cde', 'cde', 'array'])\n  ['abc', 'bcd', 'array']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['abc', 'abc', 'abc', 'array'])\n  ['abc']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['cde', 'cde', 'cde', 'array'])\n  ['cde']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['abc', 'abc', 'abc', 'array'])\n  ['abc']\n  */\nconst wordsInStrings = (strings, words) => {\n  const newList = []\n  strings.forEach(str => {\n    words.forEach(word => {\n      if (str.startsWith(word)) {\n        newList.push(word)\n      }\n    })\n  })\n  return newList\n}\n\n/*\n  Given a list of strings, this function returns a list of the first 2 words in\n  the strings.\n  >>> wordsInStrings([], [])\n  []\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['', '', '', ''])\n  ['abc', 'bcd']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['cde', 'cde', 'cde', 'array'])\n  ['cde', 'cde']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['abc', 'abc', 'abc', 'array'])\n  ['abc']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['cde', 'cde', 'cde', 'array'])\n  ['cde']\n  */\nconst wordsInStrings = (strings, words) => {\n  const newList = []\n  strings.forEach(str => {\n    words.forEach(word => {\n      if (str.startsWith(word)) {\n        if (newList.length === 0) {\n          newList.push(word)\n        } else {\n          newList.push(word)\n          if (newList.length === 2) {\n            break\n          }\n        }\n      }\n    })\n  })\n  return newList\n}\n\n/*\n  Given a list of strings, this function returns a list of the first 3 words in\n  the strings.\n  >>> wordsInStrings([], [])\n  []\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['', '', '', ''])\n  ['abc', 'bcd', 'cde']\n  >>> wordsInStrings(['abc', 'bcd', 'cde', 'array'], ['cde', 'cde', 'cde', 'array'])\n  ['cde', 'cde', 'cde']\n  >>> wordsInStrings(['abc',"}
{"task_id": "JavaScript/30", "prompt": "/*Return onyl positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Return onyl positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) result.push(l[i]);\n  }\n  return result;\n};\n\n/*\n  * Convert list of string into array of integer\n  *\n  * @param {string} str - String to convert\n  * @returns {number[]} - Array of integer\n  *\n  * @example\n  * convert('hello') -> [1, 2, 3]\n  * convert('hello world') -> [1, 2, 3, 4]\n  * convert('hello') -> [1, 2, 3]\n  * convert('123') -> [1, 2, 3]\n  * convert('123 456') -> [1, 2, 3, 456]\n  */\nconst convert = (str) => {\n  const result = [];\n  let index = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      index += 1;\n      continue;\n    }\n    result[index] = parseInt(str[i]);\n    index += 1;\n  }\n  return result;\n};\n\nmodule.exports = {\n  getPositive,\n  convert\n};\n<|endoftext|>"}
{"task_id": "JavaScript/31", "prompt": "/*Return ture if a given number is prime, and aflse otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Return ture if a given number is prime, and aflse otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n    if (n === 1) {\n        return false\n    }\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i === 0) {\n            return false\n        }\n        i = i + 1\n    }\n    return true\n}\n\n/*\n  Calculate a Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(2)\n  1\n  >>> fib(1)\n  1\n  >>> fib(0)\n  0\n  >>> fib(-1)\n  >>> // TypeError: 'undefined' is not iterable\n  >>> // TypeError: 'fib' object is not callable\n  */\nconst fib = (n) => {\n    if (n === 0) {\n        return 0\n    }\n    if (n === 1) {\n        return 1\n    }\n    return fib(n - 1) + fib(n - 2)\n}\n\n/*\n  Calculate a Lucas number.\n  >>> lucas(10)\n  47\n  >>> lucas(1)\n  0\n  >>> lucas(0)\n  >>> // TypeError: 'undefined' is not iterable\n  >>> // TypeError: 'lucas' object is not callable\n  */\nconst lucas = (n) => {\n    if (n === 0) {\n        return 0\n    }\n    if (n === 1) {\n        return 1\n    }\n    return lucas(n - 1) + lucas(n - 2)\n}\n\n/*\n  Return a number of prime numbers between two numbers.\n  >>> prime(10, 20)\n  [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n  >>> prime(0, 2)\n  []\n  >>> prime(0, 1)\n  []\n  >>> prime(1, 2)\n  []\n  >>> prime(2, 3)\n  [2]\n  >>> prime(2, 1)\n  []\n  >>> prime(3, 4)\n  [3]\n  >>> prime(2, 3)\n  []\n  >>> prime(2, 3)\n  []\n  */\nconst prime = (n, m) => {\n    let primes = [];\n    if (n === 0 || n === 1) {\n        return []\n    }\n    if (n < m) {\n        return []\n    }\n    for (let i = n; i > 1; i--) {\n        if (isPrime(i)) {\n            primes.push(i);\n        }\n    }\n    return primes\n}\n\n/*\n  Return a number of fibonacci numbers between two numbers.\n  >>> fib(10, 20)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  >>> fib(0, 2)\n  []\n  >>> fib(0, 1)\n  []\n  >>> fib(1, 2)\n  []\n  >>> fib(2, 3)\n  [1]\n  >>> fib(2, 1)\n  []\n  >>> fib(3, 4)\n  [1]\n  >>> fib(2, 3)\n  []\n  >>> fib(2, 3)\n  []\n  */\nconst fib = (n, m) => {\n    let fibonacci = [], fibonacci2 = [], fibonacci3 = [];\n    if (n === 0 || n === 1) {\n        return []\n    }\n    if (n < m) {\n        return []\n    }\n    for (let i = n; i > 1; i--) {\n        fibonacci.push(i);\n        fibonacci2.push(fibonacci[i - 1]);\n        fibonacci3.push(fibonacci[i - 1] + fibonacci2[i - 1]);\n    }\n    return fibonacci\n}\n\n/*\n  Return a number of lucas numbers between two numbers.\n  >>> lucas(10, 20)\n  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  >>> lucas(0, 2)\n  []\n  >>> lucas(0, 1)\n  []\n  >>> lucas(1, 2)\n  []\n  >>> lucas(2, 3)\n  [0]\n  >>> lucas(2, 1)\n  []\n  >>> lucas(3, 4)\n  [1]\n  >>> lucas(2, 3)\n  []\n  >>> lucas(2, 3)\n  []\n  */\nconst lucas = (n, m) => {\n    let lucas = [], lucas2 = [], lucas3 = [];\n    if (n === 0 || n === 1) {\n        return []\n    }\n    if (n < m) {\n        return []\n    }\n    for (let i = n; i > 1; i--) {\n        lucas.push(i);\n        lucas2.push(lucas[i - 1]);\n        lucas3.push(lucas[i - 1] + lucas2[i - 1]);\n    }\n    return lucas\n}\n\n/*\n  Return a sum of prime numbers.\n  >>> sumPrime(10, 20)\n  1364\n  >>> sumPrime(0, 2)\n  0\n  >>> sumPrime(0, 1)\n  0\n  >>> sumPrime(1, 2)\n  0\n  >>> sumPrime(2, 3)\n  6\n  >>> sumPrime(2, 1)\n  0\n  >>> sumPrime(3, 4)\n  9\n  >>> sumPrime(2, 3)\n  0\n  >>> sumPrime(2, 3)\n  0\n  */\nconst sumPrime = (n, m) => {\n    let sum = 0;\n    if (n === 0 || n === 1) {\n        return 0\n    }\n    if (n < m) {\n        return 0\n    }\n    for (let i = n;"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polyonmial with ocefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findZero find x such that poly(x) = 0.\n  findZero returns only onyl zero point, even fi teher are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coeffciient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evaluates polyonmial with ocefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findZero find x such that poly(x) = 0.\n  findZero returns only onyl zero point, even fi teher are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coeffciient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length % 2 === 0) {\n    return findZero(xs.slice(1));\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 0) {\n      return xs[i];\n    }\n  }\n  return 0;\n}\n\n/*\n  Given a list of numbers and xs, return the first number that satisfies the equation.\n  >>> round(findSolution([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  >>> round(findSolution([0, 0, 0]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 0]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 2]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 3]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 4]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 5]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 6]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 7]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 8]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 9]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 10]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 11]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 12]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 13]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 14]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 15]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round(findSolution([-6, 11, -6, 1, 16]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  >>> round("}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by three, while its values at the idnicies that are divisible by three are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by three, while its values at the idnicies that are divisible by three are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const lPrime = [];\n  const sortPrime = (n) => {\n    const k = (n % 3 === 0)? n - 3 : n;\n    return k;\n  };\n  for (let i = 0; i < l.length; i++) {\n    lPrime[i] = sortPrime(l[i]);\n  }\n  return lPrime;\n};\n\n// console.log(sortThird([1, 2, 3]));\n// console.log(sortThird([5, 6, 3, 4, 8, 9, 2]));\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by five, while its values at the idnicies that are divisible by five are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortFive([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> sortFive([1, 2, 3, 4, 5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n  >>> sortFive([8, 9, 7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst sortFive = (l) => {\n  const lPrime = [];\n  const sortPrime = (n) => {\n    const k = (n % 5 === 0)? n - 5 : n;\n    return k;\n  };\n  for (let i = 0; i < l.length; i++) {\n    lPrime[i] = sortPrime(l[i]);\n  }\n  return lPrime;\n};\n\n// console.log(sortFive([1, 2, 3, 4, 5, 6, 7]));\n// console.log(sortFive([1, 2, 3, 4, 5, 6, 7, 8]));\n// console.log(sortFive([8, 9, 7, 6, 5, 4, 3, 2, 1]));\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by seven, while its values at the idnicies that are divisible by seven are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortSeven([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> sortSeven([1, 2, 3, 4, 5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n  >>> sortSeven([8, 9, 7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst sortSeven = (l) => {\n  const lPrime = [];\n  const sortPrime = (n) => {\n    const k = (n % 7 === 0)? n - 7 : n;\n    return k;\n  };\n  for (let i = 0; i < l.length; i++) {\n    lPrime[i] = sortPrime(l[i]);\n  }\n  return lPrime;\n};\n\n// console.log(sortSeven([1, 2, 3, 4, 5, 6, 7]));\n// console.log(sortSeven([1, 2, 3, 4, 5, 6, 7, 8]));\n// console.log(sortSeven([8, 9, 7, 6, 5, 4, 3, 2, 1]));\n<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": false, "gc": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let i, j, x, len = l.length, count = 1, result = [];\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      x = l[i];\n      if (x!== l[j]) {\n        if (x < l[j]) {\n          result.push(x);\n          count++;\n        }\n      }\n    }\n  }\n  return result.filter((x, i) => x === l[i]);\n};\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  if (!l) {\n    return 0;\n  }\n\n  return l[l.length - 1];\n};\n\nexport default maxElement;\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Reutrn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Reutrn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n    let count = 0;\n    let divisor = 11;\n    while (n > 0) {\n        if (n % divisor === 0) {\n            count++;\n        }\n        divisor++;\n        n--;\n    }\n    return count;\n};\n\nexport default fizzBuzz;<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the odd indicise, while tis avlues ta the even indicies are equal\n  to the values of the even idnicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the odd indicise, while tis avlues ta the even indicies are equal\n  to the values of the even idnicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const dif = l.length - 1;\n  const len = l.length;\n  const sorted = [];\n  for (let i = 0; i < len; i += 2) {\n    sorted.push(l[i]);\n  }\n  for (let i = 1; i < len; i += 2) {\n    sorted.push(l[i]);\n  }\n  return sorted;\n};\n\nmodule.exports = sortEven;\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclci functino. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclci functino. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (const group of s.split('')) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  for (let i = 0; i < Math.floor((groups2.length + 2) / 3); i++) {\n    groups.push(groups2.slice(3 * i, Math.min((3 * i + 3), groups2.length)));\n  }\n  return groups.join('');\n}\n\n/*\n  takes as input string with cyclic encoding. Returns encoded string.\n  */\nconst encode = (s) => encodeCyclic(encode_cyclic(s));\n\n/*\n  takes as input string with cyclic encoding. Returns decoded string.\n  */\nconst decode = (s) => decodeCyclic(encode_cyclic(s));\n\nmodule.exports = {\n  encode,\n  decode\n};\n<|endoftext|>"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number taht is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib returns n-th number taht is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 1) {\n    return undefined;\n  }\n  const fib = primeFib(n - 1) + primeFib(n - 2);\n  return isPrime(fib)? fib : undefined;\n};\n\nexport default primeFib;\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to zero, nad false toherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to zero, nad false toherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  let i = 0;\n  while (i < l.length - 2) {\n    sum = l[i] + l[i + 1] + l[i + 2];\n    if (sum === 0) {\n      return true;\n    }\n    i += 3;\n  }\n  return false;\n};\n\nexport default triplesSumToZero;\n<|endoftext|>"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly tsraight infinitely long line.\n  n cars are driving left to rigth;  simutlaneously, a different set of n acrs\n  are driivng right to left.   The two sets of cars start out being very far rfom\n  each other.  All casr move in the same speed.  Two cars are said to colilde\n  when a car thta's moving left to right hits a car that's moving right ot left.\n  However, the cars are infinitely sturyd and strong; as a result, they continue omving\n  in their trajectory as if htey did not colldie.\n\n  This ufnction outputs teh number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imagine a road that's a perfectly tsraight infinitely long line.\n  n cars are driving left to rigth;  simutlaneously, a different set of n acrs\n  are driivng right to left.   The two sets of cars start out being very far rfom\n  each other.  All casr move in the same speed.  Two cars are said to colilde\n  when a car thta's moving left to right hits a car that's moving right ot left.\n  However, the cars are infinitely sturyd and strong; as a result, they continue omving\n  in their trajectory as if htey did not colldie.\n\n  This ufnction outputs teh number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n    let a = 0;\n    let b = 0;\n    let i = 0;\n\n    for (i = 0; i < n - 1; i++) {\n        a = Math.abs(car[i].x - car[i + 1].x);\n        b = Math.abs(car[i].x - car[i + 1].x);\n\n        if (a > b) {\n            car[i].x += car[i + 1].x - car[i].x;\n        } else if (a < b) {\n            car[i + 1].x += car[i].x - car[i + 1].x;\n        } else {\n            car[i].x += car[i + 1].x - car[i].x;\n            car[i + 1].x += car[i].x - car[i + 1].x;\n        }\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        a = Math.abs(car[i].x - car[i - 1].x);\n        b = Math.abs(car[i].x - car[i - 1].x);\n\n        if (a > b) {\n            car[i].x += car[i - 1].x - car[i].x;\n        } else if (a < b) {\n            car[i - 1].x += car[i].x - car[i - 1].x;\n        } else {\n            car[i].x += car[i - 1].x - car[i].x;\n            car[i - 1].x += car[i].x - car[i - 1].x;\n        }\n    }\n}\n<|endoftext|>"}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": false, "gc": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  return l.slice(1, -1).reduce((acc, curr) => {\n    acc.push(curr + 1);\n    return acc;\n  }, []);\n};\n\n// const incrList = (l) => {\n//   return l.slice(1, -1).reduce((acc, curr) => {\n//     acc.push(curr + 1);\n//     return acc;\n//   }, []);\n// };\n\nconst addList = (l1, l2) => {\n  let newList = [...l1];\n  for (let i = 0; i < l2.length; i++) {\n    newList.push(l2[i]);\n  }\n  return newList;\n};\n\nconst sumList = (l1, l2) => {\n  let newList = [];\n  for (let i = 0; i < l1.length; i++) {\n    newList.push(l1[i] + l2[i]);\n  }\n  return newList;\n};\n\nconst incrListBy = (l, n) => {\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + n);\n  }\n  return newList;\n};\n\nconst testAddList = () => {\n  let l1 = [1, 2, 3];\n  let l2 = [4, 5, 6];\n  console.log(addList(l1, l2));\n};\n\nconst testSumList = () => {\n  let l1 = [1, 2, 3];\n  let l2 = [4, 5, 6];\n  console.log(sumList(l1, l2));\n};\n\nconst testIncList = () => {\n  let l1 = [1, 2, 3];\n  let l2 = [4, 5, 6];\n  console.log(incrList(l1));\n};\n\nconst testIncListBy = () => {\n  let l1 = [1, 2, 3];\n  let l2 = [4, 5, 6];\n  console.log(incrListBy(l1, 3));\n};\n\n// console.log(incrList(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(incrListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n\n// console.log(sumList([1, 2, 3], [4, 5, 6]));\n// console.log(sumListBy([1, 2, 3], [4, 5, 6]));\n\n// console.log(sumList(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n\n// console.log(incrListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumList(incrListBy(incrList([1, 2, 3]), incrList([4, 5, 6]))));\n\n// console.log(sumList([1, 2, 3], [4, 5, 6]));\n// console.log(sumListBy([1, 2, 3], [4, 5, 6]));\n\n// console.log(sumList(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n\n// console.log(incrListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumList(incrListBy(incrList([1, 2, 3]), incrList([4, 5, 6]))));\n\n// console.log(sumList([1, 2, 3], [4, 5, 6]));\n// console.log(sumListBy([1, 2, 3], [4, 5, 6]));\n\n// console.log(sumList(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n\n// console.log(incrListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumList(incrListBy(incrList([1, 2, 3]), incrList([4, 5, 6]))));\n\n// console.log(sumList([1, 2, 3], [4, 5, 6]));\n// console.log(sumListBy([1, 2, 3], [4, 5, 6]));\n\n// console.log(sumList(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n\n// console.log(sumList([1, 2, 3], [4, 5, 6]));\n// console.log(sumListBy([1, 2, 3], [4, 5, 6]));\n\n// console.log(sumList(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log(sumListBy(incrList([1, 2, 3]), incrList([4, 5, 6])));\n\n// console.log(sumList([1, 2, 3], [4, 5, 6]));\n// console.log(sumListBy([1, 2, 3], [4, 5, 6]));\n\n// console.log(sumList(incrList([1, 2, 3]), incrList([4, 5, 6])));\n// console.log"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length - 1; i++) {\n    sum += l[i];\n    if (sum < 0) sum = 0;\n    if (sum > 0) return false;\n  }\n  sum += l[l.length - 1];\n  if (sum < 0) sum = 0;\n  return sum === 0;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Change numecrial base of ipnut number x to base.\n  return string representation after the conversion.\n  base numbers are lses than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Change numecrial base of ipnut number x to base.\n  return string representation after the conversion.\n  base numbers are lses than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n    const arr = x.toString(base).split('');\n    let result = '';\n    for (let i = arr.length - 1; i >= 0; i--) {\n        result += arr[i];\n    }\n    return result;\n}\n\n/**\n  * Compute the number of leading zeroes.\n  * @param  {Number} x\n  * @return {Number}\n  *   the number of leading zeroes of x\n  *   (x < 0 return -1, x = 0 return 0, x > 0 return 1)\n  *   e.g.\n  *   >>> leadingZeroes(3)\n  *   0\n  *   >>> leadingZeroes(4)\n  *   1\n  *   >>> leadingZeroes(-3)\n  *   -1\n  *   >>> leadingZeroes(0)\n  *   0\n  *   >>> leadingZeroes(1)\n  *   0\n  */\nconst leadingZeroes = x => {\n    if (x < 0) return -1;\n    if (x === 0) return 0;\n    return 1;\n}\n\n/**\n  * Compute the number of trailing zeroes.\n  * @param  {Number} x\n  * @return {Number}\n  *   the number of trailing zeroes of x\n  *   (x < 0 return -1, x = 0 return 0, x > 0 return 1)\n  *   e.g.\n  *   >>> trailingZeroes(3)\n  *   1\n  *   >>> trailingZeroes(4)\n  *   0\n  *   >>> trailingZeroes(-3)\n  *   -1\n  *   >>> trailingZeroes(0)\n  *   0\n  *   >>> trailingZeroes(1)\n  *   1\n  */\nconst trailingZeroes = x => {\n    if (x < 0) return -1;\n    if (x === 0) return 0;\n    return 1;\n}\n\n/**\n  * Compute the number of significant digits.\n  * @param  {Number} x\n  * @return {Number}\n  *   the number of significant digits of x\n  *   (x < 0 return -1, x = 0 return 0, x > 0 return 1)\n  *   e.g.\n  *   >>> significantDigits(3)\n  *   1\n  *   >>> significantDigits(4)\n  *   1\n  *   >>> significantDigits(-3)\n  *   -1\n  *   >>> significantDigits(0)\n  *   0\n  *   >>> significantDigits(1)\n  *   1\n  */\nconst significantDigits = x => {\n    if (x < 0) return -1;\n    if (x === 0) return 0;\n    return 1;\n}\n\n/**\n  * Compute the number of significant digits of x.\n  * @param  {Number} x\n  * @return {Number}\n  *   the number of significant digits of x\n  *   (x < 0 return -1, x = 0 return 0, x > 0 return 1)\n  *   e.g.\n  *   >>> significantDigits(3, 2)\n  *   1\n  *   >>> significantDigits(4, 2)\n  *   2\n  *   >>> significantDigits(-3, 2)\n  *   -1\n  *   >>> significantDigits(0, 2)\n  *   0\n  *   >>> significantDigits(1, 2)\n  *   1\n  */\nconst significantDigits2 = (x, base) => {\n    const arr = x.toString(base).split('');\n    let result = 0;\n    for (let i = arr.length - 1; i >= 0; i--) {\n        result += arr[i].length;\n    }\n    return result;\n}\n\n/**\n  * Convert an integer to base two.\n  * @param  {Number} x\n  * @return {Number}\n  *   the number in base two of x\n  *   e.g.\n  *   >>> toBaseTwo(3)\n  *   3\n  *   >>> toBaseTwo(4)\n  *   4\n  *   >>> toBaseTwo(-3)\n  *   -3\n  *   >>> toBaseTwo(0)\n  *   0\n  *   >>> toBaseTwo(1)\n  *   1\n  */\nconst toBaseTwo = x => {\n    if (x < 0) return -1;\n    if (x === 0) return 0;\n    return 1;\n}\n\n/**\n  * Convert an integer to base ten.\n  * @param  {Number} x\n  * @return {Number}\n  *   the number in base ten of x\n  *   e.g.\n  *   >>> toBaseTen(3)\n  *   3\n  *   >>> toBaseTen(4)\n  *   4\n  *   >>> toBaseTen(-3)\n  *   -3\n  *   >>> toBaseTen(0)\n  *   0\n  *   >>> toBaseTen(1)\n  *   1\n  */\nconst toBaseTen = x => {\n    if (x < 0) return -1;\n    if (x === 0) return 0;\n    return 1;\n}\n\nmodule.exports = {\n    changeBase,\n    leadingZeroes,\n    trailingZeroes,\n    significantDigits,\n    significantDigits2,\n    toBaseTwo,\n    toBaseTen\n};\n<|endoftext|>"}
{"task_id": "JavaScript/45", "prompt": "/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const b = a * (h / 2);\n  return Math.sqrt(b * (b - a) * (2 * h - a) * (2 * h - b) * (b - 2 * h) / 12);\n};\n\n/*\n  Givne the area of a triangle given the length of each side and high.\n  >>> triangleArea(3, 5)\n  10\n  */\nconst triangleArea2 = (a, h) => {\n  return triangleArea(a, h) / 2;\n};\n\nconst triangleArea3 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(3) / 4;\n};\n\nconst triangleArea4 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\n/*\n  Givne the area of a triangle given the length of each side and high.\n  >>> triangleArea3(3, 5)\n  10\n  */\nconst triangleArea5 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(3) / 4;\n};\n\nconst triangleArea6 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\n/*\n  Givne the area of a triangle given the length of each side and high.\n  >>> triangleArea4(3, 5)\n  10\n  */\nconst triangleArea7 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\n/*\n  Givne the area of a triangle given the length of each side and high.\n  >>> triangleArea5(3, 5)\n  10\n  */\nconst triangleArea8 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea9 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\n/*\n  Givne the area of a triangle given the length of each side and high.\n  >>> triangleArea6(3, 5)\n  10\n  */\nconst triangleArea10 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea11 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea12 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea13 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea14 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea15 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\n/*\n  Givne the area of a triangle given the length of each side and high.\n  >>> triangleArea6(3, 5)\n  10\n  */\nconst triangleArea16 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea17 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea18 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea19 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea20 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea21 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea22 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea23 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea24 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n\nconst triangleArea25 = (a, h) => {\n  return triangleArea(a, h) * Math.sqrt(5) / 8;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/46", "prompt": "/*The Fbi4 number seuqence si a sqeuence similar to the Fibbonacci sequnece taht's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Fbi4 number seuqence si a sqeuence similar to the Fibbonacci sequnece taht's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n    }\n}\n\nconst fib4_ = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_2 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_3 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_4 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_5 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_6 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_7 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_8 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_9 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_10 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_11 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_12 = (n) => {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 0;\n    } else if (n === 2) {\n        return 2;\n    } else {\n        return fib4_(n - 1) + fib4_(n - 2) + fib4_(n - 3) + fib4_(n - 4);\n    }\n}\n\nconst fib4_13 = (n) => {\n    if (n === 0) {\n        return"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": false, "gc": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  let half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*\n  Return the median of the values in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median2 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  let half = Math.floor(sorted.length / 2);\n  let a = sorted[half];\n  let b = sorted[half + 1];\n  if (a > b) {\n    return a;\n  } else {\n    return b;\n  }\n};\n\n// ______________________________________________________________________________\n\n/*\n  Return the median of the values in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median3 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  let half = Math.floor(sorted.length / 2);\n  let a = sorted[half];\n  let b = sorted[half + 1];\n  if (a > b) {\n    return b;\n  } else {\n    return a;\n  }\n};\n\n// ______________________________________________________________________________\n\n/*\n  Return the median of the values in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median4 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  let half = Math.floor(sorted.length / 2);\n  let a = sorted[half];\n  let b = sorted[half + 1];\n  let c = sorted[half + 2];\n  let d = sorted[half + 3];\n  if (a > b) {\n    if (c > d) {\n      return d;\n    } else {\n      return c;\n    }\n  } else {\n    if (c > d) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n};\n\n// ______________________________________________________________________________\n\n/*\n  Return the median of the values in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median5 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  let half = Math.floor(sorted.length / 2);\n  let a = sorted[half];\n  let b = sorted[half + 1];\n  let c = sorted[half + 2];\n  let d = sorted[half + 3];\n  let e = sorted[half + 4];\n  if (a > b) {\n    if (c > d) {\n      if (e > d) {\n        return d;\n      } else {\n        return e;\n      }\n    } else {\n      if (c > e) {\n        return c;\n      } else {\n        return e;\n      }\n    }\n  } else {\n    if (c > d) {\n      if (e > d) {\n        return a;\n      } else {\n        return e;\n      }\n    } else {\n      if (e > d) {\n        return a;\n      } else {\n        return d;\n      }\n    }\n  }\n};\n\n// ______________________________________________________________________________\n\n/*\n  Return the median of the values in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median6 = (l) => {\n  const sorted = l.sort((a, b) => a - b);\n  let half = Math.floor(sorted.length / 2);\n  let a = sorted[half];\n  let b = sorted[half + 1];\n  let c = sorted[half + 2];\n  let d = sorted[half + 3];\n  let e = sorted[half + 4];\n  let f = sorted[half + 5];\n  if (a > b) {\n    if (c > d) {\n      if (e > d) {\n        if (f > d) {\n          return d;\n        } else {\n          return f;\n        }\n      } else {\n        if (e > c) {\n          return e;\n        } else {\n          return c;\n        }\n      }\n    } else {\n      if (c > e) {\n        if (f > e) {\n          return e;\n        } else {\n          return f;\n        }\n      } else {\n        if (f > d) {\n          return f;\n        } else {\n          return d;\n        }\n      }\n    }\n  } else {\n    if (c > d) {\n      if (e > d) {\n        if (f > d) {\n          return d;\n        } else {\n          return f;\n        }\n      } else {\n        if (e > c) {\n          return e;\n        } else {\n          return c;\n        }\n      }\n    } else {\n      if (f > d) {\n        if (e > d) {\n          return e;\n        } else {\n          return f;\n        }\n      } else {\n        if (e > c) {\n          return e;\n        } else {\n          return c;\n        }\n      }\n    }\n  }\n};\n\n// ______________________________________________________________________________\n\n/*\n  Return the median of the values in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a apilndrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Checks if given string is a apilndrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  if (typeof text!=='string') {\n    return false;\n  }\n  let reversed = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversed += text[i];\n  }\n  return text === reversed;\n};\n\nexport default isPalindrome;\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n moudlo p (be aware of numreics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Return 2^n moudlo p (be aware of numreics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if(n == 0) return 1;\n  if(n == 1) return p;\n  const k = (n % p) + p;\n  return modp(k, p);\n}\n<|endoftext|>"}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chraCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns deocded stirng.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chraCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns deocded stirng.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    (((ch.charCodeAt(0) - \"a\".charCodeAt(0)) - 5) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns number of encoded chars in string.\n  */\nconst length = (s) => {\n  return encodeShift(s).length;\n}\n\n/*\n  returns string with length of the given encoded string.\n  */\nconst getLength = (s) => {\n  return `${s.length}`;\n}\n\n/*\n  returns encoded string with length of the given encoded string.\n  */\nconst getLengthWithShift = (s) => {\n  return `${length(s)}${getLength(s)}`;\n}\n\n/*\n  returns string with the same length as the given encoded string.\n  */\nconst getLengthWithShiftAndDecodeShift = (s) => {\n  return `${getLengthWithShift(s)}${decodeShift(s)}`;\n}\n\n/*\n  returns number of encoded chars in string.\n  */\nconst getLengthWithoutShift = (s) => {\n  return decodeShift(s).length;\n}\n\n/*\n  returns string with length of the given encoded string.\n  */\nconst getLengthWithoutShiftWithShift = (s) => {\n  return `${getLengthWithoutShift(s)}${getLengthWithShift(s)}`;\n}\n\n/*\n  returns the encoded string with the same length as the given encoded string.\n  */\nconst getLengthWithoutShiftWithShiftAndDecodeShift = (s) => {\n  return `${getLengthWithoutShift(s)}${getLengthWithShiftAndDecodeShift(s)}`;\n}\n\nmodule.exports = {\n  encodeShift,\n  decodeShift,\n  length,\n  getLength,\n  getLengthWithShift,\n  getLengthWithShiftAndDecodeShift,\n  getLengthWithoutShift,\n  getLengthWithoutShiftWithShift,\n  getLengthWithoutShiftWithShiftAndDecodeShift\n};\n<|endoftext|>"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and rteurns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and rteurns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n    let result = text\n    // remove vowels\n    result = result.replace(/[aeiouAEIOU]/g, '')\n    // remove spaces\n    result = result.replace(/\\s/g, '')\n    // remove multiple spaces\n    result = result.replace(/\\s{2,}/g,'')\n    return result\n}\n\n/*\n  cleanText is a function that takes string and rteurns string without\n  non-alphanumeric characters.\n  >>> cleanText('')\n  ''\n  >>> cleanText(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> cleanText('abcdef')\n  'abcdef'\n  >>> cleanText('aaaaa')\n  'aaaaa'\n  >>> cleanText('aaBAA')\n  'aaBAA'\n  >>> cleanText('zbcd')\n  'zbcd'\n  */\nconst cleanText = (text) => {\n    let result = text\n    // remove non-alphanumeric characters\n    result = result.replace(/\\W/g, '')\n    // remove multiple spaces\n    result = result.replace(/\\s{2,}/g,'')\n    return result\n}\n\n/*\n  countWords is a function that takes string and returns number of words\n  >>> countWords('')\n  0\n  >>> countWords('a')\n  1\n  >>> countWords('a b')\n  2\n  >>> countWords('a b c')\n  3\n  >>> countWords('a b c d e')\n  4\n  >>> countWords('aa bb cc dd')\n  4\n  >>> countWords('aa bb cc dd ee')\n  5\n  >>> countWords('aa bb cc dd ee ff')\n  6\n  >>> countWords('aa bb cc dd ee ff gg hh')\n  7\n  >>> countWords('aa bb cc dd ee ff gg hh ii')\n  8\n  */\nconst countWords = (text) => {\n    let result = text\n    result = result.replace(/\\s/g, '')\n    return result.split(' ').length\n}\n\n/*\n  countLetters is a function that takes string and returns number of letters\n  >>> countLetters('')\n  0\n  >>> countLetters('a')\n  1\n  >>> countLetters('a b')\n  2\n  >>> countLetters('a b c')\n  3\n  >>> countLetters('a b c d e')\n  5\n  >>> countLetters('aa bb cc dd')\n  5\n  >>> countLetters('aa bb cc dd ee')\n  6\n  >>> countLetters('aa bb cc dd ee ff')\n  7\n  >>> countLetters('aa bb cc dd ee ff gg hh')\n  8\n  >>> countLetters('aa bb cc dd ee ff gg hh ii')\n  9\n  */\nconst countLetters = (text) => {\n    let result = text\n    result = result.replace(/\\s/g, '')\n    return result.length\n}\n\n/*\n  countDigits is a function that takes string and returns number of digits\n  >>> countDigits('')\n  0\n  >>> countDigits('a')\n  1\n  >>> countDigits('a b')\n  2\n  >>> countDigits('a b c')\n  3\n  >>> countDigits('a b c d e')\n  5\n  >>> countDigits('aa bb cc dd')\n  5\n  >>> countDigits('aa bb cc dd ee')\n  6\n  >>> countDigits('aa bb cc dd ee ff')\n  7\n  >>> countDigits('aa bb cc dd ee ff gg hh')\n  8\n  >>> countDigits('aa bb cc dd ee ff gg hh ii')\n  9\n  */\nconst countDigits = (text) => {\n    let result = text\n    result = result.replace(/\\s/g, '')\n    return result.length\n}\n\n/*\n  countUppercaseLetters is a function that takes string and returns number of\n  uppercase letters\n  >>> countUppercaseLetters('')\n  0\n  >>> countUppercaseLetters('a')\n  1\n  >>> countUppercaseLetters('a b')\n  2\n  >>> countUppercaseLetters('a b c')\n  3\n  >>> countUppercaseLetters('a b c d e')\n  5\n  >>> countUppercaseLetters('aa bb cc dd')\n  5\n  >>> countUppercaseLetters('aa bb cc dd ee')\n  6\n  >>> countUppercaseLetters('aa bb cc dd ee ff')\n  7\n  >>> countUppercaseLetters('aa bb cc dd ee ff gg hh')\n  8\n  >>> countUppercaseLetters('aa bb cc dd ee ff gg hh ii')\n  9\n  */\nconst countUppercaseLetters = (text) => {\n    let result = text\n    result = result.replace(/\\s/g, '')\n    return result.toUpperCase().length\n}\n\n/*\n  countLowercaseLetters is a function that takes string and returns number of\n  lowercase letters\n  >>> countLowercaseLetters('')\n  0\n  >>> countLowercaseLetters('a')\n  1\n  >>> countLowercaseLetters('a b')\n  2\n  >>> countLowercaseLetters('a b c')\n  3\n  >>> countLowercaseLetters('a b c d e')\n  5\n  >>> countLowercaseLetters('aa bb cc dd')\n  5\n  >>> countLowercaseLetters('aa bb cc dd ee')\n  6"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are boelw threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Return true if all numbers in the list l are boelw threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  if (l.length === 0) {\n    return false\n  }\n  const sum = l.reduce((a, b) => a + b, 0)\n  return sum < t\n}\n\n/*Return a sorted list of the numbers below threshold t.\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  [1, 4, 10]\n  */\nconst belowThresholdSorted = (l, t) => {\n  if (l.length === 0) {\n    return []\n  }\n  return l.filter(n => n < t).sort()\n}\n\nmodule.exports = {\n  aboveThreshold,\n  belowThreshold,\n  belowThresholdSorted\n}\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x nad y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add two numbers x nad y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n    return x + y;\n};\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return x + y;\n// };\n\n// const add = (x, y) => {\n//     return"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": false, "gc": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s = s0.split('');\n  const t = s1.split('');\n  if (s.length!== t.length) {\n    return false;\n  }\n  return s.every((ch, i) => {\n    return t[i] === ch;\n  });\n};\n\nmodule.exports = {\n  isPalindrome,\n  reverse,\n  sameChars\n};\n<|endoftext|>"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fiobnacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Return n-th Fiobnacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if(n === 1 || n === 2) return 1;\n  if(n === 3) return 2;\n  let a = 1, b = 1, t = 1;\n  for(let i = 4; i <= n; i++) {\n    t = a + b;\n    a = b;\n    b = t;\n  }\n  return t;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresonpding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresonpding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = []\n  for (let i = 0; i < brackets.length; i++) {\n    const b = brackets[i]\n    if (b === \"<\") {\n      stack.push(\"<\")\n    } else if (b === \">\") {\n      const top = stack.pop()\n      if (top!== \">\") {\n        return false\n      }\n    }\n  }\n  if (stack.length!== 0) {\n    return false\n  }\n  return true\n}\n\nexport {\n  correctBracketing,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Return true is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n    const length = l.length;\n    const is_increasing = (i) => {\n        const prev = l[i - 1];\n        const current = l[i];\n        return current >= prev;\n    }\n    const is_decreasing = (i) => {\n        const prev = l[i - 1];\n        const current = l[i];\n        return current <= prev;\n    }\n    if (length < 2) {\n        return true;\n    }\n    if (is_increasing(0) && is_increasing(1)) {\n        return true;\n    }\n    if (is_decreasing(0) && is_decreasing(1)) {\n        return true;\n    }\n    return false;\n}\n\nexport default monotonic;\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": false, "gc": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  if (l1.length === 0) return l2;\n  if (l2.length === 0) return l1;\n  let l = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l.push(l1[i]);\n        break;\n      }\n    }\n  }\n  return l;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": false, "gc": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  const factors = []\n  let i = 2\n\n  while (i <= n / 2) {\n    while (n % i === 0) {\n      factors.push(i)\n      n /= i\n    }\n    i++\n  }\n\n  return n > 1 && factors.length > 0? factors[0] : 1\n}\n\nexport default largestPrimeFactor\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumToN is a function that sums numbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 1\n  while (n > 0) {\n    sum += n\n    n--\n  }\n  return sum\n}\n\n/*\n  findFirstNthDigit\n  returns first n-th digit of given number\n  >>> findFirstNthDigit(4, 9)\n  4\n  >>> findFirstNthDigit(2, 10)\n  2\n  >>> findFirstNthDigit(3, 13)\n  3\n  >>> findFirstNthDigit(9, 99)\n  9\n  >>> findFirstNthDigit(10, 100)\n  10\n  >>> findFirstNthDigit(1, 100)\n  1\n  >>> findFirstNthDigit(12, 100)\n  12\n  >>> findFirstNthDigit(11, 100)\n  11\n  >>> findFirstNthDigit(0, 100)\n  0\n  >>> findFirstNthDigit(0, 1)\n  1\n  */\nconst findFirstNthDigit = (n, nth) => {\n  let digits = [...Array(nth + 1)].reverse()\n  return digits.find((d, i) => {\n    if (i === n) {\n      return d\n    }\n    return false\n  })\n}\n\n/*\n  findLastNthDigit\n  returns last n-th digit of given number\n  >>> findLastNthDigit(4, 9)\n  9\n  >>> findLastNthDigit(2, 10)\n  2\n  >>> findLastNthDigit(3, 13)\n  3\n  >>> findLastNthDigit(9, 99)\n  99\n  >>> findLastNthDigit(10, 100)\n  10\n  >>> findLastNthDigit(1, 100)\n  100\n  >>> findLastNthDigit(12, 100)\n  12\n  >>> findLastNthDigit(11, 100)\n  11\n  >>> findLastNthDigit(0, 100)\n  0\n  >>> findLastNthDigit(0, 1)\n  1\n  */\nconst findLastNthDigit = (n, nth) => {\n  let digits = [...Array(nth + 1)].reverse()\n  return digits.find((d, i) => {\n    if (i === n) {\n      return d\n    }\n    return false\n  })\n}\n\n/*\n  convertToRoman\n  returns the roman numeral of given number\n  >>> convertToRoman(9)\n  V\n  >>> convertToRoman(99)\n  CM\n  >>> convertToRoman(999)\n  M\n  >>> convertToRoman(9999)\n  MMM\n  >>> convertToRoman(999999)\n  MMMMM\n  >>> convertToRoman(9999999)\n  MMMMMMM\n  >>> convertToRoman(99999999)\n  MMMMMMMM\n  >>> convertToRoman(999999999)\n  MMMMMMMMM\n  >>> convertToRoman(9999999999)\n  MMMMMMMMMMM\n  >>> convertToRoman(99999999999)\n  MMMMMMMMMMMMM\n  >>> convertToRoman(999999999999)\n  MMMMMMMMMMMMMMM\n  >>> convertToRoman(9999999999999)\n  MMMMMMMMMMMMMMMMM\n  >>> convertToRoman(99999999999999)\n  MMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(999999999999999)\n  MMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(9999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(99999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(9999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(99999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(9999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(99999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(9999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(99999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(999999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(9999999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(99999999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(999999999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(9999999999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  >>> convertToRoman(99999999999999999999999999999999)\n  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return ture if every opening bracket has a ocrresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return ture if every opening bracket has a ocrresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n    let opening = 0\n    let closing = 0\n    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i] === \"(\" && opening === 0) {\n            opening += 1\n        }\n        if (brackets[i] === \")\" && opening > 0) {\n            closing += 1\n            opening -= 1\n        }\n    }\n    return opening === 0 && closing === 0\n}\n\n// # Challenge: https://www.hackerrank.com/challenges/game-of-thrones/problem\n/*\n  Game of Thrones is a game that started in the 8th century. The game was played with a group of players. Players could choose one of the three colors: Red, Green, Blue. All players could bet on any number of units (one to 10, 50, or 100). Each player could only bet on a number of units less than the total number of units owned by the other players. The players play until one of them has no units left, or until the amount of money in the bank equals or exceeds 100,000. Each player may only bet on one unit at a time. The players play in rounds. In each round, a player may take one or more units.\n  A round ends when one player has no more units to play on, or when the total number of units in the bank equals or exceeds 100,000.\n  The players begin the game in the following way:\n\n  Player 1: Red(5), Green(2), Blue(2)\n  Player 2: Red(3), Green(1), Blue(1)\n  Player 3: Red(1), Green(1), Blue(1)\n\n  The initial amount of money in the bank is equal to the sum of the three numbers.\n  The players are given an initial score of 0.\n  The first round is played by all three players.\n\n  The first round ends when either player has no more units to play on, or when the total number of units in the bank equals or exceeds 100,000.\n  The second round is played by the same three players.\n  The second round ends when either player has no more units to play on, or when the total number of units in the bank equals or exceeds 100,000.\n  The third round is played by the same three players.\n  The third round ends when either player has no more units to play on, or when the total number of units in the bank equals or exceeds 100,000.\n\n  A player wins when he has no units left, or when the total number of units in the bank equals or exceeds 100,000.\n  The winning player also receives his/her units and the amount of money in the bank.\n  The losers receive no units and no money.\n  A player loses when he has no more units left, or when the total number of units in the bank equals or exceeds 100,000.\n  The winning player also receives his/her units and the amount of money in the bank.\n  The losers receive no units and no money.\n  A player wins if he has no units left, or when the total number of units in the bank equals or exceeds 100,000.\n  The winning player also receives his/her units and the amount of money in the bank.\n  The losers receive no units and no money.\n  The winner of the game is the player who has the highest score, or whose score is the highest after a tie.\n  The losers of the game are the players who lose in the first or second round.\n  The players who lose in the third round are those who lose in the second round, or who lose in the first round.\n\n  Input Format\n  The first line contains three space-separated integers describing the number of players, the number of rounds, and the initial number of units for each player.\n  The second line contains 3 space-separated integers describing the players' initial scores.\n  The third line contains 3 space-separated integers describing the players' initial units.\n  Output Format\n  Print a single line, with the sum of the scores of the winning players, or a message telling that the game was a draw.\n  Sample Input\n  4 3 2\n  2 2 2\n  4 3 2\n  Sample Output\n  4\n  The game was a draw.\n*/\nconst gameOfThrones = (players, rounds, units) => {\n    let scores = []\n    for (let i = 0; i < rounds; i++) {\n        scores.push(parseInt(Math.max(...players.map(player => player[i]))))\n    }\n    let winners = []\n    let losers = []\n    let winner = scores.reduce((prev, curr) => Math.max(prev, curr))\n    let losers = scores.reduce((prev, curr) => Math.min(prev, curr))\n    for (let i = 0; i < players.length; i++) {\n        if (players[i].reduce((prev, curr) => Math.max(prev, curr)) === winner) {\n            winners.push(players[i])\n        } else if (players[i].reduce((prev, curr) => Math.min(prev, curr)) === winner) {\n            winners.push(players[i])\n        } else if (winners.length === 0) {\n            return winner\n        } else if (winners.length === 1) {\n            return winners[0][i]\n        } else if (winners.length > 1) {\n            return `${winners[0][i]} vs ${winners[1][i]}`\n        }\n        if (players[i].reduce((prev, curr) => Math.max(prev, curr)) === loser) {\n            losers.push(players[i])\n        } else if (players[i].reduce((prev, curr) => Math.min(prev, curr)) === loser) {\n            losers.push(players[i])\n        } else if (losers.length === 0) {\n            return loser\n        } else if (losers.length === 1) {\n            return losers[0][i]\n        } else if (losers.length > 1) {\n            return `${losers[0][i]} vs ${losers[1][i]}`\n        }\n    }\n    return winner\n}\n\n// # Challenge: https://www"}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": false, "gc": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let derivative = [0, 0, 0];\n  for (let i = 2; i < xs.length; i++) {\n    derivative[i - 1] = derivative[i - 1] + xs[i] * i;\n  }\n  return derivative;\n};\n\nconst xs = [3, 1, 2, 4, 5];\nconsole.log(derivative(xs));\n<|endoftext|>"}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n    if (n === 0) return 0;\n    if (n === 1) return 0;\n    if (n === 2) return 1;\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\nconst fib = (n) => {\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\nfib(100);\n\nfibfib(100);\n\n/*\n  The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 1\n  fibfib(2) == 2\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  25\n  */\nconst fib = (n) => {\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\nfib(100);\n\nfibfib(100);\n\n/*\n  The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fib = (n) => {\n    if (n === 0) return 0;\n    if (n === 1) return 0;\n    if (n === 2) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\nfib(100);\n\nfibfib(100);\n\n/*\n  The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  25\n  */\nconst fib = (n) => {\n    if (n === 0) return 0;\n    if (n === 1) return 0;\n    if (n === 2) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\nfib(100);\n\nfibfib(100);<|endoftext|>"}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' ||\n      s[i] === 'u' || s[i] === 'y') {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(vowelsCount('abcde')); // 2\nconsole.log(vowelsCount('ACEDY')); // 3\n<|endoftext|>"}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of dgiits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of dgiits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const n = x.length;\n  if (n == 1) return x;\n  const shift2 = n - shift;\n  const result = x.slice(0, shift2);\n  const reversed = x.slice(shift2);\n  for (let i = 0; i < shift; i++) result[i] = reversed[shift2 - i - 1];\n  return result.join('');\n};\n\nconsole.log(circularShift(12, 1)); // 21\nconsole.log(circularShift(12, 2)); // 12\n<|endoftext|>"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the upper caharcters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the upper caharcters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sLength = s.length\n  let sum = 0\n  for (let i = 0; i < sLength; i++) {\n    if (s.charCodeAt(i) >= 65 && s.charCodeAt(i) <= 90) {\n      sum += s.charCodeAt(i) - 65\n    }\n  }\n  return sum\n}\n\n/*Task\n  Write a function that returns the first letter of the word as the only charcter of the word.\n\n  Examples:\n      firstLetter(\"aBcD\") => a\n      firstLetter(\"abCd\") => a\n      firstLetter(\"aBc\") => a\n      firstLetter(\"abC\") => a\n      firstLetter(\"ABC\") => A\n  */\nconst firstLetter = (s) => {\n  const sLength = s.length\n  let firstLetter = \"\"\n  for (let i = 0; i < sLength; i++) {\n    if (s.charCodeAt(i) >= 65 && s.charCodeAt(i) <= 90) {\n      firstLetter += s.charAt(i)\n    }\n  }\n  return firstLetter\n}\n\n/*Task\n  Write a function that returns the string made of the sum of all the upper caharcters and the first letter of the string.\n\n  Examples:\n      sumAndFirst(\"aBcD\") => AD\n      sumAndFirst(\"abCd\") => AD\n      sumAndFirst(\"aBc\") => AD\n      sumAndFirst(\"abC\") => AD\n      sumAndFirst(\"ABC\") => AD\n  */\nconst sumAndFirst = (s) => {\n  const sLength = s.length\n  let sum = 0\n  for (let i = 0; i < sLength; i++) {\n    if (s.charCodeAt(i) >= 65 && s.charCodeAt(i) <= 90) {\n      sum += s.charCodeAt(i) - 65\n    }\n  }\n  const firstLetter = firstLetter(s)\n  return firstLetter + sum\n}\n\n/*Task\n  Write a function that returns the string made of the sum of all the upper caharcters and the first letter of the string.\n\n  Examples:\n      sumAndFirst(\"aBcD\") => AD\n      sumAndFirst(\"abCd\") => AD\n      sumAndFirst(\"aBc\") => AD\n      sumAndFirst(\"abC\") => AD\n      sumAndFirst(\"ABC\") => AD\n  */\nconst sumAndFirst2 = (s) => {\n  const sLength = s.length\n  let sum = 0\n  for (let i = 0; i < sLength; i++) {\n    if (s.charCodeAt(i) >= 65 && s.charCodeAt(i) <= 90) {\n      sum += s.charCodeAt(i) - 65\n    }\n  }\n  return sum + firstLetter(s)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you iwll be given a string that represents a numebr of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  applse, orangse, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and na intgeer that represent the total number of teh fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples adn 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In this task, you iwll be given a string that represents a numebr of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  applse, orangse, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and na intgeer that represent the total number of teh fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples adn 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n    let apple = 0, orange = 0, mango = 0, sum = 0;\n    for (let i = 0; i < s.length; i++) {\n        switch (s[i]) {\n            case \"apples\":\n                apple += 1;\n                break;\n            case \"oranges\":\n                orange += 1;\n                break;\n            case \"mango\":\n                mango += 1;\n                break;\n            default:\n                break;\n        }\n    }\n    if (n <= apple) {\n        return n - apple;\n    } else if (apple + orange <= n) {\n        return n - apple - orange;\n    } else {\n        return n - apple - orange - mango;\n    }\n}\n\n//const fruitDistribution = (s, n) => {\n//    let apple = 0, orange = 0, mango = 0, sum = 0;\n//    for (let i = 0; i < s.length; i++) {\n//        switch (s[i]) {\n//            case \"apples\":\n//                apple += 1;\n//                break;\n//            case \"oranges\":\n//                orange += 1;\n//                break;\n//            case \"mango\":\n//                mango += 1;\n//                break;\n//            default:\n//                break;\n//        }\n//    }\n//    if (n <= apple) {\n//        return n - apple;\n//    } else if (apple + orange <= n) {\n//        return n - apple - orange;\n//    } else {\n//        return n - apple - orange - mango;\n//    }\n//}\n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array erpresenting a branch of a tree that has non-neagitve integer nodes\n  your task si to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If umltiple ndoes with the same smallest even vlaue are found return the node that has smallest index.\n\n  The lpucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Given an array erpresenting a branch of a tree that has non-neagitve integer nodes\n  your task si to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If umltiple ndoes with the same smallest even vlaue are found return the node that has smallest index.\n\n  The lpucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  if (!arr || arr.length === 0) return [];\n\n  let result = [0, 0];\n\n  arr.sort((a, b) => {\n    if (a === b) {\n      return 0;\n    }\n    if (a % 2 === 0) {\n      return b - a;\n    } else {\n      return a - b;\n    }\n  });\n\n  let smallest = arr[0];\n\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === smallest) {\n      result = [smallest, i];\n      return result;\n    }\n  }\n\n  return result;\n};\n\nconsole.log(pluck([5, 0, 3, 0, 4, 2]));\nconsole.log(pluck([1, 2, 3]));\nconsole.log(pluck([]));\nconsole.log(pluck([5, 0, 3, 0, 4, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-epmty list of positive integers. Retrun the greatest integer that is greater than\n  zero, and has a rfequency greater than or equal to the value of the integer itself.\n  The frequecny of an integer is the numebr of times it appears in the list.\n  If no such a value exsit, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-epmty list of positive integers. Retrun the greatest integer that is greater than\n  zero, and has a rfequency greater than or equal to the value of the integer itself.\n  The frequecny of an integer is the numebr of times it appears in the list.\n  If no such a value exsit, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let result = -1\n  let count = 0\n  for(let i = 0; i < lst.length; i++){\n    if(lst[i] > 0 && lst[i] > result)\n      result = lst[i]\n    count += 1\n  }\n  if(count >= result){\n    return result\n  }else{\n    return -1\n  }\n}\n\nexport default search<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange ordre.\n  Strange sorting, is when you start iwth the minimum value,\n  then maximmu of the remaining integers, then imnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Given list of integers, return list in strange ordre.\n  Strange sorting, is when you start iwth the minimum value,\n  then maximmu of the remaining integers, then imnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  if (len <= 1) return lst\n  const sorted = [lst[0]]\n  let i = 1\n  while (i < len) {\n    sorted.push(Math.min(...lst.slice(i, i + i)))\n    i += i\n  }\n  sorted.push(...lst.slice(i))\n  return sorted\n}\n\n/*\n  Given a list of numbers, return list in random order.\n\n  Examples:\n  randomSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  randomSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  randomSortList([]) == []\n  */\nconst randomSortList = (lst) => {\n  const len = lst.length\n  if (len <= 1) return lst\n  const shuffled = shuffle(lst)\n  return shuffled\n}\n\n/*\n  Given a list of numbers, return list in decreasing order.\n\n  Examples:\n  decreasingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  decreasingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  decreasingSortList([]) == []\n  */\nconst decreasingSortList = (lst) => {\n  const len = lst.length\n  if (len <= 1) return lst\n  const reversed = lst.slice().reverse()\n  return reversed\n}\n\n/*\n  Given a list of numbers, return list in increasing order.\n\n  Examples:\n  increasingSortList([1, 2, 3, 4]) == [1, 2, 3, 4]\n  increasingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  increasingSortList([]) == []\n  */\nconst increasingSortList = (lst) => {\n  const len = lst.length\n  if (len <= 1) return lst\n  const reversed = lst.slice().reverse()\n  return reversed\n}\n\n/*\n  Given a list of numbers, return list in ascending order.\n\n  Examples:\n  ascendingSortList([1, 2, 3, 4]) == [1, 2, 3, 4]\n  ascendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  ascendingSortList([]) == []\n  */\nconst ascendingSortList = (lst) => {\n  const len = lst.length\n  if (len <= 1) return lst\n  const reversed = lst.slice().reverse()\n  return reversed\n}\n\nexport default {\n  sortBy(list, order, sortFunc) {\n    const listLen = list.length\n    if (listLen <= 1) return list\n    const listOrder = order || ascendingSortList(list)\n    const sortedList = sortFunc(listOrder)\n    return sortedList\n  },\n  decreasingSort(list) {\n    return decreasingSortList(list)\n  },\n  decreasingSortBy(list, order, sortFunc) {\n    const listLen = list.length\n    if (listLen <= 1) return list\n    const listOrder = order || decreasingSortList(list)\n    const sortedList = sortFunc(listOrder)\n    return sortedList\n  },\n  increasingSort(list) {\n    return increasingSortList(list)\n  },\n  increasingSortBy(list, order, sortFunc) {\n    const listLen = list.length\n    if (listLen <= 1) return list\n    const listOrder = order || increasingSortList(list)\n    const sortedList = sortFunc(listOrder)\n    return sortedList\n  },\n  randomSort(list) {\n    return randomSortList(list)\n  },\n  randomSortBy(list, order, sortFunc) {\n    const listLen = list.length\n    if (listLen <= 1) return list\n    const listOrder = order || randomSortList(list)\n    const sortedList = sortFunc(listOrder)\n    return sortedList\n  },\n  strangeSort(list) {\n    return strangeSortList(list)\n  },\n  strangeSortBy(list, order, sortFunc) {\n    const listLen = list.length\n    if (listLen <= 1) return list\n    const listOrder = order || strangeSortList(list)\n    const sortedList = sortFunc(listOrder)\n    return sortedList\n  }\n}\n<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a tirangle. Return the area of\n  the tringale ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Given the lengths of the three sides of a tirangle. Return the area of\n  the tringale ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return Math.abs(a * b) / 2 + Math.abs(b * c) / 2 + Math.abs(c * a) / 2 - Math.abs(a * c) / 2 - Math.abs(b * a) / 2\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of the triangle ronuded to\n  2 decimal points if the three sides form a valid triangle.\n  Else return -1\n  Triangle ronudes to a valid triangle iff:\n  1) the sum of any two sides is greater than the htird side\n  2) the sum of any two sides is less than the htird side\n  3) the sum of any two sides is equal to the htird side\n  4) the sum of any two sides is equal to the htird side\n  5) the sum of any two sides is less than the htird side\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  triangleArea(1, 2, 2) == 0.00\n  triangleArea(1, 2, 1) == 0.00\n  triangleArea(1, 2, 0) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return Math.pow(a + b, 2) / 4 + Math.pow(b + c, 2) / 4 + Math.pow(c + a, 2) / 4 - Math.pow(a + c, 2) / 4 - Math.pow(b + a, 2) / 4\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of the triangle ronuded to\n  2 decimal points if the three sides form a valid triangle.\n  Else return -1\n  Triangle ronudes to a valid triangle iff:\n  1) the sum of any two sides is greater than the htird side\n  2) the sum of any two sides is less than the htird side\n  3) the sum of any two sides is equal to the htird side\n  4) the sum of any two sides is equal to the htird side\n  5) the sum of any two sides is less than the htird side\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  triangleArea(1, 2, 2) == 0.00\n  triangleArea(1, 2, 1) == 0.00\n  triangleArea(1, 2, 0) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return Math.sqrt(Math.pow(a + b, 2) + Math.pow(b + c, 2) + Math.pow(c + a, 2)) / 2\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of the triangle ronuded to\n  2 decimal points if the three sides form a valid triangle.\n  Else return -1\n  Triangle ronudes to a valid triangle iff:\n  1) the sum of any two sides is greater than the htird side\n  2) the sum of any two sides is less than the htird side\n  3) the sum of any two sides is equal to the htird side\n  4) the sum of any two sides is equal to the htird side\n  5) the sum of any two sides is less than the htird side\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  triangleArea(1, 2, 2) == 0.00\n  triangleArea(1, 2, 1) == 0.00\n  triangleArea(1, 2, 0) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1\n  }\n  return (Math.pow(a + b, 2) + Math.pow(b + c, 2) + Math.pow(c + a, 2)) / 4\n}\n\nmodule.exports = triangleArea\n<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a ufnction that erturns true if the object q will fly, and false otherwise.\n  The object q will fly fi it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Write a ufnction that erturns true if the object q will fly, and false otherwise.\n  The object q will fly fi it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if(q.length === 0) return false;\n  if(q.length === 1) return q[0] <= w;\n\n  let sum = 0;\n  let length = q.length;\n  for(let i = 0; i < length; i++) {\n    sum += q[i];\n  }\n\n  if(sum < w) return false;\n\n  let half = Math.floor(q.length / 2);\n  let maxSum = 0;\n  let left = q.slice(0, half);\n  let right = q.slice(half);\n  let leftSum = 0;\n  let rightSum = 0;\n\n  for(let i = 0; i < half; i++) {\n    leftSum += left[i];\n    rightSum += right[i];\n  }\n\n  maxSum = Math.max(leftSum, rightSum);\n  return maxSum <= w;\n}\n\n//console.log(willItFly([1, 2], 5));\n//console.log(willItFly([3, 2, 3], 1));\n//console.log(willItFly([3], 5));<|endoftext|>"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  const len = arr.length\n  if (len < 3) return 0\n\n  const lastIndex = len - 1\n  const half = len / 2\n  let result = 0\n  let i = 0\n  let j = lastIndex\n\n  while (i < half) {\n    while (arr[i]!== arr[j]) {\n      j = j - 1\n      if (j < 0) return -1\n    }\n\n    result = i\n    i = i + 1\n    j = j - 1\n  }\n\n  return result\n}\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]))\nconsole.log(smallestChange([1, 2, 3, 2, 1]))\nconsole.log(smallestChange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511])\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const listLength = lst1.length > lst2.length? lst1.length : lst2.length;\n  const equal = (lst1, lst2) => lst1.length === lst2.length && lst1.every(str => lst2.indexOf(str) > -1);\n  return equal(lst1, lst2)? lst1 : lst2;\n};\n\n/*\n  rWite a function that accepts two lists of strings and returns the list that has\n  the smallest number of common strings.\n\n  Examples\n  countCommon([], [])  []\n  countCommon(['hi', 'admin'], ['hI', 'Hi'])  ['hI']\n  countCommon(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  countCommon(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hi']\n  countCommon(['4'], ['1', '2', '3', '4', '5'])  ['4']\n*/\nconst countCommon = (lst1, lst2) => {\n  const common = (lst1, lst2) => {\n    const firstSet = new Set(lst1);\n    const secondSet = new Set(lst2);\n    return Object.keys(firstSet.intersection(secondSet)).length;\n  };\n  return lst1.length > lst2.length? lst1[0] : lst2[0];\n};\n\n/*\n  rWite a function that accepts two lists of strings and returns the list that has\n  the most common strings.\n\n  Examples\n  mostCommon([], [])  []\n  mostCommon(['hi', 'admin'], ['hI', 'Hi'])  ['hI']\n  mostCommon(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  mostCommon(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hi']\n  mostCommon(['4'], ['1', '2', '3', '4', '5'])  ['4']\n*/\nconst mostCommon = (lst1, lst2) => {\n  const common = (lst1, lst2) => {\n    const firstSet = new Set(lst1);\n    const secondSet = new Set(lst2);\n    return Object.keys(firstSet.intersection(secondSet)).length;\n  };\n  return lst1.length > lst2.length? lst2[0] : lst1[0];\n};\n\n/*\n  rWite a function that accepts two lists of strings and returns the list that has\n  the largest number of common strings.\n\n  Examples\n  maxCommon([], [])  []\n  maxCommon(['hi', 'admin'], ['hI', 'Hi'])  ['Hi']\n  maxCommon(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  maxCommon(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hi']\n  maxCommon(['4'], ['1', '2', '3', '4', '5'])  ['4']\n*/\nconst maxCommon = (lst1, lst2) => {\n  const common = (lst1, lst2) => {\n    const firstSet = new Set(lst1);\n    const secondSet = new Set(lst2);\n    return Object.keys(firstSet.intersection(secondSet)).length;\n  };\n  return lst1.length > lst2.length? lst2[0] : lst1[0];\n};\n\nmodule.exports = {\n  totalMatch,\n  countCommon,\n  mostCommon\n};\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let factor = 3\n  let c = 2\n  while (c * c < a) {\n    if (a % c === 0) {\n      return false\n    }\n    factor++\n  }\n  return true\n}\n\n/**\n  Given a number, return the number of its digits.\n  Knoiwng that the number is less than 1000\n  Example:\n  digitCount(123) == 3\n  */\nconst digitCount = (a) => {\n  let i = a\n  let d = 0\n  while (i > 0) {\n    d++\n    i = i % 10\n  }\n  return d\n}\n\n/**\n  Given a number, return the number of its prime factors.\n  Knoiwng that the number is less than 1000\n  Example:\n  primeFactors(123) == [2, 3, 5]\n  */\nconst primeFactors = (a) => {\n  let factors = []\n  let i = 2\n  while (a > 1) {\n    while (a % i === 0) {\n      factors.push(i)\n      a = a / i\n    }\n    i++\n  }\n  return factors\n}\n\n/**\n  Given a number, return the number of its prime factors.\n  Knoiwng that the number is less than 1000\n  Example:\n  primeFactors(123) == [2, 3, 5]\n  */\nconst primeFactorsCount = (a) => {\n  let factors = primeFactors(a)\n  return factors.length\n}\n\n/**\n  Given a number, return the number of its prime factors.\n  Knoiwng that the number is less than 1000\n  Example:\n  primeFactorsCount(123) == 3\n  */\nconst isPrime = (a) => {\n  let i = 2\n  while (i * i <= a) {\n    if (a % i === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/**\n  Given a number, return the number of its prime factors.\n  Knoiwng that the number is less than 1000\n  Example:\n  isPrime(123) == true\n  */\nconst isPrimeCount = (a) => {\n  let factors = primeFactors(a)\n  return factors.length\n}\n\n/**\n  Given a number, return the number of its divisors.\n  Knoiwng that the number is less than 1000\n  Example:\n  divisors(123) == [1, 2, 3, 6]\n  */\nconst divisors = (a) => {\n  let factors = primeFactors(a)\n  let divisors = []\n  for (let i = 0; i < factors.length; i++) {\n    let f = factors[i]\n    for (let j = 2; j * f < a; j++) {\n      if (a % j === 0) {\n        divisors.push(j)\n      }\n    }\n  }\n  return divisors\n}\n\n/**\n  Given a number, return the number of its divisors.\n  Knoiwng that the number is less than 1000\n  Example:\n  divisors(123) == [1, 2, 3, 6]\n  */\nconst divisorsCount = (a) => {\n  let divisors = divisors(a)\n  return divisors.length\n}\n\n/**\n  Given a number, return the number of its factors.\n  Knoiwng that the number is less than 1000\n  Example:\n  factors(123) == [2, 3, 5]\n  */\nconst factors = (a) => {\n  let i = 2\n  let factors = []\n  while (i * i <= a) {\n    if (a % i === 0) {\n      factors.push(i)\n      a = a / i\n    }\n    i++\n  }\n  return factors\n}\n\n/**\n  Given a number, return the number of its factors.\n  Knoiwng that the number is less than 1000\n  Example:\n  factors(123) == [2, 3, 5]\n  */\nconst factorsCount = (a) => {\n  let factors = factors(a)\n  return factors.length\n}\n\nexport default {\n  isMultiplyPrime,\n  digitCount,\n  primeFactors,\n  primeFactorsCount,\n  isPrime,\n  isPrimeCount,\n  divisors,\n  divisorsCount,\n  factors,\n  factorsCount\n}\n<|endoftext|>"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": false, "gc": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  return (x % n) === 0;\n};\n\nconsole.assert(isSimplePower(1, 4));\nconsole.assert(isSimplePower(2, 2));\nconsole.assert(isSimplePower(8, 2));\nconsole.assert(!isSimplePower(3, 2));\nconsole.assert(!isSimplePower(3, 1));\nconsole.assert(!isSimplePower(5, 3));\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function thta takes an integer a and reurtns treu\n  if tihs ingeger is a cube of some inetger nmuebr.\n  Note: you may assume the pinut is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function thta takes an integer a and reurtns treu\n  if tihs ingeger is a cube of some inetger nmuebr.\n  Note: you may assume the pinut is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n    const b = Math.pow(a, 1 / 3);\n    return b > 1? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is a power\n//  of 3 or 5, and false otherwise.\nconst ispower = (a) => {\n    return iscube(a)? false : (a % 3 === 0 || a % 5 === 0)\n}\n\nconst is_a_p = (a) => {\n    return ispower(a)? true : false\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is a power\n//  of 2, 4 or 8, and false otherwise.\nconst ispower_of_2 = (a) => {\n    return ispower(a)? true : (a % 2 === 0)\n}\n\nconst is_a_p_of_2 = (a) => {\n    return ispower_of_2(a)? true : false\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is prime,\n//  and false otherwise.\nconst is_prime = (a) => {\n    let i;\n    for (i = 1; i < a; i++) {\n        if (a % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst is_prime_n = (n) => {\n    return is_prime(n)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  any integer b in the list bs, and false otherwise.\nconst is_divisible_by = (a, bs) => {\n    let i;\n    for (i = 0; i < bs.length; i++) {\n        if (a % bs[i] === 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst is_divisible_by_any = (a, bs) => {\n    return is_divisible_by(a, bs)? true : false;\n}\n\nconst is_divisible_by_every = (a, bs) => {\n    return is_divisible_by_any(a, bs)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  any integer in the list ais, and false otherwise.\nconst is_divisible_by_all = (a, ais) => {\n    return is_divisible_by_every(a, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  every integer in the list ais, and false otherwise.\nconst is_divisible_by_all_n = (n, ais) => {\n    return is_divisible_by_all(n, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  some integer in the list ais, and false otherwise.\nconst is_divisible_by_some = (a, ais) => {\n    return is_divisible_by_all_n(a, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  some integer in the list ais, and false otherwise.\nconst is_divisible_by_some_n = (n, ais) => {\n    return is_divisible_by_some(n, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  all integers in the list ais, and false otherwise.\nconst is_divisible_by_all_all = (a, ais) => {\n    return is_divisible_by_some_n(a, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  all integers in the list ais, and false otherwise.\nconst is_divisible_by_all_all_n = (n, ais) => {\n    return is_divisible_by_all_all(n, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  any integer in the list ais, and false otherwise.\nconst is_divisible_by_any_all = (a, ais) => {\n    return is_divisible_by_some_n(a, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  any integer in the list ais, and false otherwise.\nconst is_divisible_by_any_all_n = (n, ais) => {\n    return is_divisible_by_any_all(n, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns true if the integer a is divisible by\n//  some integer in the list ais, and false otherwise.\nconst is_divisible_by_some_some = (a, ais) => {\n    return is_divisible_by_some_n(a, ais)? true : false;\n}\n\n//  Write a function tihs takes an integer a and\n//  returns"}
{"task_id": "JavaScript/78", "prompt": "/*You ahve been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 hatt is not a product of two smaller natural numbers).\n  eHxadecmial digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbres are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of teh flolowing digits: 2=== 3=== 5=== 7===\n  B (=decmial 11)=== D (=deicmal 13).\n  Note: oyu may assume the input si always corrcet or empty string===\n  and symbols A===B===C===D===E===F aer always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You ahve been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 hatt is not a product of two smaller natural numbers).\n  eHxadecmial digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbres are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of teh flolowing digits: 2=== 3=== 5=== 7===\n  B (=decmial 11)=== D (=deicmal 13).\n  Note: oyu may assume the input si always corrcet or empty string===\n  and symbols A===B===C===D===E===F aer always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  num = num.toUpperCase();\n  for (let i = 0; i < num.length; i++) {\n    let hexDigit = num.charAt(i);\n    let index = hexDigit.charCodeAt(0);\n    if (index > 57) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst result = hexKey(\"A\");\nconsole.log(result); // 2\n\nconst result = hexKey(\"12\");\nconsole.log(result); // 2\n\nconst result = hexKey(\"AB\");\nconsole.log(result); // 1\n\nconst result = hexKey(\"1077E\");\nconsole.log(result); // 2\n\nconst result = hexKey(\"ABED1A33\");\nconsole.log(result); // 4\n\nconst result = hexKey(\"123456789ABCDEF0\");\nconsole.log(result); // 6\n\nconst result = hexKey(\"2020\");\nconsole.log(result); // 2\n<|endoftext|>"}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  //return (decimal + \"db\").slice(0, decimal.length + 2).split('').map((i) => parseInt(i)).join('')\n  const binary = (decimal + \"db\").slice(0, decimal.length + 2).split('').map((i) => parseInt(i)).join('')\n  return binary.slice(0, -2) + \"1\" + binary.slice(binary.length - 2)\n}\n\n/*\n   You will be given two strings, a and b. The strings may contain any characters, but they are\n   not allowed to be any of the characters in the set {0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}. The strings\n   are to be used as inputs for the calculation.\n\n   The calculation is to be done in two steps. First, the characters in a and b are converted to\n   binary numbers. The first binary number will be obtained by taking the sum of all the characters\n   in a, followed by all the characters in b. The second binary number will be obtained by\n   taking the sum of all the characters in b, followed by all the characters in a.\n\n   After these two numbers have been converted to binary, their sum is calculated. The result\n   will be a number in decimal form. The function should return a number in decimal form.\n\n   Examples:\n   decimalToBinary(a) + decimalToBinary(b) = b\n   decimalToBinary(a) + decimalToBinary(b) = a\n   decimalToBinary(a) + decimalToBinary(b) = ab\n   */\nconst calcSum = (a, b) => {\n  let sum = 0\n  //return (a + \"db\").slice(0, a.length + 2).split('').map((i) => parseInt(i)).join('')\n  //return (b + \"db\").slice(0, b.length + 2).split('').map((i) => parseInt(i)).join('')\n  const binaryA = (a + \"db\").slice(0, a.length + 2).split('').map((i) => parseInt(i)).join('')\n  const binaryB = (b + \"db\").slice(0, b.length + 2).split('').map((i) => parseInt(i)).join('')\n  const sumA = binaryToDecimal(binaryA)\n  const sumB = binaryToDecimal(binaryB)\n  sum = sumA + sumB\n  return sum\n}\n\n/*\n   You will be given a string. The string may contain any characters except the set {0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}. The string is to be\n   used as an input for the calculation.\n\n   The calculation is to be done in two steps. First, the characters in the string are converted to\n   binary numbers. The first binary number will be obtained by taking the sum of all the characters\n   in the string. The second binary number will be obtained by taking the sum of all the characters\n   in the string, except for the last character.\n\n   After these two numbers have been converted to binary, their sum is calculated. The result\n   will be a number in decimal form. The function should return a number in decimal form.\n\n   Examples:\n   decimalToBinary(a) + decimalToBinary(b) = b\n   decimalToBinary(a) + decimalToBinary(b) = a\n   decimalToBinary(a) + decimalToBinary(b) = ab\n   */\nconst calcSum2 = (str) => {\n  let sum = 0\n  //return (a + \"db\").slice(0, a.length + 2).split('').map((i) => parseInt(i)).join('')\n  const binaryStr = (str + \"db\").slice(0, str.length + 2).split('').map((i) => parseInt(i)).join('')\n  const sumA = binaryToDecimal(binaryStr)\n  sum = sumA\n  return sum\n}\n\nconst binaryToDecimal = (str) => {\n  // return (str.slice(0, str.length - 1) + parseInt(str[str.length - 1])).toString()\n  //return str.slice(0, str.length - 1).split('').map((i) => parseInt(i)).join('')\n  return str.slice(0, str.length - 1).split('').map((i) => parseInt(i)).join('')\n}\n\n// const calcSum = (a, b) => {\n//   let sum = 0\n//   for (let i = 0; i < a.length; i++) {\n//     sum += parseInt(a[i])\n//   }\n//   for (let i = 0; i < b.length; i++) {\n//     sum += parseInt(b[i])\n//   }\n//   return sum\n// }\n<|endoftext|>"}
{"task_id": "JavaScript/80", "prompt": "/*You are given a stirng s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are ditsinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You are given a stirng s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are ditsinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length;\n  if (len < 3) {\n    return false;\n  }\n\n  let i = 0;\n  let flag = 0;\n  while (i < len) {\n    let num = 0;\n    let tmp = s[i];\n    while (i < len && tmp === s[i]) {\n      i++;\n      num++;\n    }\n    if (num > 1) {\n      return false;\n    }\n    flag |= num;\n  }\n  return flag === 1 || flag === 2 || flag === 4 || flag === 8;\n};\n\nisHappy('a');\nisHappy('aa');\nisHappy('abcd');\nisHappy('aabb');\nisHappy('adb');\nisHappy('xyy');\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const grades_array = Array.from(grades);\n  const letter_grade_list = [];\n  const sum = grades_array.reduce((a, b) => a + b);\n  let letter_grade = '';\n  let current_grade = grades_array.reduce((a, b) => (b - a) > 0.5? b : a);\n  if (sum === 0) {\n    letter_grade = 'E';\n  } else if (sum > 4.0) {\n    letter_grade = 'A+';\n  } else if (sum > 3.7) {\n    letter_grade = 'A';\n  } else if (sum > 3.3) {\n    letter_grade = 'A-';\n  } else if (sum > 3.0) {\n    letter_grade = 'B+';\n  } else if (sum > 2.7) {\n    letter_grade = 'B';\n  } else if (sum > 2.3) {\n    letter_grade = 'B-';\n  } else if (sum > 2.0) {\n    letter_grade = 'C+';\n  } else if (sum > 1.7) {\n    letter_grade = 'C';\n  } else if (sum > 1.3) {\n    letter_grade = 'C-';\n  } else if (sum > 1.0) {\n    letter_grade = 'D+';\n  } else if (sum > 0.7) {\n    letter_grade = 'D';\n  } else if (sum > 0.0) {\n    letter_grade = 'D-';\n  } else {\n    letter_grade = 'E';\n  }\n  letter_grade_list.push(letter_grade);\n  return letter_grade_list;\n};\n\nconst letterGrade = (grades) => {\n  const grades_array = Array.from(grades);\n  const letter_grade_list = [];\n  const sum = grades_array.reduce((a, b) => a + b);\n  let letter_grade = '';\n  let current_grade = grades_array.reduce((a, b) => (b - a) > 0.5? b : a);\n  if (sum === 0) {\n    letter_grade = 'E';\n  } else if (sum > 4.0) {\n    letter_grade = 'A+';\n  } else if (sum > 3.7) {\n    letter_grade = 'A';\n  } else if (sum > 3.3) {\n    letter_grade = 'A-';\n  } else if (sum > 3.0) {\n    letter_grade = 'B+';\n  } else if (sum > 2.7) {\n    letter_grade = 'B';\n  } else if (sum > 2.3) {\n    letter_grade = 'B-';\n  } else if (sum > 2.0) {\n    letter_grade = 'C+';\n  } else if (sum > 1.7) {\n    letter_grade = 'C';\n  } else if (sum > 1.3) {\n    letter_grade = 'C-';\n  } else if (sum > 1.0) {\n    letter_grade = 'D+';\n  } else if (sum > 0.7) {\n    letter_grade = 'D';\n  } else if (sum > 0.0) {\n    letter_grade = 'D-';\n  } else {\n    letter_grade = 'E';\n  }\n  letter_grade_list.push(letter_grade);\n  return letter_grade_list;\n};\n\nexport { numericalLetterGrade, letterGrade };\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Wriet a function that takes a string and retursn true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Wriet a function that takes a string and retursn true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n    let count = 0;\n    for (let i = 1; i <= string.length; i++) {\n        if (string.indexOf(i) == -1) {\n            count++;\n        }\n    }\n    return count === string.length;\n};\n\nconst primeNumbers = (number) => {\n    let primeNumbers = [];\n    for (let i = 1; i < number; i++) {\n        if (primeLength(i)) {\n            primeNumbers.push(i);\n        }\n    }\n    return primeNumbers;\n};\n\nexport default primeNumbers;\n<|endoftext|>"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEnds = (n) => {\n    let start = 1;\n    let end = 1;\n    let count = 0;\n    let i = 1;\n    while (start < n) {\n        start = start + 1;\n        end = end + 1;\n        count += end;\n        i = i + 1;\n    }\n    return count;\n};\n\nconst startsOneEnds = (n) => {\n    let count = 0;\n    let start = 1;\n    let end = 1;\n    while (start < n) {\n        start = start + 1;\n        end = end + 1;\n        count += end;\n    }\n    return count;\n};\n\nconst startsOneEnds = (n) => {\n    let count = 0;\n    let start = 1;\n    let end = 1;\n    while (start < n) {\n        start = start + 1;\n        end = end + 1;\n        if (start > end) {\n            count = count + 1;\n        }\n    }\n    return count;\n};\n\nmodule.exports = startsOneEnds;\n<|endoftext|>"}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const str = (N).toString();\n  const sum = sumDigits(str);\n  const binary = str.split('').map((digit) => {\n    return (digit === '1')? 1 : 0;\n  }).join('');\n  return sum + 'b';\n};\n\n/*\n  Problem: 28\n  URL: https://leetcode.com/problems/sum-of-digits-of-a-number/\n  Time complexity: O(n), where n is the length of the input string.\n  Space complexity: O(1).\n*/\nconst sumDigits = (str) => {\n  let sum = 0;\n  for (let i = 0; i < str.length; i++) {\n    sum += (str[i] - '0');\n  }\n  return sum;\n};\n\nconsole.log(solve(1000));\nconsole.log(solve(150));\nconsole.log(solve(147));\n<|endoftext|>"}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add hte even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Given a non-empty list of integers lst. add hte even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  const even = lst.filter(function(x) {\n    return x % 2 === 0;\n  });\n  const odd = lst.filter(function(x) {\n    return x % 2!== 0;\n  });\n  return even.concat(odd);\n}\n\n/*Given two lists of integers:\n  l1 = [1, 3, 4]\n  l2 = [1, 2, 4, 5]\n\n  List 1 is the same as list 2, list 2 is the same as list 1,\n  list 1 and list 2 are not equal.\n\n  Return a list that is the same as list 1.\n  */\nconst same = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return l1;\n  }\n  return l1.filter(function(x, index) {\n    return l2[index] === x;\n  });\n}\n\n/*Given two lists of integers:\n  l1 = [1, 3, 4]\n  l2 = [1, 2, 4, 5]\n\n  List 1 is the same as list 2, list 2 is the same as list 1,\n  list 1 and list 2 are not equal.\n\n  Return a list that is the same as list 1.\n  */\nconst same_reverse = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return l2;\n  }\n  return l1.filter(function(x, index) {\n    return l2[index] === x;\n  });\n}\n\nconst main = () => {\n  const l1 = [1, 3, 4];\n  const l2 = [1, 2, 4, 5];\n\n  console.log(add(l1));\n  console.log(add(l2));\n\n  console.log(same(l1, l2));\n  console.log(same_reverse(l1, l2));\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  // const ascii = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z','', '.', ':', ';', '-', '!', '?', '*', ')', ')', ']', ']', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', ')', '"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow2 = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow2(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow2 = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow2(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return []\n  const [row, col] = lst[0]\n  let cnt = 0\n  for (let i = 0; i < row.length; i++) {\n    if (row[i] === x) {\n      cnt++\n      if (cnt === col) return [[row[i], col],...getRow(lst.slice(1), x)]\n    }\n  }\n  return []\n}\n\nconst getRow = (lst, x)"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you iwll sort the given array in ascending order fi the sum( first index value, lats index value) is odd,\n  or sort it in descending order if the sum( first inedx value, last inedx value) is even.\n\n  Note:\n  * odn't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you iwll sort the given array in ascending order fi the sum( first index value, lats index value) is odd,\n  or sort it in descending order if the sum( first inedx value, last inedx value) is even.\n\n  Note:\n  * odn't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const result = array.slice()\n  let index = 0\n  let currentSum = 0\n  let currentElement\n  const sorted = result.sort((a, b) => {\n    if (currentSum % 2 === 0) {\n      return a - b\n    }\n    return b - a\n  })\n  currentSum = sorted[0]\n  for (index = 0; index < sorted.length; index++) {\n    currentElement = sorted[index]\n    if (currentSum!== currentElement) {\n      break\n    }\n    currentSum += currentElement\n  }\n  for (index = 0; index < sorted.length; index++) {\n    result[index] = sorted[index]\n  }\n  return result\n}\n\nexport default sortArray\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    result += alphabet[(s[i] - 'a') + 2]\n  }\n  return result\n}\n\n// Test code\nconst tests = [\n  'abcdefghijklmnopqrstuvwxyz',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf',\n  'gf"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallest() taht erturns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallest() taht erturns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n    let current = lst[0]\n    let next = lst[1]\n    for (let i = 2; i < lst.length; i++) {\n        if (lst[i] < current) {\n            current = lst[i]\n            next = lst[i - 1]\n        }\n    }\n    return next\n}\n\nconsole.log(nextSmallest([1, 2, 3, 4, 5]));\nconsole.log(nextSmallest([5, 1, 4, 3, 2]));\nconsole.log(nextSmallest([]));\nconsole.log(nextSmallest([1, 1]));\n<|endoftext|>"}
{"task_id": "JavaScript/91", "prompt": "/*\n  Yuo'll be igven a strign of worsd, and your task is to count the number\n  of boredosm. A boredom is a sentence thta starts with the word \"I\".\n  eSntences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  Yuo'll be igven a strign of worsd, and your task is to count the number\n  of boredosm. A boredom is a sentence thta starts with the word \"I\".\n  eSntences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n    const s = S.split(\".\")\n    if(s.length == 1 && s[0].length < 4)\n        return true\n    const last = s[s.length-1]\n    return last.toLowerCase() == \"bored\"\n}\n\n/*\n  Given a string S, find the longest string that contains only 'boredosm',\n  where \"boredosm\" is a sentence delimited by '.', '?' or '!'\n \n  For example:\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  'Imbored'\n \n  Note:\n  This is a very simple implementation.\n*/\nconst findLongestBoredosm = (S) => {\n    let str = \"\"\n    const s = S.split(\".\")\n    for(let i = 0; i < s.length-1; i++)\n        str += s[i]+\".\"\n    return str + s[s.length-1]\n}\n\n/*\n  Given a string S, find the number of words in the longest string that contains\n  only 'boredosm', where \"boredosm\" is a sentence delimited by '.', '?' or '!'\n \n  For example:\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  4\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  2\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  1\n \n  Note:\n  This is a very simple implementation.\n*/\nconst findNumberOfLongestBoredosm = (S) => {\n    let str = \"\"\n    const s = S.split(\".\")\n    for(let i = 0; i < s.length-1; i++)\n        str += s[i]+\".\"\n    return str.length\n}\n\n/*\n  Given a string S, find the longest string that contains only 'boredosm',\n  where \"boredosm\" is a sentence delimited by '.', '?' or '!'\n \n  For example:\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  'Imbored'\n \n  Note:\n  This is a very simple implementation.\n*/\nconst findLongestBoredosm = (S) => {\n    let str = \"\"\n    const s = S.split(\".\")\n    for(let i = 0; i < s.length-1; i++)\n        str += s[i]+\".\"\n    return str + s[s.length-1]\n}\n\n/*\n  Given a string S, find the number of words in the longest string that contains\n  only 'boredosm', where \"boredosm\" is a sentence delimited by '.', '?' or '!'\n \n  For example:\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  4\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  2\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  1\n \n  Note:\n  This is a very simple implementation.\n*/\nconst findNumberOfLongestBoredosm = (S) => {\n    let str = \"\"\n    const s = S.split(\".\")\n    for(let i = 0; i < s.length-1; i++)\n        str += s[i]+\".\"\n    return str.length\n}\n\n/*\n  Given a string S, find the longest string that contains only 'boredosm',\n  where \"boredosm\" is a sentence delimited by '.', '?' or '!'\n \n  For example:\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  'Imbored'\n \n  Note:\n  This is a very simple implementation.\n*/\nconst findLongestBoredosm = (S) => {\n    let str = \"\"\n    const s = S.split(\".\")\n    for(let i = 0; i < s.length-1; i++)\n        str += s[i]+\".\"\n    return str + s[s.length-1]\n}\n\n/*\n  Given a string S, find the number of words in the longest string that contains\n  only 'boredosm', where \"boredosm\" is a sentence delimited by '.', '?' or '!'\n \n  For example:\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  4\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  2\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  1\n \n  Note:\n  This is a very simple implementation.\n*/\nconst findNumberOfLongestBoredosm = (S) => {\n    let str = \"\"\n    const s = S.split(\".\")\n    for(let i = 0; i < s.length-1; i++)\n        str += s[i]+\".\"\n    return str.length\n}\n\n/*\n  Given a string S, find the longest string that contains only 'boredosm',\n  where \"boredosm\" is a sentence delimited by '.', '?' or '!'\n \n  For example:\n  >>> isBored(\"I'm bored. I'm really bored. I'm so bored.\")\n  'Imbored'\n \n  Note:\n  This is a very simple implementation.\n*/\nconst findLongestBoredosm = (S) => {\n    let str = \"\"\n    const s = S.split(\".\")\n    for(let i = 0; i < s.length-1; i++)\n        str += s[i]+\".\"\n    return str + s[s.length-1]\n}\n\n/*\n  Given a string S"}
{"task_id": "JavaScript/92", "prompt": "/* Create a funciton that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Create a funciton that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  return (x === y + z) || (x === z + y) || (x === y - z) || (x === z - y);\n};\n\n/* Create a function that takes 2 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt2(5, 2)  true\n  anyInt2(3, 2)  false\n  anyInt2(3, -2)  true\n  anyInt2(3.6, -2.2)  false\n  */\nconst anyInt2 = (x, y) => {\n  return (x === y + x) || (x === y - x);\n};\n\n/* Create a function that takes 2 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt3(5, 2, 7)  true\n  anyInt3(3, 2, 2)  false\n  anyInt3(3, -2, 1)  true\n  anyInt3(3.6, -2.2, 2)  false\n  */\nconst anyInt3 = (x, y, z) => {\n  return (x === y + z) || (x === z + y) || (x === y - z);\n};\n\nconst anyInt4 = (x, y, z, a) => {\n  return (x === y + z) || (x === z + y) || (x === y - z) || (x === z - y);\n};\n\n/* Create a function that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt4(5, 2, 7, 3)  true\n  anyInt4(3, 2, 2, 2)  false\n  anyInt4(3, -2, 1, 1)  true\n  anyInt4(3.6, -2.2, 2, 2)  false\n  */\nconst anyInt5 = (x, y, z, a) => {\n  return (x === y + z) || (x === z + y) || (x === y - z) || (x === z - y);\n};\n\n/* Create a function that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt5(5, 2, 7, 3)  true\n  anyInt5(3, 2, 2, 2)  false\n  anyInt5(3, -2, 1, 1)  true\n  anyInt5(3.6, -2.2, 2, 2)  false\n  */\nconst anyInt6 = (x, y, z, a) => {\n  return (x === y + z) || (x === z + y) || (x === y - z) || (x === z - y);\n};\n\n/* Create a function that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt6(5, 2, 7, 3, 3)  true\n  anyInt6(3, 2, 2, 2, 2)  false\n  anyInt6(3, -2, 1, 1, 1)  true\n  anyInt6(3.6, -2.2, 2, 2, 2)  false\n  */\nconst anyInt7 = (x, y, z, a, b) => {\n  return (x === y + z) || (x === z + y) || (x === y - z) || (x === z - y);\n};\n\n/* Create a function that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt7(5, 2, 7, 3, 3)  true\n  anyInt7(3, 2, 2, 2, 2)  false\n  anyInt7(3, -2, 1, 1, 1)  true\n  anyInt7(3.6, -2.2, 2, 2, 2)  false\n  */\nconst anyInt8 = (x, y, z, a, b) => {\n  return (x === y + z) || (x === z + y) || (x === y - z) || (x === z - y);\n};\n\n/* Create a function that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt8(5, 2, 7, 3, 3, 3)  true\n  anyInt8(3, 2, 2, 2, 2, 2)  false\n  anyInt8(3, -2, 1, 1, 1, 1)  true\n  anyInt8(3.6, -2.2, 2, 2, 2, 2)  false\n  */\nconst anyInt9 = (x, y, z, a, b, c) => {\n  return (x === y + z) || (x === z + y) || (x === y - z) || (x === z - y);\n};\n\n"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that ti swaps case fo all letters, replaces all vowels in \n  hte message with the eltter that appears 2 places ahead of that \n  vwoel in the english alphabet. \n  Assume onyl letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function that takes a message, and encodes in such a \n  way that ti swaps case fo all letters, replaces all vowels in \n  hte message with the eltter that appears 2 places ahead of that \n  vwoel in the english alphabet. \n  Assume onyl letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  let encoded = \"\";\n  let i = 0;\n  while (i < message.length) {\n    let letter = message[i];\n    let index = alphabet.indexOf(letter);\n    if (index > 0) {\n      let newIndex = index + 2;\n      let newLetter = alphabet[newIndex];\n      encoded += newLetter;\n    } else {\n      encoded += letter;\n    }\n    i++;\n  }\n  return encoded;\n};\n\n// Test\nconsole.log(encode('This is a message'));\n<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find hte largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You are given a list of integers.\n  You need to find hte largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let num = 0\n  const prime = []\n  const primeSize = 0\n\n  const primeFinder = (n) => {\n    if (n <= 1) {\n      return 1\n    }\n    let p = 2\n    let count = 0\n    while (p * p <= n) {\n      if (n % p === 0) {\n        count += 1\n        if (prime.indexOf(p) === -1) {\n          prime.push(p)\n          primeSize += 1\n        }\n      }\n      p = p + 1\n    }\n    return count\n  }\n\n  const largestPrime = (n) => {\n    let p = 0\n    let primeCount = 0\n    for (let i = 2; i <= n; i++) {\n      if (primeCount === primeSize) {\n        break\n      }\n      if (primeFinder(i) === 1) {\n        p = i\n        primeCount += 1\n      }\n    }\n    return p\n  }\n\n  for (let i = 0; i < lst.length; i++) {\n    num = num + largestPrime(parseInt(lst[i]))\n  }\n  return num\n}\n\nconst sumOfDigits = (num) => {\n  let sum = 0\n  while (num!== 0) {\n    sum += num % 10\n    num = num / 10\n  }\n  return sum\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n    if (count === 5) {\n      break\n    }\n    if (num % 10 === 1) {\n      p = num\n      count += 1\n    }\n    num = num / 10\n  }\n  return p\n}\n\nconst largestPrime = (num) => {\n  let p = 0\n  let count = 0\n  while (num!== 0) {\n"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return rtue if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Given a dictionary, return rtue if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  const lowerKeys = keys.filter(key => key.toLowerCase() === key)\n  const upperKeys = keys.filter(key => key.toUpperCase() === key)\n  return (lowerKeys.length === keys.length) || (upperKeys.length === keys.length)\n}\n\n/**\n  Given a dictionary, return true if all keys are strings in upper \n  case or all keys are tstrings in lower case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return true.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return true.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return false.\n  */\nconst checkDictCaseInverse = (dict) => {\n  const keys = Object.keys(dict)\n  const upperKeys = keys.filter(key => key.toUpperCase() === key)\n  const lowerKeys = keys.filter(key => key.toLowerCase() === key)\n  return (upperKeys.length === keys.length) || (lowerKeys.length === keys.length)\n}\n\nexport {checkDictCase, checkDictCaseInverse}\n<|endoftext|>"}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an arary of the first n\n  integers that rae prime numbers adn less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implement a function that takes an non-negative integer and returns an arary of the first n\n  integers that rae prime numbers adn less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const a = [];\n  for (let i = 0; i < n; i++) {\n    a.push(i);\n  }\n  const primes = [];\n  for (let i = 2; i < n; i++) {\n    if (isPrime(i)) {\n      primes.push(i);\n    }\n  }\n  const b = primes;\n  const s = a.concat(b);\n  const nPrime = a.length;\n  let sPrime = [];\n  for (let i = 0; i < nPrime; i++) {\n    sPrime.push(s[i]);\n  }\n  return sPrime;\n};\n\n/*\n * Implement a function that takes an integer n and returns true if n is a prime number,\n * and false otherwise.\n * */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n * Implement a function that takes an integer n and returns true if n is a prime number,\n * and false otherwise.\n * */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n * Implement a function that takes an integer n and returns true if n is a prime number,\n * and false otherwise.\n * */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n * Implement a function that takes an integer n and returns true if n is a prime number,\n * and false otherwise.\n * */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n * Implement a function that takes an integer n and returns true if n is a prime number,\n * and false otherwise.\n * */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n * Implement a function that takes an integer n and returns true if n is a prime number,\n * and false otherwise.\n * */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n * Implement a function that takes an integer n and returns true if n is a prime number,\n * and false otherwise.\n * */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that tkaes two inteegrs and returns \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Complete the function that tkaes two inteegrs and returns \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  if (a < 0) {\n    return -multiply(-a, b)\n  }\n\n  let num = a\n  let den = b\n\n  while (num >= b) {\n    num -= b\n  }\n\n  if (num > 0) {\n    return multiply(num, den)\n  }\n\n  if (num == 0) {\n    return 0\n  }\n\n  return multiply(a, den)\n}\n\nexport default multiply\n<|endoftext|>"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a srting s, count the number of upperacse vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Given a srting s, count the number of upperacse vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = countUpper;\n<|endoftext|>"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a nmuber\n  and returns teh closest integer to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Create a function that takes a value (string) representing a nmuber\n  and returns teh closest integer to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n    let floor = Math.floor(value);\n    let ceil = Math.ceil(value);\n    if (value === floor) {\n        return floor;\n    }\n    if (value === ceil) {\n        return ceil;\n    }\n    if (Math.abs(value - floor) < Math.abs(value - ceil)) {\n        return floor;\n    }\n    return ceil;\n}\n\nconst closestInteger2 = (value) => {\n    let floor = Math.floor(value);\n    let ceil = Math.ceil(value);\n    if (value === floor) {\n        return floor;\n    }\n    if (value === ceil) {\n        return ceil;\n    }\n    return value;\n}\n\nexport default closestInteger;\n<|endoftext|>"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const res = [];\n  const f = (n) => n % 2 === 0? n : n + 1;\n  for (let i = 1; i <= n; i++) {\n    res.push(f(i));\n  }\n  return res;\n};\n\nconst makeAPile2 = (n) => {\n  const res = [];\n  for (let i = 1; i <= n; i++) {\n    res.push(i);\n  }\n  return res;\n};\n\nconst makeAPile3 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  for (let i = 1; i <= n; i++) {\n    if (even(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile4 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  for (let i = 1; i <= n; i++) {\n    if (even(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile5 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile6 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile7 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile8 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile9 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile10 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile11 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res.push(i + 1);\n    }\n  }\n  return res;\n};\n\nconst makeAPile12 = (n) => {\n  const res = [];\n  const even = (n) => n % 2 === 0;\n  const odd = (n) => n % 2 === 1;\n  const evenOrOdd = (n) => even(n) || odd(n);\n  for (let i = 1; i <= n; i++) {\n    if (evenOrOdd(i)) {\n      res.push(i);\n    } else {\n      res."}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s]+/);\n  return words;\n};\n\nconst wordsString2 = (s) => {\n  const words = s.split(/(\\s)+/);\n  return words;\n};\n\nconst wordsString3 = (s) => {\n  const words = s.split(/[\\s\\,]+/);\n  return words;\n};\n\nconst wordsString4 = (s) => {\n  const words = s.split(/[,\\s]+/);\n  return words;\n};\n\nconst wordsString5 = (s) => {\n  const words = s.split(/[\\s\\,\\s]+/);\n  return words;\n};\n\nconst wordsString6 = (s) => {\n  const words = s.split(/[\\s\\,\\s]+/);\n  return words;\n};\n\nconst wordsString7 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString8 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s]+/);\n  return words;\n};\n\nconst wordsString9 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s]+/);\n  return words;\n};\n\nconst wordsString10 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString11 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString12 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString13 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString14 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString15 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString16 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString17 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString18 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString19 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString20 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString21 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString22 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString23 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString24 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString25 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString26 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString27 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString28 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString29 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString30 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString31 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s]+/);\n  return words;\n};\n\nconst wordsString32 = (s) => {\n  const words = s.split(/[\\s\\,\\s\\s\\,\\s\\s"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive nubmers x and y and reutrns the\n  biggest even integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive nubmers x and y and reutrns the\n  biggest even integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const arr = [x, y];\n  let res = -1;\n  let flag = 0;\n  let i = 0;\n  const len = arr.length;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      res = arr[i];\n      flag = 1;\n      break;\n    }\n    i += 1;\n  }\n  if (flag === 0) {\n    return -1;\n  }\n  while (i < len) {\n    if (arr[i] % 2 === 1) {\n      arr.push(arr[i]);\n      res += arr[i];\n    }\n    i += 1;\n  }\n  return res;\n}\n\nmodule.exports = chooseNum;\n<|endoftext|>"}
{"task_id": "JavaScript/103", "prompt": "/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let counter = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    counter += 1;\n  }\n  return (((sum + (counter - 1)) / counter).toString(2));\n}\n\nconsole.log(roundedAvg(1, 5));\nconsole.log(roundedAvg(7, 5));\nconsole.log(roundedAvg(10, 20));\nconsole.log(roundedAvg(20, 33));\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of poistive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Given a list of poistive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  return x.filter((el) => {\n    const digit = Number(el);\n    return digit % 2 === 0? false : true;\n  }).sort((a, b) => {\n    return a - b;\n  });\n};\n<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n    if (arr.length > 0) {\n        arr.sort((a, b) => {\n            if (a === b) {\n                return 0;\n            }\n            return a - b;\n        });\n    }\n    arr.reverse();\n    return arr.map((num, index) => {\n        if (index === 0) {\n            return \"One\";\n        }\n        if (index === 1) {\n            return \"Two\";\n        }\n        if (index === 2) {\n            return \"Three\";\n        }\n        if (index === 3) {\n            return \"Four\";\n        }\n        if (index === 4) {\n            return \"Five\";\n        }\n        if (index === 5) {\n            return \"Six\";\n        }\n        if (index === 6) {\n            return \"Seven\";\n        }\n        if (index === 7) {\n            return \"Eight\";\n        }\n        if (index === 8) {\n            return \"Nine\";\n        }\n    });\n};\n\nconsole.log(byLength([2, 1, 1, 4, 5, 8, 2, 3]));\n<|endoftext|>"}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const list = [];\n  for (let i = 1; i <= n; i++) {\n    const index = (i % 2 === 0)? i : i - 1;\n    const x = (i % 2 === 0)? index : i;\n    list.push(1 + x);\n  }\n  return list;\n};\n\nexport {f};\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive itneger n, return a tuple that has the nmuber of even and odd\n  integer palindromes that fall wihtin the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive itneger n, return a tuple that has the nmuber of even and odd\n  integer palindromes that fall wihtin the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let sum = 0;\n  let odd = 0;\n  const div = (x) => (x | x / 2).toString();\n\n  while (n > 0) {\n    const str = div(n);\n    const reverse = parseInt(str, 10);\n    if (str.length === reverse.toString().length) {\n      sum += (str.length === 1)? 1 : (reverse % 2)? 1 : 0;\n    } else {\n      sum += (str.length === 1)? 0 : (reverse % 2)? 1 : 0;\n    }\n    if (sum % 2 === 0) {\n      odd += 1;\n    }\n    n -= 1;\n  }\n  return [odd, sum];\n};\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n    if (arr.length === 0) return 0;\n    if (arr.length === 1) {\n        if (arr[0] > 0) return 1;\n        return 0;\n    }\n    const n = arr.length;\n    const arr2 = arr.slice();\n    let s = 0;\n    for (let i = 0; i < n; i++) {\n        if (arr[i] > 0) {\n            s += arr[i];\n        } else {\n            s += -arr[i];\n        }\n        arr2.splice(i, 1);\n    }\n    if (s > 0) {\n        return s;\n    }\n    return countNums(arr2);\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n    if (arr.length === 0) return 0;\n    if (arr.length === 1) {\n        if (arr[0] > 0) return 1;\n        return 0;\n    }\n    const n = arr.length;\n    const arr2 = arr.slice();\n    let s = 0;\n    for (let i = 0; i < n; i++) {\n        if (arr[i] > 0) {\n            s += arr[i];\n        } else {\n            s += -arr[i];\n        }\n        arr2.splice(i, 1);\n    }\n    if (s > 0) {\n        return s;\n    }\n    return countNums(arr2);\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n    if (arr.length === 0) return 0;\n    if (arr.length === 1) {\n        if (arr[0] > 0) return 1;\n        return 0;\n    }\n    const n = arr.length;\n    const arr2 = arr.slice();\n    let s = 0;\n    for (let i = 0; i < n; i++) {\n        if (arr[i] > 0) {\n            s += arr[i];\n        } else {\n            s += -arr[i];\n        }\n        arr2.splice(i, 1);\n    }\n    if (s > 0) {\n        return s;\n    }\n    return countNums(arr2);\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n    if (arr.length === 0) return 0;\n    if (arr.length === 1) {\n        if (arr[0] > 0) return 1;\n        return 0;\n    }\n    const n = arr.length;\n    const arr2 = arr.slice();\n    let s = 0;\n    for (let i = 0; i < n; i++) {\n        if (arr[i] > 0) {\n            s += arr[i];\n        } else {\n            s += -arr[i];\n        }\n        arr2.splice(i, 1);\n    }\n    if (s > 0) {\n        return s;\n    }\n    return countNums(arr2);\n};\n\nexport {\n    countNums\n};\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We have an arrya 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your atsk is to determine if\n  it si possibel to get an array sorted in non-decreasing order by performing \n  the flolowing operation on the given array:\n      You are allowde to perform right shift operation ayn number of times.\n  \n  Oen right shift operation means shifting all elements of the array yb one\n  position in the right direction. The last elemetn of the array will be moved ot\n  the startign position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted rarya by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Noet: The igven list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We have an arrya 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your atsk is to determine if\n  it si possibel to get an array sorted in non-decreasing order by performing \n  the flolowing operation on the given array:\n      You are allowde to perform right shift operation ayn number of times.\n  \n  Oen right shift operation means shifting all elements of the array yb one\n  position in the right direction. The last elemetn of the array will be moved ot\n  the startign position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted rarya by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Noet: The igven list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n    const len = arr.length;\n    if (len === 0) {\n        return true;\n    }\n    const max = arr[len - 1];\n    const result = moveOneBall(arr.slice(0, len - 1));\n    if (result) {\n        if (arr[len - 1] < max) {\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\n\nmoveOneBall([3, 4, 5, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2, 6]);\nmoveOneBall([3, 5, 4, 1, 2, 3, 5, 6, 9, 8]);\n<|endoftext|>"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  return (lst1.length > 1 && lst2.length > 1)? \"YES\" : \"NO\";\n};\n\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4]));\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n    const char = test.toLowerCase();\n    const charMap = {};\n    const count = {};\n    \n    for (let i = 0; i < char.length; i++) {\n        if (charMap[char[i]]) {\n            charMap[char[i]].push(count[char[i]]);\n            count[char[i]]++;\n        } else {\n            charMap[char[i]] = [count[char[i]]];\n            count[char[i]]++;\n        }\n    }\n    \n    return charMap;\n};\n\n// tests\nconst tests = [\n    '',\n    'abc',\n    'abcabcbcd',\n    'aaaaaaabccccc',\n    'abbcccabbbccccc',\n    'abbbcccabbbcbbccccc'\n];\n\ntests.forEach( (test) => {\n    console.log(`histogram(${test})`);\n    console.log(histogram(test));\n});\n<|endoftext|>"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have to deleted all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const newStr = s.replace(c, '');\n  return [newStr, newStr.length - newStr.length % c.length]\n}\n\nconst checkPailndrome = (s, c) => {\n  if (s === c) return [s, true]\n  const [s1, isPailndrome] = reverseDelete(s, c)\n  const [s2, isPailndrome] = reverseDelete(s1, c)\n  return [s2, isPailndrome]\n}\n\nconst task = (params) => {\n  let [s, c] = params\n  let [s1, isPailndrome] = checkPailndrome(s, c)\n  return [s1, isPailndrome]\n}\n\ntask((['abcd', 'ab']));\ntask((['abcd', 'ba']))\ntask((['abcdef', 'b']));\ntask((['abcd', 'a']));\ntask((['a', 'b']));\ntask((['a', 'b']));\ntask((['a', 'a']));\ntask((['a', 'a']));\ntask((['a', 'b']));\ntask((['a', 'b']));\ntask((['b', 'a']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b']));\ntask((['b', 'b'"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the numbre of odd elements in the\n  string i of the input.\" where all the i's should be replacde by the number\n  of odd dgiits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the numbre of odd elements in the\n  string i of the input.\" where all the i's should be replacde by the number\n  of odd dgiits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const l = lst.length;\n  if (l === 0) return [];\n\n  let oddCount = 0;\n  for (let i = 0; i < l; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i].charAt(j) === '1') {\n        count += 1;\n      }\n    }\n\n    oddCount += count;\n  }\n\n  return [`the number of odd elements ${oddCount} of the ${l} input.`];\n};\n\nexport default oddCount;\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of ientgres nums, find the minimum sum of any non-epmty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of ientgres nums, find the minimum sum of any non-epmty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const minSum = -1;\n  const minSubArray = -1;\n  const sum = 0;\n  const length = nums.length;\n  const i = 0;\n\n  while (i < length) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n      if (sum >= 0 && sum < minSum) {\n        minSum = sum;\n        minSubArray = i;\n      }\n    }\n    i++;\n  }\n\n  return minSubArray;\n};\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]));\nconsole.log(minSubArraySum([-1, -2, -3]));\n<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Ecah row represents a snigle well,\n  and each 1 in a row represetns a single unit of awter.\n  Each well has a corresponding bucket that can be used ot extract watre rfom it, \n  and all buckets have the saem capacity.\n  Your task is to use the buckets to mepty the wells.\n  Output the number fo times you need ot lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Ecah row represents a snigle well,\n  and each 1 in a row represetns a single unit of awter.\n  Each well has a corresponding bucket that can be used ot extract watre rfom it, \n  and all buckets have the saem capacity.\n  Your task is to use the buckets to mepty the wells.\n  Output the number fo times you need ot lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const gridLength = grid.length\n    const capacityLength = capacity.length\n    \n    const [\n        row = 0,\n        col = 0\n    ] = [gridLength, grid[0].length]\n\n    const rowMax = gridLength - row\n    const colMax = grid[0].length - col\n\n    let fillCount = 0\n\n    while (row > 0 || col > 0) {\n        if (row > 0) {\n            if (grid[row][col] === 1) {\n                row--\n                col++\n                fillCount++\n            } else {\n                col++\n            }\n        } else {\n            row--\n        }\n\n        if (col > 0) {\n            if (grid[row][col] === 1) {\n                col--\n                row++\n                fillCount++\n            } else {\n                row++\n            }\n        } else {\n            col--\n        }\n    }\n\n    if (fillCount > capacityLength) {\n        return fillCount\n    } else {\n        return capacityLength - fillCount\n    }\n}\n\nconst test = [\n    [0,0,1,0,0],\n    [0,1,0,0,0],\n    [1,1,1,1,1],\n    [0,1,1,1,0],\n    [0,0,0,0,0]\n]\n\nconsole.log(maxFill(test, 1))\nconsole.log(maxFill(test, 2))\nconsole.log(maxFill(test, 5))\nconsole.log(maxFill(test, 10))\nconsole.log(maxFill(test, 100))\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const arrWithBits = [0, 0, 0, 0, 0]\n  const sortedArr = arr.slice()\n  const sortedArrWithBits = sortedArr.slice()\n  const sortedArrWithBitsLength = sortedArr.length\n  let counter = 0\n  let i = 0\n  let j = 0\n  let flag = 0\n  let sumOfOnes = 0\n\n  for (i = 0; i < sortedArrWithBitsLength; i++) {\n    sumOfOnes = 0\n\n    for (j = 0; j < sortedArrWithBitsLength; j++) {\n      if (sortedArr[i] == 1) {\n        sumOfOnes += 1\n      }\n    }\n\n    arrWithBits[i] = sumOfOnes\n\n    if (sumOfOnes > 0) {\n      counter += 1\n    }\n  }\n\n  if (counter === sortedArrWithBitsLength) {\n    return sortedArr\n  }\n\n  for (i = 0; i < sortedArrWithBitsLength; i++) {\n    if (arrWithBits[i] === 0) {\n      sortedArrWithBits[i] = sortedArr[i]\n    }\n  }\n\n  return sortedArrWithBits\n}\n\nexport default sortArray\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n ocnsonants, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n ocnsonants, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = s.split(' ')\n  const selected = []\n  const num = n\n\n  words.forEach((w) => {\n    if (w.length === num) {\n      selected.push(w)\n    }\n  })\n\n  return selected\n}\n\n/*Given a string s and a number n, you have been tasked to implement a function \n  that returns the number of words in the string that are n-length or longer, \n  including spaces.\n  Example:\n  lengthOfLongWords(\"Hello world\", 3) ==> 5\n  lengthOfLongWords(\"Hello world\", 2) ==> 0\n  lengthOfLongWords(\"Hello world\", 1) ==> 0\n  lengthOfLongWords(\"Hello world\", 4) ==> 0\n  lengthOfLongWords(\"Hello world\", 5) ==> 1\n  lengthOfLongWords(\"Hello world\", 6) ==> 0\n  lengthOfLongWords(\"Hello world\", 7) ==> 0\n  lengthOfLongWords(\"Hello world\", 8) ==> 1\n  lengthOfLongWords(\"Hello world\", 9) ==> 1\n  lengthOfLongWords(\"Hello world\", 10) ==> 1\n  lengthOfLongWords(\"Hello world\", 11) ==> 0\n  lengthOfLongWords(\"Hello world\", 12) ==> 0\n  lengthOfLongWords(\"Hello world\", 13) ==> 0\n  lengthOfLongWords(\"Hello world\", 14) ==> 1\n  lengthOfLongWords(\"Hello world\", 15) ==> 0\n  lengthOfLongWords(\"Hello world\", 16) ==> 0\n  lengthOfLongWords(\"Hello world\", 17) ==> 0\n  lengthOfLongWords(\"Hello world\", 18) ==> 1\n  lengthOfLongWords(\"Hello world\", 19) ==> 0\n  lengthOfLongWords(\"Hello world\", 20) ==> 0\n  lengthOfLongWords(\"Hello world\", 21) ==> 0\n  lengthOfLongWords(\"Hello world\", 22) ==> 1\n  lengthOfLongWords(\"Hello world\", 23) ==> 0\n  lengthOfLongWords(\"Hello world\", 24) ==> 0\n  lengthOfLongWords(\"Hello world\", 25) ==> 0\n  lengthOfLongWords(\"Hello world\", 26) ==> 0\n  lengthOfLongWords(\"Hello world\", 27) ==> 0\n  lengthOfLongWords(\"Hello world\", 28) ==> 1\n  lengthOfLongWords(\"Hello world\", 29) ==> 0\n  lengthOfLongWords(\"Hello world\", 30) ==> 0\n  lengthOfLongWords(\"Hello world\", 31) ==> 0\n  lengthOfLongWords(\"Hello world\", 32) ==> 0\n  lengthOfLongWords(\"Hello world\", 33) ==> 0\n  lengthOfLongWords(\"Hello world\", 34) ==> 1\n  lengthOfLongWords(\"Hello world\", 35) ==> 0\n  lengthOfLongWords(\"Hello world\", 36) ==> 0\n  lengthOfLongWords(\"Hello world\", 37) ==> 0\n  lengthOfLongWords(\"Hello world\", 38) ==> 0\n  lengthOfLongWords(\"Hello world\", 39) ==> 0\n  lengthOfLongWords(\"Hello world\", 40) ==> 0\n  lengthOfLongWords(\"Hello world\", 41) ==> 0\n  lengthOfLongWords(\"Hello world\", 42) ==> 0\n  lengthOfLongWords(\"Hello world\", 43) ==> 0\n  lengthOfLongWords(\"Hello world\", 44) ==> 0\n  lengthOfLongWords(\"Hello world\", 45) ==> 0\n  lengthOfLongWords(\"Hello world\", 46) ==> 0\n  lengthOfLongWords(\"Hello world\", 47) ==> 0\n  lengthOfLongWords(\"Hello world\", 48) ==> 0\n  lengthOfLongWords(\"Hello world\", 49) ==> 0\n  lengthOfLongWords(\"Hello world\", 50) ==> 0\n  lengthOfLongWords(\"Hello world\", 51) ==> 0\n  lengthOfLongWords(\"Hello world\", 52) ==> 1\n  lengthOfLongWords(\"Hello world\", 53) ==> 0\n  lengthOfLongWords(\"Hello world\", 54) ==> 0\n  lengthOfLongWords(\"Hello world\", 55) ==> 0\n  lengthOfLongWords(\"Hello world\", 56) ==> 0\n  lengthOfLongWords(\"Hello world\", 57) ==> 0\n  lengthOfLongWords(\"Hello world\", 58) ==> 0\n  lengthOfLongWords(\"Hello world\", 59) ==> 0\n  lengthOfLongWords(\"Hello world\", 60) ==> 0\n  lengthOfLongWords(\"Hello world\", 61) ==> 0\n  lengthOfLongWords(\"Hello world\", 62) ==> 0\n  lengthOfLongWords(\"Hello world\", 63) ==> 0\n  lengthOfLongWords(\"Hello world\", 64) ==> 0\n  lengthOfLongWords(\"Hello world\", 65) ==> 0\n  lengthOfLongWords(\"Hello world\", 66) ==> 0\n  lengthOfLongWords(\"Hello world\", 67) ==> 0\n  lengthOfLongWords(\"Hello world\", 68) ==> 0\n  lengthOfLongWords(\"Hello world\", 69) ==> 0\n  lengthOfLongWords(\"Hello world\", 70) ==> 0\n  lengthOfLongWords(\"Hello world\", 71) ==> 0\n  lengthOfLongWords(\"Hello world\", 72) ==> 0\n  lengthOfLongWords(\"Hello world\", 73) ==> 0\n  lengthOfLongWords(\"Hello world\", 74) ==> 0\n  lengthOfLongWords(\"Hello world\", 75) ==> 0\n  lengthOfLongWords(\"Hello world\", 76) ==> 0\n  lengthOfLongWords(\"Hello world\", 77) ==> 0\n  lengthOfLongWords(\"Hello world\", 78) ==> 0\n  lengthOfLongWords(\"Hello world\", 79) ==> 0\n  lengthOfLongWords(\"Hello world\", 80) ==> 0\n  lengthOfLongWords(\"Hello world\", 81) ==> 0\n  lengthOfLong"}
{"task_id": "JavaScript/118", "prompt": "/*Yuo are given a word. Your task is ot find the closest vowel that stands between \n  two consonants from hte rihgt side of the word (case senstiiev).\n  \n  Vowels in teh beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met hte above condition. \n\n  You mya asusme that the given strign contains Egnlihs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*Yuo are given a word. Your task is ot find the closest vowel that stands between \n  two consonants from hte rihgt side of the word (case senstiiev).\n  \n  Vowels in teh beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met hte above condition. \n\n  You mya asusme that the given strign contains Egnlihs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const letter = word[0];\n  const end = word.slice(1);\n  let closestVowel = '';\n\n  for (let i = 0; i < vowels.length; i++) {\n    const vowel = vowels[i];\n    if (word.indexOf(vowel) === 0) {\n      return vowel;\n    }\n    if (word.indexOf(vowel) === end.indexOf(vowel)) {\n      return vowel;\n    }\n    if (Math.abs(end.indexOf(vowel) - word.indexOf(vowel)) < Math.abs(end.indexOf(vowel) - word.indexOf(vowel))) {\n      return vowel;\n    }\n  }\n  return closestVowel;\n};\n\n// Test\n\nconsole.log(getClosestVowel(\"FULL\"));\nconsole.log(getClosestVowel(\"ab\"));\nconsole.log(getClosestVowel(\"quick\"));\nconsole.log(getClosestVowel(\"yogurt\"));\nconsole.log(getClosestVowel(\"abcdef\"));\nconsole.log(getClosestVowel(\"a\"));\nconsole.log(getClosestVowel(\"\"));\nconsole.log(getClosestVowel(\"abcd\"));\n<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const check = (str) => {\n    let stack = [];\n    for (let i = 0; i < str.length; i++) {\n      if (str[i] === ')') {\n        stack.push(str[i]);\n      } else if (str[i] === '(') {\n        if (stack.length > 0 && stack[stack.length - 1] === ')') {\n          stack.pop();\n        } else {\n          return false;\n        }\n      }\n    }\n    if (stack.length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  for (let i = 0; i < lst.length; i++) {\n    if (check(lst[i])) {\n      return 'Yes';\n    }\n  }\n  return 'No';\n};\n\n// const matchParens = (lst) => {\n//   const stack = [];\n//   for (let i = 0; i < lst.length; i++) {\n//     if (lst[i] === ')') {\n//       if (stack.length > 0 && stack[stack.length - 1] === '(') {\n//         stack.pop();\n//       } else {\n//         return false;\n//       }\n//     } else if (lst[i] === '(') {\n//       stack.push(lst[i]);\n//     }\n//   }\n//   if (stack.length === 0) {\n//     return true;\n//   } else {\n//     return false;\n//   }\n// };\n\n// const matchParens = (lst) => {\n//   const stack = [];\n//   for (let i = 0; i < lst.length; i++) {\n//     if (lst[i] === ')') {\n//       if (stack.length > 0 && stack[stack.length - 1] === '(') {\n//         stack.pop();\n//       } else {\n//         return false;\n//       }\n//     } else if (lst[i] === '(') {\n//       stack.push(lst[i]);\n//     }\n//   }\n//   if (stack.length === 0) {\n//     return true;\n//   } else {\n//     return false;\n//   }\n// };\n\nconsole.log(matchParens([]));\nconsole.log(matchParens(['()']));\nconsole.log(matchParens(['())']));\nconsole.log(matchParens(['(()']));\nconsole.log(matchParens(['()(', ')', ')']));\nconsole.log(matchParens(['())()']));\nconsole.log(matchParens(['()()()']));\nconsole.log(matchParens(['()()(', ')', ')']));\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  let start = 0\n  let end = arr.length - 1\n  let tmp = 0\n  let i = 0\n  let max = 0\n  while (i < k) {\n    if (end < start) {\n      tmp = arr[end]\n      arr[end] = arr[start]\n      arr[start] = tmp\n      end--\n      start++\n      i++\n    } else {\n      if (arr[end] > arr[end - 1]) {\n        tmp = arr[end]\n        arr[end] = arr[end - 1]\n        arr[end - 1] = tmp\n        end--\n        i++\n      } else {\n        break\n      }\n    }\n  }\n  return arr\n}\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Gvien a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Gvien a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nconsole.log(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list htat has the odd numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a sorted list htat has the odd numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  if (n === 1) {\n    return [1];\n  }\n  const odd = [];\n  const step = 2;\n  const sum = n;\n  while (sum!== 1) {\n    if (sum % 2 === 1) {\n      odd.unshift(sum);\n    }\n    sum = sum / step;\n  }\n  return odd.concat([1]);\n};\n\nmodule.exports = getOddCollatz;\n<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a fucntion which validates a given date tsring and\n  ertruns true fi the date is valid otherwise false.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You have to write a fucntion which validates a given date tsring and\n  ertruns true fi the date is valid otherwise false.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n    if(!date) {\n        return false;\n    }\n    let months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];\n    let days = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30'];\n    let day = parseInt(date.split('-')[2]);\n    let month = parseInt(date.split('-')[1]);\n    let year = parseInt(date.split('-')[0]);\n    if(day < 1 || day > 31) {\n        return false;\n    }\n    if(month < 1 || month > 12) {\n        return false;\n    }\n    if(year < 1900 || year > 2100) {\n        return false;\n    }\n    let is_valid = true;\n    for(let i = 1; i < months.length; i++) {\n        if(date.split('-')[1] == months[i]) {\n            is_valid = false;\n        }\n    }\n    if(is_valid) {\n        for(let i = 1; i < days.length; i++) {\n            if(date.split('-')[2] == days[i]) {\n                is_valid = false;\n            }\n        }\n    }\n    if(is_valid) {\n        if(date.split('-')[2] == '29' || date.split('-')[2] == '30' || date.split('-')[2] == '31') {\n            is_valid = false;\n        }\n    }\n    return is_valid;\n}\nmodule.exports = validDate;<|endoftext|>"}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1, ... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  if (txt === null || txt.length === 0) return [];\n  const words = txt.split(/\\s+/);\n  const numWords = words.length;\n  const ret = [];\n  for (let i = 0; i < numWords; i += 1) {\n    const word = words[i];\n    ret.push(word);\n  }\n  return ret;\n};\n\nconst removeDuplicates = (arr) => {\n  const newArr = [];\n  const seen = {};\n  const len = arr.length;\n  for (let i = 0; i < len; i += 1) {\n    const val = arr[i];\n    if (!seen[val]) {\n      seen[val] = 1;\n      newArr.push(val);\n    }\n  }\n  return newArr;\n};\n\nconst removeDuplicatesWithOrder = (arr) => {\n  const newArr = [];\n  const seen = {};\n  const len = arr.length;\n  for (let i = 0; i < len; i += 1) {\n    const val = arr[i];\n    if (!seen[val]) {\n      seen[val] = 1;\n      newArr.push(val);\n    }\n  }\n  return newArr;\n};\n\nconst isUpperCase = (str) => {\n  return /^[A-Z]/.test(str);\n};\n\nconst isLowerCase = (str) => {\n  return /^[a-z]/.test(str);\n};\n\nconst isNumber = (str) => {\n  return /^[0-9]/.test(str);\n};\n\nconst isLetter = (str) => {\n  return /^[a-z]/.test(str) || /^[A-Z]/.test(str);\n};\n\nconst isLetterOrDigit = (str) => {\n  return /^[a-zA-Z0-9]/.test(str);\n};\n\nconst isAllUpperCase = (str) => {\n  return /^[A-Z]/.test(str);\n};\n\nconst isAllLowerCase = (str) => {\n  return /^[a-z]/.test(str);\n};\n\nconst isUpperOrLowerCase = (str) => {\n  return /^[A-Za-z]/.test(str);\n};\n\nconst contains = (arr, item) => {\n  return arr.indexOf(item)!== -1;\n};\n\nconst containsAll = (arr, items) => {\n  for (let i = 0; i < items.length; i += 1) {\n    const item = items[i];\n    if (!contains(arr, item)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst containsAllExcept = (arr, items) => {\n  for (let i = 0; i < items.length; i += 1) {\n    const item = items[i];\n    if (contains(arr, item)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst containsAny = (arr, items) => {\n  for (let i = 0; i < items.length; i += 1) {\n    const item = items[i];\n    if (contains(arr, item)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst containsAnyExcept = (arr, items) => {\n  for (let i = 0; i < items.length; i += 1) {\n    const item = items[i];\n    if (contains(arr, item)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst containsLetters = (str) => {\n  return /^[a-zA-Z]/.test(str);\n};\n\nconst containsUppercaseLetters = (str) => {\n  return /^[A-Z]/.test(str);\n};\n\nconst containsLowercaseLetters = (str) => {\n  return /^[a-z]/.test(str);\n};\n\nconst containsDigits = (str) => {\n  return /^[0-9]/.test(str);\n};\n\nconst containsLettersOrDigits = (str) => {\n  return /^[a-zA-Z0-9]/.test(str);\n};\n\nconst containsUppercaseLettersOrDigits = (str) => {\n  return /^[A-Z0-9]/.test(str);\n};\n\nconst containsLowercaseLettersOrDigits = (str) => {\n  return /^[a-z0-9]/.test(str);\n};\n\nconst containsUppercaseLettersOrNumbers = (str) => {\n  return /^[A-Z0-9]/.test(str);\n};\n\nconst containsLowercaseLettersOrNumbers = (str) => {\n  return /^[a-z0-9]/.test(str);\n};\n\nconst containsLettersOrNumbers = (str) => {\n  return /^[a-zA-Z0-9]/.test(str);\n};\n\nconst containsLettersOrNumbersOrSpaces = (str) => {\n  return /^[a-zA-Z0-9 ]/.test(str);\n};\n\nconst containsLettersOrNumbersOrSpaces = (str) => {\n  return /^[a-zA-Z0-9 ]/.test(str);\n};\n\nconst containsSpaces = (str) => {\n  return /^[ ]/.test(str);\n};\n\nconst containsNumbers = (str) => {\n  return /^[0-9]/.test(str);\n};\n\nconst containsNumbersOrSpaces ="}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  let res = lst.length === 0\n  let last = 0\n  let count = 0\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] === lst[last]) {\n      count++\n    } else {\n      count = 0\n    }\n    if (count === 2) {\n      res = false\n    }\n    last = i\n  }\n  return res\n}\n\n/*\n  Given a list of numbers, return how many of them are divisble by 5.\n  Examples\n  numberOfDivisbleBy5([1, 2, 3, 4, 5])  3\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6])  3\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7])  0\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7, 8])  3\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7, 8, 9])  0\n  */\nconst numberOfDivisbleBy5 = (lst) => {\n  let res = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5 === 0) {\n      res++\n    }\n  }\n  return res\n}\n\n/*\n  Given a list of numbers, return the first one that is divisble by 5.\n  Examples\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7])  5\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7, 8])  7\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7, 8, 9])  9\n  */\nconst firstNumberDivisbleBy5 = (lst) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5 === 0) {\n      return lst[i]\n    }\n  }\n  return null\n}\n\n/*\n  Given a list of numbers, return the first one that is not divisble by 5.\n  Examples\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7, 8])  1\n  numberOfDivisbleBy5([1, 2, 3, 4, 5, 6, 7, 8, 9])  2\n  */\nconst firstNumberNotDivisbleBy5 = (lst) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5!== 0) {\n      return lst[i]\n    }\n  }\n  return null\n}\n\n/*\n  Given a list of numbers, return the number of times they appear in the list.\n  Examples\n  numberOfOccurences([1, 2, 3, 4, 5, 6, 7])  5\n  numberOfOccurences([1, 2, 3, 4, 5, 6, 7, 8])  1\n  numberOfOccurences([1, 2, 3, 4, 5, 6, 7, 8, 9])  0\n  */\nconst numberOfOccurences = (lst) => {\n  let res = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst.indexOf(lst[i])!== -1) {\n      res++\n    }\n  }\n  return res\n}\n\nexport {\n  isSorted,\n  numberOfDivisbleBy5,\n  firstNumberDivisbleBy5,\n  firstNumberNotDivisbleBy5,\n  numberOfOccurences\n}\n<|endoftext|>"}
{"task_id": "JavaScript/127", "prompt": "/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let start1 = interval1[0]\n  let end1 = interval1[1]\n  let start2 = interval2[0]\n  let end2 = interval2[1]\n\n  // if start1 <= end2 and start2 <= end1 then they intersect\n  if (start1 <= end2 && start2 <= end1) {\n    let start = Math.min(start1, start2)\n    let end = Math.max(end1, end2)\n\n    if (isPrime(end - start)) {\n      return `${start}-${end}`\n    }\n  }\n\n  return `NO`\n}\n\nconst isPrime = (num) => {\n  if (num === 2) {\n    return true\n  }\n  if (num === 3) {\n    return true\n  }\n  if (num === 5) {\n    return true\n  }\n  if (num === 7) {\n    return true\n  }\n  if (num === 11) {\n    return true\n  }\n  if (num === 13) {\n    return true\n  }\n  if (num === 17) {\n    return true\n  }\n  if (num === 19) {\n    return true\n  }\n  if (num === 23) {\n    return true\n  }\n  if (num === 29) {\n    return true\n  }\n  if (num === 31) {\n    return true\n  }\n  if (num === 37) {\n    return true\n  }\n  if (num === 41) {\n    return true\n  }\n  if (num === 43) {\n    return true\n  }\n  if (num === 47) {\n    return true\n  }\n  if (num === 53) {\n    return true\n  }\n  if (num === 59) {\n    return true\n  }\n  if (num === 61) {\n    return true\n  }\n  if (num === 67) {\n    return true\n  }\n  if (num === 71) {\n    return true\n  }\n  if (num === 73) {\n    return true\n  }\n  if (num === 79) {\n    return true\n  }\n  if (num === 83) {\n    return true\n  }\n  if (num === 89) {\n    return true\n  }\n  if (num === 97) {\n    return true\n  }\n  if (num === 101) {\n    return true\n  }\n  if (num === 103) {\n    return true\n  }\n  if (num === 107) {\n    return true\n  }\n  if (num === 109) {\n    return true\n  }\n  if (num === 113) {\n    return true\n  }\n  if (num === 127) {\n    return true\n  }\n  if (num === 131) {\n    return true\n  }\n  if (num === 137) {\n    return true\n  }\n  if (num === 139) {\n    return true\n  }\n  if (num === 149) {\n    return true\n  }\n  if (num === 151) {\n    return true\n  }\n  if (num === 157) {\n    return true\n  }\n  if (num === 163) {\n    return true\n  }\n  if (num === 167) {\n    return true\n  }\n  if (num === 179) {\n    return true\n  }\n  if (num === 181) {\n    return true\n  }\n  if (num === 191) {\n    return true\n  }\n  if (num === 193) {\n    return true\n  }\n  if (num === 197) {\n    return true\n  }\n  if (num === 199) {\n    return true\n  }\n  if (num === 211) {\n    return true\n  }\n  if (num === 223) {\n    return true\n  }\n  if (num === 227) {\n    return true\n  }\n  if (num === 229) {\n    return true\n  }\n  if (num === 233) {\n    return true\n  }\n  if (num === 239) {\n    return true\n  }\n  if (num === 241) {\n    return true\n  }\n  if (num === 251) {\n    return true\n  }\n  if (num === 257) {\n    return true\n  }\n  if (num === 263) {\n    return true\n  }\n  if (num === 269) {\n    return true\n  }\n  if (num === 271) {\n    return true\n  }\n  if (num === 277) {\n    return true\n  }\n  if (num === 281) {\n    return true\n  }\n  if (num === 283) {\n    return true\n  }\n  if (num === 293) {\n    return true\n  }\n  if (num === 307) {\n    return true\n  }\n  if (num === 311) {\n    return true\n  }\n  if (num === 313) {\n    return true\n  }\n  if (num === 317) {\n    return true\n  }\n  if (num === 331) {\n    return true\n  }\n  if (num === 337) {\n    return true\n  }\n  if (num === 347) {\n    return true\n  }\n  if (num === 349) {\n    return true\n  }\n  if"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null;\n  const res = arr.reduce((acc, num) => {\n    const sign = num > 0? 1 : num < 0? -1 : 0;\n    return sign * Math.abs(num) * acc;\n  }, 0);\n  return res;\n};\n\nconsole.log(prodSigns([-2, -1, 1, 2]));\nconsole.log(prodSigns([-2, -1, 1, 2, 3, -4]));\nconsole.log(prodSigns([0, 1]));\nconsole.log(prodSigns([]));\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columsn (N >= 2) and a positive integer k, \n  each cell of the grid onctains a value. Every integer in the range [1, N * N]\n  inclusive appeasr exactly once on the eclls of the grid.\n\n  You have to find the minimum path of length k in the grid. Yuo can strat\n  rfom any cell, and in eahc tesp you can move to any of teh neighbor cells,\n  in other words, you can go to cells which sahre an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT og off the grid.\n  A path A (of length k) is conisdered less than a path B (of length k) if\n  after making the ordered lists of teh values on the clels htat A nad B go\n  through (let's call thme lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < lst_B[i] adn for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed taht the answer is unique.\n  Return an ordreed list of the vlaues on the cells that the minimum path go thruogh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Given a grid with N rows and N columsn (N >= 2) and a positive integer k, \n  each cell of the grid onctains a value. Every integer in the range [1, N * N]\n  inclusive appeasr exactly once on the eclls of the grid.\n\n  You have to find the minimum path of length k in the grid. Yuo can strat\n  rfom any cell, and in eahc tesp you can move to any of teh neighbor cells,\n  in other words, you can go to cells which sahre an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT og off the grid.\n  A path A (of length k) is conisdered less than a path B (of length k) if\n  after making the ordered lists of teh values on the clels htat A nad B go\n  through (let's call thme lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < lst_B[i] adn for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed taht the answer is unique.\n  Return an ordreed list of the vlaues on the cells that the minimum path go thruogh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const n = grid.length;\n  const n2 = grid[0].length;\n  const ans = [];\n  let currentPath = [];\n  let visited = {};\n  let row = 0, col = 0;\n\n  while (row < n && col < n2) {\n    const path = [];\n    for (let i = 0; i < k; i++) {\n      path.push(grid[row][col]);\n      row = Math.min(row + 1, n - 1);\n      col = Math.min(col + 1, n2 - 1);\n    }\n    if (visited[path] === undefined) {\n      visited[path] = true;\n      ans.push(path);\n    }\n  }\n  return ans;\n};\n\nmodule.exports = minPath;\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  const fib = fibonacci(n)\n  return fib.reduce((acc, x) => {\n    return [...acc, x + 1]\n  }, [1])\n}\n\nconst fib = (n) => {\n  let pre = 1\n  let next = 1\n  if(n === 1) return [1]\n  if(n === 2) return [1, 2]\n  for(let i = 3; i < n; i++) {\n    pre = next\n    next = (pre + next) / 2\n  }\n  return [1, 2, 3,...next]\n}\n\ntri(6)\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": false, "gc": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  const total = 0\n  const temp = 0\n  for (let i = n; i > 0; i--) {\n    temp = parseInt(i.toString(), 10)\n    if (temp % 2 === 1) {\n      total += temp\n    }\n  }\n  return total\n}\n\n/*\n  Given two positive integers a and b, return the sum of the numbers between a and b\n  If a > b, return the sum of the numbers between b and a\n*/\nconst sum = (a, b) => {\n  const total = 0\n  for (let i = a; i <= b; i++) {\n    total += i\n  }\n  return total\n}\n\n/*\n  Given two numbers, return the number of digits in the longer number\n*/\nconst digitsInLonger = (a, b) => {\n  const aDigits = digits(a)\n  const bDigits = digits(b)\n  return (aDigits > bDigits)? aDigits : bDigits\n}\n\n/*\n  Given two numbers, return the number of digits in the shorter number\n*/\nconst digitsInShorter = (a, b) => {\n  const aDigits = digits(a)\n  const bDigits = digits(b)\n  return (aDigits < bDigits)? aDigits : bDigits\n}\n\n/*\n  Given two numbers, return the number of digits in the sum of the numbers\n*/\nconst digitsInSum = (a, b) => {\n  return sum(a, b)\n}\n\nconst tests = {\n  digits: {\n    (a) => a,\n    (b) => b,\n    (a, b) => digitsInLonger(a, b)\n  },\n  sum: {\n    (a, b) => a + b,\n    (a, b) => sum(a, b)\n  },\n  digitsInLonger: {\n    (a, b) => digitsInLonger(a, b)\n  },\n  digitsInShorter: {\n    (a, b) => digitsInShorter(a, b)\n  },\n  digitsInSum: {\n    (a, b) => digitsInSum(a, b)\n  }\n}\n\n/*\n  Write a function:\n  \n  function (a, b) {\n    return a + b\n  }\n  \n  that returns the sum of the numbers a and b.\n  \n  Hint:\n  \n  You may want to write a helper function that takes two numbers as arguments\n  and returns the number of digits in the sum of those numbers.\n  \n  If a number has fewer digits, your helper function should return the number\n  of digits in that number.\n  \n  If a number has more digits, your helper function should return the number\n  of digits in that number.\n  \n  If a number has the same number of digits, your helper function should return\n  the number of digits in that number.\n  \n  Test your helper function by calling it with the numbers 1 and 3.\n  \n  Hint:\n  \n  You will probably need to write a helper function that takes two numbers as\n  arguments and returns the number of digits in the sum of those numbers.\n*/\nconst helper = (a, b) => {\n  const aDigits = digits(a)\n  const bDigits = digits(b)\n  return (aDigits > bDigits)? aDigits : bDigits\n}\n\n/*\n  Write a function:\n  \n  function (a, b) {\n    return a + b\n  }\n  \n  that returns the sum of the numbers a and b.\n  \n  Hint:\n  \n  You may want to write a helper function that takes two numbers as arguments\n  and returns the number of digits in the sum of those numbers.\n  \n  If a number has fewer digits, your helper function should return the number\n  of digits in that number.\n  \n  If a number has more digits, your helper function should return the number\n  of digits in that number.\n  \n  If a number has the same number of digits, your helper function should return\n  the number of digits in that number.\n  \n  Test your helper function by calling it with the numbers 1 and 3.\n  \n  Hint:\n  \n  You will probably need to write a helper function that takes two numbers as\n  arguments and returns the number of digits in the sum of those numbers.\n*/\nconst helper2 = (a, b) => {\n  const aDigits = digits(a)\n  const bDigits = digits(b)\n  return (aDigits < bDigits)? aDigits : bDigits\n}\n\nconst sumOfDigits = (a, b) => {\n  return helper2(a, b)\n}\n\nconsole.log(sumOfDigits(1, 3))\n<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  ture\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  ture\n  */\nconst isNested = (string) => {\n    const stack = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === '[' || string[i] === ']') {\n            stack.push(string[i]);\n        } else if (string[i] === '[' && stack.length === 1) {\n            stack.push(string[i]);\n        } else if (string[i] === ']' && stack.length > 1) {\n            stack.pop();\n        }\n    }\n    return stack.length === 1;\n};\n\n// eslint-disable-next-line max-len\nexport const input = '[[]]'\nexport const output = 'true'\n\nexport const input2 = '[[]]'\nexport const output2 = 'false'\n\nexport const input3 = '[]'\nexport const output3 = 'false'\n\nexport const input4 = '[[]]'\nexport const output4 = 'true'\n\nexport const input5 = '[]'\nexport const output5 = 'false'\n\nexport const input6 = '[[]]'\nexport const output6 = 'true'\n<|endoftext|>"}
{"task_id": "JavaScript/133", "prompt": "/*Yuo are gievn a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) frist.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*Yuo are gievn a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) frist.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const l = lst.length;\n  const s = sum(lst);\n  let ret = 0;\n  for (let i = 0; i < l; i++) {\n    ret += Math.round(lst[i] * lst[i]);\n  }\n  return ret;\n};\n\nconst sum = (lst) => {\n  const s = 0;\n  for (let i = 0; i < lst.length; i++) {\n    s += lst[i];\n  }\n  return s;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Create a ufnction htat returns true if the last chraacter\n  of a given string is an alphaebtical character and is not\n  a part of a word, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Create a ufnction htat returns true if the last chraacter\n  of a given string is an alphaebtical character and is not\n  a part of a word, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt[txt.length - 1]\n  const charType = getCharType(lastChar)\n  const isWord = isWordChar(lastChar)\n  return isALetter(lastChar) &&!isWord\n}\n\nconst isALetter = (char) => {\n  return char >= 97 && char <= 122\n}\n\nconst getCharType = (char) => {\n  switch (char) {\n    case 97: return 'a'\n    case 65: return 'A'\n    case 65: return 'A'\n    case 66: return 'b'\n    case 98: return 'c'\n    case 68: return 'C'\n    case 99: return 'd'\n    case 69: return 'D'\n    case 70: return 'E'\n    case 71: return 'F'\n    case 72: return 'G'\n    case 73: return 'H'\n    case 74: return 'I'\n    case 75: return 'J'\n    case 76: return 'K'\n    case 77: return 'L'\n    case 78: return 'M'\n    case 79: return 'N'\n    case 80: return 'O'\n    case 81: return 'P'\n    case 82: return 'Q'\n    case 83: return 'R'\n    case 84: return 'S'\n    case 85: return 'T'\n    case 86: return 'U'\n    case 87: return 'V'\n    case 88: return 'W'\n    case 89: return 'X'\n    case 90: return 'Y'\n    case 89: return 'Z'\n    case 68: return 'h'\n    case 83: return 'j'\n    case 85: return 'o'\n    case 86: return 'p'\n    case 90: return 'z'\n    case 97: return 'a'\n    case 65: return 'A'\n    case 65: return 'A'\n    case 66: return 'b'\n    case 98: return 'c'\n    case 68: return 'C'\n    case 99: return 'd'\n    case 69: return 'D'\n    case 70: return 'E'\n    case 71: return 'F'\n    case 72: return 'G'\n    case 73: return 'H'\n    case 74: return 'I'\n    case 75: return 'J'\n    case 76: return 'K'\n    case 77: return 'L'\n    case 78: return 'M'\n    case 79: return 'N'\n    case 80: return 'O'\n    case 81: return 'P'\n    case 82: return 'Q'\n    case 83: return 'R'\n    case 84: return 'S'\n    case 85: return 'T'\n    case 86: return 'U'\n    case 87: return 'V'\n    case 88: return 'W'\n    case 89: return 'X'\n    case 90: return 'Y'\n    case 89: return 'Z'\n    case 68: return 'h'\n    case 83: return 'j'\n    case 85: return 'o'\n    case 86: return 'p'\n    case 90: return 'z'\n    default: return 'x'\n  }\n}\n\nconst isWordChar = (char) => {\n  return char >= 65 && char <= 90 || char >= 97 && char <= 122\n}\n<|endoftext|>"}
{"task_id": "JavaScript/135", "prompt": "/*Creaet a function wihch rteurns the largest index of an element which\n  is not greater than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creaet a function wihch rteurns the largest index of an element which\n  is not greater than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let i = 1;\n  let j = arr.length;\n  let max;\n  while (i < j) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n    }\n    i += 1;\n  }\n  return max;\n}\n\nexport { canArrange };\n<|endoftext|>"}
{"task_id": "JavaScript/136", "prompt": "/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst.slice(1).reverse());\n  let [ c, d ] = largestSmallestIntegers(lst);\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers2 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst);\n  let [ c, d ] = largestSmallestIntegers(lst.slice(1).reverse());\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers3 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst.slice(1).reverse());\n  let [ c, d ] = largestSmallestIntegers(lst);\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers4 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst.slice(1).reverse());\n  let [ c, d ] = largestSmallestIntegers(lst);\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers5 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst);\n  let [ c, d ] = largestSmallestIntegers(lst.slice(1).reverse());\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers6 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst);\n  let [ c, d ] = largestSmallestIntegers(lst.slice(1).reverse());\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers7 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst);\n  let [ c, d ] = largestSmallestIntegers(lst.slice(1).reverse());\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers8 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst);\n  let [ c, d ] = largestSmallestIntegers(lst.slice(1).reverse());\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers9 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst);\n  let [ c, d ] = largestSmallestIntegers(lst.slice(1).reverse());\n  if (c === null) {\n    return [a, b];\n  }\n  if (c > a) {\n    return [c, b];\n  }\n  if (c === a) {\n    return [a, d];\n  }\n  if (c < a) {\n    return [c, d];\n  }\n  return [a, d];\n};\n\nconst largestSmallestIntegers10 = (lst) => {\n  let [ a, b ] = largestSmallestIntegers(lst);\n  let [ c, d ] = largestSmallestIntegers(lst.slice(1).reverse());\n  if (c === null) {\n    return [a, b];\n  }\n"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be . or ,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\nconts compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\nconts compareOne = (a, b) => {\n  const aNum = parseInt(a, 10);\n  const bNum = parseInt(b, 10);\n  const aFloat = parseFloat(a);\n  const bFloat = parseFloat(b);\n\n  if (isNaN(aNum) && isNaN(bNum)) {\n    return null;\n  }\n  if (aNum > bNum) {\n    return a;\n  }\n  if (aNum < bNum) {\n    return b;\n  }\n  if (aFloat > bFloat) {\n    return a;\n  }\n  if (aFloat < bFloat) {\n    return b;\n  }\n  return b;\n};\n\n/*\n  create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareTwo(1, 2.5)  2.5\n  compareTwo(1, \"2,3\")  \"2,3\"\n  compareTwo(\"5,1\", \"6\")  \"6\"\n  compareTwo(\"1\", 1)  null\n  */\nconts compareTwo = (a, b) => {\n  const aNum = parseInt(a, 10);\n  const bNum = parseInt(b, 10);\n  const aFloat = parseFloat(a);\n  const bFloat = parseFloat(b);\n\n  if (isNaN(aNum) && isNaN(bNum)) {\n    return null;\n  }\n  if (aNum > bNum) {\n    return b;\n  }\n  if (aNum < bNum) {\n    return a;\n  }\n  if (aFloat > bFloat) {\n    return b;\n  }\n  if (aFloat < bFloat) {\n    return a;\n  }\n  return b;\n};\n\n/*\n  create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareThree(1, 2.5)  2.5\n  compareThree(1, \"2,3\")  \"2,3\"\n  compareThree(\"5,1\", \"6\")  \"6\"\n  compareThree(\"1\", 1)  null\n  */\nconts compareThree = (a, b) => {\n  const aNum = parseInt(a, 10);\n  const bNum = parseInt(b, 10);\n  const aFloat = parseFloat(a);\n  const bFloat = parseFloat(b);\n\n  if (isNaN(aNum) && isNaN(bNum)) {\n    return null;\n  }\n  if (aNum > bNum) {\n    return b;\n  }\n  if (aNum < bNum) {\n    return a;\n  }\n  if (aFloat > bFloat) {\n    return a;\n  }\n  if (aFloat < bFloat) {\n    return b;\n  }\n  return b;\n};\n\n/*\n  create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareFour(1, 2.5)  2.5\n  compareFour(1, \"2,3\")  \"2,3\"\n  compareFour(\"5,1\", \"6\")  \"6\"\n  compareFour(\"1\", 1)  null\n  */\nconts compareFour = (a, b) => {\n  const aNum = parseInt(a, 10);\n  const bNum = parseInt(b, 10);\n  const aFloat = parseFloat(a);\n  const bFloat = parseFloat(b);\n\n  if (isNaN(aNum) && isNaN(bNum)) {\n    return null;\n  }\n  if (aNum > bNum) {\n    return b;\n  }\n  if (aNum < bNum) {\n    return a;\n  }\n  if (aFloat > bFloat) {\n    return a;\n  }\n  if (aFloat < bFloat) {\n    return b;\n  }\n  return b;\n};\n\n/*\n  create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareFive(1, 2.5)  2.5\n  compareFive(1, \"2,3\")  \"2,3\"\n  compareFive(\"5,1\", \"6\")  \"6\"\n  compareFive(\"1\", 1)  null\n  */\nconts compareFive = (a, b) => {\n  const aNum = parseInt(a, 10);\n  const bNum = parseInt(b, 10);\n  const aFloat = parseFloat(a);\n  const bFloat = parseFloat(b);\n\n  if ("}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}\n\n/*\n  Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) =="}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorila(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Brazilian factorial is defined as:\n  brazilian_factorila(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  //return Math.pow(Math.E, n) * Math.pow(Math.E, n - 1) * Math.pow(Math.E, n - 2) * Math.pow(Math.E, n - 3) * Math.pow(Math.E, n - 4) * Math.pow(Math.E, n - 5) * Math.pow(Math.E, n - 6) * Math.pow(Math.E, n - 7) * Math.pow(Math.E, n - 8) * Math.pow(Math.E, n - 9) * Math.pow(Math.E, n - 10) * Math.pow(Math.E, n - 11) * Math.pow(Math.E, n - 12) * Math.pow(Math.E, n - 13) * Math.pow(Math.E, n - 14) * Math.pow(Math.E, n - 15) * Math.pow(Math.E, n - 16) * Math.pow(Math.E, n - 17) * Math.pow(Math.E, n - 18) * Math.pow(Math.E, n - 19) * Math.pow(Math.E, n - 20);\n  return (n === 0)? 1 : n * specialFactorial(n - 1);\n}\n\nmodule.exports = {\n  factorial: factorial,\n  specialFactorial: specialFactorial\n}<|endoftext|>"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more htan 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more htan 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let spaces = text.replace(/\\s+/g, '_')\n  if (text.length > 2 && text.indexOf('  ') > -1) {\n    let spaces2 = spaces.replace(/-+/g, '-')\n    spaces = spaces2\n  }\n  return spaces\n}\n\n//------------------------------------------------------------------------------\n\nlet test = [\n  {input: \"Example\", expected: \"Example\"},\n  {input: \"Example 1\", expected: \"Example_1\"},\n  {input: \"Example   3\", expected: \"Example-3\"},\n  {input: \"  Example   3\", expected: \"Example-3\"},\n  {input: \"Example\", expected: \"Example\"}\n]\n\nfor (let test of test) {\n  console.log(`Input: ${test.input}`)\n  console.log(`Output: ${fixSpaces(test.input)}`)\n}\n\n//------------------------------------------------------------------------------\n<|endoftext|>"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which tkaes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, adn returns 'No' ohtewrise.\n  A file's name is considered to be valid if adn only if all the following conditions \n  are met:\n  - Theer should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, nad it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the odt shoudl be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Create a function which tkaes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, adn returns 'No' ohtewrise.\n  A file's name is considered to be valid if adn only if all the following conditions \n  are met:\n  - Theer should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, nad it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the odt shoudl be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let is_valid = true;\n  if(!file_name.includes(\".\")) {\n    is_valid = false;\n  }\n  if(file_name.length > 3) {\n    is_valid = false;\n  }\n  let first_char = file_name[0];\n  if(!(first_char.match(/[a-zA-Z]/)) ) {\n    is_valid = false;\n  }\n  let second_char = file_name[1];\n  if(!(second_char.match(/[0-9]/)) ) {\n    is_valid = false;\n  }\n  if(file_name.includes(\".\")) {\n    let dot_index = file_name.indexOf(\".\");\n    let second_char_after_dot = file_name.substring(dot_index+1);\n    if(second_char_after_dot.includes(\"txt\") || second_char_after_dot.includes(\"exe\") || second_char_after_dot.includes(\"dll\")) {\n      is_valid = true;\n    } else {\n      is_valid = false;\n    }\n  }\n  return is_valid;\n};\n\nmodule.exports = {\n  fileNameCheck\n};<|endoftext|>"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This fucntion will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if tis index si a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list hwose indexes are not a multiple of 3 or 4. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  This fucntion will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if tis index si a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list hwose indexes are not a multiple of 3 or 4. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const result = 0;\n  const lstLen = lst.length;\n  for (let i = 0; i < lstLen; i++) {\n    if (i % 3 === 0) {\n      result += lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      result += lst[i] * lst[i] * lst[i];\n    } else {\n      result += lst[i];\n    }\n  }\n  return result;\n};\n\nconst sumSquaresAndCube = (lst) => {\n  const result = 0;\n  const lstLen = lst.length;\n  for (let i = 0; i < lstLen; i++) {\n    if (i % 3 === 0) {\n      result += lst[i] * lst[i] * lst[i];\n    } else if (i % 4 === 0) {\n      result += lst[i] * lst[i] * lst[i] * lst[i];\n    } else {\n      result += lst[i] * lst[i];\n    }\n  }\n  return result;\n};\n\nexport {\n  sumSquares,\n  sumSquaresAndCube\n};\n<|endoftext|>"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are gievn a strnig representign a sentence,\n  the sentence contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal sentence,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new strnig should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are gievn a strnig representign a sentence,\n  the sentence contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal sentence,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new strnig should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let newSentence = '';\n  let i = 0;\n  while(i < sentence.length){\n    let word = sentence.substring(i, i+1);\n    newSentence += word;\n    i++;\n    if(i < sentence.length && sentence[i] ==''){\n      newSentence += word;\n      i++;\n    }\n  }\n  return newSentence;\n}\n\nconst wordsInSentence = (sentence) => {\n  let newSentence = '';\n  let i = 0;\n  while(i < sentence.length){\n    let word = sentence.substring(i, i+1);\n    newSentence += word;\n    i++;\n    if(i < sentence.length && sentence[i] ==''){\n      newSentence += word;\n      i++;\n    }\n  }\n  return newSentence;\n}\n\n/*\n  You are gievn a string,\n  the string contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal string,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"This is a test\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"lets go for swimming\"\n */\nconst wordsInSentence = (sentence) => {\n  let newSentence = '';\n  let i = 0;\n  while(i < sentence.length){\n    let word = sentence.substring(i, i+1);\n    newSentence += word;\n    i++;\n    if(i < sentence.length && sentence[i] ==''){\n      newSentence += word;\n      i++;\n    }\n  }\n  return newSentence;\n}\n\n/*\n  You are gievn a string,\n  the string contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal string,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"This is a test\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"lets go for swimming\"\n */\nconst wordsInSentence = (sentence) => {\n  let newSentence = '';\n  let i = 0;\n  while(i < sentence.length){\n    let word = sentence.substring(i, i+1);\n    newSentence += word;\n    i++;\n    if(i < sentence.length && sentence[i] ==''){\n      newSentence += word;\n      i++;\n    }\n  }\n  return newSentence;\n}\n\n/*\n  You are gievn a string,\n  the string contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal string,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"This is a test\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"lets go for swimming\"\n */\nconst wordsInSentence = (sentence) => {\n  let newSentence = '';\n  let i = 0;\n  while(i < sentence.length){\n    let word = sentence.substring(i, i+1);\n    newSentence += word;\n    i++;\n    if(i < sentence.length && sentence[i] ==''){\n      newSentence += word;\n      i++;\n    }\n  }\n  return newSentence;\n}\n\nconst wordsInSentence = (sentence) => {\n  let newSentence = '';\n  let i = 0;\n  while(i < sentence.length){\n    let word = sentence.substring(i, i+1);\n    newSentence += word;\n    i++;\n    if(i < sentence.length && sentence[i] ==''){\n      newSentence += word;\n      i++;\n    }\n  }\n  return newSentence;\n}\n\n/*\n  You are gievn a string,\n  the string contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal string,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"This is a test\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"lets go for swimming\"\n */\nconst wordsInSentence = (sentence) => {\n  let newSentence = '';\n  let i = 0;\n  while(i < sentence.length){\n    let word = sentence.substring(i, i+1);\n    newSentence += word;\n    i++;\n    if(i < sentence.length && sentence[i] ==''){\n      newSentence += word;\n      i++;\n    }\n  }\n  return newSentence;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  let xDigits = x.split(\"/\").map(digit => parseInt(digit));\n  let nDigits = n.split(\"/\").map(digit => parseInt(digit));\n  let result = false;\n  if (xDigits[0] === nDigits[0]) {\n    if (xDigits[1] === nDigits[1]) {\n      if (xDigits[0] === nDigits[0]) {\n        if (xDigits[1] === nDigits[1]) {\n          result = true;\n        } else if (xDigits[1] > nDigits[1]) {\n          result = true;\n        }\n      } else if (xDigits[1] > nDigits[1]) {\n        result = true;\n      }\n    } else if (xDigits[1] > nDigits[1]) {\n      result = true;\n    }\n  } else if (xDigits[0] > nDigits[0]) {\n    if (xDigits[1] === nDigits[1]) {\n      result = true;\n    }\n  }\n  return result;\n}\n\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const list = [];\n  for (let i = 0; i < nums.length; i++) {\n    list.push(nums[i]);\n  }\n  list.sort((a, b) => {\n    const sumA = sumDigits(a);\n    const sumB = sumDigits(b);\n    if (sumA > sumB) {\n      return -1;\n    }\n    if (sumA < sumB) {\n      return 1;\n    }\n    return 0;\n  });\n  return list;\n};\n\n/*\n  Write a function that counts how many times a given char\n  occurs in a string.\n\n  For example:\n  >>> countOccurrences('abcde', 'c') == 3\n  >>> countOccurrences('abcde', 'x') == 0\n  */\nconst countOccurrences = (str, char) => {\n  const charCount = {};\n  for (let i = 0; i < str.length; i++) {\n    charCount[str[i]] = (charCount[str[i]] || 0) + 1;\n  }\n  return charCount[char];\n};\n\n/*\n  Write a function that finds the largest element of an array of\n  integers.\n\n  For example:\n  >>> findLargest([1, 2, 3]) == 3\n  >>> findLargest([1, 2, 3, 4, 5]) == 5\n  >>> findLargest([]) == undefined\n  */\nconst findLargest = (nums) => {\n  let largest = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (largest < nums[i]) {\n      largest = nums[i];\n    }\n  }\n  return largest;\n};\n\n/*\n  Write a function that finds the smallest element of an array of\n  integers.\n\n  For example:\n  >>> findSmallest([1, 2, 3]) == 1\n  >>> findSmallest([1, 2, 3, 4, 5]) == 1\n  >>> findSmallest([]) == undefined\n  */\nconst findSmallest = (nums) => {\n  let smallest = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (smallest > nums[i]) {\n      smallest = nums[i];\n    }\n  }\n  return smallest;\n};\n\n/*\n  Write a function that finds the second largest element of an array of\n  integers.\n\n  For example:\n  >>> findSecondLargest([1, 2, 3]) == 2\n  >>> findSecondLargest([1, 2, 3, 4, 5]) == 4\n  >>> findSecondLargest([]) == undefined\n  */\nconst findSecondLargest = (nums) => {\n  let largest = findLargest(nums);\n  let secondLargest = largest;\n  let secondLargestIdx = 0;\n  let count = 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > largest) {\n      secondLargest = largest;\n      secondLargestIdx = i;\n      largest = nums[i];\n      count = 1;\n    } else if (nums[i] > largest && nums[i] < secondLargest) {\n      secondLargest = nums[i];\n      secondLargestIdx = i;\n      count++;\n    }\n  }\n  return secondLargest;\n};\n\n/*\n  Write a function that finds the second smallest element of an array of\n  integers.\n\n  For example:\n  >>> findSecondSmallest([1, 2, 3]) == 2\n  >>> findSecondSmallest([1, 2, 3, 4, 5]) == 2\n  >>> findSecondSmallest([]) == undefined\n  */\nconst findSecondSmallest = (nums) => {\n  let smallest = findSmallest(nums);\n  let secondSmallest = smallest;\n  let secondSmallestIdx = 0;\n  let count = 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < smallest) {\n      secondSmallest = smallest;\n      secondSmallestIdx = i;\n      smallest = nums[i];\n      count = 1;\n    } else if (nums[i] < smallest && nums[i] > secondSmallest) {\n      secondSmallest = nums[i];\n      secondSmallestIdx = i;\n      count++;\n    }\n  }\n  return secondSmallest;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary htat are greater than 10 and both \n  frist nad last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary htat are greater than 10 and both \n  frist nad last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    let x = nums[i];\n    if ((x >= 10) && (x <= 50) && ((x % 2) === 1)) {\n      result++;\n    }\n  }\n  return result;\n};\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the numebr of tripels (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] si a multpile fo 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the numebr of tripels (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] si a multpile fo 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n    const arr = Array.from({ length: n }, (x, i) => i * i - i + 1);\n    const triples = arr.filter((_, i) => i < arr.length - 1).reduce((acc, cur) => [...acc, [cur,...arr.slice(i + 1)], cur].filter((_, index) => index < arr.length - 1), []);\n    return triples.length;\n};\n\nconsole.log(getMaxTriples(5));<|endoftext|>"}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar ysstem: the clsoerst to the Sun\n  is Mercury, the next one is Venus, then Earht, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function shuold return a tuple conatining all planets whose orbist are\n  loctaed ebtween the orbit of planet1 adn the orbit of planet2, sorted by\n  the proximity to the sun.\n  The funtcion should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* There are eight planets in our solar ysstem: the clsoerst to the Sun\n  is Mercury, the next one is Venus, then Earht, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function shuold return a tuple conatining all planets whose orbist are\n  loctaed ebtween the orbit of planet1 adn the orbit of planet2, sorted by\n  the proximity to the sun.\n  The funtcion should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let result = [];\n  let planet1_orbit = [];\n  let planet2_orbit = [];\n  const sun = {};\n\n  // get the orbital elements of planet1\n  const planet1_orbital_elements = orbitalElements(planet1);\n  // get the orbital elements of planet2\n  const planet2_orbital_elements = orbitalElements(planet2);\n  // check if planet1 and planet2 are correct\n  if(planet1_orbital_elements && planet2_orbital_elements){\n    // if the elements of the two planets are correct\n    // get the sun orbital elements\n    const sun_orbital_elements = orbitalElements(sun);\n    // find the distance between the two planets\n    const distance = distanceBetween(planet1_orbital_elements, planet2_orbital_elements);\n    // find the distance between the two suns\n    const sun_distance = distanceBetween(sun_orbital_elements, planet2_orbital_elements);\n    // if the distance is less than the distance between the suns\n    if(distance < sun_distance){\n      // check if planet1 is closer to the sun than planet2\n      if(distance < planet2_orbital_elements.distance){\n        // check if planet2 is closer to the sun than planet1\n        if(distance < planet1_orbital_elements.distance){\n          // check if planet1 is the closest to the sun\n          if(planet1_orbital_elements.distance < planet2_orbital_elements.distance){\n            // check if planet2 is the closest to the sun\n            if(planet2_orbital_elements.distance < planet1_orbital_elements.distance){\n              // check if planet1 is the closest to the sun\n              if(planet1_orbital_elements.distance < sun_distance){\n                // add planet1 to the result list\n                result.push(planet1);\n              }\n              // check if planet2 is the closest to the sun\n              if(planet2_orbital_elements.distance < sun_distance){\n                // add planet2 to the result list\n                result.push(planet2);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const list = lst.filter(e => e.length % 2!== 0)\n  const sorted = list.sort((a, b) => a.length - b.length)\n  const sum = sorted.reduce((a, b) => a + b, 0)\n  return list.filter(e => e.length === sum)\n}\n\nconsole.log(sortedListSum([\"ab\", \"a\", \"aaa\", \"cd\"]))\n<|endoftext|>"}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n    if (isPrime(n)) {\n        return x;\n    }\n    else {\n        return y;\n    }\n}\n\nconst isPrime = (n) => {\n    let i = 2;\n    while (i < n) {\n        if (n % i === 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nmodule.exports = xOrY;<|endoftext|>"}
{"task_id": "JavaScript/151", "prompt": "/* iGven a list of numbres, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negaitve or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* iGven a list of numbres, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negaitve or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) return 0\n  let sum = 0\n  lst.forEach((x) => {\n    if (x % 2 === 1) {\n      sum += x * x\n    }\n  })\n  return sum\n}\n\n/**\n  doubleTheDifferenceBy(x) returns the difference of the numbers in the list\n  that are even multiplied by x.\n  doubleTheDifferenceBy([1, 3, 2, 0]) == 1 * 3 + 2 * 0 + 0 = 6\n  doubleTheDifferenceBy([-1, -2, 0]) == 0\n  doubleTheDifferenceBy([9, -2]) == 81\n  doubleTheDifferenceBy([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifferenceBy = (lst) => {\n  if (lst.length === 0) return 0\n  let sum = 0\n  lst.forEach((x) => {\n    if (x % 2 === 0) {\n      sum += x * x\n    }\n  })\n  return sum\n}\n\n/**\n  doubleTheDifferenceWith(x) returns the difference of the numbers in the list\n  that are even divided by x.\n  doubleTheDifferenceWith([1, 3, 2, 0]) == 1 / 3 + 2 / 0 + 0 = 1\n  doubleTheDifferenceWith([-1, -2, 0]) == 0\n  doubleTheDifferenceWith([9, -2]) == 81\n  doubleTheDifferenceWith([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifferenceWith = (lst) => {\n  if (lst.length === 0) return 0\n  let sum = 0\n  lst.forEach((x) => {\n    if (x % 2 === 0) {\n      sum += x / x\n    }\n  })\n  return sum\n}\n\n/**\n  intTheDifference([1, 3, 2, 0]) == 2\n  intTheDifference([-1, -2, 0]) == 0\n  intTheDifference([9, -2]) == 2\n  intTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst intTheDifference = (lst) => {\n  if (lst.length === 0) return 0\n  let sum = 0\n  lst.forEach((x) => {\n    if (x % 1 === 0) {\n      sum += x\n    }\n  })\n  return sum\n}\n\n/**\n  intTheDifferenceBy(x) returns the difference of the numbers in the list\n  that are even multiplied by x.\n  intTheDifferenceBy([1, 3, 2, 0]) == 2 * 3 + 2 * 0 + 0 = 6\n  intTheDifferenceBy([-1, -2, 0]) == 0\n  intTheDifferenceBy([9, -2]) == 2 * 9 + 2 * -2 = 36\n  intTheDifferenceBy([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst intTheDifferenceBy = (lst) => {\n  if (lst.length === 0) return 0\n  let sum = 0\n  lst.forEach((x) => {\n    if (x % 1 === 0) {\n      sum += x * x\n    }\n  })\n  return sum\n}\n\n/**\n  intTheDifferenceWith(x) returns the difference of the numbers in the list\n  that are even divided by x.\n  intTheDifferenceWith([1, 3, 2, 0]) == 2 / 3 + 2 / 0 + 0 = 1\n  intTheDifferenceWith([-1, -2, 0]) == 0\n  intTheDifferenceWith([9, -2]) == 2 / 9 + 2 / -2 = 2\n  intTheDifferenceWith([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst intTheDifferenceWith = (lst) => {\n  if (lst.length === 0) return 0\n  let sum = 0\n  lst.forEach((x) => {\n    if (x % 1 === 0) {\n      sum += x / x\n    }\n  })\n  return sum\n}\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeilng when the reslut of some long-awaited\n  eevnt is finally knwno. The feelings and thuoghts you have at that ommnet are\n  definitely worth noting dwon and cmoparing.\n  Your task is to determine if a person correctly guessed hte results of a number of matches.\n  You are given two arrays of socres and guesses of equal length, where each index shows a match. \n  Return an array of the same elgnth denoting how far off each guess was. If they have guessed correctyl,\n  the avlue is 0, and if not, the value si the absoulte difference ebtween the guess and the csore.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I think we all remember that feeilng when the reslut of some long-awaited\n  eevnt is finally knwno. The feelings and thuoghts you have at that ommnet are\n  definitely worth noting dwon and cmoparing.\n  Your task is to determine if a person correctly guessed hte results of a number of matches.\n  You are given two arrays of socres and guesses of equal length, where each index shows a match. \n  Return an array of the same elgnth denoting how far off each guess was. If they have guessed correctyl,\n  the avlue is 0, and if not, the value si the absoulte difference ebtween the guess and the csore.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let diffs = game.map((x, i) => (x - guess[i]));\n  return game.map((x, i) => (diffs[i] < 0? -diffs[i] : diffs[i]));\n}\n\n/*\n  #2\n  \n  \n  #3\n  \n  #4\n  \n  #5\n  \n  \n  #6\n  \n  \n  #7\n  \n  \n  #8\n  \n  \n  #9\n  \n  \n  #10\n  \n  \n  #11\n  \n  \n  #12\n  \n  \n  #13\n  \n  \n  #14\n  \n  \n  #15\n  \n  \n  #16\n  \n  \n  #17\n  \n  \n  #18\n  \n  \n  #19\n  \n  \n  #20\n  \n  \n  #21\n  \n  \n  #22\n  \n  \n  #23\n  \n  \n  #24\n  \n  \n  #25\n  \n  \n  #26\n  \n  \n  #27\n  \n  \n  #28\n  \n  \n  #29\n  \n  \n  #30\n  \n  \n  #31\n  \n  \n  #32\n  \n  \n  #33\n  \n  \n  #34\n  \n  \n  #35\n  \n  \n  #36\n  \n  \n  #37\n  \n  \n  #38\n  \n  \n  #39\n  \n  \n  #40\n  \n  \n  #41\n  \n  \n  #42\n  \n  \n  #43\n  \n  \n  #44\n  \n  \n  #45\n  \n  \n  #46\n  \n  \n  #47\n  \n  \n  #48\n  \n  \n  #49\n  \n  \n  #50\n  \n  \n  #51\n  \n  \n  #52\n  \n  \n  #53\n  \n  \n  #54\n  \n  \n  #55\n  \n  \n  #56\n  \n  \n  #57\n  \n  \n  #58\n  \n  \n  #59\n  \n  \n  #60\n  \n  \n  #61\n  \n  \n  #62\n  \n  \n  #63\n  \n  \n  #64\n  \n  \n  #65\n  \n  \n  #66\n  \n  \n  #67\n  \n  \n  #68\n  \n  \n  #69\n  \n  \n  #70\n  \n  \n  #71\n  \n  \n  #72\n  \n  \n  #73\n  \n  \n  #74\n  \n  \n  #75\n  \n  \n  #76\n  \n  \n  #77\n  \n  \n  #78\n  \n  \n  #79\n  \n  \n  #80\n  \n  \n  #81\n  \n  \n  #82\n  \n  \n  #83\n  \n  \n  #84\n  \n  \n  #85\n  \n  \n  #86\n  \n  \n  #87\n  \n  \n  #88\n  \n  \n  #89\n  \n  \n  #90\n  \n  \n  #91\n  \n  \n  #92\n  \n  \n  #93\n  \n  \n  #94\n  \n  \n  #95\n  \n  \n  #96\n  \n  \n  #97\n  \n  \n  #98\n  \n  \n  #99\n  \n  \n  #100\n  \n  \n  #101\n  \n  \n  #102\n  \n  \n  #103\n  \n  \n  #104\n  \n  \n  #105\n  \n  \n  #106\n  \n  \n  #107\n  \n  \n  #108\n  \n  \n  #109\n  \n  \n  #110\n  \n  \n  #111\n  \n  \n  #112\n  \n  \n  #113\n  \n  \n  #114\n  \n  \n  #115\n  \n  \n  #116\n  \n  \n  #117\n  \n  \n  #118\n  \n  \n  #119\n  \n  \n  #120\n  \n  \n  #121\n  \n  \n  #122\n  \n  \n  #123\n  \n  \n  #124\n  \n  \n  #125\n  \n  \n  #126\n  \n  \n  #127\n  \n  \n  #128\n  \n  \n  #129\n  \n  \n  #130\n  \n  \n  #131\n  \n  \n  #132\n  \n  \n  #133\n  \n  \n  #134\n  \n  \n  #135\n  \n  \n  #136\n  \n  \n  #137\n  \n  \n  #138\n  \n  \n  #139\n  \n  \n  #140\n  \n  \n  #141\n  \n  \n  #142\n  \n  \n  #143\n  \n  \n  #144\n  \n  \n  #145\n  \n  \n  #146\n  \n  \n  #147\n  \n  \n  #148\n  \n  \n  #149\n  \n  \n  #150\n  \n  \n  #151\n  \n  \n  #152\n  \n  "}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used ot load additoianl classes to the lcass. The\n  stregnth of the extenison is as follwos: Let CAP be the nmuber of the uppercsae\n  lettres in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strentgh is given by the fraction CPA - SM.\n  You shuold find the srtonegst extensino and return a string in thsi\n  fomrat: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used ot load additoianl classes to the lcass. The\n  stregnth of the extenison is as follwos: Let CAP be the nmuber of the uppercsae\n  lettres in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strentgh is given by the fraction CPA - SM.\n  You shuold find the srtonegst extensino and return a string in thsi\n  fomrat: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let i = 0;\n  let strongestExtension = '';\n\n  // get the strength of the extension\n  extensions.forEach((extension) => {\n    let name = extension.split('.')[1];\n    let cap = name.charAt(0).toUpperCase() + name.slice(1);\n    let strength = cap.length - name.length;\n\n    if (strength > i) {\n      strongestExtension = class_name + '.' + extension;\n      i = strength;\n    }\n  });\n\n  return strongestExtension;\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You are givne 2 words. You need to return true if the escond word or any of its rotations is a substring in the fisrt word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => ture\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => rtue\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You are givne 2 words. You need to return true if the escond word or any of its rotations is a substring in the fisrt word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => ture\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => rtue\n  */\nconst cycpatternCheck = (a, b) => {\n  let i = 0, j = 0;\n  while(i < a.length && j < b.length) {\n    if(a[i] === b[j]) {\n      i++;\n      j++;\n    } else {\n      if(!cycpatternCheck(a.slice(i + 1), b.slice(j + 1))) {\n        return false;\n      }\n      j++;\n      i = 0;\n    }\n  }\n  return true;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/155", "prompt": "/*Given na integre. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Given na integre. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  const count = 0;\n  let n = num;\n  while (n) {\n    count += n % 2;\n    n = n / 2;\n  }\n  return (count, n);\n}\n\n/*Given a number n, return a tuple that has the sum of all the digits of n. */\nconst sumDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum;\n}\n\n/*Given a number n, return a tuple that has the product of all the digits of n. */\nconst productDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product;\n}\n\n/*Given a number n, return a tuple that has the sum of the digits of n squared. */\nconst sumOfSquaredDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum * sum;\n}\n\n/*Given a number n, return a tuple that has the product of the digits of n squared. */\nconst productOfSquaredDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product * product;\n}\n\n/*Given a number n, return a tuple that has the sum of the digits of n cubed. */\nconst sumOfCubedDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum * sum * sum;\n}\n\n/*Given a number n, return a tuple that has the product of the digits of n cubed. */\nconst productOfCubedDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product * product * product;\n}\n\n/*Given a number n, return a tuple that has the sum of the digits of n quartered. */\nconst sumOfQuartedDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum * sum * sum * sum;\n}\n\n/*Given a number n, return a tuple that has the product of the digits of n quartered. */\nconst productOfQuartedDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product * product * product * product;\n}\n\n/*Given a number n, return a tuple that has the sum of the digits of n squared and n cubed. */\nconst sumOfSquaredAndCubedDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum * sum * sum;\n}\n\n/*Given a number n, return a tuple that has the product of the digits of n squared and n cubed. */\nconst productOfSquaredAndCubedDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product * product * product;\n}\n\n/*Given a number n, return a tuple that has the sum of the digits of n cubed and n quartered. */\nconst sumOfCubedAndQuartedDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum * sum * sum * sum;\n}\n\n/*Given a number n, return a tuple that has the product of the digits of n cubed and n quartered. */\nconst productOfCubedAndQuartedDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product * product * product * product;\n}\n\n/*Given a number n, return a tuple that has the sum of the digits of n squared and n cubed and n quartered. */\nconst sumOfSquaredAndCubedAndQuartedDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum * sum * sum * sum * sum;\n}\n\n/*Given a number n, return a tuple that has the product of the digits of n squared and n cubed and n quartered. */\nconst productOfSquaredAndCubedAndQuartedDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product * product * product * product * product;\n}\n\n/*Given a number n, return a tuple that has the sum of the digits of n squared, n cubed and n quartered. */\nconst sumOfSquaredCubedAndQuartedDigits = (num) => {\n  const sum = 0;\n  while (num) {\n    sum += num % 10;\n    num = num / 10;\n  }\n  return sum * sum * sum * sum * sum * sum;\n}\n\n/*Given a number n, return a tuple that has the product of the digits of n squared, n cubed and n quartered. */\nconst productOfSquaredCubedAndQuartedDigits = (num) => {\n  const product = 1;\n  while (num) {\n    product *= num % 10;\n    num = num / 10;\n  }\n  return product * product * product * product * product * product;\n}\n\n/*Given a number n, return a tuple that has"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Gievn a positive integer, obtain its roman numearl equivaletn as a string,\n  and return it in lowercase.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Gievn a positive integer, obtain its roman numearl equivaletn as a string,\n  and return it in lowercase.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const letters = {\n    1: 'I',\n    4: 'IV',\n    5: 'V',\n    9: 'IX',\n    10: 'X',\n    40: 'XL',\n    50: 'L',\n    90: 'XC',\n    100: 'C',\n    400: 'CD',\n    500: 'D',\n    900: 'CM',\n  }\n\n  let string = ''\n\n  for (let i = 1; i <= number; i++) {\n    let num = i\n    let l = letters[num]\n\n    while (num > 1) {\n      num = num / 10\n      l = l + letters[num]\n    }\n\n    string += l.toLowerCase()\n  }\n\n  return string\n}\n\n/*\n  Gievn a positive integer, obtain its roman numearl equivaletn as a string,\n  and return it in lowercase.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  const letters = {\n    1: 'I',\n    4: 'IV',\n    5: 'V',\n    9: 'IX',\n    10: 'X',\n    40: 'XL',\n    50: 'L',\n    90: 'XC',\n    100: 'C',\n    400: 'CD',\n    500: 'D',\n    900: 'CM',\n  }\n\n  let string = ''\n\n  for (let i = 1; i <= number; i++) {\n    let num = i\n    let l = letters[num]\n\n    while (num > 1) {\n      num = num / 10\n      l = l + letters[num]\n    }\n\n    string += l\n  }\n\n  return string\n}\n\nmodule.exports = {\n  intToRoman,\n  intToMiniRoman,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a_squared = (a * a) / 2;\n  const b_squared = (b * b) / 2;\n  const c_squared = (c * c) / 2;\n  const s_squared = (a * b) / 2;\n  const area = (a * c) / 2;\n  if (area === 0) {\n    return (a_squared + b_squared === c_squared);\n  } else {\n    return (area === s_squared && (b_squared === c_squared));\n  }\n}\n<|endoftext|>"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with amximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with amximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  const max = words[0];\n  let maxCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    const w = words[i];\n    if (w.length > maxCount) {\n      max = w;\n      maxCount = w.length;\n    }\n  }\n  return max;\n};\n\nconst findMax = (words) => {\n  const max = words[0];\n  let maxCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    const w = words[i];\n    if (w.length > maxCount) {\n      max = w;\n      maxCount = w.length;\n    }\n  }\n  return max;\n};\n\nconsole.log(findMax([0, \"\", 1, \"a\", \"\", \"a\", \"aa\"]));\nconsole.log(findMax([0, \"\", 1, \"a\", \"\", \"a\", \"aa\", \"\", \"\", \"a\"]));\nconsole.log(findMax([0, \"\", 1, \"a\", \"\", \"a\", \"aa\", \"\", \"\", \"a\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\","}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const eaten = number - need;\n  const left = remaining - eaten;\n  \n  if (left <= 0) {\n    return [left, 0];\n  }\n  \n  const result = [left, eaten];\n  \n  return result;\n}\n\nconsole.log(eat(5, 6, 10));\nconsole.log(eat(4, 8, 9));\nconsole.log(eat(1, 10, 10));\nconsole.log(eat(2, 11, 5));\n<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has baisc algebra operations, and \n  hte escond list is a list of integers. Use the two gievn lists to build the algerbic \n  expression nad return the evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. The first list has baisc algebra operations, and \n  hte escond list is a list of integers. Use the two gievn lists to build the algerbic \n  expression nad return the evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  // Check that operator list has at least one item\n  if (operator.length < 1) {\n    throw new Error(\"operator list must have at least one element\");\n  }\n\n  // Check that operand list has at least two items\n  if (operand.length < 2) {\n    throw new Error(\"operand list must have at least two elements\");\n  }\n\n  // Check that all elements in operand list are non-negative\n  operand.forEach(e => {\n    if (e < 0) {\n      throw new Error(\"all elements in operand list must be non-negative\");\n    }\n  })\n\n  // Iterate through operand list\n  for (let i = 0; i < operand.length - 1; i++) {\n    let a = operand[i];\n    let b = operand[i + 1];\n\n    // If operator is not a basic algebra operator, throw an error\n    if (operator.indexOf('+') === -1 && operator.indexOf('-') === -1 &&\n      operator.indexOf('*') === -1 && operator.indexOf('//') === -1 &&\n      operator.indexOf('**') === -1) {\n      throw new Error(\"operator list must consist of all the basic algebra operators\");\n    }\n\n    // If b is not an integer, throw an error\n    if (typeof b!== 'number') {\n      throw new Error(\"operand list must consist of all the integers\");\n    }\n\n    // Find the operation on a and b\n    let operation;\n    if (operator.indexOf('+')!== -1) {\n      operation = '+';\n    } else if (operator.indexOf('-')!== -1) {\n      operation = '-';\n    } else if (operator.indexOf('*')!== -1) {\n      operation = '*';\n    } else if (operator.indexOf('//')!== -1) {\n      operation = '//';\n    } else if (operator.indexOf('**')!== -1) {\n      operation = '**';\n    }\n\n    // Perform the operation\n    let result = a + b * b;\n    let remainder = result % b;\n\n    // Check that result is an integer\n    if (typeof result!== 'number') {\n      throw new Error(\"result must be an integer\");\n    }\n\n    // If remainder is non-zero, throw an error\n    if (remainder!== 0) {\n      throw new Error(\"result must be an integer\");\n    }\n\n    // If the result is zero, return the first value\n    if (result === 0) {\n      return a;\n    }\n\n    // Otherwise, return the result\n    return result;\n  }\n\n  // Check that the last element in the operand list is an integer\n  let a = operand[operand.length - 1];\n\n  // If the last element is not an integer, throw an error\n  if (typeof a!== 'number') {\n    throw new Error(\"operand list must consist of all the integers\");\n  }\n\n  // Check that the first element in the operand list is an integer\n  let b = operand[0];\n\n  // If the first element is not an integer, throw an error\n  if (typeof b!== 'number') {\n    throw new Error(\"operand list must consist of all the integers\");\n  }\n\n  // Find the operation on a and b\n  let operation;\n  if (operator.indexOf('+')!== -1) {\n    operation = '+';\n  } else if (operator.indexOf('-')!== -1) {\n    operation = '-';\n  } else if (operator.indexOf('*')!== -1) {\n    operation = '*';\n  } else if (operator.indexOf('//')!== -1) {\n    operation = '//';\n  } else if (operator.indexOf('**')!== -1) {\n    operation = '**';\n  }\n\n  // Perform the operation\n  let result = a + b * b;\n  let remainder = result % b;\n\n  // Check that result is an integer\n  if (typeof result!== 'number') {\n    throw new Error(\"result must be an integer\");\n  }\n\n  // If remainder is non-zero, throw an error\n  if (remainder!== 0) {\n    throw new Error(\"result must be an integer\");\n  }\n\n  // If the result is zero, return the first value\n  if (result === 0) {\n    return a;\n  }\n\n  // Otherwise, return the result\n  return result;\n}\n\n// Print the result of the algorithm\nconst printResult = (operator, operand) => {\n  let expression = doAlgebra(operator, operand);\n  console.log(expression);\n};\n\n// Print the result of the algorithm\nconst main = () => {\n  let operator = ['+', '*', '-'];\n  let operand = [2, 3, 4, 5];\n  printResult(operator, operand);\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/161", "prompt": "/*You rae given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You rae given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let l = s.length;\n  let result = \"\";\n  for(let i = 0; i < l; i++) {\n    let c = s.charAt(i);\n    if(isalpha(c)) {\n      if(c == s.charAt(i).toUpperCase()) {\n        result += c.toLowerCase();\n      } else {\n        result += c.toUpperCase();\n      }\n    } else {\n      result += c;\n    }\n  }\n  return result;\n};\n\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n    if (text === undefined) return null;\n    return new Buffer(text, 'utf8').toString('hex');\n}\n\n/*\n  Given a string 'text', return its sha1 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '3c01b9c26852d6ee2d9d133516ce9a5d'\n  */\nconst stringToSha1 = (text) => {\n    if (text === undefined) return null;\n    return new Buffer(text, 'utf8').toString('hex');\n}\n\n/*\n  Given a string 'text', return its sha256 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '6d9dff8e7c7a6d7d55f3a3c5a6d0a1a1a2d7d5b8ec1d4e0c6b2a6d9da'\n  */\nconst stringToSha256 = (text) => {\n    if (text === undefined) return null;\n    return new Buffer(text, 'utf8').toString('hex');\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd2b0917ff1c65b9d28f6f908b7e0f6f8e3d2b2c18b7a5f9e4c4d6b5b7d2e7b6'\n  */\nconst stringToSha512 = (text) => {\n    if (text === undefined) return null;\n    return new Buffer(text, 'utf8').toString('hex');\n}\n\nmodule.exports = {\n    stringToMd5,\n    stringToSha1,\n    stringToSha256,\n    stringToSha512\n}<|endoftext|>"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive nitegers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Given two positive nitegers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  while (a <= b) {\n    result.push(a);\n    a += 2;\n  }\n  return result;\n};\n\n/*\n  Given two positive nitegers a and b, return the odd digits between a\n  and b, in ascending order.\n\n  For example:\n  generateOdds(2, 8) => [2, 4, 6, 8]\n  generateOdds(8, 2) => [2, 4, 6, 8]\n  generateOdds(10, 14) => [10, 12, 14]\n  */\nconst generateOdds = (a, b) => {\n  let result = [];\n  while (a <= b) {\n    if (a % 2 === 1) {\n      result.push(a);\n    }\n    a += 2;\n  }\n  return result;\n};\n\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n  generateIntegers,\n  generateOdds\n};\n<|endoftext|>"}
