{"task_id": "JavaScript/0", "prompt": "/* Check if in gives list of numbers, was any two numbers closer to each other than gives threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Check if in gives list of numbers, was any two numbers closer to each other than gives threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = numbers[0];\n  let closest = ", "passed": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input to this functions is a string contains multiple group of nested parentheses. Your goals is to separating those group into separate strings and return the list of those. Separate group was balancing (each open brace is properly close) and not nest within each other Ignore any space in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input to this functions is a string contains multiple group of nested parentheses. Your goals is to separating those group into separate strings and return the list of those. Separate group was balancing (each open brace is properly close) and not nest within each other Ignore any space in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/).map((group) => {\n    const [open, close] = group.split('(');\n    return [open, close];\n  });\n  return paren_groups.reduce((acc, group) => {\n    const [open, close] = group;\n    acc.push(open);\n    acc.push(close);\n    return acc;\n  }, []);\n};\n\n/**\n  Given a string containing multiple group of parentheses, return the list of those groups. Ignore any space in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsIgnoreSpace = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/).map((group) => {\n    const [open, close] = group.split('(');\n    return [open, close];\n  });\n  return paren_groups.reduce((acc, group) => {\n    const [open, close] = group;\n    acc.push(open);\n    acc.push(close);\n    return acc;\n  }, []);\n};\n\n/**\n  Given a string containing multiple group of parentheses, return the list of those groups. Ignore any space in the input string.\n  >>> separateParenGroupsIgnoreSpace('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsIgnoreSpaceIgnoreSpace = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/).map((group) => {\n    const [open, close] = group.split('(');\n    return [open, close];\n  });\n  return paren_groups.reduce((acc, group) => {\n    const [open, close] = group;\n    acc.push(open);\n    acc.push(close);\n    return acc;\n  }, []);\n};\n\n/**\n  Given a string containing multiple group of parentheses, return the list of those groups. Ignore any space in the input string.\n  >>> separateParenGroupsIgnoreSpaceIgnoreSpace('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpace = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/).map((group) => {\n    const [open, close] = group.split('(');\n    return [open, close];\n  });\n  return paren_groups.reduce((acc, group) => {\n    const [open, close] = group;\n    acc.push(open);\n    acc.push(close);\n    return acc;\n  }, []);\n};\n\n/**\n  Given a string containing multiple group of parentheses, return the list of those groups. Ignore any space in the input string.\n  >>> separateParenGroupsIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpace", "passed": 0}
{"task_id": "JavaScript/10", "prompt": "/* Tests if gniven strig is a palindrome */ const isPalindrome = (string) => { return string == string.split('').reverse().join('');\n}\n\n/* Finds the shorter palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Tests if gniven strig is a palindrome */ const isPalindrome = (string) => { return string == string.split('').reverse().join('');\n}\n\n/* Finds the shorter palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let reversedString = string.reverse();\n  let prefix = '';\n  let suffix = '';\n  let length = string.length;\n  let i;\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || string.trim().length == 0) {\n    return '';\n  }\n\n  /* If string is empty or contains only whitespaces, return empty string */\n  if (length == 0 || ", "passed": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Gives a positive integers n, you had to made a piles of n level of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, you had to made a piles of n level of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(i + 1);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return a list of all possible combinations of n elements. Each combination is a list with n elements.\n\n Examples:\n  >>> combinations(3)\n  [[1, 2], [1, 3], [2, 3], [1, 4], [2, 4], [1, 5], [2, 5], [1, 6], [2, 6], [1, 7], [2, 7], [1, 8], [2, 8], [1, 9], [2, 9], [1, 10], [2, 10], [1, 11], [2, 11], [1, 12], [2, 12], [1, 13], [2, 13], [1, 14], [2, 14], [1, 15], [2, 15], [1, 16], [2, 16], [1, 17], [2, 17], [1, 18], [2, 18], [1, 19], [2, 19], [1, 20], [2, 20], [1, 21], [2, 21], [1, 22], [2, 22], [1, 23], [2, 23], [1, 24], [2, 24], [1, 25], [2, 25], [1, 26], [2, 26], [1, 27], [2, 27], [1, 28], [2, 28], [1, 29], [2, 29], [1, 30], [2, 30], [1, 31], [2, 31], [1, 32], [2, 32], [1, 33], [2, 33], [1, 34], [2, 34], [1, 35], [2, 35], [1, 36], [2, 36], [1, 37], [2, 37], [1, 38], [2, 38], [1, 39], [2, 39], [1, 40], [2, 40], [1, 41], [2, 41], [1, 42], [2, 42], [1, 43], [2, 43], [1, 44], [2, 44], [1, 45], [2, 45], [1, 46], [2, 46], [1, 47], [2, 47], [1, 48], [2, 48], [1, 49], [2, 49], [1, 50], [2, 50], [1, 51], [2, 51], [1, 52], [2, 52], [1, 53], [2, 53], [1, 54], [2, 54], [1, 55], [2, 55], [1, 56], [2, 56], [1, 57], [2, 57], [1, 58], [2, 58], [1, 59], [2, 59], [1, 60], [2, 60], [1, 61], [2, 61], [1, 62], [2, 62], [1, 63], [2, 63], [1, 64], [2, 64], [1, 65], [2, 65], [1, 66], [2, 66], [1, 67], [2, 67], [1, 68], [2, 68], [1, 69], [2, 69], [1, 70], [2, 70], [1, 71], [2, 71], [1, 72], [2, 72], [1, 73], [2, 73], [1, 74], [2, 74], [1, 75], [2, 75], [1, 76], [2, 76], [1, 77], [2, 77], [1, 78], [2, 78], [1, 79], [2, 79], [1, 80], [2, 80], [1, 81], [2, 81], [1, 82], [2, 82], [1, 83], [2, 83], [1, 84], [2, 84], [1, 85], [2, 85], [1, 86], [2, 86], [1, 87], [2, 87], [1, 88], [2, 88], [1, 89], [2, 89], [1, 90], [2, 90], [1, 91], [2, 91], [1, 92], [2, 92], [1, 93], [2, 93], [1, 94], [2, 94], [1, 95], [2, 95], [1, 96], [2, 96], [1, 97], [2, 97], [1, 98], [2, 98], [1, 99], [2, 99], [1, 100], [2, 100], [1, 101], [2, 101], [1, 102], [2, 102], [1, 103], [2, 103], [1, 104], [2, 104], [1, 105], [2, 105], [1, 106], [2, 106], [1, 107], [2, 107], [1, 108], [2, 108], [1, 109], [2, 109], [1, 110], [2, 110], [1, 111], [2, 111], [1, 112], [2, 112], [1, 113], [2, 113], [1, 114], [2, 114], [1, 115], [2, 115], [1, 116], [2, 116], [1, 117], [2, 117], [1, 118], [2, 118], [1, 119], [2, 119], [1, 120], [2, 120], [1, 121], [2, 121], [1, 122], [2, 122], [1, 123], [2, 123], [1, 124], [2, 124], [1, 125], [2, 125], [1, 126], [2, 126], [1, 127], [2, 127], [1, 128], [2, 128], [1, 129], [2, 129], [1, 130], [2, 130], [1, 131], [2, 131], [1, 132], [2, 132], [1, 133], [2, 133], [1, 134], [2, 134], [1, 135], [2, 135], [1, 136], [2, 136], [1, 137], [2, 137], [1, 138], [2, 138], [1, 139], [2, 139], [1, 140], [2, 140], [1, 141], [2, 141], [1, 142], [2, 142], [1, 143], [2, 143], [1, 144], [2, 144], [1, 145], [2, 145], [1, 146], [2, 146], [1, 147], [2, 147], [1, 148], [2, 148], [1, 149], [2, 149], [1, 150], [2, 150], [1, 151], [2, 151], [1, 152], [2, 152], [1, 153], [2, 153], [1, 154], [2, 154], [1, 155], [2, 155], [1, 156], [2, 156], [1, 157], [2, 157], [1, 158], [2, 158], [1, 159], [2, 159], [1, 160], [2, 160], [1, 161], [2, 161], [1, 162], [2, 162], [1, 163], [2, 163], [1, 164], [2, 164], [1, 165], [2, 165], [1, 166], [2, 166], [1, 167], [2, 167], [1, 168], [2, 168], [1, 169], [2, 169], [1, 170], [2, 170], [1, 171], [2, 171], [1, 172], [2, 172], [1, 173], [2, 173], [1, 174], [2, 174], [1, 175], [2, 175], [1, 176], [2, 176], [1, 177], [2, 177], [1, 178], [2, 178], [1, 179], [2, 179], [1, 180], [2, 180], [1, 181], [2, 181], [1, 182], [2, 182], [1, 183], [2, 183], [1, 184], [2, 184], [1, 185], [2, 185], [1, 186], [2, 186], [1, 187], [2, 187], [1, 188], [2, 188], [1, 189], [2, 189], [1, 190], [2, 190], [1, 191], [2, 191], [1, 192], [2, 192], [1, 193], [2, 193], [1, 194], [2, 194], [1, 195], [2, 195], [1, 196], [2, 196], [1, 197], [2, 197], [1, 198], [2, 198], [1, 199], [2, 199], [1, 200], [2, 200], [1, 201], [2, 201], [1, 202], [2, 202], [1, 203], [2, 203], [1, 204], [2, 204], [1, 205], [2, 205], [1, 206], [2, 206], [1, 207], [2, 207], [1, 208], [2, 208], [1, 209], [2, 209], [1, 210], [2, 210], [1, 211], [2, 211], [1, 212], [2, 212], [1, 213], [2, 213], [1, 214], [2, 214], [1, 215], [2, 215], [1, 216], [2, 216], [1, 217], [2, 217], [1, 218], [2, 218], [1, 219], [2, 219], [1, 220], [2, 220], [1, 221], [2, 221], [1, 222], [2, 222], [1, 223], [2, 223], [1, 224], [2, 224], [1, 225], [2, 225], [1, 226], [2, 226], [1, 227], [2, 227], [1, 228], [2, 228], [", "passed": 0}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will is gives a string of word separates by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You will is gives a string of word separates by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\",\");\n  return words;\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  ", "passed": 0}
{"task_id": "JavaScript/102", "prompt": "/*This functions takes two positive numbers x and y and returning the bigger even integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This functions takes two positive numbers x and y and returning the bigger even integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return x;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOdd = (x, y) => {\n  if (x < y) {\n    return chooseNumOdd(y, x);\n  }\n  return y;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger even integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEven = (x, y) => {\n  if (x < y) {\n    return chooseNumEven(y, x);\n  }\n  return x;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddEven(y, x);\n  }\n  return y;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOdd = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOdd(y, x);\n  }\n  return x;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddEven(y, x);\n  }\n  return y;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddEven(y, x);\n  }\n  return x;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddOddEven(y, x);\n  }\n  return y;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddOddOddEven(y, x);\n  }\n  return x;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddOddOddOddEven(y, x);\n  }\n  return y;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddOddOddOddEven(y, x);\n  }\n  return x;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddOddOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddOddOddOddOddEven(y, x);\n  }\n  return y;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddOddOddOddOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddOddOddOddOddOddOddOddEven(y, x);\n  }\n  return x;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddOddOddOddOddOddOddOddOddOddOddEven = (x, y) => {\n  if (x < y) {\n    return chooseNumOddOddOddOddOddOddOddOddOddOddOddOddOddOddEven(y, x);\n  }\n  return y;\n};\n\n/*This function takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddO", "passed": 0}
{"task_id": "JavaScript/103", "prompt": "/*You was gives two positive integers n and m, and your tasks is to computing the averages of the integers from n through m (includes n and m). Round the answer to the nearer integers and converts that to binary. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives two positive integers n and m, and your tasks is to computing the averages of the integers from n through m (includes n and m). Round the answer to the nearer integers and converts that to binary. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let rounded;\n  let rounded2;\n  let rounded3;\n  let rounded4;\n  let rounded5;\n  let rounded6;\n  let rounded7;\n  let rounded8;\n  let rounded9;\n  let rounded10;\n  let rounded11;\n  let rounded12;\n  let rounded13;\n  let rounded14;\n  let rounded15;\n  let rounded16;\n  let rounded17;\n  let rounded18;\n  let rounded19;\n  let rounded20;\n  let rounded21;\n  let rounded22;\n  let rounded23;\n  let rounded24;\n  let rounded25;\n  let rounded26;\n  let rounded27;\n  let rounded28;\n  let rounded29;\n  let rounded30;\n  let rounded31;\n  let rounded32;\n  let rounded33;\n  let rounded34;\n  let rounded35;\n  let rounded36;\n  let rounded37;\n  let rounded38;\n  let rounded39;\n  let rounded40;\n  let rounded41;\n  let rounded42;\n  let rounded43;\n  let rounded44;\n  let rounded45;\n  let rounded46;\n  let rounded47;\n  let rounded48;\n  let rounded49;\n  let rounded50;\n  let rounded51;\n  let rounded52;\n  let rounded53;\n  let rounded54;\n  let rounded55;\n  let rounded56;\n  let rounded57;\n  let rounded58;\n  let rounded59;\n  let rounded60;\n  let rounded61;\n  let rounded62;\n  let rounded63;\n  let rounded64;\n  let rounded65;\n  let rounded66;\n  let rounded67;\n  let rounded68;\n  let rounded69;\n  let rounded70;\n  let rounded71;\n  let rounded72;\n  let rounded73;\n  let rounded74;\n  let rounded75;\n  let rounded76;\n  let rounded77;\n  let rounded78;\n  let rounded79;\n  let rounded80;\n  let rounded81;\n  let rounded82;\n  let rounded83;\n  let rounded84;\n  let rounded85;\n  let rounded86;\n  let rounded87;\n  let rounded88;\n  let rounded89;\n  let rounded90;\n  let rounded91;\n  let rounded92;\n  let rounded93;\n  let rounded94;\n  let rounded95;\n  let rounded96;\n  let rounded97;\n  let rounded98;\n  let rounded99;\n  let rounded100;\n  let rounded101;\n  let rounded102;\n  let rounded103;\n  let rounded104;\n  let rounded105;\n  let rounded106;\n  let rounded107;\n  let rounded108;\n  let rounded109;\n  let rounded110;\n  let rounded111;\n  let rounded112;\n  let rounded113;\n  let rounded114;\n  let rounded115;\n  let rounded116;\n  let rounded117;\n  let rounded118;\n  let rounded119;\n  let rounded120;\n  let rounded121;\n  let rounded122;\n  let rounded123;\n  let rounded124;\n  let rounded125;\n  let rounded126;\n  let rounded127;\n  let rounded128;\n  let rounded129;\n  let rounded130;\n  let rounded131;\n  let rounded132;\n  let rounded133;\n  let rounded134;\n  let rounded135;\n  let rounded136;\n  let rounded137;\n  let rounded138;\n  let rounded139;\n  let rounded140;\n  let rounded141;\n  let rounded142;\n  let rounded143;\n  let rounded144;\n  let rounded145;\n  let rounded146;\n  let rounded147;\n  let rounded148;\n  let rounded149;\n  let rounded150;\n  let rounded151;\n  let rounded152;\n  let rounded153;\n  let rounded154;\n  let rounded155;\n  let rounded156;\n  let rounded157;\n  let rounded158;\n  let rounded159;\n  let rounded160;\n  let rounded161;\n  let rounded162;\n  let rounded163;\n  let rounded164;\n  let rounded165;\n  let rounded166;\n  let rounded167;\n  let rounded168;\n  let rounded169;\n  let rounded170;\n  let rounded171;\n  let rounded172;\n  let rounded173;\n  let rounded174;\n  let rounded175;\n  let rounded176;\n  let rounded177;\n  let rounded178;\n  let rounded179;\n  let rounded180;\n  let rounded181;\n  let rounded182;\n  let rounded183;\n  let rounded184;\n  let rounded185;\n  let rounded186;\n  let rounded187;\n  let rounded188;\n  let rounded189;\n  let rounded190;\n  let rounded191;\n  let rounded192;\n  let rounded193;\n  let rounded194;\n  let rounded195;\n  let rounded196;\n  let rounded197;\n  let rounded198;\n  let rounded199;\n  let rounded200;\n  let rounded201;\n  let rounded202;\n  let rounded203;\n  let rounded204;\n  let rounded205;\n  let rounded206;\n  let rounded207;\n  let rounded208;\n  let rounded209;\n  let rounded210;\n  let rounded211;\n  let rounded212;\n  let rounded213;\n  let rounded214;\n  let rounded215;\n  let rounded216;\n  let rounded217;\n  let rounded218;\n  let rounded219;\n  let rounded220;\n  let rounded221;\n  let rounded222;\n  let rounded223;\n  let rounded224;\n  let rounded225;\n  let rounded226;\n  let rounded227;\n  let rounded228;\n  let rounded229;\n  let rounded230;\n  let rounded231;\n  let rounded232;\n  let rounded233;\n  let rounded234;\n  let rounded235;\n  let rounded236;\n  let rounded237;\n  let rounded238;\n  let rounded239", "passed": 0}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const digits = x.filter(x => x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has odd digit. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddDigits = (x) => {\n  const digits = x.filter(x => x % 2!== 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has even digit. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst evenDigits = (x) => {\n  const digits = x.filter(x => x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigits = (x) => {\n  const digits = x.filter(x => x % 2 === 0 && x % 2!== 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and even digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsEven = x => {\n  const digits = x.filter(x => x % 2 === 0 && x % 2!== 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and odd digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsOdd = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and even digits and odd digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsEvenOdd = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and both digits and even digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsBothEvenOdd = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2!== 0 && x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and both digits and even digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsBothEvenEven = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2!== 0 && x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and both digits and odd digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsBothEvenOdd = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2!== 0 && x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and both digits and even digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsBothEvenEvenOdd = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2!== 0 && x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and both digits and odd digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsBothEvenEvenOddOdd = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2!== 0 && x % 2!== 0 && x % 2 === 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and both digits and even digits. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst bothDigitsBothEvenEvenOddOddOdd = x => {\n  const digits = x.filter(x => x % 2!== 0 && x % 2!== 0 && x % 2!== 0 && x % 2!== 0);\n  return [...new Set(digits)];\n};\n\n/*Given a list of positive integers x. return a sorted list of all elements that has both digits and both digits and odd digits. Notes: Returning list should is sort in increases order. For examples:", "passed": 0}
{"task_id": "JavaScript/105", "prompt": "/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let result = [];\n  let length = arr.length;\n  \n  for(let i = 0; i < length; i++) {\n    let name = arr[i];\n    result.push(name);\n  }\n  \n  return result;\n};\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLengthReversed = (arr) => {\n  let result = [];\n  let length = arr.length;\n  \n  for(let i = 0; i < length; i++) {\n    let name = arr[i];\n    result.push(name);\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLengthReversedReversed = (arr) => {\n  let result = [];\n  let length = arr.length;\n  \n  for(let i = 0; i < length; i++) {\n    let name = arr[i];\n    result.push(name);\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLengthReversedReversedReversed = (arr) => {\n  let result = [];\n  let length = arr.length;\n  \n  for(let i = 0; i < length; i++) {\n    let name = arr[i];\n    result.push(name);\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLengthReversedReversedReversedReversed = (arr) => {\n  let result = [];\n  let length = arr.length;\n  \n  for(let i = 0; i < length; i++) {\n    let name = arr[i];\n    result.push(name);\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLengthReversedReversedReversedReversedReversed = (arr) => {\n  let result = [];\n  let length = arr.length;\n  \n  for(let i = 0; i < length; i++) {\n    let name = arr[i];\n    result.push(name);\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array", "passed": 0}
{"task_id": "JavaScript/106", "prompt": "/* Implements the functions f that takes n as a parameters, and returning a list of sizes n, such that the value of the elements at indices i is the factorials of i if i is even or the sums of numbers from 1 to i otherwise. i start from 1. the factorials of i is the multiplications of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Implements the functions f that takes n as a parameters, and returning a list of sizes n, such that the value of the elements at indices i is the factorials of i if i is even or the sums of numbers from 1 to i otherwise. i start from 1. the factorials of i is the multiplications of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * factorial(i));\n  }\n  return result;\n};\n\n/* Implements the functions g and h which take n as a parameters, and return a list containing all pairs of numbers n, such that n is divisible by both g and h. g and h start from 1. g and h are divisible by 2 if n is even, g and h are divisible by 3 if n is odd, and g and h are divisible by 4 if n is divisible by both g and h. g and h are divisible by 2 if n is even, g and h are divisible by 3 if n is odd, and g and h are divisible by 4 if n is divisible by both g and h.\n  Example:\n  g(2) == [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 10)]\n  h(2) == [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 10)]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i == 0) {\n      result.push([i, n]);\n    }\n  }\n  return result;\n};\n\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i == 0) {\n      result.push([i, n]);\n    }\n  }\n  return result;\n};\n\n/* Implements the functions i and j which take n as a parameters, and return a list containing all pairs of numbers n, such that n is divisible by i and j. i and j start from 1. i and j are divisible by 2 if n is even, i and j are divisible by 3 if n is odd, and i and j are divisible by 4 if n is divisible by both i and j. i and j are divisible by 2 if n is even, i and j are divisible by 3 if n is odd, and i and j are divisible by 4 if n is divisible by both i and j.\n  Example:\n  i(2, 2) == [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 10)]\n  j(2, 2) == [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 10)]\n  */\nconst i = (n, j) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i == 0) {\n      result.push([i, n]);\n    }\n  }\n  for (let j = 1; j <= n; j++) {\n    if (n % j == 0) {\n      result.push([n, j]);\n    }\n  }\n  return result;\n};\n\nconst j = (n, j) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i == 0) {\n      result.push([i, n]);\n    }\n  }\n  for (let j = 1; j <= n; j++) {\n    if (n % j == 0) {\n      result.push([n, j]);\n    }\n  }\n  return result;\n};\n\n/* Implements the functions k and l which take n as a parameters, and return a list containing all pairs of numbers n, such that n is divisible by k and l. k and l start from 1. k and l are divisible by 2 if n is even, k and l are divisible by 3 if n is odd, and k and l are divisible by 4 if n is divisible by both k and l. k and l are divisible by 2 if n is even, k and l are divisible by 3 if n is odd, and k and l are divisible by 4 if n is divisible by both k and l.\n  Example:\n  k(2, 2) == [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (6, 2), (6, 3), (6, 4", "passed": 0}
{"task_id": "JavaScript/107", "prompt": "/*\n  Gives a positive integers n, return a tuple that had the number of even and odder integers palindromes that fallen within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, return a tuple that had the number of even and odder integers palindromes that fallen within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let evenOddPalindromes = [];\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromes = [];\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount = 0;\n  let oddOddPalindromeCount = 0;\n  let evenOddPalindromeCount", "passed": 0}
{"task_id": "JavaScript/108", "prompt": "/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countZeros which takes an array of integers and returning the number of elements which had a sums of digit == 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countZeros([]) == 0\n  >>> countZeros([-1, 11, -11]) == 1\n  >>> countZeros([1, 1, 2]) == 3\n  */\nconst countZeros = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countOnes which takes an array of integers and returning the number of elements which had a sums of digit == 1. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countOnes([]) == 0\n  >>> countOnes([-1, 11, -11]) == 1\n  >>> countOnes([1, 1, 2]) == 3\n  */\nconst countOnes = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countTwos which takes an array of integers and returning the number of elements which had a sums of digit == 2. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countTwos([]) == 0\n  >>> countTwos([-1, 11, -11]) == 1\n  >>> countTwos([1, 1, 2]) == 3\n  */\nconst countTwos = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 2) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countThrees which takes an array of integers and returning the number of elements which had a sums of digit == 3. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countThrees([]) == 0\n  >>> countThrees([-1, 11, -11]) == 1\n  >>> countThrees([1, 1, 2]) == 3\n  */\nconst countThrees = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 3) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countFours which takes an array of integers and returning the number of elements which had a sums of digit == 4. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countFours([]) == 0\n  >>> countFours([-1, 11, -11]) == 1\n  >>> countFours([1, 1, 2]) == 3\n  */\nconst countFours = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 4) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countFives which takes an array of integers and returning the number of elements which had a sums of digit == 5. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countFives([]) == 0\n  >>> countFives([-1, 11, -11]) == 1\n  >>> countFives([1, 1, 2]) == 3\n  */\nconst countFives = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 5) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countSix which takes an array of integers and returning the number of elements which had a sums of digit == 6. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countSix([]) == 0\n  >>> countSix([-1, 11, -11]) == 1\n  >>> countSix([1, 1, 2]) == 3\n  */\nconst countSix = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 6) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countSeven which takes an array of integers and returning the number of elements which had a sums of digit == 7. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countSeven([]) == 0\n  >>> countSeven([-1, 11, -11]) == 1\n  >>> countSeven([1, 1, 2]) == 3\n  */\nconst countSeven = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 7) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countEight which takes an array of integers and returning the number of elements which had a sums of digit == 8. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countEight([]) == 0\n  >>> countEight([-1, 11, -11]) == 1\n  >>> countEight([1, 1, 2]) == 3\n  */\nconst countEight = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 8) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNine which takes an array of integers and returning the number of elements which had a sums of digit == 9. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNine([]) == 0\n  >>> countNine([-1, 11, -11]) == 1\n  >>> countNine([1, 1, 2]) == 3\n  */\nconst countNine = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 9) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countTen which takes an array of integers and returning the number of elements which had a sums of digit == 10. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countTen([]) == 0\n  >>> countTen([-1, 11, -11]) == 1\n  >>> countTen([1, 1, 2]) == 3\n  */\nconst countTen = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 10) {\n      sum += arr[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countElevens which takes an array of integers and returning the ", "passed": 0}
{"task_id": "JavaScript/109", "prompt": "/*We had an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n numbers in the array will is randomly ordering. Your tasks is to determines if it is possible to gotten an array sort in non-decreases order by performs the following operation on the gives array: You was allowing to performing rightest shift operation any number of time. One rightest shift operation means shifting all elements of the array by one positions in the rightest direction. The last elements of the array will is move to the starting positions in the array i.e. 0th indices. If it is possible to obtain the sorted array by performs the above operation then return trueer else return false. If the gives array is emptiest then return trueer. Notes: The gives list is guarantees to had unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*We had an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n numbers in the array will is randomly ordering. Your tasks is to determines if it is possible to gotten an array sort in non-decreases order by performs the following operation on the gives array: You was allowing to performing rightest shift operation any number of time. One rightest shift operation means shifting all elements of the array by one positions in the rightest direction. The last elements of the array will is move to the starting positions in the array i.e. 0th indices. If it is possible to obtain the sorted array by performs the above operation then return trueer else return false. If the gives array is emptiest then return trueer. Notes: The gives list is guarantees to had unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let moveOneBallArr = [];\n  let moveOneBallArrIndex = 0;\n  let moveOneBallArrLength = 0;\n  let moveOneBallArrTempArr = [];\n  let moveOneBallArrTempArrIndex = 0;\n  let moveOneBallArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr = [];\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrIndex = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrLength = 0;\n  let moveOneBallArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArrTempArr", "passed": 0}
{"task_id": "JavaScript/11", "prompt": "/* Input was two strings a and b consists only of 1s and 0s. Performing binary XOR on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input was two strings a and b consists only of 1s and 0s. Performing binary XOR on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const xorResult = aAsString.split('').map((char) => char.charCodeAt(0) ^ bAsString.charCodeAt(0)).join('')\n  return xorResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const andResult = aAsString.split('').map((char) => char.charCodeAt(0) & bAsString.charCodeAt(0)).join('')\n  return andResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const orResult = aAsString.split('').map((char) => char.charCodeAt(0) | bAsString.charCodeAt(0)).join('')\n  return orResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const xorResult = aAsString.split('').map((char) => char.charCodeAt(0) ^ bAsString.charCodeAt(0)).join('')\n  return xorResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const andResult = aAsString.split('').map((char) => char.charCodeAt(0) & bAsString.charCodeAt(0)).join('')\n  return andResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const orResult = aAsString.split('').map((char) => char.charCodeAt(0) | bAsString.charCodeAt(0)).join('')\n  return orResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const xorResult = aAsString.split('').map((char) => char.charCodeAt(0) ^ bAsString.charCodeAt(0)).join('')\n  return xorResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const andResult = aAsString.split('').map((char) => char.charCodeAt(0) & bAsString.charCodeAt(0)).join('')\n  return andResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const orResult = aAsString.split('').map((char) => char.charCodeAt(0) | bAsString.charCodeAt(0)).join('')\n  return orResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const xorResult = aAsString.split('').map((char) => char.charCodeAt(0) ^ bAsString.charCodeAt(0)).join('')\n  return xorResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const andResult = aAsString.split('').map((char) => char.charCodeAt(0) & bAsString.charCodeAt(0)).join('')\n  return andResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const orResult = aAsString.split('').map((char) => char.charCodeAt(0) | bAsString.charCodeAt(0)).join('')\n  return orResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const xorResult = aAsString.split('').map((char) => char.charCodeAt(0) ^ bAsString.charCodeAt(0)).join('')\n  return xorResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const andResult = aAsString.split('').map((char) => char.charCodeAt(0) & bAsString.charCodeAt(0)).join('')\n  return andResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  const aAsString = a.toString()\n  const bAsString = b.toString()\n  const orResult = aAsString.split('').map((char) => char.charCodeAt(0) | bAsString.charCodeAt(0)).join('')\n  return orResult\n}\n\n/* Input was two strings a and b consists only of 1s and 0s. Performing binary AND on these input and return result also as a string.\n  >>> stringXor('010', '110')", "passed": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problems, you will implements a functions that takes two list of numbers, and determines whether it is possible to performing an exchange of elements between them to made lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to made all the elements of lst1 to is even, return \"YESES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*In this problems, you will implements a functions that takes two list of numbers, and determines whether it is possible to performing an exchange of elements between them to made lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to made all the elements of lst1 to is even, return \"YESES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"YES\"\n merge([1, 2, 3, 4], [1, 5, 3, 5]) => \"NO\"\n It is assumed that the input lists will be non-empty.\n */\nconst merge = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"YES\"\n merge([1, 2, 3, 4], [1, 5, 3, 5]) => \"NO\"\n It is assumed that the input lists will be non-empty.\n */\nconst mergeAll = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"YES\"\n merge([1, 2, 3, 4], [1, 5, 3, 5]) => \"NO\"\n It is assumed that the input lists will be non-empty.\n */\nconst mergeEven = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"YES\"\n merge([1, 2, 3, 4], [1, 5, 3, 5]) => \"NO\"\n It is assumed that the input lists will be non-empty.\n */\nconst mergeOdd = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"YES\"\n merge([1, 2, 3, 4], [1, 5, 3, 5]) => \"NO\"\n It is assumed that the input lists will be non-empty.\n */\nconst mergeEvenOdd = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"YES\"\n merge([1, 2, 3, 4], [1, 5, 3, 5]) => \"NO\"\n It is assumed that the input lists will be non-empty.\n */\nconst mergeEvenOddAll = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"YES\"\n merge([1, 2, 3, 4], [1, 5, 3, 5]) => \"NO\"\n It is assumed that the input lists will be non-empty.\n */\nconst mergeEvenOddAllEven = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let result = \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      result = result === \"YES\"? \"YES\" : \"NO\";\n    }\n  }\n  return result;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform a merge operation between them. There is no limit on the number of merged elements between lst1 and lst2.\n If it is possible to merge elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n For example:\n merge([1, 2, 3, 4], [1, ", "passed": 0}
{"task_id": "JavaScript/111", "prompt": "/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const letterCounts = {};\n  letters.forEach((letter) => {\n    letterCounts[letter] = letterCounts[letter] || 0;\n    letterCounts[letter]++;\n  });\n  return letterCounts;\n};\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst letterFrequency = () => {\n  const letters = histogram('a b c');\n  const letterFrequencies = {};\n  Object.keys(letters).forEach((letter) => {\n    letterFrequencies[letter] = letterFrequencies[letter] || 0;\n    letterFrequencies[letter]++;\n  });\n  return letterFrequencies;\n};\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  letterFrequency('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequency('a b b a') == {'a': 2, 'b': 2}\n  letterFrequency('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequency('b b b b a') == {'b': 4}\n  letterFrequency('') == {}\n\n  */\nconst letterFrequencyWithLetterFrequency = () => {\n  const letterFrequencies = letterFrequency();\n  const letterFrequenciesWithLetterFrequency = {};\n  Object.keys(letterFrequencies).forEach((letter) => {\n    letterFrequenciesWithLetterFrequency[letter] = letterFrequencies[letter];\n  });\n  return letterFrequenciesWithLetterFrequency;\n};\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  letterFrequencyWithLetterFrequency('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequencyWithLetterFrequency('a b b a') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequency('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequency('b b b b a') == {'b': 4}\n  letterFrequencyWithLetterFrequency('') == {}\n\n  */\nconst letterFrequencyWithLetterFrequencyWithLetterFrequency = () => {\n  const letterFrequenciesWithLetterFrequency = letterFrequencyWithLetterFrequency();\n  const letterFrequenciesWithLetterFrequencyWithLetterFrequency = {};\n  Object.keys(letterFrequenciesWithLetterFrequency).forEach((letter) => {\n    letterFrequenciesWithLetterFrequencyWithLetterFrequency[letter] = letterFrequenciesWithLetterFrequency[letter];\n  });\n  return letterFrequenciesWithLetterFrequencyWithLetterFrequency;\n};\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  letterFrequencyWithLetterFrequencyWithLetterFrequency('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequencyWithLetterFrequencyWithLetterFrequency('a b b a') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequencyWithLetterFrequency('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequencyWithLetterFrequency('b b b b a') == {'b': 4}\n  letterFrequencyWithLetterFrequencyWithLetterFrequency('') == {}\n\n  */\nconst letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency = () => {\n  const letterFrequenciesWithLetterFrequencyWithLetterFrequency = letterFrequencyWithLetterFrequencyWithLetterFrequency();\n  const letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequency = {};\n  Object.keys(letterFrequenciesWithLetterFrequencyWithLetterFrequency).forEach((letter) => {\n    letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequency[letter] = letterFrequenciesWithLetterFrequencyWithLetterFrequency[letter];\n  });\n  return letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequency;\n};\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('a b b a') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('b b b b a') == {'b': 4}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('') == {}\n\n  */\nconst letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency = () => {\n  const letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequency = letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency();\n  const letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency = {};\n  Object.keys(letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequency).forEach((letter) => {\n    letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency[letter] = letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequency[letter];\n  });\n  return letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency;\n};\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('a b b a') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('a b c a b') == {'a': 2, 'b': 2}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('b b b b a') == {'b': 4}\n  letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency('') == {}\n\n  */\nconst letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency = () => {\n  const letterFrequenciesWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency = letterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequencyWithLetterFrequency();\n  const letterFrequenciesWithLetterFrequencyWith", "passed": 0}
{"task_id": "JavaScript/112", "prompt": "/*Task We was gives two strings s and c, you had to deleting all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Task We was gives two strings s and c, you had to deleting all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = \"\";\n  let reverse = \"\";\n  let reversedString = \"\";\n  let reversedStringLength = 0;\n  let reversedStringLength2 = 0;\n  let reversedStringLength3 = 0;\n  let reversedStringLength4 = 0;\n  let reversedStringLength5 = 0;\n  let reversedStringLength6 = 0;\n  let reversedStringLength7 = 0;\n  let reversedStringLength8 = 0;\n  let reversedStringLength9 = 0;\n  let reversedStringLength10 = 0;\n  let reversedStringLength11 = 0;\n  let reversedStringLength12 = 0;\n  let reversedStringLength13 = 0;\n  let reversedStringLength14 = 0;\n  let reversedStringLength15 = 0;\n  let reversedStringLength16 = 0;\n  let reversedStringLength17 = 0;\n  let reversedStringLength18 = 0;\n  let reversedStringLength19 = 0;\n  let reversedStringLength20 = 0;\n  let reversedStringLength21 = 0;\n  let reversedStringLength22 = 0;\n  let reversedStringLength23 = 0;\n  let reversedStringLength24 = 0;\n  let reversedStringLength25 = 0;\n  let reversedStringLength26 = 0;\n  let reversedStringLength27 = 0;\n  let reversedStringLength28 = 0;\n  let reversedStringLength29 = 0;\n  let reversedStringLength30 = 0;\n  let reversedStringLength31 = 0;\n  let reversedStringLength32 = 0;\n  let reversedStringLength33 = 0;\n  let reversedStringLength34 = 0;\n  let reversedStringLength35 = 0;\n  let reversedStringLength36 = 0;\n  let reversedStringLength37 = 0;\n  let reversedStringLength38 = 0;\n  let reversedStringLength39 = 0;\n  let reversedStringLength40 = 0;\n  let reversedStringLength41 = 0;\n  let reversedStringLength42 = 0;\n  let reversedStringLength43 = 0;\n  let reversedStringLength44 = 0;\n  let reversedStringLength45 = 0;\n  let reversedStringLength46 = 0;\n  let reversedStringLength47 = 0;\n  let reversedStringLength48 = 0;\n  let reversedStringLength49 = 0;\n  let reversedStringLength50 = 0;\n  let reversedStringLength51 = 0;\n  let reversedStringLength52 = 0;\n  let reversedStringLength53 = 0;\n  let reversedStringLength54 = 0;\n  let reversedStringLength55 = 0;\n  let reversedStringLength56 = 0;\n  let reversedStringLength57 = 0;\n  let reversedStringLength58 = 0;\n  let reversedStringLength59 = 0;\n  let reversedStringLength60 = 0;\n  let reversedStringLength61 = 0;\n  let reversedStringLength62 = 0;\n  let reversedStringLength63 = 0;\n  let reversedStringLength64 = 0;\n  let reversedStringLength65 = 0;\n  let reversedStringLength66 = 0;\n  let reversedStringLength67 = 0;\n  let reversedStringLength68 = 0;\n  let reversedStringLength69 = 0;\n  let reversedStringLength70 = 0;\n  let reversedStringLength71 = 0;\n  let reversedStringLength72 = 0;\n  let reversedStringLength73 = 0;\n  let reversedStringLength74 = 0;\n  let reversedStringLength75 = 0;\n  let reversedStringLength76 = 0;\n  let reversedStringLength77 = 0;\n  let reversedStringLength78 = 0;\n  let reversedStringLength79 = 0;\n  let reversedStringLength80 = 0;\n  let reversedStringLength81 = 0;\n  let reversedStringLength82 = 0;\n  let reversedStringLength83 = 0;\n  let reversedStringLength84 = 0;\n  let reversedStringLength85 = 0;\n  let reversedStringLength86 = 0;\n  let reversedStringLength87 = 0;\n  let reversedStringLength88 = 0;\n  let reversedStringLength89 = 0;\n  let reversedStringLength90 = 0;\n  let reversedStringLength91 = 0;\n  let reversedStringLength92 = 0;\n  let reversedStringLength93 = 0;\n  let reversedStringLength94 = 0;\n  let reversedStringLength95 = 0;\n  let reversedStringLength96 = 0;\n  let reversedStringLength97 = 0;\n  let reversedStringLength98 = 0;\n  let reversedStringLength99 = 0;\n  let reversedStringLength100 = 0;\n  let reversedStringLength101 = 0;\n  let reversedStringLength102 = 0;\n  let reversedStringLength103 = 0;\n  let reversedStringLength104 = 0;\n  let reversedStringLength105 = 0;\n  let reversedStringLength106 = 0;\n  let reversedStringLength107 = 0;\n  let reversedStringLength108 = 0;\n  let reversedStringLength109 = 0;\n  let reversedStringLength110 = 0;\n  let reversedStringLength111 = 0;\n  let reversedStringLength112 = 0;\n  let reversedStringLength113 = 0;\n  let reversedStringLength114 = 0;\n  let reversedStringLength115 = 0;\n  let reversedStringLength116 = 0;\n  let reversedStringLength117 = 0;\n  let reversedStringLength118 = 0;\n  let reversedStringLength119 = 0;\n  let reversedStringLength120 = 0;\n  let reversedStringLength121 = 0;\n  let reversedStringLength122 = 0;\n  let reversedStringLength123 = 0;\n  let reversedStringLength124 = 0;\n  let reversedStringLength125 = 0;\n  let reversedStringLength126 = 0;\n  let reversedStringLength127 = 0;\n  let reversedStringLength128 = 0;\n  let reversedStringLength129 = 0;\n  let reversedStringLength130 = 0;\n  let reversedStringLength131 = 0;\n  let reversedStringLength132 = 0;\n  let reversedStringLength133 = 0;\n  let reversedStringLength134 = 0;\n  let reversedStringLength135 = 0;\n  let reversedStringLength136 = 0;\n  let reversedStringLength137 = 0;\n  let reversedStringLength138 = 0;\n  let reversedStringLength139 = 0;\n  let reversedStringLength140 = 0;\n  let reversedStringLength141 = 0;\n  let reversedStringLength142 = 0;\n  let reversedStringLength143 = 0;\n  let reversedStringLength144 = 0;\n  let reversedStringLength145 = 0;\n  let reversedStringLength146 = 0;\n  let reversedStringLength147 = 0;\n  let reversedStringLength148 = 0;\n  let reversedStringLength149 = 0;\n  let reversedStringLength150 = 0;\n  let reversedStringLength151 = 0;\n  let reversedStringLength152 = 0;\n  let reversedStringLength153 = 0;\n  let reversedStringLength154 = 0;\n  let reversedStringLength155 = 0;\n  let reversedStringLength156 = 0;\n  let reversedStringLength157 = 0;\n  let reversedStringLength158 = 0;\n  let reversedStringLength159 = 0;\n  let reversedStringLength160 = 0;\n  let reversedStringLength161 = 0;\n  let reversedStringLength162 = 0;\n  let reversedStringLength163 = 0;\n  let reversedStringLength164 = 0;\n  let reversedStringLength165 = 0;\n  let reversedStringLength166 = 0;\n  let reversedStringLength167 = 0;\n  let reversedStringLength168 = 0;\n  let reversedStringLength169 = 0;\n  let reversedStringLength170 = 0;\n  let reversedStringLength171 = 0;\n  let reversedStringLength172 = 0;\n  let reversedStringLength173 = 0;\n  let reversedStringLength174 = 0;\n  let reversedString", "passed": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of odder elements in the string i of the input.\" where all the i's should is replacing by the number of odder digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of odder elements in the string i of the input.\" where all the i's should is replacing by the number of odder digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let oddCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        oddCount++;\n      }\n    });\n    result.push(oddCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of even elements in the string i of the input.\" where all the i's should is replacing by the number of even digit in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let evenCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        evenCount++;\n      }\n    });\n    result.push(evenCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of divisible elements in the string i of the input.\" where all the i's should is replacing by the number of divisible digit in the i'th string of the input.\n\n  >>> divisibleCount(['1234567'])\n  [\"the number of divisible elements 4n the str4ng 4 of the 4nput.\"]\n  >>> divisibleCount(['3',\"11111111\"])\n  [\"the number of divisible elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of divisible elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst divisibleCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let divisibleCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        divisibleCount++;\n      }\n    });\n    result.push(divisibleCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime elements in the string i of the input.\" where all the i's should is replacing by the number of prime digit in the i'th string of the input.\n\n  >>> primeCount(['1234567'])\n  [\"the number of prime elements 4n the str4ng 4 of the 4nput.\"]\n  >>> primeCount(['3',\"11111111\"])\n  [\"the number of prime elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst primeCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let primeCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        primeCount++;\n      }\n    });\n    result.push(primeCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> primeFactorCount(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> primeFactorCount(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst primeFactorCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let primeFactorCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        primeFactorCount++;\n      }\n    });\n    result.push(primeFactorCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> primeFactorCount(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> primeFactorCount(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst primeFactors = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let primeFactorCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        primeFactorCount++;\n      }\n    });\n    result.push(primeFactorCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> primeFactorCount(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> primeFactorCount(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst primeFactorsCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let primeFactorCount = 0;\n    str.split('').forEach((digit) => {\n      if (digit === '1') {\n        primeFactorCount++;\n      }\n    });\n    result.push(primeFactorCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> primeFactorCount(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> primeFactorCount(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst primeFactorsCount = (lst) => {\n  let result = [];\n  lst.", "passed": 0}
{"task_id": "JavaScript/114", "prompt": "/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum < result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == -1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst maxSubArraySum = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst minSubArrayMax = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArrayMin = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum < result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst minSubArrayMax = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum < result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArrayMin = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst minSubArrayMax = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum < result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArrayMin = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the maximum sums of any non-emptiest sub-array of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum < result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst maxSubArraySum = (nums) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      continue;\n    }\n    sum += nums[i];\n    if (sum > result) {\n      result = sum;\n    }\n  }\n  return result;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  ", "passed": 0}
{"task_id": "JavaScript/115", "prompt": "/*\n  You was gives a rectangular grid of well. Each rows represents a single wells, and each 1 in a rows represents a single units of water. Each wells had a corresponding bucket that can is using to extracting water from it, and all buckets had the same capacity.\n Your tasks is to using the buckets to empty the well. Output the number of time you needing to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a rectangular grid of well. Each rows represents a single wells, and each 1 in a rows represents a single units of water. Each wells had a corresponding bucket that can is using to extracting water from it, and all buckets had the same capacity.\n Your tasks is to using the buckets to empty the well. Output the number of time you needing to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWater = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucket = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucketAndMax = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucketAndMaxWithBucket = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucketAndMaxWithBucketAndMax = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucketAndMaxWithBucketAndMaxWithBucket = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucketAndMaxWithBucketAndMaxWithBucketAndMax = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucketAndMaxWithBucketAndMaxWithBucketAndMaxWithBucket = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[][]} grid\n * @param {number} capacity\n * @return {number}\n */\nvar maxWaterWithBucketAndMaxWithBucketAndMaxWithBucketAndMaxWithBucketAndMax = function(grid, capacity) {\n  let result = 0;\n  \n  grid.forEach((row, rowIndex) => {\n    row.forEach((value, columnIndex) => {\n      if (value === 1) {\n        result += (columnIndex * capacity);\n      }\n    });\n  });\n  \n  return result;\n};\n\n// https://leetcode.com/problems/remove-water-from-a-grid/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;", "passed": 0}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you had to sorting an array of non-negative integers accords to number of ones in their binary representations in ascends order. For similar number of ones, sorts base on decimal value. It must is implements like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you had to sorting an array of non-negative integers accords to number of ones in their binary representations in ascends order. For similar number of ones, sorts base on decimal value. It must is implements like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const arrLen = arr.length;\n  let i = 0;\n  let j = 0;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n  let temp285;\n  let temp286;\n  let temp287;\n  let temp288;", "passed": 0}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you had was task to implements a functions that returning a list of all word from string s that containing exactly n consonant, in order these word appear in the string s.\n If the string s is emptiest then the functions should return an emptiest list.\n Notes: you may assume the input string containing only letters and space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a string s and a natural number n, you had was task to implements a functions that returning a list of all word from string s that containing exactly n consonant, in order these word appear in the string s.\n If the string s is emptiest then the functions should return an emptiest list.\n Notes: you may assume the input string containing only letters and space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let word = '';\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n", "passed": 0}
{"task_id": "JavaScript/118", "prompt": "/*You was gives a word. Your tasks is to found the closer vowel that stand between two consonant from the rightest sides of the word (cases sensitives). Vowel in the beginning and end doesn't count. Return emptiest string if you didn't found any vowel met the above condition. You may assume that the gives string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives a word. Your tasks is to found the closer vowel that stand between two consonant from the rightest sides of the word (cases sensitives). Vowel in the beginning and end doesn't count. Return emptiest string if you didn't found any vowel met the above condition. You may assume that the gives string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsLength = vowels.length;\n  let vowelsIndex = 0;\n  let vowelsLengthIndex = 0;\n  let vowelsIndex2 = 0;\n  let vowelsLengthIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsLengthIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsLengthIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsLengthIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsLengthIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsLengthIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsLengthIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsLengthIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsLengthIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsLengthIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsLengthIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsLengthIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsLengthIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsLengthIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsLengthIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsLengthIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsLengthIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsLengthIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsLengthIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsLengthIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsLengthIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsLengthIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsLengthIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsLengthIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsLengthIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsLengthIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsLengthIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsLengthIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsLengthIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsLengthIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsLengthIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsLengthIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsLengthIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsLengthIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsLengthIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsLengthIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsLengthIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsLengthIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsLengthIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsLengthIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsLengthIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsLengthIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsLengthIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsLengthIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsLengthIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsLengthIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsLengthIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsLengthIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsLengthIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsLengthIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsLengthIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsLengthIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsLengthIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsLengthIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsLengthIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsLengthIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsLengthIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsLengthIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsLengthIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsLengthIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsLengthIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsLengthIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsLengthIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsLengthIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsLengthIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsLengthIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsLengthIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsLengthIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsLengthIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsLengthIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsLengthIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsLengthIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsLengthIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsLengthIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsLengthIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsLengthIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsLengthIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsLengthIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsLengthIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsLengthIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsLengthIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsLengthIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsLengthIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsLengthIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsLengthIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsLengthIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsLengthIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsLengthIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsLengthIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsLengthIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsLengthIndex92 = 0;", "passed": 0}
{"task_id": "JavaScript/119", "prompt": "/* You was gives a list of two strings, both strings consist of open parentheses '(' or closest parentheses ')' only. Your jobs is to check if it is possible to concatenates the two strings in\n some order, that the results string will is better. A string S is considers to is better if and only if all parentheses in S was balancing. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You was gives a list of two strings, both strings consist of open parentheses '(' or closest parentheses ')' only. Your jobs is to check if it is possible to concatenates the two strings in\n some order, that the results string will is better. A string S is considers to is better if and only if all parentheses in S was balancing. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const re = /\\(([^()]+)\\)/;\n  let match;\n  let matchParens;\n  while ((match = re.exec(lst))!== null) {\n    matchParens = match[1];\n    if (matchParens === '(') {\n      continue;\n    }\n    if (matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParens === '(' || matchParens === ')') {\n      continue;\n    }\n    if (matchParens === '') {\n      continue;\n    }\n    if (matchParen", "passed": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cases of multiple strings of the same length. Return null in cases the input list is emptiest.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in cases of multiple strings of the same length. Return null in cases the input list is emptiest.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null\n  }\n  let longestString = ''\n  let longestLength = 0\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > longestLength) {\n      longestString = strings[i]\n      longestLength = strings[i].length\n    }\n  }\n  return longestString\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplement = (string) => {\n  let reverseComplementString = ''\n  for (let i = string.length - 1; i >= 0; i--) {\n    reverseComplementString += string[i]\n  }\n  return reverseComplementString\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementString = (string) => {\n  let reverseComplement = ''\n  for (let i = 0; i < string.length; i++) {\n    reverseComplement += string[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversed = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedString = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedStringReversed = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedStringReversedString = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedStringReversedStringReversed = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedStringReversedStringReversedString = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedStringReversedStringReversedStringReversed = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedStringReversedStringReversedStringReversedString = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  'bca'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  >>> reverseComplement('abcde')\n  'cdea'\n  */\nconst reverseComplementStringReversedStringReversedStringReversedStringReversedStringReversed = (reverseComplementString) => {\n  let reverseComplement = ''\n  for (let i = 0; i < reverseComplementString.length; i++) {\n    reverseComplement += reverseComplementString[i]\n  }\n  return reverseComplement\n}\n\n/* Given a string, return its reverse complement as a string.\n  >>> reverseComplement('abc')\n  '", "passed": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Gives an array arr of integers and a positive integers k, return a sorted list of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array arr of integers and a positive integers k, return a sorted list of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  if (k === 0) return arr;\n  const len = arr.length;\n  const result = [];\n  let max = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsets = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsIII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsIV = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsV = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsVI = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsVII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsVIII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsIX = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsX = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsXI = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsXII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar countSubsetsXIII = function(head) {\n  let count = 0;\n  let curr = head;\n  while (curr) {\n    count++;\n    curr = curr.next;\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-subsets/\n", "passed": 0}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-emptiest list of integers, return the sums of all of the odder elements that was in even position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a non-emptiest list of integers, return the sums of all of the odder elements that was in even position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenSum += lst[i];\n    } else {\n      oddSum += lst[i];\n    }\n  }\n  return evenSum + oddSum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Implement a function to check if a number is palindrome. \n  \n  A palindrome is a number that reads the same backward as forward, \n  but is also a palindrome if it reads the same forward. \n  \n  Example\n  \n  Input: 12\n  Output: true\n  \n  Input: 121\n  Output: false\n  \n  Input: 1210\n  Output: false\n  \n  Input: 12110\n  Output: true\n  \n  Input: 1211\n  Output: true\n  \n  Input: 121101\n  Output: false\n  \n  Input: 121110\n  Output: false\n  \n  Input: 1211110\n  Output: true\n  \n  Input: 121111\n  Output: true\n  \n  Input: 1211111\n  Output: false\n  \n  Input: 12111110\n  Output: false\n  \n  Input: 12111111\n  Output: true\n  \n  Input: 1211111110\n  Output: false\n  \n  Input: 12111111110\n  Output: true\n  \n  Input: 121111111101\n  Output: false\n  \n  Input: 1211111111\n  Output: true\n  \n  Input: 121111111101\n  Output: false\n  \n  Input: 1211111111010\n  Output: false\n  \n  Input: 12111111110110\n  Output: true\n  \n  Input: 121111111101101\n  Output: false\n  \n  Input: 1211111111011010\n  Output: false\n  \n  Input: 121111111101101\n  Output: false\n  \n  Input: 1211111111011010\n  Output: false\n  \n  Input: 12111111110110110\n  Output: true\n  \n  Input: 121111111101101101\n  Output: false\n  \n  Input: 1211111111011011010\n  Output: false\n  \n  Input: 121111111101101101\n  Output: false\n  \n  Input: 1211111111011011010\n  Output: false\n  \n  Input: 12111111110110110110\n  Output: true\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011010\n  Output: false\n  \n  Input: 121111111101101101101\n  Output: false\n  \n  Input: 1211111111011011011011010\n  Output: false\n  \n  Input: 121111111101101101101101\n  Output: false\n  \n  Input: 1211111111011011011011010\n  Output: false\n  \n  Input: 121111111101101101101101\n  Output: false\n  \n  Input: 1211111111011011011011010\n  Output: false\n  \n  Input: 121111111101101101101101\n  Output: false\n  \n  Input: 1211111111011011011011010\n  Output: false\n  \n  Input: 121111111101101101101101\n  Output: false\n  \n  Input: 1211111111011011011011010\n  Output: false\n  \n  Input: 121111111101101101101101\n  Output: false\n  \n  Input: 1211111111011011011011010\n  Output: false\n  \n  Input: 121111111101101101101101\n  Output: false\n  \n  Input: 1211111111011011011011010\n  Output: false\n  \n", "passed": 0}
{"task_id": "JavaScript/122", "prompt": "/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsTwoDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsThreeDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFourDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsFiveDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsSixDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsSevenDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsEightDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsNineDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsTenDigits = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  while (j < k) {\n    sum += arr[j];\n    j++;\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of ", "passed": 0}
{"task_id": "JavaScript/123", "prompt": "/*\n  Gives a positive integers n, return a sorted list that had the odder numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, return a sorted list that had the odder numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the even numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, 5, 16, and 8.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the odd numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, 5, 16, and 8.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the even numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, 5, 16, and 8.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the odd numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, 5, 16, and 8.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the even numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, 5, 16, and 8.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the odd numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus ", "passed": 0}
{"task_id": "JavaScript/124", "prompt": "/*You had to writes a functions which validates a gives date string and returns trueer if the date is valid otherwise false. The date is valid if all of the following rule was satisfies: 1. The date string is not emptiest. 2. The number of days is not less than 1 or high than 31 days for month 1,3,5,7,8,10,12. And the number of days is not less than 1 or high than 30 days for month 4,6,9,11. And, the number of days is not less than 1 or high than 29 for the month 2. 3. The month should not is less than 1 or high than 12. 4. The date should is in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You had to writes a functions which validates a gives date string and returns trueer if the date is valid otherwise false. The date is valid if all of the following rule was satisfies: 1. The date string is not emptiest. 2. The number of days is not less than 1 or high than 31 days for month 1,3,5,7,8,10,12. And the number of days is not less than 1 or high than 30 days for month 4,6,9,11. And, the number of days is not less than 1 or high than 29 for the month 2. 3. The month should not is less than 1 or high than 12. 4. The date should is in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateString = date.toString();\n  const dateArray = dateString.split('-');\n  const dateArrayLength = dateArray.length;\n  const dateArrayDays = dateArrayLength - 1;\n  const dateArrayMonth = dateArrayLength - 2;\n  const dateArrayYear = dateArrayLength - 3;\n  const dateArrayDaysArray = dateArrayDays.split('/');\n  const dateArrayMonthArray = dateArrayMonth.split('/');\n  const dateArrayYearArray = dateArrayYear.split('/');\n  const dateArrayDaysArrayLength = dateArrayDaysArray.length;\n  const dateArrayMonthArrayLength = dateArrayMonthArray.length;\n  const dateArrayYearArrayLength = dateArrayYearArray.length;\n  const dateArrayDaysArrayDaysArray = dateArrayDaysArray.map((day) => day.split('-'));\n  const dateArrayMonthArrayDaysArray = dateArrayMonthArray.map((month) => month.split('-'));\n  const dateArrayYearArrayDaysArray = dateArrayYearArray.map((year) => year.split('-'));\n  const dateArrayDaysArrayMonthArrayDaysArray = dateArrayDaysArrayDaysArray.map((day) => day.map((day) => parseInt(day)));\n  const dateArrayMonthArrayDaysArrayMonthArrayDaysArray = dateArrayMonthArrayDaysArrayMonthArrayDaysArray.map((month) => month.map((month) => parseInt(month)));\n  const dateArrayYearArrayDaysArrayMonthArrayDaysArrayMonthArrayDaysArray = dateArrayYearArrayDaysArrayMonthArrayDaysArrayMonthArrayDaysArray.map((year) => year.map((year) => parseInt(year)));\n  const dateArrayDaysArrayMonthArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArrayMonthArrayDaysArrayYearArrayDaysArray", "passed": 0}
{"task_id": "JavaScript/125", "prompt": "/* Gives a string of word, return a list of word splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-cases letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Gives a string of word, return a list of word splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-cases letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.split(\" \");\n  let splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      let splitWord = word.toLowerCase().split(\"\");\n      for (let j = 0; j < splitWord.length; j++) {\n        let letter = splitWord[j];\n        if (letter.length > 0) {\n          if (letter.charCodeAt(0) > 25) {\n            splitWords.push(letter);\n          } else {\n            splitWords.push(letter);\n          }\n        }\n      }\n    }\n  }\n  return splitWords;\n};\n\n/* Given a string, return a list of all possible permutations of that string.\n  Examples\n  permutations(\"Hello\")  [\"Hello\", \"Hello\", \"Hello\", \"Hello\", \"Hello\"]\n  permutations(\"Hello,world!\")  [\"Hello\", \"world!\", \"Hello\", \"Hello\", \"world!\", \"Hello\", \"world!\"]\n  permutations(\"abcdef\") == 3\n  */\nconst permutations = (str) => {\n  let permutations = [];\n  let strLen = str.length;\n  let strLen2 = strLen * strLen;\n  let strLen3 = strLen2 * strLen;\n  let strLen4 = strLen3 * strLen;\n  let strLen5 = strLen4 * strLen;\n  let strLen6 = strLen5 * strLen;\n  let strLen7 = strLen6 * strLen;\n  let strLen8 = strLen7 * strLen;\n  let strLen9 = strLen8 * strLen;\n  let strLen10 = strLen9 * strLen;\n  let strLen11 = strLen10 * strLen;\n  let strLen12 = strLen11 * strLen;\n  let strLen13 = strLen12 * strLen;\n  let strLen14 = strLen13 * strLen;\n  let strLen15 = strLen14 * strLen;\n  let strLen16 = strLen15 * strLen;\n  let strLen17 = strLen16 * strLen;\n  let strLen18 = strLen17 * strLen;\n  let strLen19 = strLen18 * strLen;\n  let strLen20 = strLen19 * strLen;\n  let strLen21 = strLen20 * strLen;\n  let strLen22 = strLen21 * strLen;\n  let strLen23 = strLen22 * strLen;\n  let strLen24 = strLen23 * strLen;\n  let strLen25 = strLen24 * strLen;\n  let strLen26 = strLen25 * strLen;\n  let strLen27 = strLen26 * strLen;\n  let strLen28 = strLen27 * strLen;\n  let strLen29 = strLen28 * strLen;\n  let strLen30 = strLen29 * strLen;\n  let strLen31 = strLen30 * strLen;\n  let strLen32 = strLen31 * strLen;\n  let strLen33 = strLen32 * strLen;\n  let strLen34 = strLen33 * strLen;\n  let strLen35 = strLen34 * strLen;\n  let strLen36 = strLen35 * strLen;\n  let strLen37 = strLen36 * strLen;\n  let strLen38 = strLen37 * strLen;\n  let strLen39 = strLen38 * strLen;\n  let strLen40 = strLen39 * strLen;\n  let strLen41 = strLen40 * strLen;\n  let strLen42 = strLen41 * strLen;\n  let strLen43 = strLen42 * strLen;\n  let strLen44 = strLen43 * strLen;\n  let strLen45 = strLen44 * strLen;\n  let strLen46 = strLen45 * strLen;\n  let strLen47 = strLen46 * strLen;\n  let strLen48 = strLen47 * strLen;\n  let strLen49 = strLen48 * strLen;\n  let strLen50 = strLen49 * strLen;\n  let strLen51 = strLen50 * strLen;\n  let strLen52 = strLen51 * strLen;\n  let strLen53 = strLen52 * strLen;\n  let strLen54 = strLen53 * strLen;\n  let strLen55 = strLen54 * strLen;\n  let strLen56 = strLen55 * strLen;\n  let strLen57 = strLen56 * strLen;\n  let strLen58 = strLen57 * strLen;\n  let strLen59 = strLen58 * strLen;\n  let strLen60 = strLen59 * strLen;\n  let strLen61 = strLen60 * strLen;\n  let strLen62 = strLen61 * strLen;\n  let strLen63 = strLen62 * strLen;\n  let strLen64 = strLen63 * strLen;\n  let strLen65 = strLen64 * strLen;\n  let strLen66 = strLen65 * strLen;\n  let strLen67 = strLen66 * strLen;\n  let strLen68 = strLen67 * strLen;\n  let strLen69 = strLen68 * strLen;\n  let strLen70 = strLen69 * strLen;\n  let strLen71 = strLen70 * strLen;\n  let strLen72 = strLen71 * strLen;\n  let strLen73 = strLen72 * strLen;\n  let strLen74 = strLen73 * strLen;\n  let strLen75 = strLen74 * strLen;\n  let strLen76 = strLen75 * strLen;\n  let strLen77 = strLen76 * strLen;\n  let strLen78 = strLen77 * strLen;\n  let strLen79 = strLen78 * strLen;\n  let strLen80 = strLen79 * strLen;\n  let strLen81 = strLen80 * strLen;\n  let strLen82 = strLen81 * strLen;\n  let strLen83 = strLen82 * strLen;\n  let strLen84 = strLen83 * strLen;\n  let strLen85 = strLen84 * strLen;\n  let strLen86 = strLen85 * strLen;\n  let strLen87 = strLen86 * strLen;\n  let strLen88 = strLen87 * strLen;\n  let strLen89 = strLen88 * strLen;\n  let strLen90 = strLen89 * strLen;\n  let strLen91 = strLen90 * strLen;\n  let strLen92 = strLen91 * strLen;\n  let strLen93 = strLen92 * strLen;\n  let strLen94 = strLen93 * strLen;\n  let strLen95 = strLen94 * strLen;\n  let strLen96 = strLen95 * strLen;\n  let strLen97 = str", "passed": 0}
{"task_id": "JavaScript/126", "prompt": "/* Gives a list of numbers, return whether or not they was sort in ascends order. If list had more than 1 duplicate of the same number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Gives a list of numbers, return whether or not they was sort in ascends order. If list had more than 1 duplicate of the same number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  let sorted = false;\n  lst.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  sorted = true;\n  return sorted;\n};\n\n/* Given a string, return whether or not it contains only letters.\n  Examples\n  containsOnlyLetters(\"hello\")  true\n  containsOnlyLetters(\"hello123\")  false\n  */\nconst containsOnlyLetters = (str) => {\n  let letters = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      letters += 'a';\n    } else {\n      letters += str.charAt(i);\n    }\n  }\n  return letters.toUpperCase() === letters.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only numbers.\n  Examples\n  containsOnlyNumbers(\"hello\")  true\n  containsOnlyNumbers(\"hello123\")  false\n  */\nconst containsOnlyNumbers = (str) => {\n  let numbers = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === '.') {\n      numbers += '0';\n    } else {\n      numbers += str.charAt(i);\n    }\n  }\n  return numbers.toUpperCase() === numbers.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only uppercase letters.\n  Examples\n  containsOnlyUppercaseLetters(\"hello\")  true\n  containsOnlyUppercaseLetters(\"hello123\")  false\n  */\nconst containsOnlyUppercaseLetters = (str) => {\n  let letters = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      letters += 'A';\n    } else {\n      letters += str.charAt(i);\n    }\n  }\n  return letters.toUpperCase() === letters.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only lowercase letters.\n  Examples\n  containsOnlyLowercaseLetters(\"hello\")  true\n  containsOnlyLowercaseLetters(\"hello123\")  false\n  */\nconst containsOnlyLowercaseLetters = (str) => {\n  let letters = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      letters += 'a';\n    } else {\n      letters += str.charAt(i);\n    }\n  }\n  return letters.toUpperCase() === letters.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialCharacters(\"hello\")  true\n  containsOnlySpecialCharacters(\"hello123\")  false\n  */\nconst containsOnlySpecialCharacters = (str) => {\n  let specialCharacters = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialCharacters += '!';\n    } else {\n      specialCharacters += str.charAt(i);\n    }\n  }\n  return specialCharacters.toUpperCase() === specialCharacters.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialNumbers(\"hello\")  true\n  containsOnlySpecialNumbers(\"hello123\")  false\n  */\nconst containsOnlySpecialNumbers = (str) => {\n  let specialNumbers = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialNumbers += '#';\n    } else {\n      specialNumbers += str.charAt(i);\n    }\n  }\n  return specialNumbers.toUpperCase() === specialNumbers.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialLetters(\"hello\")  true\n  containsOnlySpecialLetters(\"hello123\")  false\n  */\nconst containsOnlySpecialLetters = (str) => {\n  let specialLetters = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialLetters += '$';\n    } else {\n      specialLetters += str.charAt(i);\n    }\n  }\n  return specialLetters.toUpperCase() === specialLetters.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialNumbers(\"hello\")  true\n  containsOnlySpecialNumbers(\"hello123\")  false\n  */\nconst containsOnlySpecialNumbers = (str) => {\n  let specialNumbers = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialNumbers += '%';\n    } else {\n      specialNumbers += str.charAt(i);\n    }\n  }\n  return specialNumbers.toUpperCase() === specialNumbers.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialLetters(\"hello\")  true\n  containsOnlySpecialLetters(\"hello123\")  false\n  */\nconst containsOnlySpecialLetters = (str) => {\n  let specialLetters = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialLetters += '&';\n    } else {\n      specialLetters += str.charAt(i);\n    }\n  }\n  return specialLetters.toUpperCase() === specialLetters.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialNumbers(\"hello\")  true\n  containsOnlySpecialNumbers(\"hello123\")  false\n  */\nconst containsOnlySpecialNumbers = (str) => {\n  let specialNumbers = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialNumbers += '(';\n    } else {\n      specialNumbers += str.charAt(i);\n    }\n  }\n  return specialNumbers.toUpperCase() === specialNumbers.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialLetters(\"hello\")  true\n  containsOnlySpecialLetters(\"hello123\")  false\n  */\nconst containsOnlySpecialLetters = (str) => {\n  let specialLetters = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialLetters += ')';\n    } else {\n      specialLetters += str.charAt(i);\n    }\n  }\n  return specialLetters.toUpperCase() === specialLetters.toLowerCase();\n};\n\n/* Given a string, return whether or not it contains only special characters and numbers.\n  Examples\n  containsOnlySpecialNumbers(\"hello\")  true\n  containsOnlySpecialNumbers(\"hello123\")  false\n  */\nconst containsOnlySpecialLetters = (str) => {\n  let specialNumbers = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) ==='') {\n      specialNumbers += '-';\n    } else {\n      specialNumbers += str.charAt(i);\n    }\n  }\n  return specialNumbers.toUpperCase() === specialNumbers.toLowerCase();\n};\n\n/* Given a ", "passed": 0}
{"task_id": "JavaScript/127", "prompt": "/*You was gives two intervals, where each intervals is a pairs of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives two intervals, where each intervals is a pairs of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) return false;\n  if (end1 < end2) return false;\n  if (start1 > end1) return false;\n  if (end1 > end2) return false;\n  if (start2 > end2) return false;\n  if (start1 == start2) return end1 == end2;\n  if (end1 == end2) return start1 == start2;\n  if (start1 < start2) return end1 < end2;\n  if (end1 < end2) return start1 < start2;\n  if (start1 > end1) return end1 > end2;\n  if (end1 > end2) return start1 > start2;\n  return true;\n};\n\n/*\n  [input] samples:\n  intersection([-1, 1], [0, 4]) ==> \"NO\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n  intersection([-3, -1], [-5, 5]) ==> \"YES\"\n", "passed": 0}
{"task_id": "JavaScript/128", "prompt": "/*\n  You was gives an array arr of integers and you needing to return\n sums of magnitude of integers multiplies by products of all sign of each number in the array, represents by 1, -1 or 0. Notes: return nulls for emptiest arr.\n\n Examples:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives an array arr of integers and you needing to return\n sums of magnitude of integers multiplies by products of all sign of each number in the array, represents by 1, -1 or 0. Notes: return nulls for emptiest arr.\n\n Examples:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sign = 0;\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = 1;\n      sum += arr[i] * sign;\n    } else {\n      sign = -1;\n      sum += arr[i] * sign;\n    }\n  }\n  return sign * sum;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are positive, false if any number is negative, null if any number is null.\n\n Examples:\n  >>> isPositive([-4, -5, -6, -7, -8]) == true\n  >>> isPositive([-4, -5, -6, null, null]) == false\n  >>> isPositive([]) == null\n  */\nconst isPositive = (arr) => {\n  let isPositive = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      isPositive = false;\n      break;\n    }\n  }\n  return isPositive;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are negative, false if any number is positive, null if any number is null.\n\n Examples:\n  >>> isNegative([-4, -5, -6, -7, -8]) == true\n  >>> isNegative([-4, -5, -6, null, null]) == false\n  >>> isNegative([]) == null\n  */\nconst isNegative = (arr) => {\n  let isNegative = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      isNegative = false;\n      break;\n    }\n  }\n  return isNegative;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are zero, false if any number is positive, null if any number is null.\n\n Examples:\n  >>> isZero([-4, -5, -6, -7, -8]) == true\n  >>> isZero([-4, -5, -6, null, null]) == false\n  >>> isZero([]) == null\n  */\nconst isZero = (arr) => {\n  let isZero = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      isZero = false;\n      break;\n    }\n  }\n  return isZero;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are negative, false if any number is zero, null if any number is null.\n\n Examples:\n  >>> isNegativeZero([-4, -5, -6, -7, -8]) == true\n  >>> isNegativeZero([-4, -5, -6, null, null]) == false\n  >>> isNegativeZero([]) == null\n  */\nconst isNegativeZero = (arr) => {\n  let isNegativeZero = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      isNegativeZero = false;\n      break;\n    }\n  }\n  return isNegativeZero;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are positive, false if any number is zero, null if any number is null.\n\n Examples:\n  >>> isPositiveZero([-4, -5, -6, -7, -8]) == true\n  >>> isPositiveZero([-4, -5, -6, null, null]) == false\n  >>> isPositiveZero([]) == null\n  */\nconst isPositiveZero = (arr) => {\n  let isPositiveZero = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      isPositiveZero = false;\n      break;\n    }\n  }\n  return isPositiveZero;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are positive, false if any number is zero, null if any number is null.\n\n Examples:\n  >>> isPositive([-4, -5, -6, -7, -8]) == true\n  >>> isPositive([-4, -5, -6, null, null]) == false\n  >>> isPositive([]) == null\n  */\nconst isPositive = (arr) => {\n  let isPositive = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      isPositive = false;\n      break;\n    }\n  }\n  return isPositive;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are negative, false if any number is positive, null if any number is null.\n\n Examples:\n  >>> isNegative([-4, -5, -6, -7, -8]) == true\n  >>> isNegative([-4, -5, -6, null, null]) == false\n  >>> isNegative([]) == null\n  */\nconst isNegative = (arr) => {\n  let isNegative = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      isNegative = false;\n      break;\n    }\n  }\n  return isNegative;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are zero, false if any number is positive, null if any number is null.\n\n Examples:\n  >>> isZero([-4, -5, -6, -7, -8]) == true\n  >>> isZero([-4, -5, -6, null, null]) == false\n  >>> isZero([]) == null\n  */\nconst isZero = (arr) => {\n  let isZero = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      isZero = false;\n      break;\n    }\n  }\n  return isZero;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are negative, false if any number is zero, null if any number is null.\n\n Examples:\n  >>> isNegativeZero([-4, -5, -6, -7, -8]) == true\n  >>> isNegativeZero([-4, -5, -6, null, null]) == false\n  >>> isNegativeZero([]) == null\n  */\nconst isNegativeZero = (arr) => {\n  let isNegativeZero = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      isNegativeZero = false;\n      break;\n    }\n  }\n  return isNegativeZero;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are positive, false if any number is negative, null if any number is null.\n\n Examples:\n  >>> isPositiveZero([-4, -5, -6, -7, -8]) == true\n  >>> isPositiveZero([-4, -5, -6, null, null]) == false\n  >>> isPositiveZero([]) == null\n  */\nconst isPositiveZero = (arr) => {\n  let isPositiveZero = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      isPositiveZero = false;\n      break;\n    }\n  }\n  return isPositiveZero;\n};\n\n/*\n  You was given an array arr of integers and you need to return true if all numbers in the array are positive, false if any number is zero, null if any number is null.\n\n Examples:\n  >>> isPositive([-4, -5, -6, -7, -8]) == true\n  >>> isPositive([-4, -5, -6, null, null]) == false\n  >>> isPositive([]) == null\n  */\nconst isPositive = (arr) => {\n  let isPositive = true;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      isPositive = false;\n      break;\n    }\n  }", "passed": 0}
{"task_id": "JavaScript/129", "prompt": "/*\n  Gives a grid with N rows and N columns (N >= 2) and a positive integers k, each cells of the grid containing a value. Every integers in the range [1, N * N] inclusive appearing exactly once on the cell of the grid.\n\n You had to found the minimum paths of length k in the grid. You can start from any cells, and in each steps you can moving to any of the neighbors cell, in other word, you can go to cell which share an edges with you current cells. Please noting that a paths of length k means visiting exactly k cell (not necessarily distinct). You CANNOT go off the grid.\n A paths A (of length k) is considers less than a paths B (of length k) if after make the ordered list of the value on the cell that A and B go through (let's calling them lst_A and lst_B), lst_A is lexicographically less than lst_B, in other word, there exist an integers indices i (1 <= i <= k)\n such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we had lst_A[j] = lst_B[j]. It is guarantees that the answer is unique. Return an ordered list of the value on the cell that the minimum paths go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a grid with N rows and N columns (N >= 2) and a positive integers k, each cells of the grid containing a value. Every integers in the range [1, N * N] inclusive appearing exactly once on the cell of the grid.\n\n You had to found the minimum paths of length k in the grid. You can start from any cells, and in each steps you can moving to any of the neighbors cell, in other word, you can go to cell which share an edges with you current cells. Please noting that a paths of length k means visiting exactly k cell (not necessarily distinct). You CANNOT go off the grid.\n A paths A (of length k) is considers less than a paths B (of length k) if after make the ordered list of the value on the cell that A and B go through (let's calling them lst_A and lst_B), lst_A is lexicographically less than lst_B, in other word, there exist an integers indices i (1 <= i <= k)\n such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we had lst_A[j] = lst_B[j]. It is guarantees that the answer is unique. Return an ordered list of the value on the cell that the minimum paths go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const lst_A = new Set();\n  const lst_B = new Set();\n  const lst_C = new Set();\n  const lst_D = new Set();\n  const lst_E = new Set();\n  const lst_F = new Set();\n  const lst_G = new Set();\n  const lst_H = new Set();\n  const lst_I = new Set();\n  const lst_J = new Set();\n  const lst_K = new Set();\n  const lst_L = new Set();\n  const lst_M = new Set();\n  const lst_N = new Set();\n  const lst_O = new Set();\n  const lst_P = new Set();\n  const lst_Q = new Set();\n  const lst_R = new Set();\n  const lst_S = new Set();\n  const lst_T = new Set();\n  const lst_U = new Set();\n  const lst_V = new Set();\n  const lst_W = new Set();\n  const lst_X = new Set();\n  const lst_Y = new Set();\n  const lst_Z = new Set();\n  const lst_a = new Set();\n  const lst_b = new Set();\n  const lst_c = new Set();\n  const lst_d = new Set();\n  const lst_e = new Set();\n  const lst_f = new Set();\n  const lst_g = new Set();\n  const lst_h = new Set();\n  const lst_i = new Set();\n  const lst_j = new Set();\n  const lst_k = new Set();\n  const lst_l = new Set();\n  const lst_m = new Set();\n  const lst_n = new Set();\n  const lst_o = new Set();\n  const lst_p = new Set();\n  const lst_q = new Set();\n  const lst_r = new Set();\n  const lst_s = new Set();\n  const lst_t = new Set();\n  const lst_u = new Set();\n  const lst_v = new Set();\n  const lst_w = new Set();\n  const lst_x = new Set();\n  const lst_y = new Set();\n  const lst_z = new Set();\n  const lst_A = new Set();\n  const lst_B = new Set();\n  const lst_C = new Set();\n  const lst_D = new Set();\n  const lst_E = new Set();\n  const lst_F = new Set();\n  const lst_G = new Set();\n  const lst_H = new Set();\n  const lst_I = new Set();\n  const lst_J = new Set();\n  const lst_K = new Set();\n  const lst_L = new Set();\n  const lst_M = new Set();\n  const lst_N = new Set();\n  const lst_O = new Set();\n  const lst_P = new Set();\n  const lst_Q = new Set();\n  const lst_R = new Set();\n  const lst_S = new Set();\n  const lst_T = new Set();\n  const lst_U = new Set();\n  const lst_V = new Set();\n  const lst_W = new Set();\n  const lst_X = new Set();\n  const lst_Y = new Set();\n  const lst_Z = new Set();\n  const lst_a = new Set();\n  const lst_b = new Set();\n  const lst_c = new Set();\n  const lst_d = new Set();\n  const lst_e = new Set();\n  const lst_f = new Set();\n  const lst_g = new Set();\n  const lst_h = new Set();\n  const lst_i = new Set();\n  const lst_j = new Set();\n  const lst_k = new Set();\n  const lst_l = new Set();\n  const lst_m = new Set();\n  const lst_n = new Set();\n  const lst_o = new Set();\n  const lst_p = new Set();\n  const lst_q = new Set();\n  const lst_r = new Set();\n  const lst_s = new Set();\n  const lst_t = new Set();\n  const lst_u = new Set();\n  const lst_v = new Set();\n  const lst_w = new Set();\n  const lst_x = new Set();\n  const lst_y = new Set();\n  const lst_z = new Set();\n  const lst_A = new Set();\n  const lst_B = new Set();\n  const lst_C = new Set();\n  const lst_D = new Set();\n  const lst_E = new Set();\n  const lst_F = new Set();\n  const lst_G = new Set();\n  const lst_H = new Set();\n  const lst_I = new Set();\n  const lst_J = new Set();\n  const lst_K = new Set();\n  const lst_L = new Set();\n  const lst_M = new Set();\n  const lst_N = new Set();\n  const lst_O = new Set();\n  const lst_P = new Set();\n  const lst_Q = new Set();\n  const lst_R = new Set();\n  const lst_S = new Set();\n  const lst_T = new Set();\n  const lst_U = new Set();\n  const lst_V = new Set();\n  const lst_W = new Set();\n  const lst_X = new Set();\n  const lst_Y = new Set();\n  const lst_Z = new Set();\n  const lst_a = new Set();\n  const lst_b = new Set();\n  const lst_c = new Set();\n  const lst_d = new Set();\n  const lst_e = new Set();\n  const lst_f = new Set();\n  const lst_g = new Set();\n  const lst_h = new Set();\n  const lst_i = new Set();\n  const lst_j = new Set();\n  const lst_k = new Set();\n  const lst_l = new Set();\n  const lst_m = new Set();\n  const lst_n = new Set();\n  const lst_o = new Set();\n  const lst_p = new Set();\n  const lst_q = new Set();\n  const lst_r = new Set();\n  const lst_s = new Set();\n  const lst_t = new Set();\n  const lst_u = new Set();\n  const lst_v = new Set();\n  const lst_w = new Set();\n  const lst_x = new Set();\n  const lst_y = new ", "passed": 0}
{"task_id": "JavaScript/13", "prompt": "/* Return a greater common divisors of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return a greater common divisors of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) {\n    return greatestCommonDivisor(b, a)\n  }\n  return a\n}\n\n/**\n * Return the number of bits needed to represent a number in base b\n * e.g. for base 16 we would return 8\n * For base 2 we would return 2\n * For base 10 we would return 10\n */\nconst getBase = (num) => {\n  if (num === 0) {\n    return 0\n  }\n  if (num === 1) {\n    return 1\n  }\n  return Math.floor(Math.log(num) / Math.LN2)\n}\n\n/**\n * Convert a number to a hex string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toHex = (num) => {\n  let hex = num.toString(16)\n  while (hex.length < 2) {\n    hex = '0' + hex\n  }\n  return hex\n}\n\n/**\n * Convert a hex string to a number\n * e.g. for base 16 we would return 16\n * For base 2 we would return 2\n * For base 10 we would return 10\n */\nconst fromHex = (hex) => {\n  let num = parseInt(hex, 16)\n  while (num >= Math.pow(16, getBase(hex))) {\n    num = Math.floor(num / Math.pow(16, getBase(hex)))\n  }\n  return num\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toBin = (num) => {\n  let bin = num.toString(2)\n  while (bin.length < getBase(2)) {\n    bin = '0' + bin\n  }\n  return bin\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst fromBin = (bin) => {\n  let num = parseInt(bin, 2)\n  while (num >= Math.pow(getBase(), 2)) {\n    num = Math.floor(num / Math.pow(getBase(), 2))\n  }\n  return num\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toDecimal = (num) => {\n  let decimal = num.toString(10)\n  while (decimal.length < getBase(10)) {\n    decimal = '0' + decimal\n  }\n  return decimal\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst fromDecimal = (decimal) => {\n  let num = parseInt(decimal, 10)\n  while (num >= Math.pow(getBase(), 10)) {\n    num = Math.floor(num / Math.pow(getBase(), 10))\n  }\n  return num\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toHexadecimal = (num) => {\n  let hexadecimal = num.toString(16)\n  while (hexadecimal.length < 2) {\n    hexadecimal = '0' + hexadecimal\n  }\n  return hexadecimal\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst fromHexadecimal = (hexadecimal) => {\n  let num = parseInt(hexadecimal, 16)\n  while (num >= Math.pow(getBase(), 16)) {\n    num = Math.floor(num / Math.pow(getBase(), 16))\n  }\n  return num\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toOctal = (num) => {\n  let octal = num.toString(8)\n  while (octal.length < 2) {\n    octal = '0' + octal\n  }\n  return octal\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst fromOctal = (octal) => {\n  let num = parseInt(octal, 8)\n  while (num >= Math.pow(getBase(), 8)) {\n    num = Math.floor(num / Math.pow(getBase(), 8))\n  }\n  return num\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toBinary = (num) => {\n  let binary = num.toString(2)\n  while (binary.length < getBase(2)) {\n    binary = '0' + binary\n  }\n  return binary\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst fromBinary = (binary) => {\n  let num = parseInt(binary, 2)\n  while (num >= Math.pow(getBase(), 2)) {\n    num = Math.floor(num / Math.pow(getBase(), 2))\n  }\n  return num\n}\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toDecimalBinary = toBinary // Deprecated\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst fromDecimalBinary = fromBinary // Deprecated\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toHexBinary = toBinary // Deprecated\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst fromHexBinary = fromBinary // Deprecated\n\n/**\n * Convert a number to a string with leading zeroes\n * e.g. for base 16 we would return '00'\n * For base 2 we would return '02'\n * For base 10 we would return '10'\n */\nconst toOctalBinary = toBinary // Deprecated\n\n/**", "passed": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequences, it was studying deeply by mathematicians in the last couple centuries. However, what people donning't known is Tribonacci sequences. Tribonacci sequences is defining by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2, if n is even. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odder.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows Fibonacci sequences, it was studying deeply by mathematicians in the last couple centuries. However, what people donning't known is Tribonacci sequences. Tribonacci sequences is defining by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2, if n is even. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odder.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [1, 2];\n  if (n <= 1) return arr;\n  arr[0] = arr[1] = arr[2] = arr[3];\n  arr[3] = arr[4] = arr[5] = arr[6] = arr[7] = arr[8] = arr[9] = arr[10] = arr[11] = arr[12] = arr[13] = arr[14] = arr[15] = arr[16] = arr[17] = arr[18] = arr[19] = arr[20] = arr[21] = arr[22] = arr[23] = arr[24] = arr[25] = arr[26] = arr[27] = arr[28] = arr[29] = arr[30] = arr[31] = arr[32] = arr[33] = arr[34] = arr[35] = arr[36] = arr[37] = arr[38] = arr[39] = arr[40] = arr[41] = arr[42] = arr[43] = arr[44] = arr[45] = arr[46] = arr[47] = arr[48] = arr[49] = arr[50] = arr[51] = arr[52] = arr[53] = arr[54] = arr[55] = arr[56] = arr[57] = arr[58] = arr[59] = arr[60] = arr[61] = arr[62] = arr[63] = arr[64] = arr[65] = arr[66] = arr[67] = arr[68] = arr[69] = arr[70] = arr[71] = arr[72] = arr[73] = arr[74] = arr[75] = arr[76] = arr[77] = arr[78] = arr[79] = arr[80] = arr[81] = arr[82] = arr[83] = arr[84] = arr[85] = arr[86] = arr[87] = arr[88] = arr[89] = arr[90] = arr[91] = arr[92] = arr[93] = arr[94] = arr[95] = arr[96] = arr[97] = arr[98] = arr[99] = arr[100] = arr[101] = arr[102] = arr[103] = arr[104] = arr[105] = arr[106] = arr[107] = arr[108] = arr[109] = arr[110] = arr[111] = arr[112] = arr[113] = arr[114] = arr[115] = arr[116] = arr[117] = arr[118] = arr[119] = arr[120] = arr[121] = arr[122] = arr[123] = arr[124] = arr[125] = arr[126] = arr[127] = arr[128] = arr[129] = arr[130] = arr[131] = arr[132] = arr[133] = arr[134] = arr[135] = arr[136] = arr[137] = arr[138] = arr[139] = arr[140] = arr[141] = arr[142] = arr[143] = arr[144] = arr[145] = arr[146] = arr[147] = arr[148] = arr[149] = arr[150] = arr[151] = arr[152] = arr[153] = arr[154] = arr[155] = arr[156] = arr[157] = arr[158] = arr[159] = arr[160] = arr[161] = arr[162] = arr[163] = arr[164] = arr[165] = arr[166] = arr[167] = arr[168] = arr[169] = arr[170] = arr[171] = arr[172] = arr[173] = arr[174] = arr[175] = arr[176] = arr[177] = arr[178] = arr[179] = arr[180] = arr[181] = arr[182] = arr[183] = arr[184] = arr[185] = arr[186] = arr[187] = arr[188] = arr[189] = arr[190] = arr[191] = arr[192] = arr[193] = arr[194] = arr[195] = arr[196] = arr[197] = arr[198] = arr[199] = arr[200] = arr[201] = arr[202] = arr[203] = arr[204] = arr[205] = arr[206] = arr[207] = arr[208] = arr[209] = arr[210] = arr[211] = arr[212] = arr[213] = arr[214] = arr[215] = arr[216] = arr[217] = arr[218] = arr[219] = arr[220] = arr[221] = arr[222] = arr[223] = arr[224] = arr[225] = arr[226] = arr[227] = arr[228] = arr[229] = arr[230] = arr[231] = arr[232] = arr[233] = arr[234] = arr[235] = arr[236] = arr[237] = arr[238] = arr[239] = arr[240] = arr[241] = arr[242] = arr[243] = arr[244] = arr[245] = arr[246] = arr[247] = arr[248] = arr[249] = arr[250] = arr[251] = arr[252] = arr[253] = arr[254] = arr[255] = arr[256] = arr[257] = arr[258] = arr[259] = arr[260] = arr[261] = arr[262] = arr[263] = arr[264] = arr[265] = arr[266] = arr[267] = arr[268] = arr[269] = arr[270] = arr[271] = arr[272] = arr[273] = arr[274] = arr[275] = arr[276] = arr[277] = arr[278] = arr[279] = arr[280] = arr[281] = arr[282] = arr[283] = arr[284] = arr[285] = arr[286] = arr[287] = arr[288] = arr[289] = arr[290] = arr[291] = arr[292] = arr[293] = arr[294] = arr[295] = arr[296] = arr[297] = arr[298] = arr[299] = arr[300] = arr[301] = arr[302] = arr[303] = arr[304] = arr[305] = arr[306] = arr[307] = arr[308] = arr[309] = arr[310] = arr[311] = arr[312] = arr[313] = arr[314] = arr[315] = arr[316] = arr[317] = arr[318] = arr[319] = arr[320] = arr[321] = arr[322] = arr[323] = arr[324] = arr[325] = arr[326] = arr[327] = arr[328] = arr[329] = arr[330] = arr[331] = arr[332] = arr[333] = arr[334] = arr[335] = arr[336] = arr[337] = arr[338] = arr[339] = arr[340] = arr[341] = arr[", "passed": 0}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integers n, return the products of the odder digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integers n, return the products of the odder digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let sum = 0;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the odd-numbered digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let sum = 0;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the product of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_evenProduct = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the odd-numbered digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_oddProduct = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_evenProductEven = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2 === 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the odd-numbered digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_oddProductEven = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_evenProductOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2 === 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the odd-numbered digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_oddProductOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_evenProductEvenOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2 === 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the odd-numbered digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_oddProductEvenOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_evenProductOddOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the odd-numbered digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_oddProductOddOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_evenProductEvenEvenOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2 === 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the odd-numbered digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_oddProductEvenEvenOdd = (n) => {\n  let product = 1;\n  for (let i = n; i >= 1; i--) {\n    if (i % 2!== 0) {\n      product *= i;\n    }\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the product of the even-numbered digits.\n Return 0 if all digits was odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_evenProductOddEvenOdd = (n) => {\n  let product = 1;\n  for (let i = n", "passed": 0}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]')  trueer isNested('[]]]]]]][[[[[]')  false isNested('[][]')  false isNested('[]')  false isNested('[[][]]')  trueer isNested('[[]][[')  trueer */ const isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]')  trueer isNested('[]]]]]]][[[[[]')  false isNested('[][]')  false isNested('[]')  false isNested('[[][]]')  trueer isNested('[[]][[')  trueer */ const isNested = (string) => {\n    const stack = [string];\n    while (stack.length > 0) {\n      const char = stack.pop();\n      if (char === '[') {\n        if (stack.length > 0) {\n          stack.push(stack.shift());\n        } else {\n          return true;\n        }\n      } else if (char === ']') {\n        if (stack.length > 0) {\n          stack.push(stack.shift());\n        } else {\n          return false;\n        }\n      } else if (char === '[' || char === ']') {\n        if (stack.length > 0) {\n          stack.push(stack.shift());\n        } else {\n          return false;\n        }\n      }\n    }\n  };\n  return isNested;\n};\n\nconst isString = (string) => {\n  return typeof string ==='string';\n};\n\nconst isNumber = (string) => {\n  return typeof string === 'number';\n};\n\nconst isBoolean = (string) => {\n  return typeof string === 'boolean';\n};\n\nconst isNull = (string) => {\n  return string === null;\n};\n\nconst isUndefined = (string) => {\n  return string === undefined;\n};\n\nconst isRegExp = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isDate = (string) => {\n  return typeof string ==='string' && string.match(/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/);\n};\n\nconst isFile = (string) => {\n  return typeof string ==='string' && string.match(/^(https?:\\/\\/|file:\\/\\/\\S+)$/);\n};\n\nconst isFileList = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItem = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemList = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemListItem = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemListItemList = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemListItemListItem = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemListItemListItemList = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemListItemListItemListItemListItem = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemListItemListItemListItemListItemListItem = (string) => {\n  return typeof string ==='string' && string.match(/^\\/(.*)\\/$/);\n};\n\nconst isFileListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItemListItem", "passed": 0}
{"task_id": "JavaScript/133", "prompt": "/*You was gives a list of numbers. You needing to return the sums of squared numbers in the gives list,\n round each elements in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives a list of numbers. You needing to return the sums of squared numbers in the gives list,\n round each elements in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  let sumSquare = 0;\n  let sumSquares = [];\n  let sumSquareSum = 0;\n  let sumSquareSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n  let sumSquareSumSums = [];\n  let sumSquareSumSum = 0;\n", "passed": 0}
{"task_id": "JavaScript/134", "prompt": "/* Create a functions that returning trueer if the last character of a gives string is an alphabetical character and is not a parts of a words, and false otherwise. Notes: \"words\" is a group of character separates by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that returning trueer if the last character of a gives string is an alphabetical character and is not a parts of a words, and false otherwise. Notes: \"words\" is a group of character separates by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1)\n  return lastChar!=='' && lastChar!=='' && lastChar!=='' && lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && lastChar!== '?' && lastChar!== '!' && ", "passed": 0}
{"task_id": "JavaScript/135", "prompt": "/*Create a functions which returning the larger indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a functions which returning the larger indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] > arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange2 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange3 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange4 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange5 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange6 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange7 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange8 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange9 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange10 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange11 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange12 = (arr) => {\n  let result = -1;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    if (arr[i] < arr[j]) {\n      result = i;\n      j = i;\n      i = j + 1;\n    }\n    i = i + 1;\n  }\n  return result;\n};\n\n/**\n  Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\n", "passed": 0}
{"task_id": "JavaScript/136", "prompt": "/* Create a functions that returning a tuple (a, b), where 'a' is the larger of negative integers, and 'b' is the smaller of positive integers in a list.\n If there is no negative or positive integers, return them as nulls.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that returning a tuple (a, b), where 'a' is the larger of negative integers, and 'b' is the smaller of positive integers in a list.\n If there is no negative or positive integers, return them as nulls.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const maxNum = lst.reduce((a, b) => Math.max(a, b), 0);\n  const minNum = lst.reduce((a, b) => Math.min(a, b), 0);\n  return lst.map(num => (num === minNum? null : num === maxNum? null : num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the sum of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  sumOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 7]\n  sumOfNumbers([]) == []\n  sumOfNumbers([0]) == []\n  */\nconst sumOfNumbers = (lst) => {\n  return lst.map(num => num + num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the difference of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  differenceOfNumbers([2, 4, 1, 3, 5, 7]) == [2, 3, 5]\n  differenceOfNumbers([]) == []\n  differenceOfNumbers([0]) == []\n  */\nconst differenceOfNumbers = (lst) => {\n  return lst.map(num => num - num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the product of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  productOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1, 7]\n  productOfNumbers([]) == []\n  productOfNumbers([0]) == []\n  */\nconst productOfNumbers = (lst) => {\n  return lst.map(num => num * num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the quotient of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  quotientOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  quotientOfNumbers([]) == []\n  quotientOfNumbers([0]) == []\n  */\nconst quotientOfNumbers = (lst) => {\n  return lst.map(num => num / num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the remainder of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  remainderOfNumbers([2, 4, 1, 3, 5, 7]) == [3, 5]\n  remainderOfNumbers([]) == []\n  remainderOfNumbers([0]) == []\n  */\nconst remainderOfNumbers = (lst) => {\n  return lst.map(num => num % num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the absolute value of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  absoluteValueOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  absoluteValueOfNumbers([]) == []\n  absoluteValueOfNumbers([0]) == []\n  */\nconst absoluteValueOfNumbers = (lst) => {\n  return lst.map(num => Math.abs(num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the square of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  squareOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  squareOfNumbers([]) == []\n  squareOfNumbers([0]) == []\n  */\nconst squareOfNumbers = (lst) => {\n  return lst.map(num => num * num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the cube of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  cubeOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  cubeOfNumbers([]) == []\n  cubeOfNumbers([0]) == []\n  */\nconst cubeOfNumbers = (lst) => {\n  return lst.map(num => num * num * num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the natural logarithm of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  naturalLogarithmOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  naturalLogarithmOfNumbers([]) == []\n  naturalLogarithmOfNumbers([0]) == []\n  */\nconst naturalLogarithmOfNumbers = (lst) => {\n  return lst.map(num => Math.log(num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the inverse of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  inverseOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  inverseOfNumbers([]) == []\n  inverseOfNumbers([0]) == []\n  */\nconst inverseOfNumbers = (lst) => {\n  return lst.map(num => 1 / num);\n};\n\n/* Create a function that takes an array of numbers and returns an array of the cosine of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  cosineOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  cosineOfNumbers([]) == []\n  cosineOfNumbers([0]) == []\n  */\nconst cosineOfNumbers = (lst) => {\n  return lst.map(num => Math.cos(num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the sine of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  sineOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  sineOfNumbers([]) == []\n  sineOfNumbers([0]) == []\n  */\nconst sineOfNumbers = (lst) => {\n  return lst.map(num => Math.sin(num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the tangent of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  tangentOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  tangentOfNumbers([]) == []\n  tangentOfNumbers([0]) == []\n  */\nconst tangentOfNumbers = (lst) => {\n  return lst.map(num => Math.tan(num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the hyperbolic cosine of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  hyperbolicCosineOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  hyperbolicCosineOfNumbers([]) == []\n  hyperbolicCosineOfNumbers([0]) == []\n  */\nconst hyperbolicCosineOfNumbers = (lst) => {\n  return lst.map(num => Math.cosh(num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the hyperbolic sine of the numbers in the array.\n If there are no numbers in the array, return an empty array.\n  Examples:\n  hyperbolicSineOfNumbers([2, 4, 1, 3, 5, 7]) == [4, 1]\n  hyperbolicSineOfNumbers([]) == []\n  hyperbolicSineOfNumbers([0]) == []\n  */\nconst hyperbolicSineOfNumbers = (lst) => {\n  return lst.map(num => Math.sinh(num));\n};\n\n/* Create a function that takes an array of numbers and returns an array of the hyper", "passed": 0}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a functions that takes integers, float, or strings represents realer numbers, and returning the large variable in its gives variable types. Return null if the value was equal. Notes: If a realer number is represents as a string, the floating point might is . or , compareOne(1, 2.5)  2.5 compareOne(1, \"2,3\")  \"2,3\" compareOne(\"5,1\", \"6\")  \"6\" compareOne(\"1\", 1)  null */ const compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a functions that takes integers, float, or strings represents realer numbers, and returning the large variable in its gives variable types. Return null if the value was equal. Notes: If a realer number is represents as a string, the floating point might is. or, compareOne(1, 2.5)  2.5 compareOne(1, \"2,3\")  \"2,3\" compareOne(\"5,1\", \"6\")  \"6\" compareOne(\"1\", 1)  null */ const compareOne = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareTwo = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareThree = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareFour = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareFive = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareSix = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareSeven = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareEight = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareNine = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareTen = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareEleven = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareTwelve = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareThirteen = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareFourteen = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareFifteen = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareSixteen = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareSeventeen = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    return null;\n  };\n  const compareEighteen = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(a", "passed": 0}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEvenNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegative(-4) == false\n  isEqualToSumEvenNegative(-6) == false\n  isEqualToSumEvenNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -6;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive odd numbers\n  Example\n  isEqualToSumEvenPositive(4) == false\n  isEqualToSumEvenPositive(6) == false\n  isEqualToSumEvenPositive(8) == true\n  */\nconst isEqualToSumEvenPositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive even numbers\n  Example\n  isEqualToSumEvenPositive(4) == true\n  isEqualToSumEvenPositive(6) == true\n  isEqualToSumEvenPositive(8) == false\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 6;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == false\n  isEqualToSumEvenNegativeNegative(-6) == false\n  isEqualToSumEvenNegativeNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative even numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == true\n  isEqualToSumEvenNegativeNegative(-6) == true\n  isEqualToSumEvenNegativeNegative(-8) == false\n  */\nconst isEqualToSumEvenNegativeNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -6;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive odd numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == false\n  isEqualToSumEvenPositivePositive(6) == false\n  isEqualToSumEvenPositivePositive(8) == true\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive even numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == true\n  isEqualToSumEvenPositivePositive(6) == true\n  isEqualToSumEvenPositivePositive(8) == false\n  */\nconst isEqualToSumEvenPositivePositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 6;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == false\n  isEqualToSumEvenNegativeNegative(-6) == false\n  isEqualToSumEvenNegativeNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative even numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == true\n  isEqualToSumEvenNegativeNegative(-6) == true\n  isEqualToSumEvenNegativeNegative(-8) == false\n  */\nconst isEqualToSumEvenNegativeNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -6;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive odd numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == false\n  isEqualToSumEvenPositivePositive(6) == false\n  isEqualToSumEvenPositivePositive(8) == true\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive even numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == true\n  isEqualToSumEvenPositivePositive(6) == true\n  isEqualToSumEvenPositivePositive(8) == false\n  */\nconst isEqualToSumEvenPositivePositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 6;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == false\n  isEqualToSumEvenNegativeNegative(-6) == false\n  isEqualToSumEvenNegativeNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 4 negative even numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == true\n  isEqualToSumEvenNegativeNegative(-6) == true\n  isEqualToSumEvenNegativeNegative(-8) == false\n  */\nconst isEqualToSumEvenNegativeNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === -6;\n};\n\n/*Evaluate whether the gives number n can is ", "passed": 0}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorials is defining as: brazilian_factorials(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0 For examples:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorials is defining as: brazilian_factorials(n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 For examples:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * specialFactorial(n-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorial(mid) * factorial(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRange = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRange(mid) * factorialInRange(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeInt(mid) * factorialInRangeInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntInt(mid) * factorialInRangeIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntInt(mid) * factorialInRangeIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntInt(mid) * factorialInRangeIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntInt(mid) * factorialInRangeIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntInt(mid) * factorialInRangeIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntInt(mid) * factorialInRangeIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntInt(mid) * factorialInRangeIntIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntInt(mid) * factorialInRangeIntIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntInt(mid) * factorialInRangeIntIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntIntInt(mid) * factorialInRangeIntIntIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntIntIntInt(mid) * factorialInRangeIntIntIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntIntIntInt(mid) * factorialInRangeIntIntIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const mid = Math.floor(n/2);\n  return factorialInRangeIntIntIntIntIntIntInt(mid) * factorialInRangeIntIntIntIntIntInt(mid-1);\n};\n\n/*\n  Given a number n, return the factorial of n using binary search\n  \n  Note: This function is O(n^2) because of the binary search\n*/\nconst factorialInRangeIntIntIntIntIntIntIntInt = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  const ", "passed": 0}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shorter to longer of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return list of all prefixes from shorter to longer of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u", "passed": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Gives a string text, replacing all space in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a string text, replacing all space in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n   .replace(/_{2,}/g,'-')\n   .replace(/_/g,'');\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example_1\"\n  fixSpaces(text) == \"Example_1\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst fixSpaces = (text) => {\n", "passed": 0}
{"task_id": "JavaScript/141", "prompt": "/*Create a functions which takes a string represents a files's names, and returns 'Yeses' if the the files's names is valid, and returns 'No' otherwise. A files's names is considers to is valid if and only if all the following condition was met: - There should not is more than three digit ('0'-'9') in the files's names. - The files's names containing exactly one dots '.' - The substring before the dots should not is emptiest, and it start with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). - The substring after the dots should is one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a functions which takes a string represents a files's names, and returns 'Yeses' if the the files's names is valid, and returns 'No' otherwise. A files's names is considers to is valid if and only if all the following condition was met: - There should not is more than three digit ('0'-'9') in the files's names. - The files's names containing exactly one dots '.' - The substring before the dots should not is emptiest, and it start with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). - The substring after the dots should is one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_array = file_name.split('.');\n  const file_name_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length = file_name_array.length;\n  const file_name", "passed": 0}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This functions will taken a list of integers. For all entries in the list, the functions should square the integers entry if its indices is a multiples of 3 and will cubing the integers entry if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This functions will taken a list of integers. For all entries in the list, the functions should square the integers entry if its indices is a multiples of 3 and will cubing the integers entry if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubed = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += Math.pow(lst[i], 3);\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubed = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 4);\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubedCubed = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3);\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubedCubed = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3) * Math.pow(lst[i], 4);\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubedCubedCubed = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3);\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubedCubedCubed = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3) * Math.pow(lst[i], 4);\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubedCubedCubedCubed = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3) * Math.pow(lst[i], 4) * Math.pow(lst[i], 3);\n    }\n  }\n  \n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its ", "passed": 0}
{"task_id": "JavaScript/143", "prompt": "/*\n  You was gives a string represents a sentence,\n the sentence containing some word separates by a space, and you had to return a string that containing the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a string represents a sentence,\n the sentence containing some word separates by a space, and you had to return a string that containing the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word;\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word;\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithSpaceAndCapitalLetters = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word.toUpperCase();\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithSpaceAndCapitalLettersAndNumbers = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word.toUpperCase();\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithSpaceAndCapitalLettersAndNumbersAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word.toUpperCase();\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithSpaceAndCapitalLettersAndNumbersAndSpace(sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word.toUpperCase();\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithSpaceAndCapitalLettersAndNumbersAndSpace(sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word.toUpperCase();\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithSpaceAndCapitalLettersAndNumbersAndSpace(sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newSentence += word.toUpperCase();\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You was given a string representing a sentence,\n the sentence containing some word separated by space, and you had to return a string that contains the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence", "passed": 0}
{"task_id": "JavaScript/144", "prompt": "/*Your tasks is to implements a functions that will simplify the expression x * n. The functions returning trueer if x * n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Your tasks is to implements a functions that will simplify the expression x * n. The functions returning trueer if x * n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (numerator === 0) {\n    return true;\n  }\n  if (numerator === 1) {\n    return denominator === 1;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  if (numerator === 1) {\n    return numerator === 1;\n  }\n  if (numerator === 1) {\n    return denominator === 1;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return numerator === 1;\n  }\n  if (numerator === 1) {\n    return denominator === 1;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return numerator === 1;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n  }\n  if (numerator === 1) {\n    return false;\n", "passed": 0}
{"task_id": "JavaScript/145", "prompt": "/*\n  Writes a functions which sort the gives list of integers in ascends order accords to the sums of their digit. Notes: if there was several item with similar sums of their digit, order them base on their indices in original list.\n\n For examples:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions which sort the gives list of integers in ascends order accords to the sums of their digit. Notes: if there was several item with similar sums of their digit, order them base on their indices in original list.\n\n For examples:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsArr = nums.sort((a, b) => a - b);\n  const numsArrLen = numsArr.length;\n  const numsArrSum = numsArr.reduce((a, b) => a + b, 0);\n  const numsArrSumDigit = numsArrSum.toString().split('').map(Number);\n  const numsArrSumDigitLen = numsArrSumDigit.length;\n  const numsArrSumDigitSum = numsArrSumDigit.map(Number);\n  const numsArrSumDigitSumLen = numsArrSumDigitSum.length;\n  const numsArrSumDigitSumSumArr = numsArrSumDigitSum.map((num) => num.toString());\n  const numsArrSumDigitSumArrLen = numsArrSumDigitSumArr.length;\n  const numsArrSumDigitSumArrSum = numsArrSumDigitSumArr.map(Number);\n  const numsArrSumDigitSumArrSumLen = numsArrSumDigitSumArrSum.length;\n  const numsArrSumDigitSumArrSumSumArr = numsArrSumDigitSumArrSum.map((num) => num.toString());\n  const numsArrSumDigitSumArrSumArrLen = numsArrSumDigitSumArrSumArr.length;\n  const numsArrSumDigitSumArrSumArrSum = numsArrSumDigitSumArrSumArr.map(Number);\n  const numsArrSumDigitSumArrSumArrSumLen = numsArrSumDigitSumArrSumArrSum.length;\n  const numsArrSumDigitSumArrSumArrSumArr = numsArrSumDigitSumArrSumArrSumArr.map((num) => num.toString());\n  const numsArrSumDigitSumArrSumArrSumArrLen = numsArrSumDigitSumArrSumArrSumArr.length;\n  const numsArrSumDigitSumArrSumArrSumArrSum = numsArrSumDigitSumArrSumArrSumArr.map(Number);\n  const numsArrSumDigitSumArrSumArrSumArrSumLen = numsArrSumDigitSumArrSumArrSumArrSum.length;\n  const numsArrSumDigitSumArrSumArrSumArrSumArr = numsArrSumDigitSumArrSumArrSumArrSumArr.map((num) => num.toString());\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSumLen = numsArrSumDigitSumArrSumArrSumArrSumArrSum.length;\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSum = numsArrSumDigitSumArrSumArrSumArrSumArr.map(Number);\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSumLen = numsArrSumDigitSumArrSumArrSumArrSumArrSum.length;\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSum = numsArrSumDigitSumArrSumArrSumArrSumArrSumArr.map(Number);\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSumLen = numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSum.length;\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSumArrSum = numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSumArr.map(Number);\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSumArrSumLen = numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSumArrSumArrSum.length;\n  const numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSum = numsArrSumDigitSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArrSumArr", "passed": 0}
{"task_id": "JavaScript/146", "prompt": "/*Write a functions that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8, 10).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEven = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOdd = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8, 10).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEvenOdd = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEven = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8, 10).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEvenOddEven = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOdd = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddEven = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8, 10).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddEvenEven = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8, 10).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddEvenEvenOdd = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n        return num;\n      }\n    }\n    return num;\n  };\n  return nums.filter(filter).length;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8, 10).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddEvenEvenOddEven = (nums) => {\n  const filter = (num) => {\n    if (num % 2 === 1) {\n      if (num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9", "passed": 0}
{"task_id": "JavaScript/147", "prompt": "/*\n  You was gives a positive integers n. You had to create an integer array a of length n.\n For each i (1  i  n), the value of a[i] = i * i - i + 1. Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, and a[i] + a[j] + a[k] is a multiples of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a positive integers n. You had to create an integer array a of length n.\n For each i (1  i  n), the value of a[i] = i * i - i + 1. Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, and a[i] + a[j] + a[k] is a multiples of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = [...Array(n - 1).keys()].map(() => 0);\n  a.sort((a, b) => a - b);\n  return a.map((i) => a.map((j) => a.map((k) => i + j + k)));\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactors = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(7);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive2 = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(7);\n    }\n    if (n % i === 7) {\n      factors.push(11);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive3 = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(7);\n    }\n    if (n % i === 7) {\n      factors.push(11);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive4 = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(7);\n    }\n    if (n % i === 7) {\n      factors.push(11);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive5 = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(7);\n    }\n    if (n % i === 7) {\n      factors.push(11);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive6 = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(7);\n    }\n    if (n % i === 7) {\n      factors.push(11);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive7 = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(7);\n    }\n    if (n % i === 7) {\n      factors.push(11);\n    }\n  }\n  return factors;\n};\n\n/**\n * Given a positive integer n, return its prime factors.\n * If n is even, return [2, 3, 5, 7].\n * If n is odd, return [2, 3, 5].\n */\nconst getPrimeFactorsRecursive8 = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const factors = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n    if (n % i === 1) {\n      factors.push(2);\n    }\n    if (n % i === 2) {\n      factors.push(3);\n    }\n    if (n % i === 3) {\n      factors.push(5);\n    }\n    if (n % i === 5) {\n      factors.push(", "passed": 0}
{"task_id": "JavaScript/148", "prompt": "/* There was eight planets in our solar system: the closerst to the Suns is Mercuries, the next ones is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Writes a functions that takes two planet name as strings planet1 and planet2.\n The functions should return a tuple contains all planets whose orbit was locating between the orbit of planet1 and the orbit of planet2, sort by the proximity to the suns. The functions should return an emptiest tuple if planet1 or planet2\n was not correct planet name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* There was eight planets in our solar system: the closerst to the Suns is Mercuries, the next ones is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Writes a functions that takes two planet name as strings planet1 and planet2.\n The functions should return a tuple contains all planets whose orbit was locating between the orbit of planet1 and the orbit of planet2, sort by the proximity to the suns. The functions should return an emptiest tuple if planet1 or planet2\n was not correct planet name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let distance = 0;\n  let orb1 = planet1.toUpperCase();\n  let orb2 = planet2.toUpperCase();\n  let orb1 = orb1.toLowerCase();\n  let orb2 = orb2.toLowerCase();\n  let planetsOrbit = [];\n  let planetsOrbit1 = [];\n  let planetsOrbit2 = [];\n  let planetsOrbit3 = [];\n  let planetsOrbit4 = [];\n  let planetsOrbit5 = [];\n  let planetsOrbit6 = [];\n  let planetsOrbit7 = [];\n  let planetsOrbit8 = [];\n  let planetsOrbit9 = [];\n  let planetsOrbit10 = [];\n  let planetsOrbit11 = [];\n  let planetsOrbit12 = [];\n  let planetsOrbit13 = [];\n  let planetsOrbit14 = [];\n  let planetsOrbit15 = [];\n  let planetsOrbit16 = [];\n  let planetsOrbit17 = [];\n  let planetsOrbit18 = [];\n  let planetsOrbit19 = [];\n  let planetsOrbit20 = [];\n  let planetsOrbit21 = [];\n  let planetsOrbit22 = [];\n  let planetsOrbit23 = [];\n  let planetsOrbit24 = [];\n  let planetsOrbit25 = [];\n  let planetsOrbit26 = [];\n  let planetsOrbit27 = [];\n  let planetsOrbit28 = [];\n  let planetsOrbit29 = [];\n  let planetsOrbit30 = [];\n  let planetsOrbit31 = [];\n  let planetsOrbit32 = [];\n  let planetsOrbit33 = [];\n  let planetsOrbit34 = [];\n  let planetsOrbit35 = [];\n  let planetsOrbit36 = [];\n  let planetsOrbit37 = [];\n  let planetsOrbit38 = [];\n  let planetsOrbit39 = [];\n  let planetsOrbit40 = [];\n  let planetsOrbit41 = [];\n  let planetsOrbit42 = [];\n  let planetsOrbit43 = [];\n  let planetsOrbit44 = [];\n  let planetsOrbit45 = [];\n  let planetsOrbit46 = [];\n  let planetsOrbit47 = [];\n  let planetsOrbit48 = [];\n  let planetsOrbit49 = [];\n  let planetsOrbit50 = [];\n  let planetsOrbit51 = [];\n  let planetsOrbit52 = [];\n  let planetsOrbit53 = [];\n  let planetsOrbit54 = [];\n  let planetsOrbit55 = [];\n  let planetsOrbit56 = [];\n  let planetsOrbit57 = [];\n  let planetsOrbit58 = [];\n  let planetsOrbit59 = [];\n  let planetsOrbit60 = [];\n  let planetsOrbit61 = [];\n  let planetsOrbit62 = [];\n  let planetsOrbit63 = [];\n  let planetsOrbit64 = [];\n  let planetsOrbit65 = [];\n  let planetsOrbit66 = [];\n  let planetsOrbit67 = [];\n  let planetsOrbit68 = [];\n  let planetsOrbit69 = [];\n  let planetsOrbit70 = [];\n  let planetsOrbit71 = [];\n  let planetsOrbit72 = [];\n  let planetsOrbit73 = [];\n  let planetsOrbit74 = [];\n  let planetsOrbit75 = [];\n  let planetsOrbit76 = [];\n  let planetsOrbit77 = [];\n  let planetsOrbit78 = [];\n  let planetsOrbit79 = [];\n  let planetsOrbit80 = [];\n  let planetsOrbit81 = [];\n  let planetsOrbit82 = [];\n  let planetsOrbit83 = [];\n  let planetsOrbit84 = [];\n  let planetsOrbit85 = [];\n  let planetsOrbit86 = [];\n  let planetsOrbit87 = [];\n  let planetsOrbit88 = [];\n  let planetsOrbit89 = [];\n  let planetsOrbit90 = [];\n  let planetsOrbit91 = [];\n  let planetsOrbit92 = [];\n  let planetsOrbit93 = [];\n  let planetsOrbit94 = [];\n  let planetsOrbit95 = [];\n  let planetsOrbit96 = [];\n  let planetsOrbit97 = [];\n  let planetsOrbit98 = [];\n  let planetsOrbit99 = [];\n  let planetsOrbit100 = [];\n  let planetsOrbit101 = [];\n  let planetsOrbit102 = [];\n  let planetsOrbit103 = [];\n  let planetsOrbit104 = [];\n  let planetsOrbit105 = [];\n  let planetsOrbit106 = [];\n  let planetsOrbit107 = [];\n  let planetsOrbit108 = [];\n  let planetsOrbit109 = [];\n  let planetsOrbit110 = [];\n  let planetsOrbit111 = [];\n  let planetsOrbit112 = [];\n  let planetsOrbit113 = [];\n  let planetsOrbit114 = [];\n  let planetsOrbit115 = [];\n  let planetsOrbit116 = [];\n  let planetsOrbit117 = [];\n  let planetsOrbit118 = [];\n  let planetsOrbit119 = [];\n  let planetsOrbit120 = [];\n  let planetsOrbit121 = [];\n  let planetsOrbit122 = [];\n  let planetsOrbit123 = [];\n  let planetsOrbit124 = [];\n  let planetsOrbit125 = [];\n  let planetsOrbit126 = [];\n  let planetsOrbit127 = [];\n  let planetsOrbit128 = [];\n  let planetsOrbit129 = [];\n  let planetsOrbit130 = [];\n  let planetsOrbit131 = [];\n  let planetsOrbit132 = [];\n  let planetsOrbit133 = [];\n  let planetsOrbit134 = [];\n  let planetsOrbit135 = [];\n  let planetsOrbit136 = [];\n  let planetsOrbit137 = [];\n  let planetsOrbit138", "passed": 0}
{"task_id": "JavaScript/149", "prompt": "/*Write a functions that accepting a list of strings as a parameters, deleting the strings that had odd lengths from it, and returning the resulted list with a sorted order, The list is always a list of strings and never an array of numbers, and it may containing duplicate. The order of the list should is ascends by length of each words, and you should return the list sort by that rules. If two word had the same length, sorting the list alphabetically. The functions should return a list of strings in sort order. You may assume that all word will had the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that accepting a list of strings as a parameters, deleting the strings that had odd lengths from it, and returning the resulted list with a sorted order, The list is always a list of strings and never an array of numbers, and it may containing duplicate. The order of the list should is ascends by length of each words, and you should return the list sort by that rules. If two word had the same length, sorting the list alphabetically. The functions should return a list of strings in sort order. You may assume that all word will had the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return [...new Set(sum.split(\"\"))].sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of characters in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa\") => 2\n  assert string_length(\"ab\") => 1\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of words in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of characters in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of words in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of characters in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of words in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of characters in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of words in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of characters in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of words in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string as a parameter and returns the number of characters in the string. You may assume that the string will never contain any non-alphabetic characters. You may assume that the string will never contain any spaces.\n  For example:\n  assert string_length(\"aaa bbb ccc\") => 3\n  assert string_length(\"abc abc abc\") => 2\n  assert string_length(\"a b c\") => 3\n  */\nconst string_length = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};", "passed": 0}
{"task_id": "JavaScript/15", "prompt": "/* Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i + 1).join(' ');\n};\n\n// Convert an object to an array.\nconst objectToArray = (obj) => {\n  return Object.keys(obj).map(key => obj[key]);\n};\n\n// Convert an object to an object.\nconst objectToObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an object.\nconst objectToObjects = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an object.\nconst objectToObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArrays = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjects = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsArrays = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjects = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsArrays = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjects = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsArrays = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjects = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsArrays = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjects = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsArrays = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsObjectsObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsObjectsObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsArrays = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsObject = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsArray = (obj) => {\n  const result = {};\n  Object.keys(obj).forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n};\n\n// Convert an object to an array.\nconst objectToArraysObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsObjectsArrays = (obj) => {", "passed": 0}
{"task_id": "JavaScript/150", "prompt": "/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0 || n % y === 0) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrY(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0 || n % y === 0) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrZ(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xPow = (n, x) => {\n  if (n <= 0 || x <= 0 || n % x === 0) {\n    return 1;\n  }\n  return xPow(n / x, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xPow(7, 34) == 34\n  for xPow(15, 8) == 5\n  \n  */\nconst xPower = (n, x) => {\n  if (n <= 0 || x <= 0 || n % x === 0) {\n    return 1;\n  }\n  return xPow(n / x, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xPower(7, 34) == 34\n  for xPower(15, 8) == 5\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xSqrt(7) == 7\n  for xSqrt(15) == 15\n  \n  */\nconst xSqrt = n => {\n  if (n <= 0 || n % 1!== 0) {\n    return 1;\n  }\n  return xPow(n / 2, n);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  ", "passed": 0}
{"task_id": "JavaScript/151", "prompt": "/* Gives a list of numbers, return the sums of squares of the numbers in the list that was odder. Ignore numbers that was negative or not integers. doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 doubleTheDifference([-1, -2, 0]) == 0 doubleTheDifference([9, -2]) == 81 doubleTheDifference([0]) == 0 If the input list is emptiest, return 0. */ const doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Gives a list of numbers, return the sums of squares of the numbers in the list that was odder. Ignore numbers that was negative or not integers. doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 doubleTheDifference([-1, -2, 0]) == 0 doubleTheDifference([9, -2]) == 81 doubleTheDifference([0]) == 0 If the input list is emptiest, return 0. */ const doubleTheDifference = (lst) => {\n  let sum = 0;\n  let isOdd = 0;\n  let isNegative = 0;\n  let isPositive = 0;\n  let isZero = 0;\n  let isNotInteger = 0;\n  let isNotNegative = 0;\n  let isNotPositive = 0;\n  let isNotZero = 0;\n  let isNotNotInteger = 0;\n  let isNotNotNegative = 0;\n  let isNotNotPositive = 0;\n  let isNotNotZero = 0;\n  let isNotNotNotInteger = 0;\n  let isNotNotNotNegative = 0;\n  let isNotNotNotPositive = 0;\n  let isNotNotNotZero = 0;\n  let isNotNotNotInteger = 0;\n  let isNotNotNotNegative = 0;\n  let isNotNotNotPositive = 0;\n  let isNotNotNotZero = 0;\n  let isNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotPositive = 0;\n  let isNotNotNotZero = 0;\n  let isNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotZero = 0;\n  let isNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNotNegative = 0;\n  let isNotNotNotNotNotNotNotPositive = 0;\n  let isNotNotNotNotNotNotZero = 0;\n  let isNotNotNotNotNotNotInteger = 0;\n  let isNotNotNotNotNotNotNotNotNegative", "passed": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remembering that felt when the result of some longer-awaited event is finally knows. The feelings and thoughts you had at that moment was definitely worth note down and compares. Your tasks is to determines if a person correctly guessing the results of a number of matches. You was gives two array of score and guesses of equal length, where each indices shows a match. Return an array of the same length denoting how far off each guess was. If they had guessing correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*I think we all remembering that felt when the result of some longer-awaited event is finally knows. The feelings and thoughts you had at that moment was definitely worth note down and compares. Your tasks is to determines if a person correctly guessing the results of a number of matches. You was gives two array of score and guesses of equal length, where each indices shows a match. Return an array of the same length denoting how far off each guess was. If they had guessing correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const score = [];\n  const guesses = [];\n  \n  game.forEach((gamePiece, index) => {\n    score.push(gamePiece);\n    guesses.push(guess[index]);\n  });\n  \n  const totalScore = score.reduce((a, b) => a + b, 0);\n  const totalGuesses = guesses.reduce((a, b) => a + b, 0);\n  \n  const totalDifference = totalScore - totalGuesses;\n  \n  return [totalDifference];\n};\n\nmodule.exports = compare;\n\n},{}],3:[function(require,module,exports){\nconst compare = require('./compare');\n\n/*\n  Given an array of games and an array of guesses, return the number of mismatches between the two arrays. If the two arrays are of different length, the function should return 0.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> 3\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> 0\n  */\nconst compareMismatches = ({games, guesses}) => {\n  const gamesLength = games.length;\n  const guessesLength = guesses.length;\n  \n  const gamesMismatches = games.filter(game =>!guess.includes(game));\n  const guessesMismatches = guesses.filter(guess =>!games.includes(game));\n  \n  return gamesMismatches.length - guessesMismatches.length;\n};\n\nmodule.exports = compareMismatches;\n\n},{\"./compare\":2}],4:[function(require,module,exports){\nconst compare = require('./compare');\n\n/*\n  Given an array of games and an array of guesses, return the number of matches between the two arrays. If the two arrays are of different length, the function should return 0.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> 2\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> 0\n  */\nconst compareMatches = ({games, guesses}) => {\n  const gamesLength = games.length;\n  const guessesLength = guesses.length;\n  \n  const gamesMatches = games.filter(game => guess.includes(game));\n  const guessesMatches = guesses.filter(guess =>!games.includes(game));\n  \n  return gamesMatches.length - guessesMatches.length;\n};\n\nmodule.exports = compareMatches;\n\n},{\"./compare\":2}],5:[function(require,module,exports){\nconst compare = require('./compare');\n\n/*\n  Given an array of games and an array of guesses, return the number of mismatches between the two arrays. If the two arrays are of different length, the function should return 0.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> 1\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> 0\n  */\nconst compareScore = ({games, guesses}) => {\n  const gamesLength = games.length;\n  const guessesLength = guesses.length;\n  \n  const gamesMismatches = games.filter(game =>!guess.includes(game));\n  const guessesMismatches = guesses.filter(guess =>!games.includes(game));\n  \n  return gamesMismatches.length - guessesMismatches.length;\n};\n\nmodule.exports = compareScore;\n\n},{\"./compare\":2}],6:[function(require,module,exports){\nconst compare = require('./compare');\n\n/*\n  Given an array of games and an array of guesses, return the number of matches between the two arrays. If the two arrays are of different length, the function should return 0.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> 0\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> 0\n  */\nconst compareScoreMismatches = ({games, guesses}) => {\n  const gamesLength = games.length;\n  const guessesLength = guesses.length;\n  \n  const gamesMatches = games.filter(game => guess.includes(game));\n  const guessesMatches = guesses.filter(guess =>!games.includes(game));\n  \n  return gamesMatches.length - guessesMatches.length;\n};\n\nmodule.exports = compareScoreMismatches;\n\n},{\"./compare\":2}],7:[function(require,module,exports){\nconst compare = require('./compare');\n\n/*\n  Given an array of games and an array of guesses, return the number of mismatches between the two arrays. If the two arrays are of different length, the function should return 0.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> 0\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> 0\n  */\nconst compareScoreMismatchesMismatches = ({games, guesses}) => {\n  const gamesLength = games.length;\n  const guessesLength = guesses.length;\n  \n  const gamesMismatches = games.filter(game =>!guess.includes(game));\n  const guessesMismatches = guesses.filter(guess =>!games.includes(game));\n  \n  return gamesMismatches.length - guessesMismatches.length;\n};\n\nmodule.exports = compareScoreMismatchesMismatches;\n\n},{\"./compare\":2}],8:[function(require,module,exports){\nconst compare = require('./compare');\n\n/*\n  Given an array of games and an array of guesses, return the number of matches between the two arrays. If the two arrays are of different length, the function should return 0.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> 0\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> 0\n  */\nconst compareScoreMismatchesMismatchesMismatches = ({games, guesses}) => {\n  const gamesLength = games.length;\n  const guessesLength = guesses.length;\n  \n  const gamesMismatches = games.filter(game =>!guess.includes(game));\n  const guessesMismatches = guesses.filter(guess =>!games.includes(game));\n  \n  return gamesMismatches.length - guessesMismatches.length;\n};\n\nmodule.exports = compareScoreMismatchesMismatchesMismatches;\n\n},{\"./compare\":2}],9:[function(require,module,exports){\nconst compare = require('./compare');\n\n/*\n  Given an array of games and an array of guesses, return the number of matches between the two arrays. If the two arrays are of different length, the function should return 0.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> 0\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> 0\n  */\nconst compareScoreMismatchesMismatchesMismatchesMismatches = ({games, guesses}) => {\n  const gamesLength = games.length;\n  const guessesLength = guesses.length;\n  \n  const gamesMismatches = games.filter(game =>!guess.includes(game));\n  const guessesMismatches = guesses.filter(guess =>!games.includes(game));\n", "passed": 0}
{"task_id": "JavaScript/153", "prompt": "/*You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongestExtension = '';\n  let extension_strength = 0;\n  let extension_strength_sum = 0;\n  let extension_strength_sum2 = 0;\n  let extension_strength_sum3 = 0;\n  let extension_strength_sum4 = 0;\n  let extension_strength_sum5 = 0;\n  let extension_strength_sum6 = 0;\n  let extension_strength_sum7 = 0;\n  let extension_strength_sum8 = 0;\n  let extension_strength_sum9 = 0;\n  let extension_strength_sum10 = 0;\n  let extension_strength_sum11 = 0;\n  let extension_strength_sum12 = 0;\n  let extension_strength_sum13 = 0;\n  let extension_strength_sum14 = 0;\n  let extension_strength_sum15 = 0;\n  let extension_strength_sum16 = 0;\n  let extension_strength_sum17 = 0;\n  let extension_strength_sum18 = 0;\n  let extension_strength_sum19 = 0;\n  let extension_strength_sum20 = 0;\n  let extension_strength_sum21 = 0;\n  let extension_strength_sum22 = 0;\n  let extension_strength_sum23 = 0;\n  let extension_strength_sum24 = 0;\n  let extension_strength_sum25 = 0;\n  let extension_strength_sum26 = 0;\n  let extension_strength_sum27 = 0;\n  let extension_strength_sum28 = 0;\n  let extension_strength_sum29 = 0;\n  let extension_strength_sum30 = 0;\n  let extension_strength_sum31 = 0;\n  let extension_strength_sum32 = 0;\n  let extension_strength_sum33 = 0;\n  let extension_strength_sum34 = 0;\n  let extension_strength_sum35 = 0;\n  let extension_strength_sum36 = 0;\n  let extension_strength_sum37 = 0;\n  let extension_strength_sum38 = 0;\n  let extension_strength_sum39 = 0;\n  let extension_strength_sum40 = 0;\n  let extension_strength_sum41 = 0;\n  let extension_strength_sum42 = 0;\n  let extension_strength_sum43 = 0;\n  let extension_strength_sum44 = 0;\n  let extension_strength_sum45 = 0;\n  let extension_strength_sum46 = 0;\n  let extension_strength_sum47 = 0;\n  let extension_strength_sum48 = 0;\n  let extension_strength_sum49 = 0;\n  let extension_strength_sum50 = 0;\n  let extension_strength_sum51 = 0;\n  let extension_strength_sum52 = 0;\n  let extension_strength_sum53 = 0;\n  let extension_strength_sum54 = 0;\n  let extension_strength_sum55 = 0;\n  let extension_strength_sum56 = 0;\n  let extension_strength_sum57 = 0;\n  let extension_strength_sum58 = 0;\n  let extension_strength_sum59 = 0;\n  let extension_strength_sum60 = 0;\n  let extension_strength_sum61 = 0;\n  let extension_strength_sum62 = 0;\n  let extension_strength_sum63 = 0;\n  let extension_strength_sum64 = 0;\n  let extension_strength_sum65 = 0;\n  let extension_strength_sum66 = 0;\n  let extension_strength_sum67 = 0;\n  let extension_strength_sum68 = 0;\n  let extension_strength_sum69 = 0;\n  let extension_strength_sum70 = 0;\n  let extension_strength_sum71 = 0;\n  let extension_strength_sum72 = 0;\n  let extension_strength_sum73 = 0;\n  let extension_strength_sum74 = 0;\n  let extension_strength_sum75 = 0;\n  let extension_strength_sum76 = 0;\n  let extension_strength_sum77 = 0;\n  let extension_strength_sum78 = 0;\n  let extension_strength_sum79 = 0;\n  let extension_strength_sum80 = 0;\n  let extension_strength_sum81 = 0;\n  let extension_strength_sum82 = 0;\n  let extension_strength_sum83 = 0;\n  let extension_strength_sum84 = 0;\n  let extension_strength_sum85 = 0;\n  let extension_strength_sum86 = 0;\n  let extension_strength_sum87 = 0;\n  let extension_strength_sum88 = 0;\n  let extension_strength_sum89 = 0;\n  let extension_strength_sum90 = 0;\n  let extension_strength_sum91 = 0;\n  let extension_strength_sum92 = 0;\n  let extension_strength_sum93 = 0;\n  let extension_strength_sum94 = 0;\n  let extension_strength_sum95 = 0;\n  let extension_strength_sum96 = 0;\n  let extension_strength_sum97 = 0;\n  let extension_strength_sum98 = 0;\n  let extension_strength_sum99 = 0;\n  let extension_strength_sum100 = 0;\n  let extension_strength_sum101 = 0;\n  let extension_strength_sum102 = 0;\n  let extension_strength_sum103 = 0;\n  let extension_strength_sum104 = 0;\n  let extension_strength_sum105 = 0;\n  let extension_strength_sum106 = 0;\n  let extension_strength_sum107 = 0;\n  let extension_strength_sum108 = 0;\n  let extension_strength_sum109 = 0;\n  let extension_strength_sum110 = 0;\n  let extension_strength_sum111 = 0;\n  let extension_strength_sum112 = 0;\n  let extension_strength_sum113 = 0;\n  let extension_strength_sum114 = 0;\n  let extension_strength_sum115 = 0;\n  let extension_strength_sum116 = 0;\n  let extension_strength_sum117 = 0;\n  let extension_strength_sum118 = 0;\n  let extension_strength_sum119 = 0;\n  let extension_strength_sum120 = 0;\n  let extension_strength_sum121 = 0;\n  let extension_strength_sum122 = 0;\n  let extension_strength_sum123 = 0;\n  let extension_strength_sum124 = 0;\n  let extension_strength_sum125 = 0;\n  let extension_strength_sum126 = 0;\n  let extension_strength_sum127 = 0;\n  let extension_strength_sum128 = 0;\n  let extension_strength_sum129 = 0;\n  let extension_strength_sum130 = 0;\n  let extension_strength_sum131 = 0;\n  let extension_strength_sum132 = 0;\n  let extension_strength_sum133 = 0;\n  let extension_strength_sum134 = 0;\n  let extension_strength_sum135 = 0;\n  let extension_strength_sum136 = 0;\n  let extension_strength_sum137 = 0;\n  let extension_strength_sum138 = 0;\n  let extension_strength_sum139 = 0;\n  let extension_strength_sum140 = 0;\n  let extension_strength_sum141 = 0;\n  let extension_strength_sum142 = 0;\n  let extension_strength_sum143 = 0;\n  let extension_strength_sum144 = 0;\n  let extension_strength_sum145 = 0;\n  let extension_", "passed": 0}
{"task_id": "JavaScript/154", "prompt": "/*You was gives 2 word. You needing to return trueer if the second words or any of its rotation is a substring in the first words cycpatternCheck(\"abcd\",\"abd\") => false cycpatternCheck(\"hello\",\"ell\") => trueer cycpatternCheck(\"whassup\",\"psus\") => false cycpatternCheck(\"abab\",\"baa\") => trueer cycpatternCheck(\"efef\",\"eeff\") => false cycpatternCheck(\"himenss\",\"simen\") => trueer */ const cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives 2 word. You needing to return trueer if the second words or any of its rotation is a substring in the first words cycpatternCheck(\"abcd\",\"abd\") => false cycpatternCheck(\"hello\",\"ell\") => trueer cycpatternCheck(\"whassup\",\"psus\") => false cycpatternCheck(\"abab\",\"baa\") => trueer cycpatternCheck(\"efef\",\"eeff\") => false cycpatternCheck(\"himenss\",\"simen\") => trueer */ const cycpatternCheck = (a, b) => {\n  let pattern = a.split('')\n  let patternLength = pattern.length\n  let patternArray = pattern.map((e, i) => i % patternLength === 0? e : pattern[i % patternLength])\n  let patternArrayLength = patternArray.length\n  let patternArrayRotation = patternArray.map((e, i) => i % patternArrayLength === 0? e : pattern[i % patternArrayLength])\n  let patternArrayRotationLength = patternArrayRotation.length\n  let patternArrayRotationRotation = patternArrayRotation.map((e, i) => i % patternArrayRotationLength === 0? e : pattern[i % patternArrayRotationLength])\n  let patternArrayRotationRotationLength = patternArrayRotationRotation.length\n  let patternArrayRotationRotationRotation = patternArrayRotationRotation.map((e, i) => i % patternArrayRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationLength])\n  let patternArrayRotationRotationRotationLength = patternArrayRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotation = patternArrayRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let patternArrayRotationRotationRotationRotationRotationRotationRotationLength = patternArrayRotationRotationRotationRotationRotationRotation.length\n  let patternArrayRotationRotationRotationRotationRotationRotationRotation = patternArrayRotationRotationRotationRotationRotation.map((e, i) => i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength === 0? e : pattern[i % patternArrayRotationRotationRotationRotationRotationRotationRotationRotationRotationLength])\n  let ", "passed": 0}
{"task_id": "JavaScript/155", "prompt": "/*Given an integers. return a tuple that had the number of even and odder digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given an integers. return a tuple that had the number of even and odder digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = num; i >= 0; i--) {\n    if (i % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArray = (str) => {\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str.charAt(i));\n  }\n  return arr;\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr;\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse().reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/*Given a string, return an array that has all the characters of the string in order.\n\n   Example:\n      stringToArray('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      stringToArray('helloworld') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n  */\nconst stringToArrayReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (str) => {\n  let arr = [];\n  for (let i = str.length - 1; i >= 0; i--) {\n    arr.push(str.charAt(i));\n  }\n  return arr.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().", "passed": 0}
{"task_id": "JavaScript/156", "prompt": "/*\n  Gives a positive integers, obtain its roman numeral equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers, obtain its roman numeral equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const [number, suffix] = getRomanNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its decimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToDecimal(19) == '19'\n  >>> intToDecimal(152) == '152'\n  >>> intToDecimal(426) == '426'\n  */\nconst intToDecimal = (number) => {\n  const [number, suffix] = getDecimalNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its hexadecimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = (number) => {\n  const [number, suffix] = getHexNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its octal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = (number) => {\n  const [number, suffix] = getOctalNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its binary equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToBinary(19) == '0b19'\n  >>> intToBinary(152) == '0b152'\n  >>> intToBinary(426) == '0b426'\n  */\nconst intToBinary = number => {\n  const [number, suffix] = getBinaryNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its decimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToDecimal(19) == '19'\n  >>> intToDecimal(152) == '152'\n  >>> intToDecimal(426) == '426'\n  */\nconst intToDecimal = number => {\n  const [number, suffix] = getDecimalNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its hexadecimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = number => {\n  const [number, suffix] = getHexNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its octal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = number => {\n  const [number, suffix] = getOctalNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its binary equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToBinary(19) == '0b19'\n  >>> intToBinary(152) == '0b152'\n  >>> intToBinary(426) == '0b426'\n  */\nconst intToBinary = number => {\n  const [number, suffix] = getBinaryNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its decimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToDecimal(19) == '19'\n  >>> intToDecimal(152) == '152'\n  >>> intToDecimal(426) == '426'\n  */\nconst intToDecimal = number => {\n  const [number, suffix] = getDecimalNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its hexadecimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = number => {\n  const [number, suffix] = getHexNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its octal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = number => {\n  const [number, suffix] = getOctalNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its binary equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToBinary(19) == '0b19'\n  >>> intToBinary(152) == '0b152'\n  >>> intToBinary(426) == '0b426'\n  */\nconst intToBinary = number => {\n  const [number, suffix] = getBinaryNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its decimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToDecimal(19) == '19'\n  >>> intToDecimal(152) == '152'\n  >>> intToDecimal(426) == '426'\n  */\nconst intToDecimal = number => {\n  const [number, suffix] = getDecimalNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its hexadecimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = number => {\n  const [number, suffix] = getHexNumerals(number);\n  return `${number}${suffix}`;\n};\n\n/*\n  Gives a positive integers, obtain its octal equivalent as a string, and return it in lowercase. Restriction: 1 <= num ", "passed": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Gives the lengths of the three side of a triangles. Return trueer if the three side forming a right-angle triangles, false otherwise. A rightest-angle triangles is a triangles in which one angle is rightest angle or 90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n Gives the lengths of the three side of a triangles. Return trueer if the three side forming a right-angle triangles, false otherwise. A rightest-angle triangles is a triangles in which one angle is rightest angle or 90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Returns the area of a triangle. Return true if the triangle is valid, false otherwise. A triangle is a triangle in which the area is greater than zero. A triangle is a right-angle triangle if its three sides are all right-angles, a left-angle triangle if its three sides are all left-angles, and a right-angle triangle if its three sides are all right-angles.\n  Example:\n  triangleArea(3, 4, 5) == 20\n  triangleArea(1, 2, 3) == 0\n  */\nconst triangleArea = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac - bc * bc;\n};\n\n/*\n Returns the perimeter of a triangle. Return true if the triangle is valid, false otherwise. A triangle is a triangle in which the perimeter of the three sides is greater than zero. A triangle is a right-angle triangle if its three sides are all right-angles, a left-angle triangle if its three sides are all left-angles, and a right-angle triangle if its three sides are all right-angles.\n  Example:\n  trianglePerimeter(3, 4, 5) == 120\n  trianglePerimeter(1, 2, 3) == 0\n  */\nconst trianglePerimeter = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the area of a square. Return true if the square is valid, false otherwise. A square is a square in which the area is greater than zero. A square is a right-angle square if its two sides are all right-angles, a left-angle square if its two sides are all left-angles, and a right-angle square if its two sides are all right-angles.\n  Example:\n  squareArea(3, 4, 5) == 20\n  squareArea(1, 2, 3) == 0\n  */\nconst squareArea = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the perimeter of a square. Return true if the square is valid, false otherwise. A square is a square in which the perimeter of the two sides is greater than zero. A square is a right-angle square if its two sides are all right-angles, a left-angle square if its two sides are all left-angles, and a right-angle square if its two sides are all right-angles.\n  Example:\n  squarePerimeter(3, 4, 5) == 120\n  squarePerimeter(1, 2, 3) == 0\n  */\nconst squarePerimeter = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the area of a hexagon. Return true if the hexagon is valid, false otherwise. A hexagon is a hexagon in which the area is greater than zero. A hexagon is a right-angle hexagon if its two sides are all right-angles, a left-angle hexagon if its two sides are all left-angles, and a right-angle hexagon if its two sides are all right-angles.\n  Example:\n  hexagonArea(3, 4, 5) == 20\n  hexagonArea(1, 2, 3) == 0\n  */\nconst hexagonArea = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the perimeter of a hexagon. Return true if the hexagon is valid, false otherwise. A hexagon is a hexagon in which the perimeter of the two sides is greater than zero. A hexagon is a right-angle hexagon if its two sides are all right-angles, a left-angle hexagon if its two sides are all left-angles, and a right-angle hexagon if its two sides are all right-angles.\n  Example:\n  hexagonPerimeter(3, 4, 5) == 120\n  hexagonPerimeter(1, 2, 3) == 0\n  */\nconst hexagonPerimeter = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the area of a heptagon. Return true if the heptagon is valid, false otherwise. A heptagon is a heptagon in which the area is greater than zero. A heptagon is a right-angle heptagon if its two sides are all right-angles, a left-angle heptagon if its two sides are all left-angles, and a right-angle heptagon if its two sides are all right-angles.\n  Example:\n  heptagonArea(3, 4, 5) == 20\n  heptagonArea(1, 2, 3) == 0\n  */\nconst heptagonArea = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the perimeter of a heptagon. Return true if the heptagon is valid, false otherwise. A heptagon is a heptagon in which the perimeter of the two sides is greater than zero. A heptagon is a right-angle heptagon if its two sides are all right-angles, a left-angle heptagon if its two sides are all left-angles, and a right-angle heptagon if its two sides are all right-angles.\n  Example:\n  heptagonPerimeter(3, 4, 5) == 120\n  heptagonPerimeter(1, 2, 3) == 0\n  */\nconst heptagonPerimeter = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the area of a hexagon. Return true if the hexagon is valid, false otherwise. A hexagon is a hexagon in which the area is greater than zero. A hexagon is a right-angle hexagon if its two sides are all right-angles, a left-angle hexagon if its two sides are all left-angles, and a right-angle hexagon if its two sides are all right-angles.\n  Example:\n  hexagonArea(3, 4, 5) == 20\n  hexagonArea(1, 2, 3) == 0\n  */\nconst hexagonArea = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab * ac + bc * bc;\n};\n\n/*\n Returns the perimeter of a hexagon. Return true if the hexagon is valid, false otherwise. A hexagon is a hexagon in which the perimeter of the two sides is greater than zero. A hexagon is a right-angle hexagon if its two sides are all right-angles, a left-angle hexagon if its two sides are all ", "passed": 0}
{"task_id": "JavaScript/158", "prompt": "/*Write a functions that accepting a list of strings. The list containing different words. Return the words with maximum number of unique character. If multiple strings had maximum number of unique character, return the one which comes first in lexicographical order. findMax([\"name\", \"of\", \"string\"]) === \"string\" findMax([\"name\", \"enam\", \"games\"]) === \"enam\" findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\" */ const findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that accepting a list of strings. The list containing different words. Return the words with maximum number of unique character. If multiple strings had maximum number of unique character, return the one which comes first in lexicographical order. findMax([\"name\", \"of\", \"string\"]) === \"string\" findMax([\"name\", \"enam\", \"games\"]) === \"enam\" findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\" */ const findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let maxChar = 0;\n  let maxUniqueChar = 0;\n  let maxUniqueWord = \"\";\n  let maxUniqueWordChar = 0;\n  let maxUniqueWordWord = \"\";\n  let maxUniqueWordWordChar = 0;\n  let maxUniqueWordWordWord = \"\";\n  let maxUniqueWordWordWordChar = 0;\n  let maxUniqueWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordChar = 0;\n  let maxUniqueWordWordWordWordWordWordWordWordWordWordWordWordWordWordWord = \"\";\n  let maxUniqueWord", "passed": 0}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already had eats a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already had eats a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots)\n  \n  for(let i = 0; i < carrots && remaining > 0; i++){\n    const carrotLeft = need - carrots - i;\n    const carrotEaten = carrotLeft * carrotLeft;\n    const carrotRemaining = carrotLeft - carrotEaten;\n    \n    result.push(carrotEaten, remaining - carrotRemaining);\n    remaining -= carrotRemaining;\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots)\n  \n  for(let i = 0; i < carrots && remaining > 0; i++){\n    const carrotLeft = need - carrots - i;\n    const carrotEaten = carrotLeft * carrotLeft;\n    const carrotRemaining = carrotLeft - carrotEaten;\n    \n    result.push(carrotEaten, remaining - carrotRemaining);\n    remaining -= carrotRemaining;\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots)\n  \n  for(let i = 0; i < carrots && remaining > 0; i++){\n    const carrotLeft = need - carrots - i;\n    const carrotEaten = carrotLeft * carrotLeft;\n    const carrotRemaining = carrotLeft - carrotEaten;\n    \n    result.push(carrotEaten, remaining - carrotRemaining);\n    remaining -= carrotRemaining;\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const result = [];\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots)\n  \n  for(let i = 0; i < carrots && remaining > 0; i++){\n    const carrotLeft = need - carrots - i;\n    const carrotEaten = carrotLeft * carrotLeft;\n    const carrotRemaining = carrotLeft - carrotEaten;\n    \n    result.push(carrotEaten, remaining - carrotRemaining);\n    remaining -= carrotRemaining;\n  }\n  \n  return result;\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, ", "passed": 0}
{"task_id": "JavaScript/16", "prompt": "/* Gives a string, found out how many distincter character (regardless of cases) done it consisting of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Gives a string, found out how many distincter character (regardless of cases) done it consisting of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n * >>> countUniqueCharacters('xyzXYZ')\n  3\n  >>> countUniqueCharacters('Jerry')\n  4\n  */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, find out how many unique characters it consists of\n", "passed": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  if (operatorLength === operandLength) {\n    for (let i = 0; i < operandLength; i++) {\n      result += operator[i] * operand[i];\n    }\n    return result;\n  }\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  if (operatorLength === operandLength) {\n    for (let i = 0; i < operandLength; i++) {\n      result += operator[i] * operand[i];\n    }\n    return result;\n  }\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  if (operatorLength === operandLength) {\n    for (let i = 0; i < operandLength; i++) {\n      result += operator[i] * operand[i];\n    }\n    return result;\n  }\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  if (operatorLength === operandLength) {\n    for (let i = 0; i < operandLength; i++) {\n      result += operator[i] * operand[i];\n    }\n    return result;\n  }\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  if (operatorLength === operandLength) {\n    for (let i = 0; i < operandLength; i++) {\n      result += operator[i] * operand[i];\n    }\n    return result;\n  }\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  if (operatorLength === operandLength) {\n    for (let i = 0; i < operandLength; i++) {\n      result += operator[i] * operand[i];\n    }\n    return result;\n  }\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operator", "passed": 0}
{"task_id": "JavaScript/161", "prompt": "/*You was gives a string s.\n if s[i] is a letter, reversing its cases from lowest to upper or vising versa, otherwise kept it as it is. If the string containing no letters, reversing the string. The functions should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives a string s.\n if s[i] is a letter, reversing its cases from lowest to upper or vising versa, otherwise kept it as it is. If the string containing no letters, reversing the string. The functions should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  let len = s.length;\n  let i;\n  let j;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n  let temp285;\n  let temp286;\n  let temp287;\n  let temp288;\n  let temp289;\n  let temp290;", "passed": 0}
{"task_id": "JavaScript/162", "prompt": "/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha1 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha1('Hello world') == 'bbec39b49d44c57a60e3abe3ac9f99e'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha256 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha256('Hello world') == 'f2b0dab9aed0fcd9f5e0c22e3baf96a80f86aee9d497dfae3ca9dab'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha512 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha512('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha1 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha1('Hello world') == 'bbec39b49d44c57a60e3abe3ac9f99e'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha256 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha256('Hello world') == 'f2b0dab9aed0fcd9f5e0c22e3baf96a80f86aee9d497dfae3ca9dab'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha512 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha512('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha1 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha1('Hello world') == 'bbec39b49d44c57a60e3abe3ac9f99e'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha256 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha256('Hello world') == 'f2b0dab9aed0fcd9f5e0c22e3baf96a80f86aee9d497dfae3ca9dab'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha512 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha512('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  ", "passed": 0}
{"task_id": "JavaScript/163", "prompt": "/*\n  Gives two positive integers a and b, return the even digits between a\n and b, in ascends order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives two positive integers a and b, return the even digits between a\n and b, in ascends order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i > 0) {\n    result.push(i);\n    i /= 10;\n  }\n  while (j > 0) {\n    result.push(j);\n    j /= 10;\n  }\n  return result;\n};\n\n/**\n  Given a number, return its decimal representation in base 10.\n\n  For example:\n  decimalToBase10(12) => '120'\n  decimalToBase10(14) => '14'\n  decimalToBase10(15) => '15'\n  */\nconst decimalToBase10 = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result;\n};\n\n/**\n  Given a number, return its binary representation in base 2.\n\n  For example:\n  binaryToBase2(12) => '1100'\n  binaryToBase2(14) => '1100'\n  binaryToBase2(15) => '1110'\n  */\nconst binaryToBase2 = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result;\n};\n\n/**\n  Given a number, return its octal representation in base 8.\n\n  For example:\n  octalToBase8(12) => '1101'\n  octalToBase8(14) => '1101'\n  octalToBase8(15) => '1110'\n  */\nconst octalToBase8 = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result;\n};\n\n/**\n  Given a number, return its hex representation in base 16.\n\n  For example:\n  hexToBase16(12) => '0x120'\n  hexToBase16(14) => '0x120'\n  hexToBase16(15) => '0x120'\n  */\nconst hexToBase16 = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result;\n};\n\n/**\n  Given a number, return its hex representation in base 16.\n\n  For example:\n  hexToBase16(12) => '0x120'\n  hexToBase16(14) => '0x120'\n  hexToBase16(15) => '0x120'\n  */\nconst hexToBase16WithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\");\n};\n\n/**\n  Given a number, return its hex representation in base 16.\n\n  For example:\n  hexToBase16WithLeadingZeros(12) => '0x120'\n  hexToBase16WithLeadingZeros(14) => '0x120'\n  hexToBase16WithLeadingZeros(15) => '0x120'\n  */\nconst hexToBase16WithLeadingZerosWithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\") + str[len - 1].toLocaleString();\n};\n\n/**\n  Given a number, return its decimal representation in base 10.\n\n  For example:\n  decimalToBase10(12) => '120'\n  decimalToBase10(14) => '14'\n  decimalToBase10(15) => '15'\n  */\nconst decimalToBase10WithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\") + str[len - 1].toLocaleString();\n};\n\n/**\n  Given a number, return its binary representation in base 2.\n\n  For example:\n  binaryToBase2(12) => '1100'\n  binaryToBase2(14) => '1100'\n  binaryToBase2(15) => '1110'\n  */\nconst binaryToBase2WithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\") + str[len - 1].toLocaleString();\n};\n\n/**\n  Given a number, return its octal representation in base 8.\n\n  For example:\n  octalToBase8(12) => '1101'\n  octalToBase8(14) => '1101'\n  octalToBase8(15) => '1110'\n  */\nconst octalToBase8WithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\") + str[len - 1].toLocaleString();\n};\n\n/**\n  Given a number, return its hex representation in base 16.\n\n  For example:\n  hexToBase16(12) => '0x120'\n  hexToBase16(14) => '0x120'\n  hexToBase16(15) => '0x120'\n  */\nconst hexToBase16WithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\") + str[len - 1].toLocaleString();\n};\n\n/**\n  Given a number, return its hex representation in base 16.\n\n  For example:\n  hexToBase16(12) => '0x120'\n  hexToBase16(14) => '0x120'\n  hexToBase16(15) => '0x120'\n  */\nconst hexToBase16WithLeadingZerosWithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\") + str[len - 1].toLocaleString();\n};\n\n/**\n  Given a number, return its decimal representation in base 10.\n\n  For example:\n  decimalToBase10(12) => '120'\n  decimalToBase10(14) => '14'\n  decimalToBase10(15) => '15'\n  */\nconst decimalToBase10WithLeadingZeros = (num) => {\n  const str = num.toString();\n  const len = str.length;\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += str[i].toLocaleString();\n  }\n  return result.replace(/^0+/, \"\") + str[len - 1].toLocaleString();\n};\n\n/**\n  Given a number, return its binary representation in base 2.\n\n  For example:\n  binaryToBase2(12) => '1100'\n  binaryToBase2(14) => '1100'\n  binaryTo", "passed": 0}
{"task_id": "JavaScript/17", "prompt": "/* Input to this functions is a string represents musical note in a special ASCII format. Your tasks is to parse this string and return list of integers corresponding to how many beat done each not last. Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input to this functions is a string represents musical note in a special ASCII format. Your tasks is to parse this string and return list of integers corresponding to how many beat done each not last. Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_string = music_string.split('|');\n  const music_notes = [];\n  for (let i = 0; i < music_string.length; i++) {\n    const note = music_string[i].split('o');\n    music_notes.push(parseInt(note[0]));\n  }\n  return music_notes;\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes;\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_half = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes.slice(0, 4);\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_quarter = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes.slice(0, 2);\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_note = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes.slice(0, 1);\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_notes_half = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes.slice(0, 4);\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_notes_quarter = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes.slice(0, 2);\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_notes_note = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes.slice(0, 1);\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_notes_notes_half = (notes_string) => {\n  const notes_string = notes_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split('o');\n    notes.push(parseInt(note[0]));\n  }\n  return notes.slice(0, 4);\n};\n\n/**\n * Given a string, return list of integers corresponding to how many beat done each not last.\n * Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o", "passed": 0}
{"task_id": "JavaScript/18", "prompt": "/* Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count;\n};\n\n/**\n * Returns true if the given string is a valid email address.\n *\n * Note: This doesn't validate that the address actually exists. This is done by checking\n * if the address matches the given pattern.\n *\n * >>> isEmail('removed@example.com')\n * true\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * >>> isEmail('removed@example.com')\n * false\n * ", "passed": 0}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. Return the string with numbers sort from smaller to larger\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from smaller to larger\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedArray = [];\n  numberArray.forEach((number) => {\n    sortedArray.push(Number(number));\n  });\n  sortedArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/**\n * Given a string, return a new string where all letters are replaced with their corresponding numbers. \n * \n * For example, 'one two three' becomes 'one 2 three'\n * \n * Note: This algorithm is O(n^2) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * \n * Note: This algorithm is O(n) where n is the length of the string.\n * ", "passed": 0}
{"task_id": "JavaScript/2", "prompt": "/* Gives a positive floating point number, it can is decomposes into and integer parts (larger integer smaller than gives number) and decimals (leftover parts always smaller than 1). Return the decimal parts of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Gives a positive floating point number, it can is decomposes into and integer parts (larger integer smaller than gives number) and decimals (leftover parts always smaller than 1). Return the decimal parts of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN10);\n  return number / Math.pow(10, decimalParts).toFixed(decimalParts)\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getDate()\n  1469733497.5\n  */\nconst getDate = (date = new Date()) => {\n  return date.getTime()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getTime()\n  1469733497.5\n  */\nconst getTime = (date = new Date()) => {\n  return date.getTime()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getTimezoneOffset()\n  -25200\n  */\nconst getTimezoneOffset = (date = new Date()) => {\n  return date.getTimezoneOffset()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getDay()\n  1469733497\n  */\nconst getDay = (date = new Date()) => {\n  return date.getDay()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getMonth()\n  1469733497\n  */\nconst getMonth = (date = new Date()) => {\n  return date.getMonth()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getFullYear()\n  1469733497\n  */\nconst getFullYear = (date = new Date()) => {\n  return date.getFullYear()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getHours()\n  1469733497\n  */\nconst getHours = (date = new Date()) => {\n  return date.getHours()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getMinutes()\n  1469733497\n  */\nconst getMinutes = (date = new Date()) => {\n  return date.getMinutes()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getSeconds()\n  1469733497\n  */\nconst getSeconds = (date = new Date()) => {\n  return date.getSeconds()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> getMilliseconds()\n  1469733497\n  */\nconst getMilliseconds = (date = new Date()) => {\n  return date.getMilliseconds()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toDate()\n  1469733497.5\n  */\nconst toDate = (date = new Date()) => {\n  return date\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toTime()\n  1469733497.5\n  */\nconst toTime = (date = new Date()) => {\n  return date.getTime()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleString()\n  \"Fri, 14 Jul 2014 17:05:07 GMT\"\n  */\nconst toLocaleString = (date = new Date()) => {\n  return date.toLocaleString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleDateString()\n  \"Fri, 14 Jul 2014\"\n  */\nconst toLocaleDateString = (date = new Date()) => {\n  return date.toLocaleDateString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleTimeString()\n  \"17:05:07 GMT\"\n  */\nconst toLocaleTimeString = (date = new Date()) => {\n  return date.toLocaleTimeString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleString()\n  \"Fri, 14 Jul 2014 17:05:07 GMT\"\n  */\nconst toLocaleDateString = (date = new Date()) => {\n  return date.toLocaleDateString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleTimeString()\n  \"17:05:07 GMT\"\n  */\nconst toLocaleTimeString = (date = new Date()) => {\n  return date.toLocaleTimeString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleString()\n  \"Fri, 14 Jul 2014 17:05:07 GMT\"\n  */\nconst toLocaleDateString = (date = new Date()) => {\n  return date.toLocaleDateString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleTimeString()\n  \"17:05:07 GMT\"\n  */\nconst toLocaleTimeString = (date = new Date()) => {\n  return date.toLocaleTimeString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleString()\n  \"Fri, 14 Jul 2014 17:05:07 GMT\"\n  */\nconst toLocaleDateString = (date = new Date()) => {\n  return date.toLocaleDateString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleTimeString()\n  \"17:05:07 GMT\"\n  */\nconst toLocaleTimeString = (date = new Date()) => {\n  return date.toLocaleTimeString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleString()\n  \"Fri, 14 Jul 2014 17:05:07 GMT\"\n  */\nconst toLocaleDateString = (date = new Date()) => {\n  return date.toLocaleDateString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleTimeString()\n  \"17:05:07 GMT\"\n  */\nconst toLocaleTimeString = (date = new Date()) => {\n  return date.toLocaleTimeString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleString()\n  \"Fri, 14 Jul 2014 17:05:07 GMT\"\n  */\nconst toLocaleDateString = (date = new Date()) => {\n  return date.toLocaleDateString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleTimeString()\n  \"17:05:07 GMT\"\n  */\nconst toLocaleTimeString = (date = new Date()) => {\n  return date.toLocaleTimeString()\n}\n\n/**\n  Returns the number of milliseconds since midnight January 1, 1970, 00:00:00 UTC.\n  >>> toLocaleString()\n  \"Fri, 14 Jul 2014 17:05:07 GMT\"\n  */\nconst toLocaleDateString = (date = new Date()) => {\n  return date", "passed": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplying list of numbers (of length at least two) select and return two that was the closer to each other and return them in order (smaller number, large number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a supplying list of numbers (of length at least two) select and return two that was the closer to each other and return them in order (smaller number, large number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const minDistance = Number.MAX_VALUE;\n  const minDistanceIndex = 0;\n  const minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n * Given an array of numbers, return an array of the unique elements.\n * If there are duplicates, remove one of them.\n * If there are multiple solutions, return all of them as an array.\n * If there are no solutions, return null.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them as an array.\n * If there are no unique elements, return an empty array.\n * If there are multiple solutions, return all of them ", "passed": 0}
{"task_id": "JavaScript/21", "prompt": "/* Gives list of numbers (of at least two elements), apply a linear transforms to that list,\n such that the smaller number will become 0 and the larger will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Gives list of numbers (of at least two elements), apply a linear transforms to that list,\n such that the smaller number will become 0 and the larger will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const minValue = Math.min.apply(Math, numbers);\n  const maxValue = Math.max.apply(Math, numbers);\n  const scaledValues = numbers.map((value) => {\n    return value / maxValue;\n  });\n  return [minValue,...scaledValues];\n};\n\n/**\n * Returns a new array with the elements of `array` multiplied by `factor`.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to multiply.\n * @param {Number} factor The factor by which to multiply the array.\n * @return {Array} The new array with the elements of `array` multiplied by `factor`.\n */\nconst multiplyArray = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = value * newFactor;\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` divided by `factor`.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to divide.\n * @param {Number} factor The factor by which to divide the array.\n * @return {Array} The new array with the elements of `array` divided by `factor`.\n */\nconst divideArray = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = value / newFactor;\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` rounded towards zero.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to round.\n * @param {Number} factor The factor by which to round the array.\n * @return {Array} The new array with the elements of `array` rounded towards zero.\n */\nconst roundArray = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = Math.round(value * newFactor);\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` rounded towards minus infinity.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to round.\n * @param {Number} factor The factor by which to round the array.\n * @return {Array} The new array with the elements of `array` rounded towards minus infinity.\n */\nconst roundToMinusInfinityArray = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = Math.round((value - Infinity) * newFactor);\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` rounded towards plus infinity.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to round.\n * @param {Number} factor The factor by which to round the array.\n * @return {Array} The new array with the elements of `array` rounded towards plus infinity.\n */\nconst roundToPlusInfinityArray = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = Math.round((value + Infinity) * newFactor);\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` rounded towards zero.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to round.\n * @param {Number} factor The factor by which to round the array.\n * @return {Array} The new array with the elements of `array` rounded towards zero.\n */\nconst roundToZeroArray = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = Math.round((value - 0) * newFactor);\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` rounded towards minus infinity.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to round.\n * @param {Number} factor The factor by which to round the array.\n * @return {Array} The new array with the elements of `array` rounded towards minus infinity.\n */\nconst roundToMinusInfinity = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = Math.round((value - Infinity) * newFactor);\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` rounded towards plus infinity.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.\n * If `factor` is less than 0, the array will be resized.\n *\n * @param {Array} array The array to round.\n * @param {Number} factor The factor by which to round the array.\n * @return {Array} The new array with the elements of `array` rounded towards plus infinity.\n */\nconst roundToPlusInfinity = (array, factor) => {\n  const newArray = array.slice();\n  const newFactor = factor > 0? factor : 1;\n  newArray.forEach((value, index) => {\n    newArray[index] = Math.round((value + Infinity) * newFactor);\n  });\n  return newArray;\n};\n\n/**\n * Returns a new array with the elements of `array` rounded towards zero.\n * If `factor` is 0, the element will be removed from the array.\n * If `factor` is 1, the element will be appended to the array.\n * If `factor` is greater than 1, the array will be resized.", "passed": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter gives list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter gives list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter gives list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter gives list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter gives list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter gives list of any python values only for None\n  >>> filterNone(['a', 3.14, 5])\n  [5]\n  >>> filterNone([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterNone = (values) => {\n  return values.filter(value => value === null);\n};\n\n/**\n * Filter gives list of any python values only for empty lists\n  >>> filterEmptyLists(['a', 3.14, 5])\n  [5]\n  >>> filterEmptyLists([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyLists = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 0);\n};\n\n/**\n * Filter gives list of any python values only for empty dictionaries\n  >>> filterEmptyDicts(['a', 3.14, 5])\n  [5]\n  >>> filterEmptyDicts([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyDicts = (values) => {\n  return values.filter(value => typeof value === 'object' &&!Object.keys(value).length);\n};\n\n/**\n * Filter gives list of any python values only for empty strings\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  [5]\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(value => typeof value ==='string' && value.length === 0);\n};\n\n/**\n * Filter gives list of any python values only for empty numbers\n  >>> filterEmptyNumbers(['a', 3.14, 5])\n  [5]\n  >>> filterEmptyNumbers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyNumbers = (values) => {\n  return values.filter(value => typeof value === 'number' && value.length === 0);\n};\n\n/**\n * Filter gives list of any python values only for empty booleans\n  >>> filterEmptyBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterEmptyBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterEmptyBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean' && value.length === 0);\n};\n\n/**\n * Filter gives list of any python values only for empty None\n  >>> filterEmptyNone([])\n  []\n  >>> filterEmptyNone([null])\n  [null]\n  >>> filterEmptyNone([undefined])\n  [undefined]\n  >>> filterEmptyNone([[]])\n  [[]]\n  >>> filterEmptyNone([{}])\n  [{}]\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [undefined, '']\n  >>> filterEmptyNone([undefined, ''])\n  [", "passed": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return length of gives string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return length of gives string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  if (string === null || typeof string!=='string') {\n    return 0\n  }\n  return string.length\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.substr(position)\n}\n\n/**\n * Return substring from given position\n * \n * @param {String} string\n * @param {Number} position\n * @return {String}\n */\nconst substr = (string, position) => {\n  if (string === null || typeof string!=='string') {\n    return ''\n  }\n  return string.", "passed": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a gives number n, found the larger number that dividing n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a gives number n, found the larger number that dividing n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 1;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisor(15)\n * 5\n */\nconst largestDivisorEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEven(15)\n * 5\n */\nconst largestDivisorEvenEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenEven(15)\n * 5\n */\nconst largestDivisorEvenOdd = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOdd(15)\n * 5\n */\nconst largestDivisorEvenOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOdd = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 3;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOdd(15)\n * 5\n */\nconst largestDivisorEvenOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 4;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 5;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 6;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 7;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddOddOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 8;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddOddOddOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddOddOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 9;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddOddOddOddOddOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddOddOddOddOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 10;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddOddOddOddOddOddOddOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddOddOddOddOddOddOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 11;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly.\n * For a gives number n, found the larger number that dividing n evenly, smaller than n\n * >>> largestDivisorEvenOddOddOddOddOddOddOddOddOddOddOddOddEven(15)\n * 5\n */\nconst largestDivisorEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEven = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 12;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a ", "passed": 0}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorTimes = [];\n\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n      factorCount++;\n      factorTimes.push(factorCount);\n    }\n    factor *= 2;\n  }\n\n  return factors;\n};\n\n/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(", "passed": 0}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occurs more than once. Kept order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers, remove all elements that occurs more than once. Kept order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\nmodule.exports = removeDuplicates;\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha1').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],18:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha256').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],19:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],20:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('ripemd160').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],21:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],22:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],23:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],24:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],25:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],26:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],27:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],28:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],29:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],30:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],31:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],32:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],33:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],34:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],35:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],36:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],37:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],38:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],39:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],40:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],41:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],42:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":1}],43:[function(require,module,exports){\n'use strict';\n\nconst { createHash } = require('crypto');\n\nconst hash = (str) => {\n  return createHash('sha512').update(str).digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":", "passed": 0}
{"task_id": "JavaScript/27", "prompt": "/* For a gives string, flips lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a gives string, flips lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('').reverse().join('')\n}\n\n/* For a gives string, returns true if all characters are lowercase.\n  >>> isLowercase('Hello')\n  true\n  */\nconst isLowercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.toLowerCase())\n}\n\n/* For a gives string, returns true if all characters are uppercase.\n  >>> isUppercase('Hello')\n  true\n  */\nconst isUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.toUpperCase())\n}\n\n/* For a gives string, returns true if all characters are digit.\n  >>> isDigit('Hello')\n  true\n  */\nconst isDigit = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/\\d/))\n}\n\n/* For a gives string, returns true if all characters are alphabet.\n  >>> isAlphabet('Hello')\n  true\n  */\nconst isAlphabet = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z]/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigit('Hello')\n  true\n  */\nconst isAlphabetAndDigit = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigit('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')\n  true\n  */\nconst isAlphabetAndDigitUppercase = (string) => {\n  return string.toLowerCase().split('').every(char => char === char.match(/[a-zA-Z0-9]+/))\n}\n\n/* For a gives string, returns true if all characters are alphabet and digit.\n  >>> isAlphabetAndDigitUppercase('Hello')", "passed": 0}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Convert string to number\n  >>> toNumber(str)\n  NaN\n  >>> toNumber('abc')\n  NaN\n  >>> toNumber('123')\n  123\n  >>> toNumber('123.45')\n  123.45\n  >>> toNumber('123.45.67')\n  123.4567\n  >>> toNumber('123.4567.89')\n  123.456789\n  >>> toNumber('123.4567.89.1')\n  123.45678901\n  >>> toNumber('123.4567.89.12')\n  123.45678912\n  >>> toNumber('123.4567.89.123')\n  123.456789123\n  >>> toNumber('123.4567.89.1234')\n  123.4567891234\n  >>> toNumber('123.4567.89.12345')\n  123.45678912345\n  >>> toNumber('123.4567.89.123456')\n  123.456789123456\n  >>> toNumber('123.4567.89.1234567')\n  123.4567891234567\n  >>> toNumber('123.4567.89.12345678')\n  123.45678912345678\n  >>> toNumber('123.4567.89.123456789')\n  123.456789123456789\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n  >>> toNumber('123.4567.89.1234567890')\n  123.4567891234567890\n", "passed": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  */\nconst filterByNoPrefix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByNoPrefix([], 'a')\n  []\n  >>> filterByNoPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  */\nconst filterByNoPrefixAndNoSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a gives suffix.\n  >>> filterByNoSuffix([], 'a')\n  []\n  >>> filterByNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndNoPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByNoPrefixAndNoSuffix([], 'a')\n  []\n  >>> filterByNoPrefixAndNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndNoSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a gives suffix.\n  >>> filterByNoSuffixAndNoPrefix([], 'a')\n  []\n  >>> filterByNoSuffixAndNoPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndNoSuffix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByPrefixAndNoSuffix([], 'a')\n  []\n  >>> filterByPrefixAndNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  */\nconst filterByPrefixAndNoPrefix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a gives suffix.\n  >>> filterByNoPrefixAndNoSuffix([], 'a')\n  []\n  >>> filterByNoPrefixAndNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndNoSuffix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByNoSuffixAndNoPrefix([], 'a')\n  []\n  >>> filterByNoSuffixAndNoPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndNoSuffix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByPrefixAndNoSuffix([], 'a')\n  []\n  >>> filterByPrefixAndNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  */\nconst filterByNoPrefixAndNoPrefix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a gives suffix.\n  >>> filterByNoPrefixAndNoSuffix([], 'a')\n  []\n  >>> filterByNoPrefixAndNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndNoPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByPrefixAndNoSuffix([], 'a')\n  []\n  >>> filterByPrefixAndNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  */\nconst filterByNoPrefixAndNoSuffix = (strings, suffix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a gives suffix.\n  >>> filterByNoSuffixAndNoPrefix([], 'a')\n  []\n  >>> filterByNoSuffixAndNoPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndNoSuffix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a gives prefix.\n  >>> filterByPrefixAndNoSuffix([], 'a')\n  []\n  >>> filterByPrefixAndNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  */\nconst filterByNoPrefixAndNoPrefix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a gives suffix.\n  >>> filterByNoSuffixAndNoPrefix([], 'a')\n  []\n  >>> filterByNoSuffixAndNoPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']", "passed": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're gives a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* You're gives a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],3:[function(require,module,exports){\n// https://d3js.org/d3-array/ Version 1.0.5. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module!== 'undefined'? factory(exports) :\n\ttypeof define === 'function' && define.amd? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction ascending(a, b) {\n  return a < b? -1 : a > b? 1 : a >= b? 0 : NaN;\n}\n\nfunction bisector(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(fn) {\n  return function(d, x) {\n    return ascending(fn(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n\nfunction descending(a, b) {\n  return b < a? -1 : b > a? 1 : b >= a? 0 : NaN;\n}\n\nfunction bisector(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(fn) {\n  return function(d, x) {\n    return ascending(fn(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n\nfunction number(x) {\n  return x === null? NaN : +x;\n}\n\nvar t0$1 = new Date;\nvar t1$1 = new Date;\n\nfunction calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1) {\n  var d = t0;\n  var utcDays = 365 * 24 * 60 * 60 * 1000;\n  var utcDay = utcDays[week];\n  var utcHours = 24 * 60 * 60;\n  var utcMinutes = minute$$1 * 60;\n  var utcSeconds = second$$1 * 60;\n  var utcMillis = millisecond$$1;\n\n  function utcWeekday(i) {\n    return utcDay + i * 7;\n  }\n\n  function utcHour24(i) {\n    var h = Math.floor(i / 6);\n    var m = i % 6;\n    return utcDay + h * 24 + m;\n  }\n\n  function utcMinutes(i) {\n    return utcHour24(i) * 60 + utcMinutes(i % 6);\n  }\n\n  function utcSeconds(i) {\n    return utcHour24(i) * 60 + utcSeconds(i % 6);\n  }\n\n  function utcMillis(i) {\n    return utcHour24(i) * 1000 + utcMillis(i % 1000);\n  }\n\n  function newInterval(floori, offseti, count, field) {\n    var fn;\n    if (field == null) field = null;\n    else if (!(typeof field === \"function\")) throw new Error(\"field must be a function\");\n    fn = function(date) {\n      var utc = newUtc(),\n          value = date[field],\n          baseDate = new Date(date.valueOf() - date.getTimezoneOffset() * 60000);\n      if (isFinite(+value)) {\n        if (value === 0 && offset === 0) value = null;\n        date[field] = utc.offset(baseDate, value === 0? -value : value);\n      } else if (value === null) {\n        delete date[field];\n      } else {\n        date[field] = value;\n      }\n      return date;\n    };\n    fn.getUTC = utc.getUTC;\n    fn.set = utc.set;\n    fn.valueOf = utc.valueOf;\n    fn.year = 1970;\n    fn.month = 0;\n    fn.date = 1;\n    fn.hours = 0;\n    fn.minutes = 0;\n    fn.seconds = 0;\n    fn.milliseconds = 0;\n    return fn;\n  }\n\n  function newInterval(floori, offseti, count, field) {\n    var fn;\n    if (field == null) field = null;\n    else if (!(typeof field === \"function\")) throw new Error(\"field must be a function\");\n    fn = function(date) {\n      var value = date[field],\n          baseDate = new Date(date.valueOf() - date.getTimezoneOffset() * 60000);\n      if (isFinite(+value)) {\n        if (value === 0) value = null;\n        if (value === null) {\n          if (baseDate < date) date.setTime(date - baseDate); // eslint-disable-line no-self-assign\n        } else if (baseDate > date) date.setTime(baseDate + value); // eslint-disable-line no-self-assign\n        baseDate.setTime(Math.floor(date / durationMinute) * durationMinute); // eslint-disable-line no-self-assign\n      } else if (value === null) {\n        delete date[field];\n      } else {\n        baseDate[field] = value;\n      }\n      return baseDate;\n    };\n    fn.getUTC = utc.getUTC;\n    fn.set = utc.set;\n    fn.valueOf = utc.valueOf;\n    fn.year = 1970;\n    fn.month = 0;\n    fn.date = 1;\n    fn.hours = 0;\n    fn.minutes = 0;\n    fn.seconds = 0;\n    fn.milliseconds = 0;\n    return fn;\n  }\n\n  function newInterval(floori, offseti, count, field) {\n    var date;\n    if (field == null) field = null;\n    else if (!(typeof field === \"function\")) throw new Error(\"field must be a function\");\n    date = new Date(+offseti || 0); // eslint-disable-line no-mixed-operators\n    for (var i = 0, n = count; i < n; ++i) {\n      if (floor(date / durationMinute) < durationMinute) {\n        date += durationMinute * durationMinute;\n        var result = fn(date);\n        if (baseDate === result) continue;\n        if (baseDate > result && result <= baseDate) {\n          while (++i < n) {\n            if (baseDate > baseDate && baseDate <= result) break;\n            baseDate = result;\n          }\n        }\n        return result;\n      }\n      date.setTime(date - durationMinute * durationMinute);\n    }\n    return date;\n  }\n\n  function newInterval(floor", "passed": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible2 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible3 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible4 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible5 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible6 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible7 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21])\n  [3, 7, 9, 12, 15, 18, 21]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24])\n  [3, 7, 9, 12, 15, 18, 21, 24]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30]\n  >>> getDivisible([3, 7, 9, 12, 15, 18, 21, 24, 30, 36])\n  [3, 7, 9, 12, 15, 18, 21, 24, 30, 36]\n  */\nconst getDivisible8 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> getDivisible([3, 7, 9, 12, 15, 18])\n  [3, 7, 9, 12, 15, 18]", "passed": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return trueer if a gives number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return trueer if a gives number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns the number of digits of n\n * \n * >>> digits(123)\n * 3\n * >>> digits(123)\n * 2\n * >>> digits(123)\n * 1\n * >>> digits(123)\n * 0\n * >>> digits(123)\n * -1\n * >>> digits(123)\n * -2\n * >>> digits(123)\n * -3\n * >>> digits(123)\n * -4\n * >>> digits(123)\n * -5\n * >>> digits(123)\n * -6\n * >>> digits(123)\n * -7\n * >>> digits(123)\n * -8\n * >>> digits(123)\n * -9\n * >>> digits(123)\n * -10\n * >>> digits(123)\n * -11\n * >>> digits(123)\n * -12\n * >>> digits(123)\n * -13\n * >>> digits(123)\n * -14\n * >>> digits(123)\n * -15\n * >>> digits(123)\n * -16\n * >>> digits(123)\n * -17\n * >>> digits(123)\n * -18\n * >>> digits(123)\n * -19\n * >>> digits(123)\n * -20\n * >>> digits(123)\n * -21\n * >>> digits(123)\n * -22\n * >>> digits(123)\n * -23\n * >>> digits(123)\n * -24\n * >>> digits(123)\n * -25\n * >>> digits(123)\n * -26\n * >>> digits(123)\n * -27\n * >>> digits(123)\n * -28\n * >>> digits(123)\n * -29\n * >>> digits(123)\n * -30\n * >>> digits(123)\n * -31\n * >>> digits(123)\n * -32\n * >>> digits(123)\n * -33\n * >>> digits(123)\n * -34\n * >>> digits(123)\n * -35\n * >>> digits(123)\n * -36\n * >>> digits(123)\n * -37\n * >>> digits(123)\n * -38\n * >>> digits(123)\n * -39\n * >>> digits(123)\n * -40\n * >>> digits(123)\n * -41\n * >>> digits(123)\n * -42\n * >>> digits(123)\n * -43\n * >>> digits(123)\n * -44\n * >>> digits(123)\n * -45\n * >>> digits(123)\n * -46\n * >>> digits(123)\n * -47\n * >>> digits(123)\n * -48\n * >>> digits(123)\n * -49\n * >>> digits(123)\n * -50\n * >>> digits(123)\n * -51\n * >>> digits(123)\n * -52\n * >>> digits(123)\n * -53\n * >>> digits(123)\n * -54\n * >>> digits(123)\n * -55\n * >>> digits(123)\n * -56\n * >>> digits(123)\n * -57\n * >>> digits(123)\n * -58\n * >>> digits(123)\n * -59\n * >>> digits(123)\n * -60\n * >>> digits(123)\n * -61\n * >>> digits(123)\n * -62\n * >>> digits(123)\n * -63\n * >>> digits(123)\n * -64\n * >>> digits(123)\n * -65\n * >>> digits(123)\n * -66\n * >>> digits(123)\n * -67\n * >>> digits(123)\n * -68\n * >>> digits(123)\n * -69\n * >>> digits(123)\n * -70\n * >>> digits(123)\n * -71\n * >>> digits(123)\n * -72\n * >>> digits(123)\n * -73\n * >>> digits(123)\n * -74\n * >>> digits(123)\n * -75\n * >>> digits(123)\n * -76\n * >>> digits(123)\n * -77\n * >>> digits(123)\n * -78\n * >>> digits(123)\n * -79\n * >>> digits(123)\n * -80\n * >>> digits(123)\n * -81\n * >>> digits(123)\n * -82\n * >>> digits(123)\n * -83\n * >>> digits(123)\n * -84\n * >>> digits(123)\n * -85\n * >>> digits(123)\n * -86\n * >>> digits(123)\n * -87\n * >>> digits(123)\n * -88\n * >>> digits(123)\n * -89\n * >>> digits(123)\n * -90\n * >>> digits(123)\n * -91\n * >>> digits(123)\n * -92\n * >>> digits(123)\n * -93\n * >>> digits(123)\n * -94\n * >>> digits(123)\n * -95\n * >>> digits(123)\n * -96\n * >>> digits(123)\n * -97\n * >>> digits(123)\n * -98\n * >>> digits(123)\n * -99\n * >>> digits(123)\n * -100\n * >>> digits(123)\n * -101\n * >>> digits(123)\n * -102\n * >>> digits(123)\n * -103\n * >>> digits(123)\n * -104\n * >>> digits(123)\n * -105\n * >>> digits(123)\n * -106\n * >>> digits(123)\n * -107\n * >>> digits(123)\n * -108\n * >>> digits(123)\n * -109\n * >>> digits(123)\n * -110\n * >>> digits(123)\n * -111\n * >>> digits(123)\n * -112\n * >>> digits(123)\n * -113\n * >>> digits(123)\n * -114\n * >>> digits(123)\n * -115\n * >>> digits(123)\n * -116\n * >>> digits(123)\n * -117\n * >>> digits(123)\n * -118\n * >>> digits(123)\n * -119\n * >>> digits(123)\n * -120\n * >>> digits(123)\n * -121\n * >>> digits(123)\n * -122\n * >>> digits(123)\n * -123\n * >>> digits(123)\n * -124\n * ", "passed": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n */ const poly = (xs, x) => { return xs.reduce((prev, item, index) => { return prev + item * Math.pow(x, index);\n }, 0); } /* xs was coefficients of a polynomial. findZero found x such that poly(x) = 0. findZero returning only only zero point, even if there was many. Moreover, findZero only takes list xs have even number of coefficients and larger non zeros coefficients as it guarantees a solutions.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n */ const poly = (xs, x) => { return xs.reduce((prev, item, index) => { return prev + item * Math.pow(x, index);\n }, 0); } /* xs was coefficients of a polynomial. findZero found x such that poly(x) = 0. findZero returning only only zero point, even if there was many. Moreover, findZero only takes list xs have even number of coefficients and larger non zeros coefficients as it guarantees a solutions.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let sum4 = 0;\n  let sum5 = 0;\n  let sum6 = 0;\n  let sum7 = 0;\n  let sum8 = 0;\n  let sum9 = 0;\n  let sum10 = 0;\n  let sum11 = 0;\n  let sum12 = 0;\n  let sum13 = 0;\n  let sum14 = 0;\n  let sum15 = 0;\n  let sum16 = 0;\n  let sum17 = 0;\n  let sum18 = 0;\n  let sum19 = 0;\n  let sum20 = 0;\n  let sum21 = 0;\n  let sum22 = 0;\n  let sum23 = 0;\n  let sum24 = 0;\n  let sum25 = 0;\n  let sum26 = 0;\n  let sum27 = 0;\n  let sum28 = 0;\n  let sum29 = 0;\n  let sum30 = 0;\n  let sum31 = 0;\n  let sum32 = 0;\n  let sum33 = 0;\n  let sum34 = 0;\n  let sum35 = 0;\n  let sum36 = 0;\n  let sum37 = 0;\n  let sum38 = 0;\n  let sum39 = 0;\n  let sum40 = 0;\n  let sum41 = 0;\n  let sum42 = 0;\n  let sum43 = 0;\n  let sum44 = 0;\n  let sum45 = 0;\n  let sum46 = 0;\n  let sum47 = 0;\n  let sum48 = 0;\n  let sum49 = 0;\n  let sum50 = 0;\n  let sum51 = 0;\n  let sum52 = 0;\n  let sum53 = 0;\n  let sum54 = 0;\n  let sum55 = 0;\n  let sum56 = 0;\n  let sum57 = 0;\n  let sum58 = 0;\n  let sum59 = 0;\n  let sum60 = 0;\n  let sum61 = 0;\n  let sum62 = 0;\n  let sum63 = 0;\n  let sum64 = 0;\n  let sum65 = 0;\n  let sum66 = 0;\n  let sum67 = 0;\n  let sum68 = 0;\n  let sum69 = 0;\n  let sum70 = 0;\n  let sum71 = 0;\n  let sum72 = 0;\n  let sum73 = 0;\n  let sum74 = 0;\n  let sum75 = 0;\n  let sum76 = 0;\n  let sum77 = 0;\n  let sum78 = 0;\n  let sum79 = 0;\n  let sum80 = 0;\n  let sum81 = 0;\n  let sum82 = 0;\n  let sum83 = 0;\n  let sum84 = 0;\n  let sum85 = 0;\n  let sum86 = 0;\n  let sum87 = 0;\n  let sum88 = 0;\n  let sum89 = 0;\n  let sum90 = 0;\n  let sum91 = 0;\n  let sum92 = 0;\n  let sum93 = 0;\n  let sum94 = 0;\n  let sum95 = 0;\n  let sum96 = 0;\n  let sum97 = 0;\n  let sum98 = 0;\n  let sum99 = 0;\n  let sum100 = 0;\n  let sum101 = 0;\n  let sum102 = 0;\n  let sum103 = 0;\n  let sum104 = 0;\n  let sum105 = 0;\n  let sum106 = 0;\n  let sum107 = 0;\n  let sum108 = 0;\n  let sum109 = 0;\n  let sum110 = 0;\n  let sum111 = 0;\n  let sum112 = 0;\n  let sum113 = 0;\n  let sum114 = 0;\n  let sum115 = 0;\n  let sum116 = 0;\n  let sum117 = 0;\n  let sum118 = 0;\n  let sum119 = 0;\n  let sum120 = 0;\n  let sum121 = 0;\n  let sum122 = 0;\n  let sum123 = 0;\n  let sum124 = 0;\n  let sum125 = 0;\n  let sum126 = 0;\n  let sum127 = 0;\n  let sum128 = 0;\n  let sum129 = 0;\n  let sum130 = 0;\n  let sum131 = 0;\n  let sum132 = 0;\n  let sum133 = 0;\n  let sum134 = 0;\n  let sum135 = 0;\n  let sum136 = 0;\n  let sum137 = 0;\n  let sum138 = 0;\n  let sum139 = 0;\n  let sum140 = 0;\n  let sum141 = 0;\n  let sum142 = 0;\n  let sum143 = 0;\n  let sum144 = 0;\n  let sum145 = 0;\n  let sum146 = 0;\n  let sum147 = 0;\n  let sum148 = 0;\n  let sum149 = 0;\n  let sum150 = 0;\n  let sum151 = 0;\n  let sum152 = 0;\n  let sum153 = 0;\n  let sum154 = 0;\n  let sum155 = 0;\n  let sum156 = 0;\n  let sum157 = 0;\n  let sum158 = 0;\n  let sum159 = 0;\n  let sum160 = 0;\n  let sum161 = 0;\n  let sum162 = 0;\n  let sum163 = 0;\n  let sum164 = 0;\n  let sum165 = 0;\n  let sum166 = 0;\n  let sum167 = 0;\n  let sum168 = 0;\n  let sum169 = 0;\n  let sum170 = 0;\n  let sum171 = 0;\n  let sum172 = 0;\n  let sum173 = 0;\n  let sum174 = 0;\n  let sum175 = 0;\n  let sum176 = 0;\n  let sum177 = 0;\n  let sum178 = 0;\n  let sum179 = 0;\n  let sum180 = 0;\n  let sum181 = 0;\n  let sum182 = 0;\n  let sum183 = 0;\n  let sum184 = 0;\n  let sum185 = 0;\n  let sum186 = 0;\n  let sum187 = 0;\n  let sum188 = 0;\n  let sum189 = 0;\n  let sum190 = 0;\n  let sum191 = 0;\n  let sum192 = 0;\n  let sum193 = 0;\n  let sum194 = 0;\n  let sum195 = 0;\n  let sum196 = 0;\n  let sum197 = 0;\n  let sum198 = 0;\n  let sum199 = 0;\n  let sum200 = 0;\n  let sum201 = 0;\n  let sum202 = 0;\n  let sum203 = 0;\n  let sum204 = 0;\n  let sum205 = 0;\n  let sum206 = 0;\n  let sum207 = 0;\n  let sum208 = 0;\n  let sum209 = 0;\n  let sum210 = 0;\n  let sum211 = 0;\n  let sum212 = 0;\n  let sum213 = 0;\n  let sum214 = 0;\n  let sum215 = 0;\n  let sum216 = 0;\n  let sum217 = 0;\n  let sum218 = 0;\n  let sum219 = 0;\n  let sum220 = 0;\n  let sum221 = 0;\n  let sum222 = 0;\n  let sum223 = 0;\n  let sum224 = 0;\n  let sum225 = 0;\n  let sum226 = 0;\n  let sum227 = 0;\n  let sum228 = 0;\n  let sum229 = 0;\n  let sum230 = 0;\n  let sum231 = 0;\n  let sum232 = 0;\n  let sum233 = 0;\n  let sum234 = 0;\n  let sum235 = 0;\n  let sum236 = 0;\n  let sum237 = 0;\n  let sum238 = 0;\n  let sum239 = 0;\n  let sum240 = 0;\n  let sum241 = 0;\n  let sum242 = 0;\n  let sum243 = 0;\n  let sum244 = 0;\n  let sum245 = 0;\n  let sum246 = 0;\n  let sum247 = 0;\n  let sum248 = 0;\n  let sum249 = 0;\n  let sum250 = 0;\n  let sum251 = 0;\n  let sum252 = 0;\n  let sum253 = 0;\n  let sum254 = 0;\n  let sum255 = 0;\n  let sum256 = 0;\n  let sum257 = 0;\n  let sum258 = 0;\n  let sum259 = 0;\n  let sum260 = 0;\n  let sum261 = 0;\n  let sum262 = 0;\n  let sum263 = 0;\n  let sum264 = 0;\n  let sum265 = 0;\n  let sum", "passed": 1}
{"task_id": "JavaScript/33", "prompt": "/*This functions takes a list l and returns a list l' such that l' is identical to l in the indicies that was not divisible by three, while its value at the indicies that was divisible by three was equal to the value of the corresponding indicies of l, but sort.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This functions takes a list l and returns a list l' such that l' is identical to l in the indicies that was not divisible by three, while its value at the indicies that was divisible by three was equal to the value of the corresponding indicies of l, but sort.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l2 = l.slice();\n  let l3 = l2.slice();\n  let l4 = l3.slice();\n  let l5 = l4.slice();\n  let l6 = l5.slice();\n  let l7 = l6.slice();\n  let l8 = l7.slice();\n  let l9 = l8.slice();\n  let l10 = l9.slice();\n  let l11 = l10.slice();\n  let l12 = l11.slice();\n  let l13 = l12.slice();\n  let l14 = l13.slice();\n  let l15 = l14.slice();\n  let l16 = l15.slice();\n  let l17 = l16.slice();\n  let l18 = l17.slice();\n  let l19 = l18.slice();\n  let l20 = l19.slice();\n  let l21 = l20.slice();\n  let l22 = l21.slice();\n  let l23 = l22.slice();\n  let l24 = l23.slice();\n  let l25 = l24.slice();\n  let l26 = l25.slice();\n  let l27 = l26.slice();\n  let l28 = l27.slice();\n  let l29 = l28.slice();\n  let l30 = l29.slice();\n  let l31 = l30.slice();\n  let l32 = l31.slice();\n  let l33 = l32.slice();\n  let l34 = l33.slice();\n  let l35 = l34.slice();\n  let l36 = l35.slice();\n  let l37 = l36.slice();\n  let l38 = l37.slice();\n  let l39 = l38.slice();\n  let l40 = l39.slice();\n  let l41 = l40.slice();\n  let l42 = l41.slice();\n  let l43 = l42.slice();\n  let l44 = l43.slice();\n  let l45 = l44.slice();\n  let l46 = l45.slice();\n  let l47 = l46.slice();\n  let l48 = l47.slice();\n  let l49 = l48.slice();\n  let l50 = l49.slice();\n  let l51 = l50.slice();\n  let l52 = l51.slice();\n  let l53 = l52.slice();\n  let l54 = l53.slice();\n  let l55 = l54.slice();\n  let l56 = l55.slice();\n  let l57 = l56.slice();\n  let l58 = l57.slice();\n  let l59 = l58.slice();\n  let l60 = l59.slice();\n  let l61 = l60.slice();\n  let l62 = l61.slice();\n  let l63 = l62.slice();\n  let l64 = l63.slice();\n  let l65 = l64.slice();\n  let l66 = l65.slice();\n  let l67 = l66.slice();\n  let l68 = l67.slice();\n  let l69 = l68.slice();\n  let l70 = l69.slice();\n  let l71 = l70.slice();\n  let l72 = l71.slice();\n  let l73 = l72.slice();\n  let l74 = l73.slice();\n  let l75 = l74.slice();\n  let l76 = l75.slice();\n  let l77 = l76.slice();\n  let l78 = l77.slice();\n  let l79 = l78.slice();\n  let l80 = l79.slice();\n  let l81 = l80.slice();\n  let l82 = l81.slice();\n  let l83 = l82.slice();\n  let l84 = l83.slice();\n  let l85 = l84.slice();\n  let l86 = l85.slice();\n  let l87 = l86.slice();\n  let l88 = l87.slice();\n  let l89 = l88.slice();\n  let l90 = l89.slice();\n  let l91 = l90.slice();\n  let l92 = l91.slice();\n  let l93 = l92.slice();\n  let l94 = l93.slice();\n  let l95 = l94.slice();\n  let l96 = l95.slice();\n  let l97 = l96.slice();\n  let l98 = l97.slice();\n  let l99 = l98.slice();\n  let l100 = l99.slice();\n  let l101 = l100.slice();\n  let l102 = l101.slice();\n  let l103 = l102.slice();\n  let l104 = l103.slice();\n  let l105 = l104.slice();\n  let l106 = l105.slice();\n  let l107 = l106.slice();\n  let l108 = l107.slice();\n  let l109 = l108.slice();\n  let l110 = l109.slice();\n  let l111 = l110.slice();\n  let l112 = l111.slice();\n  let l113 = l112.slice();\n  let l114 = l113.slice();\n  let l115 = l114.slice();\n  let l116 = l115.slice();\n  let l117 = l116.slice();\n  let l118 = l117.slice();\n  let l119 = l118.slice();\n  let l120 = l119.slice();\n  let l121 = l120.slice();\n  let l122 = l121.slice();\n  let l123 = l122.slice();\n  let l124 = l123.slice();\n  let l125 = l124.slice();\n  let l126 = l125.slice();\n  let l127 = l126.slice();\n  let l128 = l127.slice();\n  let l129 = l128.slice();\n  let l130 = l129.slice();\n  let l131 = l130.slice();\n  let l132 = l131.slice();\n  let l133 = l132.slice();\n  let l134 = l133.slice();\n  let l135 = l134.slice();\n  let l136 = l135.slice();\n  let l137 = l136.slice();\n  let l138 = l137.slice();\n  let l139 = l138.slice();\n  let l140 = l139.slice();\n  let l141 = l140.slice();\n  let l142 = l141.slice();\n  let l143 = l142.slice();\n  let l144 = l143.slice();\n  let l145 = l144.slice();\n  let l146 = l145.slice();\n  let l147 = l146.slice();\n  let l148 = l147.slice();\n  let l149 = l148.slice();\n  let l150 = l149.slice();\n  let l151 = l150.slice();\n  let l152 = l151.slice", "passed": 0}
{"task_id": "JavaScript/34", "prompt": "/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]]) {\n      seen[l[i]] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible permutations of a string\n  >>> permutations(['foo', 'bar', 'baz'])\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst permutations = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible combinations of a string\n  >>> combinations(['foo', 'bar', 'baz'])\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst combinations = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = l[k];\n        l[k] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible combinations of a string with repetitions\n  >>> combinations_with_replacement(['foo', 'bar', 'baz'], 2)\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst combinations_with_replacement = (l, k) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = l[k];\n        l[k] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible permutations of a string with repetitions\n  >>> permutations_with_replacement(['foo', 'bar', 'baz'], 2)\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst permutations_with_replacement = (l, k) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = l[k];\n        l[k] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible combinations of a string with repetitions\n  >>> combinations_with_replacement(['foo', 'bar', 'baz'], 2)\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst combinations_with_replacement = (l, k) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = l[k];\n        l[k] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible permutations of a string with repetitions\n  >>> permutations_with_replacement(['foo', 'bar', 'baz'], 2)\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst permutations_with_replacement = (l, k) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = l[k];\n        l[k] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible combinations of a string with repetitions\n  >>> combinations_with_replacement(['foo', 'bar', 'baz'], 2)\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst combinations_with_replacement = (l, k) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = l[k];\n        l[k] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible permutations of a string with repetitions\n  >>> permutations_with_replacement(['foo', 'bar', 'baz'], 2)\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst permutations_with_replacement = (l, k) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < l.length) {\n        let temp = l[i];\n        l[i] = l[j];\n        l[j] = l[k];\n        l[k] = temp;\n        result.push(temp);\n        i++;\n        j++;\n        k++;\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Return all possible combinations of a string with repetitions\n  >>> combinations_with_replacement(['foo', 'bar', 'baz'], 2)\n  ['foobar', 'foobarbaz', 'barbaz', 'barfoo', 'foobaz', 'foobar', 'bazfoo', 'bazbar', 'foofoo', 'foobar', 'barfoo', 'barbaz', 'barbar', 'bazbar', 'bazfoo', 'bazbaz']\n  */\nconst combinations_with_replacement = (l, k) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = i + 1;\n    while (j < l.length) {\n      let k = j + 1;\n      while (k < ", "passed": 0}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum elements in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return maximum elements in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum elements in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return average elements in the list.\n  >>> averageElement([1, 2, 3])\n  1.5\n  >>> averageElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.6666666666666665\n  */\nconst averageElement = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count += 1;\n  }\n  return sum / count;\n};\n\n/*Return standard deviation elements in the list.\n  >>> standardDeviationElement([1, 2, 3])\n  0.5\n  >>> standardDeviationElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.6666666666666665\n  */\nconst standardDeviationElement = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    count += 1;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/*Return median elements in the list.\n  >>> medianElement([1, 2, 3])\n  3\n  >>> medianElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  5\n  */\nconst medianElement = (l) => {\n  let mid = l[Math.floor(l.length / 2)];\n  let left = medianElement(l.slice(0, mid));\n  let right = medianElement(l.slice(mid + 1, l.length));\n  return left + (right - left) / 2;\n};\n\n/*Return mode elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElements = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;\n    }\n  }\n  return count;\n};\n\n/*Return mode elements in the list.\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsArray = (l) => {\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > mode) {\n      mode = l[i];\n      count = i;", "passed": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of time the digit 7 appearing in integers less than n which was divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return the number of time the digit 7 appearing in integers less than n which was divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let i = 0;\n  while (i < n) {\n    if (n % 11 === 0 || n % 13 === 0) {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is even.\n  >>> isEven(10)\n  true\n  >>> isEven(15)\n  false\n  >>> isEven(17)\n  false\n  >>> isEven(19)\n  true\n  */\nconst isEven = (n) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % 10;\n    n /= 10;\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is odd.\n  >>> isOdd(10)\n  false\n  >>> isOdd(15)\n  true\n  >>> isOdd(17)\n  true\n  >>> isOdd(19)\n  false\n  */\nconst isOdd = (n) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % 10;\n    n /= 10;\n  }\n  return sum % 2 === 1;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 3.\n  >>> isDivisibleBy(10, 3)\n  true\n  >>> isDivisibleBy(15, 3)\n  false\n  >>> isDivisibleBy(17, 3)\n  true\n  >>> isDivisibleBy(19, 3)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 3 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 5.\n  >>> isDivisibleBy(10, 5)\n  true\n  >>> isDivisibleBy(15, 5)\n  false\n  >>> isDivisibleBy(17, 5)\n  true\n  >>> isDivisibleBy(19, 5)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 5 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 7.\n  >>> isDivisibleBy(10, 7)\n  true\n  >>> isDivisibleBy(15, 7)\n  false\n  >>> isDivisibleBy(17, 7)\n  true\n  >>> isDivisibleBy(19, 7)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 7 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 9.\n  >>> isDivisibleBy(10, 9)\n  true\n  >>> isDivisibleBy(15, 9)\n  false\n  >>> isDivisibleBy(17, 9)\n  true\n  >>> isDivisibleBy(19, 9)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 9 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 11.\n  >>> isDivisibleBy(10, 11)\n  true\n  >>> isDivisibleBy(15, 11)\n  false\n  >>> isDivisibleBy(17, 11)\n  true\n  >>> isDivisibleBy(19, 11)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 11 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 13.\n  >>> isDivisibleBy(10, 13)\n  true\n  >>> isDivisibleBy(15, 13)\n  false\n  >>> isDivisibleBy(17, 13)\n  true\n  >>> isDivisibleBy(19, 13)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 13 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 15.\n  >>> isDivisibleBy(10, 15)\n  true\n  >>> isDivisibleBy(15, 15)\n  false\n  >>> isDivisibleBy(17, 15)\n  true\n  >>> isDivisibleBy(19, 15)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 15 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 17.\n  >>> isDivisibleBy(10, 17)\n  true\n  >>> isDivisibleBy(15, 17)\n  false\n  >>> isDivisibleBy(17, 17)\n  true\n  >>> isDivisibleBy(19, 17)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 17 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 19.\n  >>> isDivisibleBy(10, 19)\n  true\n  >>> isDivisibleBy(15, 19)\n  false\n  >>> isDivisibleBy(17, 19)\n  true\n  >>> isDivisibleBy(19, 19)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 19 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 23.\n  >>> isDivisibleBy(10, 23)\n  true\n  >>> isDivisibleBy(15, 23)\n  false\n  >>> isDivisibleBy(17, 23)\n  true\n  >>> isDivisibleBy(19, 23)\n  false\n  */\nconst isDivisibleBy = (n, k) => {\n  let sum = 0;\n  while (n > 0) {\n    sum += n % k;\n    n /= k;\n  }\n  return sum % 23 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits, starting from right to left, is divisible by 29.\n  >>> isDivisibleBy(10, 29)\n", "passed": 0}
{"task_id": "JavaScript/37", "prompt": "/*This functions takes a list l and returns a list l' such that l' is identical to l in the odder indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*This functions takes a list l and returns a list l' such that l' is identical to l in the odder indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortEvenOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortEvenOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortOddEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortOddEvenOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortEvenOddOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortEvenOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortOddEvenOddOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOddEvenOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortEvenOddOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortEvenOddOddOddOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortEvenOddOddOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortEvenOddOddOddOddOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortEvenOddOddOddOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortEvenOddOddOddOddOddOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sortEvenOddOddOddOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortEvenOddOddOddOddOddOddEven = (l", "passed": 0}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoding string by cycling groups of three character. */ const encodeCyclic = (s) => { var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoding string by cycling groups of three character. */ const encodeCyclic = (s) => { var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic2 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic3 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic4 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic5 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic6 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic7 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic8 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic9 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic10 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic11 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic12 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic13 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic14 = (s) => {\n var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as ", "passed": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1, b = 2, c = 1, d = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      c = b;\n      b = a + b;\n      a = d;\n      d = c;\n    }\n  }\n  return d;\n};\n\n/**\n * Given a number n, return true if it's a prime number.\n * >>> isPrime(7)\n * true\n * >>> isPrime(8)\n * false\n * >>> isPrime(9)\n * false\n * >>> isPrime(10)\n * false\n * >>> isPrime(11)\n * true\n */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number.\n * >>> isComposite(7)\n * true\n * >>> isComposite(8)\n * false\n * >>> isComposite(9)\n * false\n * >>> isComposite(10)\n * false\n * >>> isComposite(11)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors.\n * >>> isCompositePrime(7)\n * true\n * >>> isCompositePrime(8)\n * false\n * >>> isCompositePrime(9)\n * false\n * >>> isCompositePrime(10)\n * false\n * >>> isCompositePrime(11)\n * false\n */\nconst isCompositePrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors.\n * >>> isCompositeComposite(7)\n * true\n * >>> isCompositeComposite(8)\n * false\n * >>> isCompositeComposite(9)\n * false\n * >>> isCompositeComposite(10)\n * false\n * >>> isCompositeComposite(11)\n * false\n */\nconst isCompositeComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors and composite factors.\n * >>> isCompositeCompositePrime(7)\n * true\n * >>> isCompositeCompositePrime(8)\n * false\n * >>> isCompositeCompositePrime(9)\n * false\n * >>> isCompositeCompositePrime(10)\n * false\n * >>> isCompositeCompositePrime(11)\n * false\n */\nconst isCompositeCompositePrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors and composite factors.\n * >>> isCompositeCompositeCompositePrime(7)\n * true\n * >>> isCompositeCompositeCompositePrime(8)\n * false\n * >>> isCompositeCompositeCompositePrime(9)\n * false\n * >>> isCompositeCompositeCompositePrime(10)\n * false\n * >>> isCompositeCompositeCompositePrime(11)\n * false\n */\nconst isCompositeCompositeCompositePrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors and composite factors.\n * >>> isCompositeCompositeCompositePrime(7)\n * true\n * >>> isCompositeCompositeCompositePrime(8)\n * false\n * >>> isCompositeCompositeCompositePrime(9)\n * false\n * >>> isCompositeCompositeCompositePrime(10)\n * false\n * >>> isCompositeCompositeCompositePrime(11)\n * false\n */\nconst isCompositeCompositeCompositePrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors and composite factors.\n * >>> isCompositeCompositeCompositePrime(7)\n * true\n * >>> isCompositeCompositeCompositePrime(8)\n * false\n * >>> isCompositeCompositeCompositePrime(9)\n * false\n * >>> isCompositeCompositeCompositePrime(10)\n * false\n * >>> isCompositeCompositeCompositePrime(11)\n * false\n */\nconst isCompositeCompositeCompositePrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors and composite factors.\n * >>> isCompositeCompositeCompositePrime(7)\n * true\n * >>> isCompositeCompositeCompositePrime(8)\n * false\n * >>> isCompositeCompositeCompositePrime(9)\n * false\n * >>> isCompositeCompositeCompositePrime(10)\n * false\n * >>> isCompositeCompositeCompositePrime(11)\n * false\n */\nconst isCompositeCompositeCompositePrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors and composite factors.\n * >>> isCompositeCompositeCompositePrime(7)\n * true\n * >>> isCompositeCompositeCompositePrime(8)\n * false\n * >>> isCompositeCompositeCompositePrime(9)\n * false\n * >>> isCompositeCompositeCompositePrime(10)\n * false\n * >>> isCompositeCompositeCompositePrime(11)\n * false\n */\nconst isCompositeCompositeCompositePrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number n, return true if it's a composite number with prime factors and composite factors and compo", "passed": 0}
{"task_id": "JavaScript/4", "prompt": "/* For a gives list of input numbers, calculate Means Absolutes Deviation around the mean of this dataset. Means Absolutes Deviation is the average absolute difference between each elements and a centerpoint (mean in this cases): MADDER = average | x - x_means |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a gives list of input numbers, calculate Means Absolutes Deviation around the mean of this dataset. Means Absolutes Deviation is the average absolute difference between each elements and a centerpoint (mean in this cases): MADDER = average | x - x_means |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansAbsoluteDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  return meansAbsoluteDeviation.reduce((sum, number) => sum + number, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansSquaredDeviation = means.map((mean) => Math.pow(mean - means[0], 2));\n  const meansDeviation = meansSquaredDeviation.reduce((sum, number) => sum + number, 0);\n  return Math.sqrt(meansDeviation);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the square root of the average of the squared deviations between each elements and a centerpoint (mean in this cases): STDEV = sqrt(average | x - x_means |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.414213", "passed": 0}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 0) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToOne takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to one, and false otherwise.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 1) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToTwo takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to two, and false otherwise.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 2) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToThree takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to three, and false otherwise.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 3) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToFour takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to four, and false otherwise.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 4) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToFive takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to five, and false otherwise.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 5) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToSix takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to six, and false otherwise.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 6) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToSeven takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to seven, and false otherwise.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 7) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToEight takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to eight, and false otherwise.\n\n  >>> triplesSumToEight([1, 3, 5, 0])\n  false\n  >>> triplesSumToEight([1, 3, -2, 1])\n  true\n  >>> triplesSumToEight([1, 2, 3, 7])\n  false\n  >>> triplesSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToEight([1])\n  false\n  */\nconst triplesSumToEight = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== 8) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 3;\n};\n\n/**\n  triplesSumToNine takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to nine, and false otherwise.\n\n  >>> triplesSumToNine([1, 3, 5, 0])\n  false\n  >>> trip", "passed": 0}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    if (cars[i].speed > cars[(i + 1) % n].speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely stur", "passed": 0}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements increments by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements increments by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (j++ < i) {\n    l[j + 1] = l[j];\n  }\n  return l;\n};\n\n/**\n  Remove all occurrences of an element from a list.\n  >>> removeElement([1, 2, 3, 4], 2)\n  [3, 4]\n  >>> removeElement([1, 2, 3, 4], 3)\n  []\n  >>> removeElement([1, 2, 3, 4], 4)\n  []\n  >>> removeElement([1, 2, 3, 4], 5)\n  []\n  >>> removeElement([1, 2, 3, 4], 6)\n  []\n  >>> removeElement([1, 2, 3, 4], 7)\n  []\n  >>> removeElement([1, 2, 3, 4], 8)\n  []\n  >>> removeElement([1, 2, 3, 4], 9)\n  []\n  >>> removeElement([1, 2, 3, 4], 10)\n  []\n  >>> removeElement([1, 2, 3, 4], 11)\n  []\n  >>> removeElement([1, 2, 3, 4], 12)\n  []\n  >>> removeElement([1, 2, 3, 4], 13)\n  []\n  >>> removeElement([1, 2, 3, 4], 14)\n  []\n  >>> removeElement([1, 2, 3, 4], 15)\n  []\n  >>> removeElement([1, 2, 3, 4], 16)\n  []\n  >>> removeElement([1, 2, 3, 4], 17)\n  []\n  >>> removeElement([1, 2, 3, 4], 18)\n  []\n  >>> removeElement([1, 2, 3, 4], 19)\n  []\n  >>> removeElement([1, 2, 3, 4], 20)\n  []\n  >>> removeElement([1, 2, 3, 4], 21)\n  []\n  >>> removeElement([1, 2, 3, 4], 22)\n  []\n  >>> removeElement([1, 2, 3, 4], 23)\n  []\n  >>> removeElement([1, 2, 3, 4], 24)\n  []\n  >>> removeElement([1, 2, 3, 4], 25)\n  []\n  >>> removeElement([1, 2, 3, 4], 26)\n  []\n  >>> removeElement([1, 2, 3, 4], 27)\n  []\n  >>> removeElement([1, 2, 3, 4], 28)\n  []\n  >>> removeElement([1, 2, 3, 4], 29)\n  []\n  >>> removeElement([1, 2, 3, 4], 30)\n  []\n  >>> removeElement([1, 2, 3, 4], 31)\n  []\n  >>> removeElement([1, 2, 3, 4], 32)\n  []\n  >>> removeElement([1, 2, 3, 4], 33)\n  []\n  >>> removeElement([1, 2, 3, 4], 34)\n  []\n  >>> removeElement([1, 2, 3, 4], 35)\n  []\n  >>> removeElement([1, 2, 3, 4], 36)\n  []\n  >>> removeElement([1, 2, 3, 4], 37)\n  []\n  >>> removeElement([1, 2, 3, 4], 38)\n  []\n  >>> removeElement([1, 2, 3, 4], 39)\n  []\n  >>> removeElement([1, 2, 3, 4], 40)\n  []\n  >>> removeElement([1, 2, 3, 4], 41)\n  []\n  >>> removeElement([1, 2, 3, 4], 42)\n  []\n  >>> removeElement([1, 2, 3, 4], 43)\n  []\n  >>> removeElement([1, 2, 3, 4], 44)\n  []\n  >>> removeElement([1, 2, 3, 4], 45)\n  []\n  >>> removeElement([1, 2, 3, 4], 46)\n  []\n  >>> removeElement([1, 2, 3, 4], 47)\n  []\n  >>> removeElement([1, 2, 3, 4], 48)\n  []\n  >>> removeElement([1, 2, 3, 4], 49)\n  []\n  >>> removeElement([1, 2, 3, 4], 50)\n  []\n  >>> removeElement([1, 2, 3, 4], 51)\n  []\n  >>> removeElement([1, 2, 3, 4], 52)\n  []\n  >>> removeElement([1, 2, 3, 4], 53)\n  []\n  >>> removeElement([1, 2, 3, 4], 54)\n  []\n  >>> removeElement([1, 2, 3, 4], 55)\n  []\n  >>> removeElement([1, 2, 3, 4], 56)\n  []\n  >>> removeElement([1, 2, 3, 4], 57)\n  []\n  >>> removeElement([1, 2, 3, 4], 58)\n  []\n  >>> removeElement([1, 2, 3, 4], 59)\n  []\n  >>> removeElement([1, 2, 3, 4], 60)\n  []\n  >>> removeElement([1, 2, 3, 4], 61)\n  []\n  >>> removeElement([1, 2, 3, 4], 62)\n  []\n  >>> removeElement([1, 2, 3, 4], 63)\n  []\n  >>> removeElement([1, 2, 3, 4], 64)\n  []\n  >>> removeElement([1, 2, 3, 4], 65)\n  []\n  >>> removeElement([1, 2, 3, 4], 66)\n  []\n  >>> removeElement([1, 2, 3, 4], 67)\n  []\n  >>> removeElement([1, 2, 3, 4], 68)\n  []\n  >>> removeElement([1, 2, 3, 4], 69)\n  []\n  >>> removeElement([1, 2, 3, 4], 70)\n  []\n  >>> removeElement([1, 2, 3, 4], 71)\n  []\n  >>> removeElement([1, 2, 3, 4], 72)\n  []\n  >>> removeElement([1, 2, 3, 4], 73)\n  []\n  >>> removeElement([1, 2, 3, 4], 74)\n  []\n  >>> removeElement([1, 2, 3, 4], 75)\n  []\n  >>> removeElement([1, 2, 3, 4], 76)\n  []\n  >>> removeElement([1, 2, 3, 4], 77)\n  []\n  >>> removeElement([1, 2, 3, 4], 78)\n  []\n  >>> removeElement([1, 2, 3, 4], 79)\n  []\n  >>> removeElement([1, 2, 3, 4], 80)\n  []\n  >>> removeElement([1, 2, 3, 4], 81)\n  []\n  >>> removeElement([1, 2, 3, 4], 82)\n  []\n  >>> removeElement([1, 2, 3, 4], 83)\n  []\n  >>> removeElement([1, 2, 3, 4], 84)\n  []\n  >>> removeElement([1, 2, 3, 4], 85)\n  []\n  >>> removeElement([1, 2, 3, 4], 86)\n  []\n  >>> removeElement([1, 2, 3, 4], 87)\n  []\n  >>> removeElement([1, 2, 3, 4], 88)\n  []\n  >>> removeElement([1, 2, 3, 4], 89)\n  []\n  >>> removeElement([1, 2, 3, 4], 90)\n  []\n  >>> removeElement([1, 2, 3, 4], 91)\n  []\n  >>> removeElement([1, 2, 3, 4], 92)\n  []\n  >>> removeElement([1, 2, 3, 4], 93)\n  []\n  >>> removeElement([1, 2, 3, 4], 94)\n  []\n  >>> removeElement([1, 2, 3, 4], 95)\n  []\n  >>> removeElement([1, 2, 3, 4], 96)\n  []\n  >>> removeElement([1, 2, 3, 4], 97)\n  []\n  >>> removeElement([1, 2, 3, 4], 98)\n  []\n  >>> removeElement([1, 2, 3, 4], 99)\n  []\n  >>> removeElement([1, 2, 3, 4], 100)\n  []\n  >>> removeElement([1, 2, 3, 4], 101)\n  []\n  >>> removeElement([1, 2, 3, 4], 102)\n  []\n  >>> removeElement([1, 2, 3, 4], 103)\n  []\n  >>> removeElement([1, 2, 3, 4], 104)\n  []\n  >>> removeElement([1, 2, 3, 4], 105)\n  []\n  >>> removeElement([1, 2, 3, 4], 106)\n  []\n  >>> removeElement([1, 2, 3, 4], 107)\n  []\n  >>> removeElement([1, 2, 3, 4], 108)\n  []\n  >>> removeElement([1, 2, 3, 4], 109)\n  []\n  >>> removeElement([1, 2, 3, 4], 110)\n  []\n  >>> removeElement([1, 2, 3, 4], 111)\n  []\n  >>> removeElement([1, 2, 3, 4], 112)\n  []\n  >>> removeElement([1, 2, 3, 4], 113)\n  []\n  >>> removeElement([1, 2, 3, 4], 114)\n  []\n  >>> ", "passed": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  pairsSumToOne takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to one, and false otherwise.\n  >>> pairsSumToOne([1, 3, 5, 0])\n  false\n  >>> pairsSumToOne([1, 3, -2, 1])\n  false\n  >>> pairsSumToOne([1, 2, 3, 7])\n  false\n  >>> pairsSumToOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToOne([1])\n  false\n  */\nconst pairsSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/**\n  pairsSumToTwo takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to two, and false otherwise.\n  >>> pairsSumToTwo([1, 3, 5, 0])\n  false\n  >>> pairsSumToTwo([1, 3, -2, 1])\n  false\n  >>> pairsSumToTwo([1, 2, 3, 7])\n  false\n  >>> pairsSumToTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTwo([1])\n  false\n  */\nconst pairsSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 2;\n};\n\n/**\n  pairsSumToThree takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to three, and false otherwise.\n  >>> pairsSumToThree([1, 3, 5, 0])\n  false\n  >>> pairsSumToThree([1, 3, -2, 1])\n  false\n  >>> pairsSumToThree([1, 2, 3, 7])\n  false\n  >>> pairsSumToThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToThree([1])\n  false\n  */\nconst pairsSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 3;\n};\n\n/**\n  pairsSumToFour takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to four, and false otherwise.\n  >>> pairsSumToFour([1, 3, 5, 0])\n  false\n  >>> pairsSumToFour([1, 3, -2, 1])\n  false\n  >>> pairsSumToFour([1, 2, 3, 7])\n  false\n  >>> pairsSumToFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFour([1])\n  false\n  */\nconst pairsSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 4;\n};\n\n/**\n  pairsSumToFive takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to five, and false otherwise.\n  >>> pairsSumToFive([1, 3, 5, 0])\n  false\n  >>> pairsSumToFive([1, 3, -2, 1])\n  false\n  >>> pairsSumToFive([1, 2, 3, 7])\n  false\n  >>> pairsSumToFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFive([1])\n  false\n  */\nconst pairsSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 5;\n};\n\n/**\n  pairsSumToSix takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to six, and false otherwise.\n  >>> pairsSumToSix([1, 3, 5, 0])\n  false\n  >>> pairsSumToSix([1, 3, -2, 1])\n  false\n  >>> pairsSumToSix([1, 2, 3, 7])\n  false\n  >>> pairsSumToSix([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSix([1])\n  false\n  */\nconst pairsSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 6;\n};\n\n/**\n  pairsSumToSeven takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to seven, and false otherwise.\n  >>> pairsSumToSeven([1, 3, 5, 0])\n  false\n  >>> pairsSumToSeven([1, 3, -2, 1])\n  false\n  >>> pairsSumToSeven([1, 2, 3, 7])\n  false\n  >>> pairsSumToSeven([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSeven([1])\n  false\n  */\nconst pairsSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 7;\n};\n\n/**\n  pairsSumToEight takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to eight, and false otherwise.\n  >>> pairsSumToEight([1, 3, 5, 0])\n  false\n  >>> pairsSumToEight([1, 3, -2, 1])\n  false\n  >>> pairsSumToEight([1, 2, 3, 7])\n  false\n  >>> pairsSumToEight([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToEight([1])\n  false\n  */\nconst pairsSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 8;\n};\n\n/**\n  pairsSumToNine takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to nine, and false otherwise.\n  >>> pairsSumToNine([1, 3, 5, 0])\n  false\n  >>> pairsSumToNine([1, 3, -2, 1])\n  false\n  >>> pairsSumToNine([1, 2, 3, 7])\n  false\n  >>> pairsSumToNine([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToNine([1])\n  false\n  */\nconst pairsSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 9;\n};\n\n/**\n  pairsSumToTen takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to ten, and false otherwise.\n  >>> pairsSumToTen([1, 3, 5, 0])\n  false\n  >>> pairsSumToTen([1, 3, -2, 1])\n  false\n  >>> pairsSumToTen([1, 2, 3, 7])\n  false\n  >>> pairsSumToTen([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTen([1])\n  false\n  */\nconst pairsSumToTen = (l) => {\n  let sum = 0;\n  for (let i = 0; i < ", "passed": 0}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n return string representations after the conversion. base numbers was less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n return string representations after the conversion. base numbers was less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base < 10) {\n    return String(Number(x).toString(base))\n  }\n  return String(Number(x).toString(base))\n}\n\n/*\n Convert string representation to number.\n >>> convertToNumber(22)\n 22\n >>> convertToNumber('22')\n 22\n >>> convertToNumber('222')\n 222\n >>> convertToNumber('222.22')\n 222.22\n >>> convertToNumber('222.222')\n 222.222\n >>> convertToNumber('222.222.22')\n 222.222.22\n >>> convertToNumber('222.222.222')\n 222.222.222\n >>> convertToNumber('222.222.222.22')\n 222.222.222.22\n >>> convertToNumber('222.222.222.222')\n 222.222.222.222\n >>> convertToNumber('222.222.222.222.22')\n 222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222')\n 222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.22')\n 222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222')\n 222.222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.222.22')\n 222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222')\n 222.222.222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222')\n 222.222.222.222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222.222')\n 222.222.222.222.222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222.222')\n 222.222.222.222.222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222.222')\n 222.222.222.222.222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222.222')\n 222.222.222.222.222.222.222.222\n >>> convertToNumber('222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.22')\n 222.222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.222.22')\n 222.222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.222.22')\n 222.222.222.222.222.22\n >>> convertToNumber('222.222.222.222.22')\n 222.222.222.222.22\n >>> convertToNumber('222.222.222.22')\n 222.222.222.22\n >>> convertToNumber('22')\n 22\n >>> convertToNumber('222')\n 222\n >>> convertToNumber('222.22')\n 222.22\n >>> convertToNumber('222.222')\n 222.222\n >>> ", "passed": 0}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a sides and higher return areas for a triangles.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given length of a sides and higher return areas for a triangles.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(6, 3)\n  12.5\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(7, 3)\n  25\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(8, 3)\n  50\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(9, 3)\n  100\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(10, 3)\n  150\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(11, 3)\n  200\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(12, 3)\n  250\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(13, 3)\n  300\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(14, 3)\n  350\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(15, 3)\n  400\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(16, 3)\n  450\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(17, 3)\n  500\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(18, 3)\n  550\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(19, 3)\n  600\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(20, 3)\n  650\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(21, 3)\n  700\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(22, 3)\n  750\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(23, 3)\n  800\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(24, 3)\n  850\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(25, 3)\n  900\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(26, 3)\n  950\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(27, 3)\n  1000\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(28, 3)\n  1050\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.sqrt(a * a + h * h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(29, 3)\n", "passed": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n Please writes a functions to efficiently computing the n-th elements of the fib4 number sequences. Do not using recursions.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n Please writes a functions to efficiently computing the n-th elements of the fib4 number sequences. Do not using recursions.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fib5 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib5(0) -> 0 fib5(1) -> 0 fib5(2) -> 2 fib5(3) -> 0 fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n Please writes a functions to efficiently computing the n-th elements of the fib5 number sequences. Do not using recursions.\n  >>> fib5(5)\n  5\n  >>> fib5(6)\n  13\n  >>> fib5(7)\n  21\n  */\nconst fib5 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5);\n};\n\n/*The Fib6 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib6(0) -> 0 fib6(1) -> 0 fib6(2) -> 2 fib6(3) -> 0 fib6(n) -> fib6(n-1) + fib6(n-2) + fib6(n-3) + fib6(n-4) + fib6(n-5) + fib6(n-6).\n Please writes a functions to efficiently computing the n-th elements of the fib6 number sequences. Do not using recursions.\n  >>> fib6(6)\n  6\n  >>> fib6(7)\n  21\n  */\nconst fib6 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6);\n};\n\n/*The Fib7 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib7(0) -> 0 fib7(1) -> 0 fib7(2) -> 2 fib7(3) -> 0 fib7(n) -> fib7(n-1) + fib7(n-2) + fib7(n-3) + fib7(n-4) + fib7(n-5) + fib7(n-6) + fib7(n-7).\n Please writes a functions to efficiently computing the n-th elements of the fib7 number sequences. Do not using recursions.\n  >>> fib7(7)\n  7\n  >>> fib7(8)\n  15\n  >>> fib7(9)\n  31\n  */\nconst fib7 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7);\n};\n\n/*The Fib8 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib8(0) -> 0 fib8(1) -> 0 fib8(2) -> 2 fib8(3) -> 0 fib8(n) -> fib8(n-1) + fib8(n-2) + fib8(n-3) + fib8(n-4) + fib8(n-5) + fib8(n-6) + fib8(n-7) + fib8(n-8).\n Please writes a functions to efficiently computing the n-th elements of the fib8 number sequences. Do not using recursions.\n  >>> fib8(8)\n  8\n  >>> fib8(9)\n  15\n  >>> fib8(10)\n  31\n  */\nconst fib8 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib8(n - 1) + fib8(n - 2) + fib8(n - 3) + fib8(n - 4) + fib8(n - 5) + fib8(n - 6) + fib8(n - 7) + fib8(n - 8);\n};\n\n/*The Fib9 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib9(0) -> 0 fib9(1) -> 0 fib9(2) -> 2 fib9(3) -> 0 fib9(n) -> fib9(n-1) + fib9(n-2) + fib9(n-3) + fib9(n-4) + fib9(n-5) + fib9(n-6) + fib9(n-7) + fib9(n-8) + fib9(n-9).\n Please writes a functions to efficiently computing the n-th elements of the fib9 number sequences. Do not using recursions.\n  >>> fib9(9)\n  9\n  >>> fib9(10)\n  15\n  >>> fib9(11)\n  31\n  */\nconst fib9 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib9(n - 1) + fib9(n - 2) + fib9(n - 3) + fib9(n - 4) + fib9(n - 5) + fib9(n - 6) + fib9(n - 7) + fib9(n - 8) + fib9(n - 9);\n};\n\n/*The Fib10 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib10(0) -> 0 fib10(1) -> 0 fib10(2) -> 2 fib10(3) -> 0 fib10(n) -> fib10(n-1) + fib10(n-2) + fib10(n-3) + fib10(n-4) + fib10(n-5) + fib10(n-6) + fib10(n-7) + fib10(n-8) + fib10(n-9) + fib10(n-10).\n Please writes a functions to efficiently computing the n-th elements of the fib10 number sequences. Do not using recursions.\n  >>> fib10(10)\n  10\n  >>> fib10(11)\n  15\n  >>> fib10(12)\n  31\n  */\nconst fib10 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib10(n - 1) + fib10(n - 2) + fib10(n - 3) + fib10(n - 4) + fib10(n - 5) + fib10(n - 6) + fib10(n - 7) + fib10(n - 8) + fib10(n - 9) + fib10(n - 10);\n};\n\n/*The Fib11 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib11(0) -> 0 fib11(1) -> 0 fib11(2) -> 2 fib11(3) -> 0 fib11(n) -> fib11(n-1) + fib11(n-2) + fib11(n-3) + fib11(n-4) + fib11(n-5) + fib11(n-6) + fib11(n-7) + fib11(n-8) + fib11(n-9) + fib11(n-10) + fib11(n-11).\n Please writes a functions to efficiently computing the n-th elements of the fib11 number sequences. Do not using recursions.\n  >>> fib11(11)\n  11\n  >>> fib11(12)\n  21\n  >>> fib11(13)\n  31\n  */\nconst fib11 = (n", "passed": 0}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  let i = Math.floor(m)\n  let j = (n - 1) - i\n  let sum = 0\n  let sum2 = 0\n  let sum3 = 0\n  let sum4 = 0\n  let sum5 = 0\n  let sum6 = 0\n  let sum7 = 0\n  let sum8 = 0\n  let sum9 = 0\n  let sum10 = 0\n  let sum11 = 0\n  let sum12 = 0\n  let sum13 = 0\n  let sum14 = 0\n  let sum15 = 0\n  let sum16 = 0\n  let sum17 = 0\n  let sum18 = 0\n  let sum19 = 0\n  let sum20 = 0\n  let sum21 = 0\n  let sum22 = 0\n  let sum23 = 0\n  let sum24 = 0\n  let sum25 = 0\n  let sum26 = 0\n  let sum27 = 0\n  let sum28 = 0\n  let sum29 = 0\n  let sum30 = 0\n  let sum31 = 0\n  let sum32 = 0\n  let sum33 = 0\n  let sum34 = 0\n  let sum35 = 0\n  let sum36 = 0\n  let sum37 = 0\n  let sum38 = 0\n  let sum39 = 0\n  let sum40 = 0\n  let sum41 = 0\n  let sum42 = 0\n  let sum43 = 0\n  let sum44 = 0\n  let sum45 = 0\n  let sum46 = 0\n  let sum47 = 0\n  let sum48 = 0\n  let sum49 = 0\n  let sum50 = 0\n  let sum51 = 0\n  let sum52 = 0\n  let sum53 = 0\n  let sum54 = 0\n  let sum55 = 0\n  let sum56 = 0\n  let sum57 = 0\n  let sum58 = 0\n  let sum59 = 0\n  let sum60 = 0\n  let sum61 = 0\n  let sum62 = 0\n  let sum63 = 0\n  let sum64 = 0\n  let sum65 = 0\n  let sum66 = 0\n  let sum67 = 0\n  let sum68 = 0\n  let sum69 = 0\n  let sum70 = 0\n  let sum71 = 0\n  let sum72 = 0\n  let sum73 = 0\n  let sum74 = 0\n  let sum75 = 0\n  let sum76 = 0\n  let sum77 = 0\n  let sum78 = 0\n  let sum79 = 0\n  let sum80 = 0\n  let sum81 = 0\n  let sum82 = 0\n  let sum83 = 0\n  let sum84 = 0\n  let sum85 = 0\n  let sum86 = 0\n  let sum87 = 0\n  let sum88 = 0\n  let sum89 = 0\n  let sum90 = 0\n  let sum91 = 0\n  let sum92 = 0\n  let sum93 = 0\n  let sum94 = 0\n  let sum95 = 0\n  let sum96 = 0\n  let sum97 = 0\n  let sum98 = 0\n  let sum99 = 0\n  let sum100 = 0\n  let sum101 = 0\n  let sum102 = 0\n  let sum103 = 0\n  let sum104 = 0\n  let sum105 = 0\n  let sum106 = 0\n  let sum107 = 0\n  let sum108 = 0\n  let sum109 = 0\n  let sum110 = 0\n  let sum111 = 0\n  let sum112 = 0\n  let sum113 = 0\n  let sum114 = 0\n  let sum115 = 0\n  let sum116 = 0\n  let sum117 = 0\n  let sum118 = 0\n  let sum119 = 0\n  let sum120 = 0\n  let sum121 = 0\n  let sum122 = 0\n  let sum123 = 0\n  let sum124 = 0\n  let sum125 = 0\n  let sum126 = 0\n  let sum127 = 0\n  let sum128 = 0\n  let sum129 = 0\n  let sum130 = 0\n  let sum131 = 0\n  let sum132 = 0\n  let sum133 = 0\n  let sum134 = 0\n  let sum135 = 0\n  let sum136 = 0\n  let sum137 = 0\n  let sum138 = 0\n  let sum139 = 0\n  let sum140 = 0\n  let sum141 = 0\n  let sum142 = 0\n  let sum143 = 0\n  let sum144 = 0\n  let sum145 = 0\n  let sum146 = 0\n  let sum147 = 0\n  let sum148 = 0\n  let sum149 = 0\n  let sum150 = 0\n  let sum151 = 0\n  let sum152 = 0\n  let sum153 = 0\n  let sum154 = 0\n  let sum155 = 0\n  let sum156 = 0\n  let sum157 = 0\n  let sum158 = 0\n  let sum159 = 0\n  let sum160 = 0\n  let sum161 = 0\n  let sum162 = 0\n  let sum163 = 0\n  let sum164 = 0\n  let sum165 = 0\n  let sum166 = 0\n  let sum167 = 0\n  let sum168 = 0\n  let sum169 = 0\n  let sum170 = 0\n  let sum171 = 0\n  let sum172 = 0\n  let sum173 = 0\n  let sum174 = 0\n  let sum175 = 0\n  let sum176 = 0\n  let sum177 = 0\n  let sum178 = 0\n  let sum179 = 0\n  let sum180 = 0\n  let sum181 = 0\n  let sum182 = 0\n  let sum183 = 0\n  let sum184 = 0\n  let sum185 = 0\n  let sum186 = 0\n  let sum187 = 0\n  let sum188 = 0\n  let sum189 = 0\n  let sum190 = 0\n  let sum191 = 0\n  let sum192 = 0\n  let sum193 = 0\n  let sum194 = 0\n  let sum195 = 0\n  let sum196 = 0\n  let sum197 = 0\n  let sum198 = 0\n  let sum199 = 0\n  let sum200 = 0\n  let sum201 = 0\n  let sum202 = 0\n  let sum203 = 0\n  let sum204 = 0\n  let sum205 = 0\n  let sum206 = 0\n  let sum207 = 0\n  let sum208 = 0\n  let sum209 = 0\n  let sum210 = 0\n  let sum211 = 0\n  let sum212 = 0\n  let sum213 = 0\n  let sum214 = 0\n  let sum215 = 0\n  let sum216 = 0\n  let sum217 = 0\n  let sum218 = 0\n  let sum219 = 0\n  let sum220 = 0\n  let sum221 = 0\n  let sum222 = 0\n  let sum223 = 0\n  let sum224 = 0\n  let sum225 = 0\n  let sum226 = 0\n  let sum227 = 0\n  let sum228 = 0\n  let sum229 = 0\n  let sum230 = 0\n  let sum231 = 0\n  let sum232 = 0\n  let sum233 = 0\n  let sum234 = 0\n  let sum235 = 0\n  let sum236 = 0\n  let sum237 = 0\n  let sum238 = 0\n  let sum239 = 0\n  let sum240 = 0\n  let sum241 = 0\n  let sum242 = 0\n  let sum243 = 0\n  let sum244 = 0\n  let sum245 = 0\n  let sum246 = 0\n  let sum247 = 0\n  let sum248 = 0\n  let sum249 = 0\n  let sum250 = 0\n  let sum251 = 0\n  let sum252 = 0\n  let sum253 = 0\n  let sum254 = 0\n  let sum255 = 0\n  let sum256 = 0\n  let sum257 = 0\n  let sum258 = 0\n  let sum259 = 0\n  let sum260 = 0\n  let sum261 = 0\n  let sum262 = 0\n  let sum263 = 0\n  let sum264 = 0\n  let sum265 = 0\n  let sum266 = 0\n  let sum267 = 0\n  let sum268 = 0\n  let sum269 = 0\n  let sum270 = 0\n  let sum271 = 0\n  let sum272 = 0\n  let sum273 = 0\n  let sum274 = 0\n  let sum275 = 0\n  let sum276 = 0\n  let sum277 = 0\n  let sum278 = 0\n  let sum279 = 0\n  let sum280 = 0\n  let sum281 = 0\n  let sum282 = 0\n  let sum283 = 0\n  let sum", "passed": 0}
{"task_id": "JavaScript/48", "prompt": "/*\n  Check if gives string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if gives string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = '';\n  let reversedTextLength = 0;\n  let reversedTextIndex = 0;\n  let reversedTextLengthIndex = 0;\n  let reversedTextIndexLength = 0;\n  let reversedTextIndexLengthIndex = 0;\n  let reversedTextLengthIndexLength = 0;\n  let reversedTextIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextIndexLengthIndexLength = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversedTextLengthIndexLengthIndex = 0;\n  let reversed", "passed": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (is aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n modulo p (is aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (p === 0) return 1;\n  if (p === 1) return n;\n  if (p === 2) return n * n;\n  if (p === 3) return n * n * n;\n  if (p === 4) return n * n * n * n;\n  if (p === 5) return n * n * n * n * n;\n  if (p === 6) return n * n * n * n * n * n;\n  if (p === 7) return n * n * n * n * n * n * n;\n  if (p === 8) return n * n * n * n * n * n * n * n;\n  if (p === 9) return n * n * n * n * n * n * n * n * n;\n  if (p === 10) return n * n * n * n * n * n * n * n * n;\n  if (p === 11) return n * n * n * n * n * n * n * n * n * n;\n  if (p === 12) return n * n * n * n * n * n * n * n * n * n;\n  if (p === 13) return n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 14) return n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 15) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 16) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 17) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 18) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 19) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 20) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 21) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 22) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 23) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 24) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 25) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 26) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 27) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 28) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 29) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 30) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 31) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 32) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 33) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 34) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 35) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 36) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 37) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 38) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 39) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 40) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 41) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 42) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 43) return n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 44) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 45) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 46) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 47) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 48) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 49) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 50) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 51) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 52) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 53) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 54) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 55) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 56) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 57) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 58) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 59) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 60) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 61) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 62) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 63) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 64) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 65) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 66) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 67) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 68) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 69) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 70) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 71) return n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 72) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 73) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 74) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 75) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 76) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 77) return n * n * n * n * n * n * n * n * n * n * n * n * n * n;\n  if (p === 78) return n * n * n * n * n * n * n * n * n * n * ", "passed": 0}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (j === numbers.length - 1) {\n      result.push(numbers[i])\n      break\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      j++\n    } else {\n      result.push(numbers[i])\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Split a list into two lists containing consecutive elements. \n * \n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 2)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 3)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 4)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 5)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 6)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 7)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 8)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 9)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 10)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 11)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 12)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 13)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 14)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 15)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 16)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 17)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 18)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 19)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 20)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 21)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 22)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 23)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 24)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 25)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 26)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 27)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 28)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 29)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 30)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 31)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 32)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 33)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 34)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 35)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 36)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 37)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 38)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 39)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 40)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,5,6,7,8,9], 41)\n * [[1], [2, 3], [4, 5], [6, 7], [8, 9]]\n * >>> splitAtConsecutive([1,2,3,4,", "passed": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoding string by shifting every character by 5 in the alphabets. */ const encodeShift = (s) => { return s.split(\"\").map(ch => String.fromCharCode(\n ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0) )).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoding string by shifting every character by 5 in the alphabets. */ const encodeShift = (s) => { return s.split(\"\").map(ch => String.fromCharCode(\n ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0) )).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const decodeShift = (s) => {\n return s.split(\"\").map(ch => String.fromCharCode(\n ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0) )).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encode = (s) => { return encodeShift(s); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decode = (s) => { return decodeShift(s); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBytes = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBytes = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToHex = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToHex = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBase64 = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBase64 = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBase64URLSafe = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBase64URLSafe = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToHexURLSafe = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToHexURLSafe = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBase64URLSafeB64 = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBase64URLSafeB64 = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToHexURLSafeB64 = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToHexURLSafeB64 = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBase64URLSafeB64URLSafe = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBase64URLSafeB64URLSafe = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToHexURLSafeB64URLSafe = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToHexURLSafeB64URLSafe = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBase64URLSafeB64URLSafeB64 = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBase64URLSafeB64URLSafeB64 = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToHexURLSafeB64URLSafeB64 = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToHexURLSafeB64URLSafeB64 = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBase64URLSafeB64URLSafeB64URLSafe = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBase64URLSafeB64URLSafeB64URLSafe = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToHexURLSafeB64URLSafeB64URLSafe = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToHexURLSafeB64URLSafeB64URLSafe = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToBase64URLSafeB64URLSafeB64URLSafeB64 = (s) => { return encode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns encoding string. */ const decodeToBase64URLSafeB64URLSafeB64URLSafeB64 = (s) => { return decode(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const encodeToHexURLSafeB64URLSafeB64URLSafeB64 = (s) => { return encode(", "passed": 0}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a functions that takes string and returns string without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a functions that takes string and returns string without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i] === 'a' || vowels[i] === 'e' || vowels[i] === 'i' || vowels[i] === 'o' || vowels[i] === 'u') {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeNumbers is a function that takes string and returns string without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNumbers('abcdef')\n  'abcdef'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNumbers = (text) => {\n  let numbers = text.split('')\n  let newText = ''\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] === '0' || numbers[i] === '1' || numbers[i] === '2' || numbers[i] === '3' || numbers[i] === '4' || numbers[i] === '5' || numbers[i] === '6' || numbers[i] === '7' || numbers[i] === '8' || numbers[i] === '9') {\n      newText += numbers[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuations is a function that takes string and returns string without punctuation.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuations('abcdef')\n  'abcdef'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'zbcd'\n  */\nconst removePunctuations = (text) => {\n  let punctuations = text.split('')\n  let newText = ''\n  for (let i = 0; i < punctuations.length; i++) {\n    if (punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '.' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '.') {\n      newText += punctuations[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeSpaces is a function that takes string and returns string without spaces.\n  >>> removeSpaces('')\n  ''\n  >>> removeSpaces(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeSpaces('abcdef')\n  'abcdef'\n  >>> removeSpaces('aaaaa')\n  ''\n  >>> removeSpaces('aaBAA')\n  'B'\n  >>> removeSpaces('zbcd')\n  'zbcd'\n  */\nconst removeSpaces = (text) => {\n  let spaces = text.split('')\n  let newText = ''\n  for (let i = 0; i < spaces.length; i++) {\n    if (spaces[i] ==='') {\n      newText += spaces[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuations is a function that takes string and returns string without punctuation.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuations('abcdef')\n  'abcdef'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'zbcd'\n  */\nconst removePunctuations = (text) => {\n  let punctuations = text.split('')\n  let newText = ''\n  for (let i = 0; i < punctuations.length; i++) {\n    if (punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '.' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '.') {\n      newText += punctuations[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeSpaces is a function that takes string and returns string without spaces.\n  >>> removeSpaces('')\n  ''\n  >>> removeSpaces(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeSpaces('abcdef')\n  'abcdef'\n  >>> removeSpaces('aaaaa')\n  ''\n  >>> removeSpaces('aaBAA')\n  'B'\n  >>> removeSpaces('zbcd')\n  'zbcd'\n  */\nconst removeSpaces = (text) => {\n  let spaces = text.split('')\n  let newText = ''\n  for (let i = 0; i < spaces.length; i++) {\n    if (spaces[i] ==='') {\n      newText += spaces[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuations is a function that takes string and returns string without punctuation.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuations('abcdef')\n  'abcdef'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'zbcd'\n  */\nconst removePunctuations = (text) => {\n  let punctuations = text.split('')\n  let newText = ''\n  for (let i = 0; i < punctuations.length; i++) {\n    if (punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '.' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '.') {\n      newText += punctuations[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeSpaces is a function that takes string and returns string without spaces.\n  >>> removeSpaces('')\n  ''\n  >>> removeSpaces(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeSpaces('abcdef')\n  'abcdef'\n  >>> removeSpaces('aaaaa')\n  ''\n  >>> removeSpaces('aaBAA')\n  'B'\n  >>> removeSpaces('zbcd')\n  'zbcd'\n  */\nconst removeSpaces = (text) => {\n  let spaces = text.split('')\n  let newText = ''\n  for (let i = 0; i < spaces.length; i++) {\n    if (spaces[i] ==='') {\n      newText += spaces[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removePunctuations is a function that takes string and returns string without punctuation.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuations('abcdef')\n  'abcdef'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'zbcd'\n  */\nconst removePunctuations = (text) => {\n  let punctuations = text.split('')\n  let newText = ''\n  for (let i = 0; i < punctuations.length; i++) {\n    if (punctuations[i] === '!", "passed": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return trueer if all numbers in the list l was below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return trueer if all numbers in the list l was below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*\n  >>> isEven([2, 3, 4, 5])\n  true\n  >>> isEven([2, 4, 6, 8])\n  false\n  */\nconst isEven = l => l.every(n => n % 2 === 0);\n\n/*\n  >>> isOdd([2, 3, 4, 5])\n  false\n  >>> isOdd([2, 4, 6, 8])\n  true\n  */\nconst isOdd = l => l.every(n => n % 2!== 0);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOdd = l => isEven(l) || isOdd(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  false\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  true\n  */\nconst isEvenOrOddOrZero = l => isEvenOrOdd(l) || isOddOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOdd([2, 3, 4, 5])\n  true\n  >>> isEvenOrOdd([2, 4, 6, 8])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOdd(l) || isOddOrZeroOrZeroOrZeroOr", "passed": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> multiply(2, 3)\n  2\n  >>> multiply(5, 7)\n  10\n  */\nconst multiply = (a, b) => {\n  return a * b;\n};\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  0\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst mod = (a, b) => {\n  return a % b;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPow = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powMod = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPow = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowMod = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPow = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowMod = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPow = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowMod = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPow = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y) % y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  1\n  */\nconst modPowModPowModPowMod = (x, y) => {\n  return x % y % y;\n};\n\n/*\n  >>> pow(2, 3)\n  ", "passed": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two word had the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if two word had the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same length.\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLength('abcd', 'dddddddabc')\n  true\n  >>> sameLength('dddddddabc', 'abcd')\n  true\n  >>> sameLength('eabcd', 'dddddddabc')\n  false\n  >>> sameLength('abcd', 'dddddddabce')\n  false\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLength = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same capitalization.\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCaps('abcd', 'dddddddabc')\n  true\n  >>> sameCaps('dddddddabc', 'abcd')\n  true\n  >>> sameCaps('eabcd', 'dddddddabc')\n  false\n  >>> sameCaps('abcd', 'dddddddabce')\n  false\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCaps = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same lowercase.\n  >>> sameLowers('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLowers('abcd', 'dddddddabc')\n  true\n  >>> sameLowers('dddddddabc', 'abcd')\n  true\n  >>> sameLowers('eabcd', 'dddddddabc')\n  false\n  >>> sameLowers('abcd', 'dddddddabce')\n  false\n  >>> sameLowers('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLowers = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i].toLowerCase()!== s1[i].toLowerCase()) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same uppercase.\n  >>> sameUppers('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameUppers('abcd', 'dddddddabc')\n  true\n  >>> sameUppers('dddddddabc', 'abcd')\n  true\n  >>> sameUppers('eabcd', 'dddddddabc')\n  false\n  >>> sameUppers('abcd', 'dddddddabce')\n  false\n  >>> sameUppers('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameUppers = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i].toUpperCase()!== s1[i].toUpperCase()) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same digit.\n  >>> sameDigits('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameDigits('abcd', 'dddddddabc')\n  true\n  >>> sameDigits('dddddddabc', 'abcd')\n  true\n  >>> sameDigits('eabcd', 'dddddddabc')\n  false\n  >>> sameDigits('abcd', 'dddddddabce')\n  false\n  >>> sameDigits('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameDigits = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same symbol.\n  >>> sameSymbols('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameSymbols('abcd', 'dddddddabc')\n  true\n  >>> sameSymbols('dddddddabc', 'abcd')\n  true\n  >>> sameSymbols('eabcd', 'dddddddabc')\n  false\n  >>> sameSymbols('abcd', 'dddddddabce')\n  false\n  >>> sameSymbols('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameSymbols = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same uppercase and lowercase letters.\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLetters('abcd', 'dddddddabc')\n  true\n  >>> sameLetters('dddddddabc', 'abcd')\n  true\n  >>> sameLetters('eabcd', 'dddddddabc')\n  false\n  >>> sameLetters('abcd', 'dddddddabce')\n  false\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLetters = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i].toLowerCase()!== s1[i].toLowerCase()) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two word have the same uppercase and lowercase letters.\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLetters('abcd', 'dddddddabc')\n  true\n  >>> sameLetters('dddddddabc', 'abcd')\n  true\n  >>> sameLetters('eabcd', 'dddddddabc')\n  false\n  >>> sameLetters('abcd', 'dddddddabce')\n  false\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLetters = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i].toLowerCase()!== ", "passed": 0}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  >>> fib(8)\n  211\n  >>> fib(9)\n  341\n  >>> fib(10)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(11)\n  110\n  >>> fibonacci(12)\n  151\n  >>> fibonacci(13)\n  211\n  >>> fibonacci(14)\n  341\n  >>> fibonacci(15)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(20)\n  55\n  >>> fibonacci(21)\n  110\n  >>> fibonacci(22)\n  151\n  >>> fibonacci(23)\n  211\n  >>> fibonacci(24)\n  341\n  >>> fibonacci(25)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(30)\n  55\n  >>> fibonacci(31)\n  110\n  >>> fibonacci(32)\n  151\n  >>> fibonacci(33)\n  211\n  >>> fibonacci(34)\n  341\n  >>> fibonacci(35)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(50)\n  55\n  >>> fibonacci(51)\n  110\n  >>> fibonacci(52)\n  151\n  >>> fibonacci(53)\n  211\n  >>> fibonacci(54)\n  341\n  >>> fibonacci(55)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(60)\n  55\n  >>> fibonacci(61)\n  110\n  >>> fibonacci(62)\n  151\n  >>> fibonacci(63)\n  211\n  >>> fibonacci(64)\n  341\n  >>> fibonacci(65)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(70)\n  55\n  >>> fibonacci(71)\n  110\n  >>> fibonacci(72)\n  151\n  >>> fibonacci(73)\n  211\n  >>> fibonacci(74)\n  341\n  >>> fibonacci(75)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(80)\n  55\n  >>> fibonacci(81)\n  110\n  >>> fibonacci(82)\n  151\n  >>> fibonacci(83)\n  211\n  >>> fibonacci(84)\n  341\n  >>> fibonacci(85)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(90)\n  55\n  >>> fibonacci(91)\n  110\n  >>> fibonacci(92)\n  151\n  >>> fibonacci(93)\n  211\n  >>> fibonacci(94)\n  341\n  >>> fibonacci(95)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(100)\n  55\n  >>> fibonacci(101)\n  110\n  >>> fibonacci(102)\n  151\n  >>> fibonacci(103)\n  211\n  >>> fibonacci(104)\n  341\n  >>> fibonacci(105)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(110)\n  55\n  >>> fibonacci(111)\n  110\n  >>> fibonacci(112)\n  151\n  >>> fibonacci(113)\n  211\n  >>> fibonacci(114)\n  341\n  >>> fibonacci(115)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(120)\n  55\n  >>> fibonacci(121)\n  110\n  >>> fibonacci(122)\n  151\n  >>> fibonacci(123)\n  211\n  >>> fibonacci(124)\n  341\n  >>> fibonacci(125)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(130)\n  55\n  >>> fibonacci(131)\n  110\n  >>> fibonacci(132)\n  151\n  >>> fibonacci(133)\n  211\n  >>> fibonacci(134)\n  341\n  >>> fibonacci(135)\n  551\n*/\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n", "passed": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\". return false if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\". return false if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openings = brackets.split(/\\<\\>\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\<\\>|\\", "passed": 0}
{"task_id": "JavaScript/57", "prompt": "/*Return trueer is list elements was monotonically increases or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return trueer is list elements was monotonically increases or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = l.length - 1;\n  while (i > 0 && j > 0) {\n    if (l[i] > l[j]) {\n      i = i - 1;\n    } else {\n      j = j - 1;\n    }\n  }\n  return i > 0 && j > 0;\n};\n\n/**\n * Return true if list elements was monotonically increases or decreasing.\n * If list elements was monotonically increases or decreasing then return true.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or decreasing then return false.\n * If list elements was monotonically increases or ", "passed": 0}
{"task_id": "JavaScript/58", "prompt": "/*Return sort unique common elements for two list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Return sort unique common elements for two list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i]);\n      i++;\n      j++;\n    } else {\n      result.push(l2[j]);\n      j++;\n    }\n  }\n  while (i < l) {\n    result.push(l1[i]);\n    i++;\n  }\n  while (j < l2) {\n    result.push(l2[j]);\n    j++;\n  }\n  return result;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst same = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      i++;\n      j++;\n    } else {\n      return false;\n    }\n  }\n  while (i < l) {\n    if (l1[i]!== l2[i]) {\n      return false;\n    }\n    i++;\n  }\n  while (j < l2) {\n    if (l1[j]!== l2[j]) {\n      return false;\n    }\n    j++;\n  }\n  return true;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqual = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      i++;\n      j++;\n    } else {\n      return false;\n    }\n  }\n  while (i < l) {\n    if (l1[i]!== l2[i]) {\n      return false;\n    }\n    i++;\n  }\n  while (j < l2) {\n    if (l1[j]!== l2[j]) {\n      return false;\n    }\n    j++;\n  }\n  return true;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualWith = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      i++;\n      j++;\n    } else {\n      return false;\n    }\n  }\n  while (i < l) {\n    if (l1[i]!== l2[i]) {\n      return false;\n    }\n    i++;\n  }\n  while (j < l2) {\n    if (l1[j]!== l2[j]) {\n      return false;\n    }\n    j++;\n  }\n  return true;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualWithSame = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      i++;\n      j++;\n    } else {\n      return false;\n    }\n  }\n  while (i < l) {\n    if (l1[i]!== l2[i]) {\n      return false;\n    }\n    i++;\n  }\n  while (j < l2) {\n    if (l1[j]!== l2[j]) {\n      return false;\n    }\n    j++;\n  }\n  return true;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualWithSameWith = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      i++;\n      j++;\n    } else {\n      return false;\n    }\n  }\n  while (i < l) {\n    if (l1[i]!== l2[i]) {\n      return false;\n    }\n    i++;\n  }\n  while (j < l2) {\n    if (l1[j]!== l2[j]) {\n      return false;\n    }\n    j++;\n  }\n  return true;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualWithSameWithSame = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      i++;\n      j++;\n    } else {\n      return false;\n    }\n  }\n  while (i < l) {\n    if (l1[i]!== l2[i]) {\n      return false;\n    }\n    i++;\n  }\n  while (j < l2) {\n    if (l1[j]!== l2[j]) {\n      return false;\n    }\n    j++;\n  }\n  return true;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualWithSameWithSameWith = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.length);\n  while (i < l && j < l2) {\n    if (l1[i] === l2[j]) {\n      i++;\n      j++;\n    } else {\n      return false;\n    }\n  }\n  while (i < l) {\n    if (l1[i]!== l2[i]) {\n      return false;\n    }\n    i++;\n  }\n  while (j < l2) {\n    if (l1[j]!== l2[j]) {\n      return false;\n    }\n    j++;\n  }\n  return true;\n};\n\n/*\n  Return true if two arrays have the same elements in the same order.\n  >>> same([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  true\n  >>> same([5, 3, 2, 8], [3, 2])\n  false\n*/\nconst isEqualWithSameWithSameWithSame = (l1, l2) => {\n  if (l1.length!== l2.length) {\n    return false;\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = Math.min(l1.length, l2.", "passed": 0}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": false, "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return i;\n};\n\n/*\n  Given a positive integer n, return true if and only if n is a prime number.\n  >>> isPrime(123)\n  true\n  >>> isPrime(124)\n  false\n  >>> isPrime(125)\n  false\n  >>> isPrime(126)\n  false\n  >>> isPrime(127)\n  false\n  >>> isPrime(128)\n  false\n  >>> isPrime(129)\n  false\n  >>> isPrime(130)\n  false\n  >>> isPrime(131)\n  false\n  >>> isPrime(132)\n  false\n  >>> isPrime(133)\n  false\n  >>> isPrime(134)\n  false\n  >>> isPrime(135)\n  false\n  >>> isPrime(136)\n  false\n  >>> isPrime(137)\n  false\n  >>> isPrime(138)\n  false\n  >>> isPrime(139)\n  false\n  >>> isPrime(140)\n  false\n  >>> isPrime(141)\n  false\n  >>> isPrime(142)\n  false\n  >>> isPrime(143)\n  false\n  >>> isPrime(144)\n  false\n  >>> isPrime(145)\n  false\n  >>> isPrime(146)\n  false\n  >>> isPrime(147)\n  false\n  >>> isPrime(148)\n  false\n  >>> isPrime(149)\n  false\n  >>> isPrime(150)\n  false\n  >>> isPrime(151)\n  false\n  >>> isPrime(152)\n  false\n  >>> isPrime(153)\n  false\n  >>> isPrime(154)\n  false\n  >>> isPrime(155)\n  false\n  >>> isPrime(156)\n  false\n  >>> isPrime(157)\n  false\n  >>> isPrime(158)\n  false\n  >>> isPrime(159)\n  false\n  >>> isPrime(160)\n  false\n  >>> isPrime(161)\n  false\n  >>> isPrime(162)\n  false\n  >>> isPrime(163)\n  false\n  >>> isPrime(164)\n  false\n  >>> isPrime(165)\n  false\n  >>> isPrime(166)\n  false\n  >>> isPrime(167)\n  false\n  >>> isPrime(168)\n  false\n  >>> isPrime(169)\n  false\n  >>> isPrime(170)\n  false\n  >>> isPrime(171)\n  false\n  >>> isPrime(172)\n  false\n  >>> isPrime(173)\n  false\n  >>> isPrime(174)\n  false\n  >>> isPrime(175)\n  false\n  >>> isPrime(176)\n  false\n  >>> isPrime(177)\n  false\n  >>> isPrime(178)\n  false\n  >>> isPrime(179)\n  false\n  >>> isPrime(180)\n  false\n  >>> isPrime(181)\n  false\n  >>> isPrime(182)\n  false\n  >>> isPrime(183)\n  false\n  >>> isPrime(184)\n  false\n  >>> isPrime(185)\n  false\n  >>> isPrime(186)\n  false\n  >>> isPrime(187)\n  false\n  >>> isPrime(188)\n  false\n  >>> isPrime(189)\n  false\n  >>> isPrime(190)\n  false\n  >>> isPrime(191)\n  false\n  >>> isPrime(192)\n  false\n  >>> isPrime(193)\n  false\n  >>> isPrime(194)\n  false\n  >>> isPrime(195)\n  false\n  >>> isPrime(196)\n  false\n  >>> isPrime(197)\n  false\n  >>> isPrime(198)\n  false\n  >>> isPrime(199)\n  false\n  >>> isPrime(200)\n  false\n  >>> isPrime(201)\n  false\n  >>> isPrime(202)\n  false\n  >>> isPrime(203)\n  false\n  >>> isPrime(204)\n  false\n  >>> isPrime(205)\n  false\n  >>> isPrime(206)\n  false\n  >>> isPrime(207)\n  false\n  >>> isPrime(208)\n  false\n  >>> isPrime(209)\n  false\n  >>> isPrime(210)\n  false\n  >>> isPrime(211)\n  false\n  >>> isPrime(212)\n  false\n  >>> isPrime(213)\n  false\n  >>> isPrime(214)\n  false\n  >>> isPrime(215)\n  false\n  >>> isPrime(216)\n  false\n  >>> isPrime(217)\n  false\n  >>> isPrime(218)\n  false\n  >>> isPrime(219)\n  false\n  >>> isPrime(220)\n  false\n  >>> isPrime(221)\n  false\n  >>> isPrime(222)\n  false\n  >>> isPrime(223)\n  false\n  >>> isPrime(224)\n  false\n  >>> isPrime(225)\n  false\n  >>> isPrime(226)\n  false\n  >>> isPrime(227)\n  false\n  >>> isPrime(228)\n  false\n  >>> isPrime(229)\n  false\n  >>> isPrime(230)\n  false\n  >>> isPrime(231)\n  false\n  >>> isPrime(232)\n  false\n  >>> isPrime(233)\n  false\n  >>> isPrime(234)\n  false\n  >>> isPrime(235)\n  false\n  >>> isPrime(236)\n  false\n  >>> isPrime(237)\n  false\n  >>> isPrime(238)\n  false\n  >>> isPrime(239)\n  false\n  >>> isPrime(240)\n  false\n  >>> isPrime(241)\n  false\n  >>> isPrime(242)\n  false\n  >>> isPrime", "passed": 0}
{"task_id": "JavaScript/6", "prompt": "/* Input to this functions is a string represents multiple group for nested parentheses separates by space. For each of the group, output the deeper level of nesting of parentheses. E.g. (()()) had maximum two level of nesting while ((())) had three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Input to this functions is a string represents multiple group for nested parentheses separates by space. For each of the group, output the deeper level of nesting of parentheses. E.g. (()()) had maximum two level of nesting while ((())) had three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_array = paren_string.split(' ');\n  const result = [];\n  for (let i = 0; i < paren_array.length; i++) {\n    const paren_char = paren_array[i];\n    if (paren_char === '(') {\n      result.push(0);\n    } else if (paren_char === ')') {\n      result.push(1);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(2);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(3);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(4);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(5);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(6);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(7);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(8);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(9);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(10);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(11);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(12);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(13);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(14);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(15);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(16);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(17);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(18);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(19);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(20);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(21);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(22);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(23);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(24);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(25);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(26);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(27);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(28);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(29);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(30);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(31);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(32);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(33);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(34);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(35);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(36);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(37);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(38);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(39);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(40);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(41);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(42);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(43);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(44);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(45);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(46);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(47);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(48);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(49);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(50);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(51);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(52);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(53);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(54);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(55);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(56);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(57);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(58);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(59);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(60);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(61);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(62);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(63);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(64);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(65);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(66);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(67);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(68);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(69);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(70);\n    } else if (paren_char === '(' || paren_char === ')') {\n      result.push(71);\n    } else if (paren_char === '(' || paren_char === ", "passed": 0}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a functions that summing numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a functions that summing numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Given a number n, return an array with n elements where each element is a\n  number between 1 and n.\n  >>> numberArrayFrom(10)\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> numberArrayFrom(100)\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 424, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, ", "passed": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\". return trueer if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\". return trueer if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/[()]/g);\n  const closingBrackets = brackets.match(/[)]/g);\n  return openingBrackets.length!== closingBrackets.length;\n};\n\n/**\n * Returns true if the given string is a valid CSS selector\n * \n * Valid CSS selectors are of the form:\n * \n * selector = { property : value }\n * \n * property can be any valid CSS property\n * \n * value can be any valid CSS value\n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n", "passed": 0}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return derivative of this polynomial in the same forms.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 +.... Return derivative of this polynomial in the same forms.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const result = [];\n  for (let i = 0; i < xs.length; i++) {\n    const x = xs[i];\n    const derivative = x * x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x", "passed": 0}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n Please writes a functions to efficiently computing the n-th elements of the fibfib number sequences.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n Please writes a functions to efficiently computing the n-th elements of the fibfib number sequences.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let fibfib = [];\n  for (let i = 1; i <= n; i++) {\n    fibfib.push(i);\n  }\n  return fibfib;\n};\n\n/*\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-th element of the fibfib number sequences.\n fibfib(n) returns the n-", "passed": 0}
{"task_id": "JavaScript/64", "prompt": "/*Write a functions vowelsCount which takes a string represents a words as input and returning the number of vowels in the string. Vowel in this cases was 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the ends of the gives words. Examples:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a functions vowelsCount which takes a string represents a words as input and returning the number of vowels in the string. Vowel in this cases was 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the ends of the gives words. Examples:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowelsCount = 0;\n  let vowelsCountArray = [];\n  let vowelsCountArrayIndex = 0;\n  let vowelsCountArrayLength = 0;\n  let vowelsCountArrayIndexLength = 0;\n  let vowelsCountArrayIndexLength2 = 0;\n  let vowelsCountArrayIndexLength2 = 0;\n  let vowelsCountArrayIndexLength3 = 0;\n  let vowelsCountArrayIndexLength4 = 0;\n  let vowelsCountArrayIndexLength5 = 0;\n  let vowelsCountArrayIndexLength6 = 0;\n  let vowelsCountArrayIndexLength7 = 0;\n  let vowelsCountArrayIndexLength8 = 0;\n  let vowelsCountArrayIndexLength9 = 0;\n  let vowelsCountArrayIndexLength10 = 0;\n  let vowelsCountArrayIndexLength11 = 0;\n  let vowelsCountArrayIndexLength12 = 0;\n  let vowelsCountArrayIndexLength13 = 0;\n  let vowelsCountArrayIndexLength14 = 0;\n  let vowelsCountArrayIndexLength15 = 0;\n  let vowelsCountArrayIndexLength16 = 0;\n  let vowelsCountArrayIndexLength17 = 0;\n  let vowelsCountArrayIndexLength18 = 0;\n  let vowelsCountArrayIndexLength19 = 0;\n  let vowelsCountArrayIndexLength20 = 0;\n  let vowelsCountArrayIndexLength21 = 0;\n  let vowelsCountArrayIndexLength22 = 0;\n  let vowelsCountArrayIndexLength23 = 0;\n  let vowelsCountArrayIndexLength24 = 0;\n  let vowelsCountArrayIndexLength25 = 0;\n  let vowelsCountArrayIndexLength26 = 0;\n  let vowelsCountArrayIndexLength27 = 0;\n  let vowelsCountArrayIndexLength28 = 0;\n  let vowelsCountArrayIndexLength29 = 0;\n  let vowelsCountArrayIndexLength30 = 0;\n  let vowelsCountArrayIndexLength31 = 0;\n  let vowelsCountArrayIndexLength32 = 0;\n  let vowelsCountArrayIndexLength33 = 0;\n  let vowelsCountArrayIndexLength34 = 0;\n  let vowelsCountArrayIndexLength35 = 0;\n  let vowelsCountArrayIndexLength36 = 0;\n  let vowelsCountArrayIndexLength37 = 0;\n  let vowelsCountArrayIndexLength38 = 0;\n  let vowelsCountArrayIndexLength39 = 0;\n  let vowelsCountArrayIndexLength40 = 0;\n  let vowelsCountArrayIndexLength41 = 0;\n  let vowelsCountArrayIndexLength42 = 0;\n  let vowelsCountArrayIndexLength43 = 0;\n  let vowelsCountArrayIndexLength44 = 0;\n  let vowelsCountArrayIndexLength45 = 0;\n  let vowelsCountArrayIndexLength46 = 0;\n  let vowelsCountArrayIndexLength47 = 0;\n  let vowelsCountArrayIndexLength48 = 0;\n  let vowelsCountArrayIndexLength49 = 0;\n  let vowelsCountArrayIndexLength50 = 0;\n  let vowelsCountArrayIndexLength51 = 0;\n  let vowelsCountArrayIndexLength52 = 0;\n  let vowelsCountArrayIndexLength53 = 0;\n  let vowelsCountArrayIndexLength54 = 0;\n  let vowelsCountArrayIndexLength55 = 0;\n  let vowelsCountArrayIndexLength56 = 0;\n  let vowelsCountArrayIndexLength57 = 0;\n  let vowelsCountArrayIndexLength58 = 0;\n  let vowelsCountArrayIndexLength59 = 0;\n  let vowelsCountArrayIndexLength60 = 0;\n  let vowelsCountArrayIndexLength61 = 0;\n  let vowelsCountArrayIndexLength62 = 0;\n  let vowelsCountArrayIndexLength63 = 0;\n  let vowelsCountArrayIndexLength64 = 0;\n  let vowelsCountArrayIndexLength65 = 0;\n  let vowelsCountArrayIndexLength66 = 0;\n  let vowelsCountArrayIndexLength67 = 0;\n  let vowelsCountArrayIndexLength68 = 0;\n  let vowelsCountArrayIndexLength69 = 0;\n  let vowelsCountArrayIndexLength70 = 0;\n  let vowelsCountArrayIndexLength71 = 0;\n  let vowelsCountArrayIndexLength72 = 0;\n  let vowelsCountArrayIndexLength73 = 0;\n  let vowelsCountArrayIndexLength74 = 0;\n  let vowelsCountArrayIndexLength75 = 0;\n  let vowelsCountArrayIndexLength76 = 0;\n  let vowelsCountArrayIndexLength77 = 0;\n  let vowelsCountArrayIndexLength78 = 0;\n  let vowelsCountArrayIndexLength79 = 0;\n  let vowelsCountArrayIndexLength80 = 0;\n  let vowelsCountArrayIndexLength81 = 0;\n  let vowelsCountArrayIndexLength82 = 0;\n  let vowelsCountArrayIndexLength83 = 0;\n  let vowelsCountArrayIndexLength84 = 0;\n  let vowelsCountArrayIndexLength85 = 0;\n  let vowelsCountArrayIndexLength86 = 0;\n  let vowelsCountArrayIndexLength87 = 0;\n  let vowelsCountArrayIndexLength88 = 0;\n  let vowelsCountArrayIndexLength89 = 0;\n  let vowelsCountArrayIndexLength90 = 0;\n  let vowelsCountArrayIndexLength91 = 0;\n  let vowelsCountArrayIndexLength92 = 0;\n  let vowelsCountArrayIndexLength93 = 0;\n  let vowelsCountArrayIndexLength94 = 0;\n  let vowelsCountArrayIndexLength95 = 0;\n  let vowelsCountArrayIndexLength96 = 0;\n  let vowelsCountArrayIndexLength97 = 0;\n  let vowelsCountArrayIndexLength98 = 0;\n  let vowelsCountArrayIndexLength99 = 0;\n  let vowelsCountArrayIndexLength100 = 0;\n  let vowelsCountArrayIndexLength101 = 0;\n  let vowelsCountArrayIndexLength102 = 0;\n  let vowelsCountArrayIndexLength103 = 0;\n  let vowelsCountArrayIndexLength104 = 0;\n  let vowelsCountArrayIndexLength105 = 0;\n  let vowelsCountArrayIndexLength106 = 0;\n  let vowelsCountArrayIndexLength107 = 0;\n  let vowelsCountArrayIndexLength108 = 0;\n  let vowelsCountArrayIndexLength109 = 0;\n  let vowelsCountArrayIndexLength110 = 0;\n  let vowelsCountArrayIndexLength111 = 0;\n  let vowelsCountArrayIndexLength112 = 0;\n  let vowelsCountArrayIndexLength113 = 0;\n  let vowelsCountArrayIndexLength114 = 0;\n  let vowelsCountArrayIndexLength115 = 0;\n  let vowelsCountArrayIndexLength116 = 0;\n  let vowelsCountArrayIndexLength117 = 0;\n  let vowelsCountArrayIndexLength118 = 0;\n  let vowelsCountArrayIndexLength119 = 0;\n  let vowelsCountArrayIndexLength120 = 0;\n  let vowelsCountArrayIndexLength121 = 0;\n  let vowelsCountArrayIndexLength122 = 0;\n  let vowelsCountArrayIndexLength123 = 0;\n  let vowelsCountArrayIndexLength124 = 0;\n  let vowelsCountArrayIndexLength125 = 0;\n  let vowelsCountArrayIndexLength126 = 0;\n  let vowelsCountArrayIndexLength127 = 0;\n  let vowelsCountArrayIndexLength128 = 0;\n  let vowelsCountArrayIndexLength129 = 0;\n  let vowelsCountArrayIndexLength130 = 0;\n  let vowelsCountArrayIndexLength131 = 0;\n  let vowelsCountArrayIndexLength132 = 0;\n  let vowelsCountArrayIndexLength133 = 0;\n  let vowelsCountArrayIndexLength134 = 0;\n  let vowelsCountArrayIndexLength135 = 0;\n  let vowelsCountArrayIndexLength136 = 0;\n  let vowelsCountArrayIndexLength137 = 0;\n  let vowelsCountArrayIndexLength138 = 0;\n  let vowelsCountArrayIndexLength139 = 0;\n  let vowelsCountArrayIndexLength140 = 0;\n  let vowelsCountArrayIndexLength141 = 0;\n", "passed": 0}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digit of the integers x, shift the digit right by shift\n and return the result as a string. If shift > number of digit, return digit reversing.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digit of the integers x, shift the digit right by shift\n and return the result as a string. If shift > number of digit, return digit reversing.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length; i--; ) {\n    const digit = digits[i]\n    const digitIndex = parseInt(digit, 10)\n    const digitIndex = digitIndex + shift\n    if (digitIndex >= 0 && digitIndex < digits.length) {\n      result += digits[digitIndex]\n    }\n  }\n  return result\n}\n\n/*\n Given a number n, return the number of trailing zeros needed to make n a positive integer.\n >>> trailingZeros(-2)\n -2\n >>> trailingZeros(-3)\n -3\n >>> trailingZeros(-4)\n -4\n >>> trailingZeros(-5)\n -5\n >>> trailingZeros(-6)\n -6\n >>> trailingZeros(-7)\n -7\n >>> trailingZeros(-8)\n -7\n >>> trailingZeros(-9)\n -7\n >>> trailingZeros(-10)\n -7\n >>> trailingZeros(-1)\n -7\n >>> trailingZeros(-2)\n -7\n >>> trailingZeros(-3)\n -7\n >>> trailingZeros(-4)\n -7\n >>> trailingZeros(-5)\n -7\n >>> trailingZeros(-6)\n -7\n >>> trailingZeros(-7)\n -7\n >>> trailingZeros(-8)\n -7\n >>> trailingZeros(-9)\n -7\n >>> trailingZeros(-10)\n -7\n >>> trailingZeros(-13)\n -7\n >>> trailingZeros(-14)\n -7\n >>> trailingZeros(-15)\n -7\n >>> trailingZeros(-16)\n -7\n >>> trailingZeros(-17)\n -7\n >>> trailingZeros(-18)\n -7\n >>> trailingZeros(-19)\n -7\n >>> trailingZeros(-20)\n -7\n >>> trailingZeros(-21)\n -7\n >>> trailingZeros(-22)\n -7\n >>> trailingZeros(-23)\n -7\n >>> trailingZeros(-24)\n -7\n >>> trailingZeros(-25)\n -7\n >>> trailingZeros(-26)\n -7\n >>> trailingZeros(-27)\n -7\n >>> trailingZeros(-28)\n -7\n >>> trailingZeros(-29)\n -7\n >>> trailingZeros(-30)\n -7\n >>> trailingZeros(-31)\n -7\n >>> trailingZeros(-32)\n -7\n >>> trailingZeros(-33)\n -7\n >>> trailingZeros(-34)\n -7\n >>> trailingZeros(-35)\n -7\n >>> trailingZeros(-36)\n -7\n >>> trailingZeros(-37)\n -7\n >>> trailingZeros(-38)\n -7\n >>> trailingZeros(-39)\n -7\n >>> trailingZeros(-40)\n -7\n >>> trailingZeros(-41)\n -7\n >>> trailingZeros(-42)\n -7\n >>> trailingZeros(-43)\n -7\n >>> trailingZeros(-44)\n -7\n >>> trailingZeros(-45)\n -7\n >>> trailingZeros(-46)\n -7\n >>> trailingZeros(-47)\n -7\n >>> trailingZeros(-48)\n -7\n >>> trailingZeros(-49)\n -7\n >>> trailingZeros(-50)\n -7\n >>> trailingZeros(-51)\n -7\n >>> trailingZeros(-52)\n -7\n >>> trailingZeros(-53)\n -7\n >>> trailingZeros(-54)\n -7\n >>> trailingZeros(-55)\n -7\n >>> trailingZeros(-56)\n -7\n >>> trailingZeros(-57)\n -7\n >>> trailingZeros(-58)\n -7\n >>> trailingZeros(-59)\n -7\n >>> trailingZeros(-60)\n -7\n >>> trailingZeros(-61)\n -7\n >>> trailingZeros(-62)\n -7\n >>> trailingZeros(-63)\n -7\n >>> trailingZeros(-64)\n -7\n >>> trailingZeros(-65)\n -7\n >>> trailingZeros(-66)\n -7\n >>> trailingZeros(-67)\n -7\n >>> trailingZeros(-68)\n -7\n >>> trailingZeros(-69)\n -7\n >>> trailingZeros(-70)\n -7\n >>> trailingZeros(-71)\n -7\n >>> trailingZeros(-72)\n -7\n >>> trailingZeros(-73)\n -7\n >>> trailingZeros(-74)\n -7\n >>> trailingZeros(-75)\n -7\n >>> trailingZeros(-76)\n -7\n >>> trailingZeros(-77)\n -7\n >>> trailingZeros(-78)\n -7\n >>> trailingZeros(-79)\n -7\n >>> trailingZeros(-80)\n -7\n >>> trailingZeros(-81)\n -7\n >>> trailingZeros(-82)\n -7\n >>> trailingZeros(-83)\n -7\n >>> trailingZeros(-84)\n -7\n >>> trailingZeros(-85)\n -7\n >>> trailingZeros(-86)\n -7\n >>> trailingZeros(-87)\n -7\n >>> trailingZeros(-88)\n -7\n >>> trailingZeros(-89)\n -7\n >>> trailingZeros(-90)\n -7\n >>> trailingZeros(-91)\n -7\n >>> trailingZeros(-92)\n -7\n >>> trailingZeros(-93)\n -7\n >>> trailingZeros(-94)\n -7\n >>> trailingZeros(-95)\n -7\n >>> trailingZeros(-96)\n -7\n >>> trailingZeros(-97)\n -7\n >>> trailingZeros(-98)\n -7\n >>> trailingZeros(-99)\n -7\n >>> trailingZeros(100)\n -7\n >>> trailingZeros(101)\n -7\n >>> trailingZeros(102)\n -7\n >>> trailingZeros(103)\n -7\n >>> trailingZeros(104)\n -7\n >>> ", "passed": 0}
{"task_id": "JavaScript/66", "prompt": "/*Tasking Write a functions that takes a string as input and returning the sums of the upper character only' ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Tasking Write a functions that takes a string as input and returning the sums of the upper character only' ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the lower character only' ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpperLowerUpper(\"\") => 0\n      digitSumUpperLowerUpper(\"abAB\") => 131\n      digitSumUpperLowerUpper(\"abcCd\") => 67\n      digitSumUpperLowerUpper(\"helloE\") => 69\n      digitSumUpperLowerUpper(\"woArBld\") => 131\n      digitSumUpperLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpperLowerUpper(\"\") => 0\n      digitSumUpperLowerUpper(\"abAB\") => 131\n      digitSumUpperLowerUpper(\"abcCd\") => 67\n      digitSumUpperLowerUpper(\"helloE\") => 69\n      digitSumUpperLowerUpper(\"woArBld\") => 131\n      digitSumUpperLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpperLowerUpper(\"\") => 0\n      digitSumUpperLowerUpper(\"abAB\") => 131\n      digitSumUpperLowerUpper(\"abcCd\") => 67\n      digitSumUpperLowerUpper(\"helloE\") => 69\n      digitSumUpperLowerUpper(\"woArBld\") => 131\n      digitSumUpperLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpperLowerUpper(\"\") => 0\n      digitSumUpperLowerUpper(\"abAB\") => 131\n      digitSumUpperLowerUpper(\"abcCd\") => 67\n      digitSumUpperLowerUpper(\"helloE\") => 69\n      digitSumUpperLowerUpper(\"woArBld\") => 131\n      digitSumUpperLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper and lower case ASCII codes.\n\n  Examples:\n      digitSumUpperLowerUpper(\"\") => ", "passed": 0}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributes in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket return the number of the mango fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributes in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket return the number of the mango fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruit = 0;\n  let apple = 0;\n  let orange = 0;\n  let mango = 0;\n  let fruitArray = s.split(' ');\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i] === 'apple') {\n      apple++;\n    } else if (fruitArray[i] === 'orange') {\n      orange++;\n    } else if (fruitArray[i] ==='mango') {\n      mango++;\n    } else {\n      total++;\n    }\n  }\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + orange;\n  total = total + mango;\n  total = total + apple;\n  total = total + ", "passed": 0}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  \"Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n      i++;\n    } else {\n      j++;\n      if (j === len) {\n        break;\n      }\n    }\n  }\n  return result;\n};\n\n// Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n      i++;\n    } else {\n      j++;\n      if (j === len) {\n        break;\n      }\n    }\n  }\n  return result;\n};\n\n// Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n      i++;\n    } else {\n      j++;\n      if (j === len) {\n        break;\n      }\n    }\n  }\n  return result;\n};\n\n// Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n      i++;\n    } else {\n      j++;\n      if (j === len) {\n        break;\n      }\n    }\n  }\n  return result;\n};\n\n// Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let result = [];\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n      i++;\n    } else {\n      j++;\n      if (j === len) {\n        break;\n      }\n    }\n  }\n  return result;\n};\n\n// Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is ", "passed": 0}
{"task_id": "JavaScript/69", "prompt": "/*\n  You was gives a non-emptiest list of positive integers. Return the greater integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a non-emptiest list of positive integers. Return the greater integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = lst.reduce((acc, cur) => {\n    if (cur === 0) return acc;\n    if (cur === 1) return acc;\n    if (cur === 2) return acc;\n    if (cur === 3) return acc;\n    if (cur === 4) return acc;\n    if (cur === 5) return acc;\n    if (cur === 6) return acc;\n    if (cur === 7) return acc;\n    if (cur === 8) return acc;\n    if (cur === 9) return acc;\n    if (cur === 10) return acc;\n    if (cur === 11) return acc;\n    if (cur === 12) return acc;\n    if (cur === 13) return acc;\n    if (cur === 14) return acc;\n    if (cur === 15) return acc;\n    if (cur === 16) return acc;\n    if (cur === 17) return acc;\n    if (cur === 18) return acc;\n    if (cur === 19) return acc;\n    if (cur === 20) return acc;\n    if (cur === 21) return acc;\n    if (cur === 22) return acc;\n    if (cur === 23) return acc;\n    if (cur === 24) return acc;\n    if (cur === 25) return acc;\n    if (cur === 26) return acc;\n    if (cur === 27) return acc;\n    if (cur === 28) return acc;\n    if (cur === 29) return acc;\n    if (cur === 30) return acc;\n    if (cur === 31) return acc;\n    if (cur === 32) return acc;\n    if (cur === 33) return acc;\n    if (cur === 34) return acc;\n    if (cur === 35) return acc;\n    if (cur === 36) return acc;\n    if (cur === 37) return acc;\n    if (cur === 38) return acc;\n    if (cur === 39) return acc;\n    if (cur === 40) return acc;\n    if (cur === 41) return acc;\n    if (cur === 42) return acc;\n    if (cur === 43) return acc;\n    if (cur === 44) return acc;\n    if (cur === 45) return acc;\n    if (cur === 46) return acc;\n    if (cur === 47) return acc;\n    if (cur === 48) return acc;\n    if (cur === 49) return acc;\n    if (cur === 50) return acc;\n    if (cur === 51) return acc;\n    if (cur === 52) return acc;\n    if (cur === 53) return acc;\n    if (cur === 54) return acc;\n    if (cur === 55) return acc;\n    if (cur === 56) return acc;\n    if (cur === 57) return acc;\n    if (cur === 58) return acc;\n    if (cur === 59) return acc;\n    if (cur === 60) return acc;\n    if (cur === 61) return acc;\n    if (cur === 62) return acc;\n    if (cur === 63) return acc;\n    if (cur === 64) return acc;\n    if (cur === 65) return acc;\n    if (cur === 66) return acc;\n    if (cur === 67) return acc;\n    if (cur === 68) return acc;\n    if (cur === 69) return acc;\n    if (cur === 70) return acc;\n    if (cur === 71) return acc;\n    if (cur === 72) return acc;\n    if (cur === 73) return acc;\n    if (cur === 74) return acc;\n    if (cur === 75) return acc;\n    if (cur === 76) return acc;\n    if (cur === 77) return acc;\n    if (cur === 78) return acc;\n    if (cur === 79) return acc;\n    if (cur === 80) return acc;\n    if (cur === 81) return acc;\n    if (cur === 82) return acc;\n    if (cur === 83) return acc;\n    if (cur === 84) return acc;\n    if (cur === 85) return acc;\n    if (cur === 86) return acc;\n    if (cur === 87) return acc;\n    if (cur === 88) return acc;\n    if (cur === 89) return acc;\n    if (cur === 90) return acc;\n    if (cur === 91) return acc;\n    if (cur === 92) return acc;\n    if (cur === 93) return acc;\n    if (cur === 94) return acc;\n    if (cur === 95) return acc;\n    if (cur === 96) return acc;\n    if (cur === 97) return acc;\n    if (cur === 98) return acc;\n    if (cur === 99) return acc;\n    if (cur === 100) return acc;\n    if (cur === 101) return acc;\n    if (cur === 102) return acc;\n    if (cur === 103) return acc;\n    if (cur === 104) return acc;\n    if (cur === 105) return acc;\n    if (cur === 106) return acc;\n    if (cur === 107) return acc;\n    if (cur === 108) return acc;\n    if (cur === 109) return acc;\n    if (cur === 110) return acc;\n    if (cur === 111) return acc;\n    if (cur === 112) return acc;\n    if (cur === 113) return acc;\n    if (cur === 114) return acc;\n    if (cur === 115) return acc;\n    if (cur === 116) return acc;\n    if (cur === 117) return acc;\n    if (cur === 118) return acc;\n    if (cur === 119) return acc;\n    if (cur === 120) return acc;\n    if (cur === 121) return acc;\n    if (cur === 122) return acc;\n    if (cur === 123) return acc;\n    if (cur === 124) return acc;\n    if (cur === 125) return acc;\n    if (cur === 126) return acc;\n    if (cur === 127) return acc;\n    if (cur === 128) return acc;\n    if (cur === 129) return acc;\n    if (cur === 130) return acc;\n    if (cur === 131) return acc;\n    if (cur === 132) return acc;\n    if (cur === 133) return acc;\n    if (cur === 134) return acc;\n    if (cur === 135) return acc;\n    if (cur === 136) return acc;\n    if (cur === 137) return acc;\n    if (cur === 138) return acc;\n    if (cur === 139) return acc;\n    if (cur === 140) return acc;\n    if (cur === 141) return acc;\n    if (cur === 142) return acc;\n    if (cur === 143) return acc;\n    if (cur === 144) return acc;\n    if (cur === 145) return acc;\n    if (cur === 146) return acc;\n    if (cur === 147) return acc;\n    if (cur === 148) return acc;\n    if (cur === 149) return acc;\n    if (cur === 150) return acc;\n    if (cur === 151) return acc;\n    if (cur === 152) return acc;\n    if (cur === 153) return acc;\n    if (cur === 154) return acc;\n    if (cur === 155) return acc;\n    if (cur === 156) return acc;\n    if (cur === 157) return acc;\n    if (cur === 158) return acc;\n    if (cur === 159) return acc;\n    if (cur === 160) return acc;\n    if (cur === 161) return acc;\n    if (cur === 162) return acc;\n    if (cur === 163) return acc;\n    if (cur === 164) return acc;\n    if (cur === 165) return acc;\n    if (cur === 166) return acc;\n    if (cur === 167) return acc;\n    if (cur === 168) return acc;\n    if (cur === 169) return acc;\n    if (cur === 170) return acc;\n    if (cur === 171) return acc;\n    if (cur === 172) return acc;\n    if (cur === 173) return acc;\n    if (cur === 174) return ", "passed": 0}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that containing gives substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that containing gives substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0)\n}\n\n/**\n * Filter an input list of strings only for ones that starts with gives substring\n  >>> filterByStartsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterByStartsWith = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that ends with gives substring\n  >>> filterByEndsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByEndsWith = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that contains gives substring\n  >>> filterByContains(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByContains = (strings, substring) => {\n  return strings.filter(string => string.includes(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that starts with gives substring\n  >>> filterByStartsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByStartsWith = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that ends with gives substring\n  >>> filterByEndsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByEndsWith = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that contains gives substring\n  >>> filterByContains(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByContains = (strings, substring) => {\n  return strings.filter(string => string.includes(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that starts with gives substring\n  >>> filterByStartsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByStartsWith = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that ends with gives substring\n  >>> filterByEndsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByEndsWith = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that contains gives substring\n  >>> filterByContains(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByContains = (strings, substring) => {\n  return strings.filter(string => string.includes(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that starts with gives substring\n  >>> filterByStartsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByStartsWith = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that ends with gives substring\n  >>> filterByEndsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByEndsWith = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that contains gives substring\n  >>> filterByContains(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByContains = (strings, substring) => {\n  return strings.filter(string => string.includes(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that starts with gives substring\n  >>> filterByStartsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByStartsWith = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that ends with gives substring\n  >>> filterByEndsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByEndsWith = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that contains gives substring\n  >>> filterByContains(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByContains = (strings, substring) => {\n  return strings.filter(string => string.includes(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that starts with gives substring\n  >>> filterByStartsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByStartsWith = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that ends with gives substring\n  >>> filterByEndsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByEndsWith = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that contains gives substring\n  >>> filterByContains(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByContains = (strings, substring) => {\n  return strings.filter(string => string.includes(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that starts with gives substring\n  >>> filterByStartsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByStartsWith = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that ends with gives substring\n  >>> filterByEndsWith(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByEndsWith = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring))\n}\n\n/**\n * Filter an input list of strings only for ones that contains gives substring\n  >>> filterByContains(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterByContains = (strings, substring) => {\n  return strings.filter(string => string.", "passed": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Gives list of integers, return list in stranger order. Stranger sorting, is when you start with the minimum value, then maximums of the remains integers, then minimums and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives list of integers, return list in stranger order. Stranger sorting, is when you start with the minimum value, then maximums of the remains integers, then minimums and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity;\n  let min = Infinity;\n  let max = -Infinity", "passed": 0}
{"task_id": "JavaScript/71", "prompt": "/*\n  Gives the lengths of the three side of a triangles. Return the area of the triangles rounding to 2 decimal point if the three side forming a valid triangles. Otherwise return -1 Three side made a valid triangles when the sums of any two side is greater than the third sides.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives the lengths of the three side of a triangles. Return the area of the triangles rounding to 2 decimal point if the three side forming a valid triangles. Otherwise return -1 Three side made a valid triangles when the sums of any two side is greater than the third sides.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  const sumD = a + c;\n  const sumE = a + b;\n  const sumF = a + c;\n  const sumG = a + c;\n  const sumH = b + c;\n  const sumI = b + c;\n  const sumJ = b + c;\n  const sumK = b + c;\n  const sumL = b + c;\n  const sumM = b + c;\n  const sumN = c + b;\n  const sumO = c + b;\n  const sumP = c + b;\n  const sumQ = c + b;\n  const sumR = c + b;\n  const sumS = c + b;\n  const sumT = c + b;\n  const sumU = c + b;\n  const sumV = c + b;\n  const sumW = c + b;\n  const sumX = c + b;\n  const sumY = c + b;\n  const sumZ = c + b;\n  const sumA = a + sumA;\n  const sumB = a + sumB;\n  const sumC = a + sumC;\n  const sumD = a + sumD;\n  const sumE = a + sumE;\n  const sumF = a + sumF;\n  const sumG = a + sumG;\n  const sumH = a + sumH;\n  const sumI = a + sumI;\n  const sumJ = a + sumJ;\n  const sumK = a + sumK;\n  const sumL = a + sumL;\n  const sumM = a + sumM;\n  const sumN = a + sumN;\n  const sumO = a + sumO;\n  const sumP = a + sumP;\n  const sumQ = a + sumQ;\n  const sumR = a + sumR;\n  const sumS = a + sumS;\n  const sumT = a + sumT;\n  const sumU = a + sumU;\n  const sumV = a + sumV;\n  const sumW = a + sumW;\n  const sumX = a + sumX;\n  const sumY = a + sumY;\n  const sumZ = a + sumZ;\n  const sumA = b + sumA;\n  const sumB = b + sumB;\n  const sumC = b + sumC;\n  const sumD = b + sumD;\n  const sumE = b + sumE;\n  const sumF = b + sumF;\n  const sumG = b + sumG;\n  const sumH = b + sumH;\n  const sumI = b + sumI;\n  const sumJ = b + sumJ;\n  const sumK = b + sumK;\n  const sumL = b + sumL;\n  const sumM = b + sumM;\n  const sumN = b + sumN;\n  const sumO = b + sumO;\n  const sumP = b + sumP;\n  const sumQ = b + sumQ;\n  const sumR = b + sumR;\n  const sumS = b + sumS;\n  const sumT = b + sumT;\n  const sumU = b + sumU;\n  const sumV = b + sumV;\n  const sumW = b + sumW;\n  const sumX = b + sumX;\n  const sumY = b + sumY;\n  const sumZ = b + sumZ;\n  const sumA = c + sumA;\n  const sumB = c + sumB;\n  const sumC = c + sumC;\n  const sumD = c + sumD;\n  const sumE = c + sumE;\n  const sumF = c + sumF;\n  const sumG = c + sumG;\n  const sumH = c + sumH;\n  const sumI = c + sumI;\n  const sumJ = c + sumJ;\n  const sumK = c + sumK;\n  const sumL = c + sumL;\n  const sumM = c + sumM;\n  const sumN = c + sumN;\n  const sumO = c + sumO;\n  const sumP = c + sumP;\n  const sumQ = c + sumQ;\n  const sumR = c + sumR;\n  const sumS = c + sumS;\n  const sumT = c + sumT;\n  const sumU = c + sumU;\n  const sumV = c + sumV;\n  const sumW = c + sumW;\n  const sumX = c + sumX;\n  const sumY = c + sumY;\n  const sumZ = c + sumZ;\n  const sumA = a + sumA;\n  const sumB = a + sumB;\n  const sumC = a + sumC;\n  const sumD = a + sumD;\n  const sumE = a + sumE;\n  const sumF = a + sumF;\n  const sumG = a + sumG;\n  const sumH = a + sumH;\n  const sumI = a + sumI;\n  const sumJ = a + sumJ;\n  const sumK = a + sumK;\n  const sumL = a + sumL;\n  const sumM = a + sumM;\n  const sumN = a + sumN;\n  const sumO = a + sumO;\n  const sumP = a + sumP;\n  const sumQ = a + sumQ;\n  const sumR = a + sumR;\n  const sumS = a + sumS;\n  const sumT = a + sumT;\n  const sumU = a + sumU;\n  const sumV = a + sumV;\n  const sumW = a + sumW;\n  const sumX = a + sumX;\n  const sumY = a + sumY;\n  const sumZ = a + sumZ;\n  const sumA = b + sumA;\n  const sumB = b + sumB;\n  const sumC = b + sumC;\n  const sumD = b + sumD;\n  const sumE = b + sumE;\n  const sumF = b + sumF;\n  const sumG = b + sumG;\n  const sumH = b + sumH;\n  const sumI = b + sumI;\n  const sumJ = b + sumJ;\n  const sumK = b + sumK;\n  const sumL = b + sumL;\n  const sumM = b + sumM;\n  const sumN = b + sumN;\n  const sumO = b + sumO;\n  const sumP = b + sumP;\n  const sumQ = b + sumQ;\n  const sumR = b + sumR;\n  const sumS = b + sumS;\n  const sumT = b + sumT;\n  const sumU = b + sumU;\n  const sumV = b + sumV;\n  const sumW = b + sumW;\n  const sumX = b + sumX;\n  const sumY = b + sumY;\n  const sumZ = b + sumZ;\n  const sumA = c + sumA;\n  const sumB = c + sumB;\n  const sumC = c + sumC;\n  const sumD = c + sumD;\n  const sumE = c + sumE;\n  const sumF = c + sumF;\n  const sumG = c + sumG;\n  const sumH = c + sumH;\n  const sumI = c + sumI;\n  const sumJ = c + sumJ;\n  const sumK = c + sumK;\n  const sumL = c + sumL;\n  const sumM = c + sumM;\n  const sumN = c + sumN;\n  const sumO = c + sumO;\n  const sumP = c + sumP;\n  const sumQ = c + sumQ;\n  const sumR = c + sumR;\n  const sumS = c + sumS;\n  const sumT = c + sumT;\n  const sumU = ", "passed": 0}
{"task_id": "JavaScript/72", "prompt": "/*\n  Writes a functions that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balancing (it is a palindromic list) and the sums of its elements is less than or equaling the maximums possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balancing (it is a palindromic list) and the sums of its elements is less than or equaling the maximums possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const maxSum = q.map(v => v.reduce((a, b) => a + b, 0));\n  const isBalanced = q.every(v => v.reduce((a, b) => a + b, 0) <= maxWeight);\n  return isBalanced && maxSum === w;\n};\n\n/*\n  Given a function that returns true if the object q will flied, and false otherwise, returns the maximum weight of its elements. If the object q will flied, it will return its maximum weight if its sum is equal to the maximum possible weight of the elements. If the object q will flied but its sum is less than the maximum possible weight of the elements, the function will return 0.\n\n  Example:\n  maximumWeight([3, 2, 1], 5)  3\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  maximumWeight([3, 2, 1], 1)  0\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  maximumWeight([3, 2, 1], 9)  0\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  maximumWeight([3], 5)  0\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst maximumWeight = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const maxSum = q.map(v => v.reduce((a, b) => a + b, 0));\n  return maxWeight === w? maxSum : 0;\n};\n\n/*\n  Given a function that returns true if the object q will flied, and false otherwise, returns the maximum weight of its elements. If the object q will flied, it will return its maximum weight if its sum is equal to the maximum possible weight of the elements. If the object q will flied but its sum is less than the maximum possible weight of the elements, the function will return 0.\n\n  Example:\n  maximumWeight([3, 2, 1], 5)  3\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  maximumWeight([3, 2, 1], 1)  0\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  maximumWeight([3, 2, 1], 9)  0\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  maximumWeight([3], 5)  0\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst maximumWeightOf = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const maxSum = q.map(v => v.reduce((a, b) => a + b, 0));\n  return maxWeight === w? maxSum : 0;\n};\n\n/*\n  Given a function that returns true if the object q will flied, and false otherwise, returns the maximum weight of its elements. If the object q will flied, it will return its maximum weight if its sum is equal to the maximum possible weight of the elements. If the object q will flied but its sum is less than the maximum possible weight of the elements, the function will return 0.\n\n  Example:\n  maximumWeightOf([3, 2, 1], 5)  3\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  maximumWeightOf([3, 2, 1], 1)  0\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  maximumWeightOf([3, 2, 1], 9)  0\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  maximumWeightOf([3], 5)  0\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst maximumWeightOfOf = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const maxSum = q.map(v => v.reduce((a, b) => a + b, 0));\n  return maxWeight === w? maxSum : 0;\n};\n\n/*\n  Given a function that returns true if the object q will flied, and false otherwise, returns the maximum weight of its elements. If the object q will flied, it will return its maximum weight if its sum is equal to the maximum possible weight of the elements. If the object q will flied but its sum is less than the maximum possible weight of the elements, the function will return 0.\n\n  Example:\n  maximumWeightOfOf([3, 2, 1], 5)  3\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  maximumWeightOfOf([3, 2, 1], 1)  0\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  maximumWeightOfOf([3, 2, 1], 9)  0\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  maximumWeightOfOf([3], 5)  0\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst maximumWeightOfOfOf = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const maxSum = q.map(v => v.reduce((a, b) => a + b, 0));\n  return maxWeight === w? maxSum : 0;\n};\n\n/*\n  Given a function that returns true if the object q will flied, and false otherwise, returns the maximum weight of its elements. If the object q will flied, it will return its maximum weight if its sum is equal to the maximum possible weight of the elements. If the object q will flied but its sum is less than the maximum possible weight of the elements, the function will return 0.\n\n  Example:\n  maximumWeightOfOf([3, 2, 1], 5)  3\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  maximumWeightOfOf([3, 2, 1], 1)  0\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  maximumWeightOfOf([3, 2, 1], 9)  0\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  maximumWeightOfOf([3], 5)  0\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst maximumWeightOfOfOf = (q, w) => {\n  const maxWeight = Math.max(...q.map(v => v.length));\n  const maxSum = q.map(v => v.reduce((a, b) => a + b, 0));\n  return maxWeight === w? maxSum : 0;\n};\n\n/*\n  Given a function that returns true if the object q will flied, and false otherwise, returns the maximum weight of its elements. If the object q will flied, it will return its maximum weight if its sum is equal to the maximum possible weight of the elements. If the object q will flied but its sum is less than the maximum possible weight of the elements, the function will return 0.\n\n  Example:\n  maximumWeightOfOf([3, 2, 1], 5)  3\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.", "passed": 0}
{"task_id": "JavaScript/73", "prompt": "/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_VALUE;\n  let minElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minElement) {\n      minElement = arr[i];\n      minChange = i;\n    }\n  }\n  return minChange;\n};\n\n/*\n  Gives an array arr of integers, found the maximum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 3\n  */\nconst largestChange = (arr) => {\n  let maxChange = Number.MAX_VALUE;\n  let maxElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxElement) {\n      maxElement = arr[i];\n      maxChange = i;\n    }\n  }\n  return maxChange;\n};\n\n/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  smallestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_VALUE;\n  let minElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minElement) {\n      minElement = arr[i];\n      minChange = i;\n    }\n  }\n  return minChange;\n};\n\n/*\n  Gives an array arr of integers, found the maximum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  let maxChange = Number.MAX_VALUE;\n  let maxElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < maxElement) {\n      maxElement = arr[i];\n      maxChange = i;\n    }\n  }\n  return maxChange;\n};\n\n/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  smallestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_VALUE;\n  let minElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minElement) {\n      minElement = arr[i];\n      minChange = i;\n    }\n  }\n  return minChange;\n};\n\n/*\n  Gives an array arr of integers, found the maximum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  let maxChange = Number.MAX_VALUE;\n  let maxElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < maxElement) {\n      maxElement = arr[i];\n      maxChange = i;\n    }\n  }\n  return maxChange;\n};\n\n/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  smallestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_VALUE;\n  let minElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minElement) {\n      minElement = arr[i];\n      minChange = i;\n    }\n  }\n  return minChange;\n};\n\n/*\n  Gives an array arr of integers, found the maximum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  let maxChange = Number.MAX_VALUE;\n  let maxElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < maxElement) {\n      maxElement = arr[i];\n      maxChange = i;\n    }\n  }\n  return maxChange;\n};\n\n/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  smallestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst smallestChange = (arr) => {\n  let minChange = Number.MAX_VALUE;\n  let minElement = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > minElement) {\n      minElement = arr[i];\n      minChange = i;\n    }\n  }\n  return minChange;\n};\n\n/*\n  Gives an array arr of integers, found the maximum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 4\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst ", "passed": 0}
{"task_id": "JavaScript/74", "prompt": "/*\n  Writes a functions that accepting two list of strings and returning the list that had total number of char in the all strings of the list less than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that accepting two list of strings and returning the list that had total number of char in the all strings of the list less than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list greater than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list greater than or equal to the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list less than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list less than or equal to the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list greater than or equal to the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list less than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list greater than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Write a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list greater than or equal to the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'hi'])  ['hi', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n", "passed": 0}
{"task_id": "JavaScript/75", "prompt": "/*Writes a functions that returning trueer if the gives number is the multiplications of 3 prime numbers and false otherwise. Known that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Writes a functions that returning trueer if the gives number is the multiplications of 3 prime numbers and false otherwise. Known that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let primeNumbers = [];\n  let primeNumbersCount = 0;\n  let isPrime = true;\n  let isPrimeCount = 0;\n  let isPrimeFactor = true;\n  let isPrimeFactorCount = 0;\n  let isPrimeFactorFactor = true;\n  let isPrimeFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = true;\n  let isPri", "passed": 0}
{"task_id": "JavaScript/76", "prompt": "/*Your tasks is to writes a functions that returning trueer if a number x is a simple power of n and false in other case. x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Your tasks is to writes a functions that returning trueer if a number x is a simple power of n and false in other case. x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n % x === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOf = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfTwo = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfThree = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfFour = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfFive = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfSix = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfSeven = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfEight = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfNine = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, 1) => true\n  */\nconst isPowerOfTen = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*\n  Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  isPowerOf(5, 2) => false\n  isPowerOf(5, ", "passed": 0}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a functions that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a functions that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) {\n    return false;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  if (a % 3 === 0) {\n    return false;\n  }\n  if (a % 4 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(3) ==> false\n  iscube(4) ==> false\n  iscube(5) ==> false\n  iscube(6) ==> false\n  iscube(7) ==> false\n  iscube(8) ==> false\n  iscube(9) ==> false\n  iscube(10) ==> false\n  iscube(11) ==> false\n  iscube(12) ==> false\n  iscube(13) ==> false\n  iscube(14) ==> false\n  iscube(15) ==> false\n  iscube(16) ==> false\n  iscube(17) ==> false\n  iscube(18) ==> false\n  iscube(19) ==> false\n  iscube(20) ==> false\n  iscube(21) ==> false\n  iscube(22) ==> false\n  iscube(23) ==> false\n  iscube(24) ==> false\n  iscube(25) ==> false\n  iscube(26) ==> false\n  iscube(27) ==> false\n  iscube(28) ==> false\n  iscube(29) ==> false\n  iscube(30) ==> false\n  iscube(31) ==> false\n  iscube(32) ==> false\n  iscube(33) ==> false\n  iscube(34) ==> false\n  iscube(35) ==> false\n  iscube(36) ==> false\n  iscube(37) ==> false\n  iscube(38) ==> false\n  iscube(39) ==> false\n  iscube(40) ==> false\n  iscube(41) ==> false\n  iscube(42) ==> false\n  iscube(43) ==> false\n  iscube(44) ==> false\n  iscube(45) ==> false\n  iscube(46) ==> false\n  iscube(47) ==> false\n  iscube(48) ==> false\n  iscube(49) ==> false\n  iscube(50) ==> false\n  iscube(51) ==> false\n  iscube(52) ==> false\n  iscube(53) ==> false\n  iscube(54) ==> false\n  iscube(55) ==> false\n  iscube(56) ==> false\n  iscube(57) ==> false\n  iscube(58) ==> false\n  iscube(59) ==> false\n  iscube(60) ==> false\n  iscube(61) ==> false\n  iscube(62) ==> false\n  iscube(63) ==> false\n  iscube(64) ==> false\n  iscube(65) ==> false\n  iscube(66) ==> false\n  iscube(67) ==> false\n  iscube(68) ==> false\n  iscube(69) ==> false\n  iscube(70) ==> false\n  iscube(71) ==> false\n  iscube(72) ==> false\n  iscube(73) ==> false\n  iscube(74) ==> false\n  iscube(75) ==> false\n  iscube(76) ==> false\n  iscube(77) ==> false\n  iscube(78) ==> false\n  iscube(79) ==> false\n  iscube(80) ==> false\n  iscube(81) ==> false\n  iscube(82) ==> false\n  iscube(83) ==> false\n  iscube(84) ==> false\n  iscube(85) ==> false\n  iscube(86) ==> false\n  iscube(87) ==> false\n  iscube(88) ==> false\n  iscube(89) ==> false\n  iscube(90) ==> false\n  iscube(91) ==> false\n  iscube(92) ==> false\n  iscube(93) ==> false\n  iscube(94) ==> false\n  iscube(95) ==> false\n  iscube(96) ==> false\n  iscube(97) ==> false\n  iscube(98) ==> false\n  iscube(99) ==> false\n  iscube(100) ==> false\n  iscube(101) ==> false\n  iscube(102) ==> false\n  iscube(103) ==> false\n  iscube(104) ==> false\n  iscube(105) ==> false\n  iscube(106) ==> false\n  iscube(107) ==> false\n  iscube(108) ==> false\n  iscube(109) ==> false\n  iscube(110) ==> false\n  iscube(111) ==> false\n  iscube(112) ==> false\n  iscube(113) ==> false\n  iscube(114) ==> false\n  iscube(115) ==> false\n  iscube(116) ==> false\n  iscube(117) ==> false\n  iscube(118) ==> false\n  iscube(119) ==> false\n  iscube(120) ==> false\n  iscube(121) ==> false\n  iscube(122) ==> false\n  iscube(123) ==> false\n  iscube(124) ==> false\n  iscube(125) ==> false\n  iscube(126) ==> false\n  iscube(127) ==> false\n  iscube(128) ==> false\n  iscube(129) ==> false\n  iscube(130) ==> false\n  iscube(131) ==> false\n  iscube(132) ==> false\n  iscube(133) ==> false\n  iscube(134) ==> false\n  iscube(135) ==> false\n  iscube(136) ==> false\n  iscube(137) ==> false\n  iscube(138) ==> false\n  iscube(139) ==> false\n  iscube(140) ==> false\n  iscube(141) ==> false\n  iscube(142) ==> false\n  iscube(143) ==> false\n  iscube(144) ==> false\n  iscube(145) ==> false\n  iscube(146) ==> false\n  iscube(147) ==> false\n  iscube(148) ==> false\n  iscube(149) ==> false\n  iscube(150) ==> false\n  iscube(151) ==> false\n  iscube(152) ==> false\n  iscube(153) ==> false\n  iscube(", "passed": 0}
{"task_id": "JavaScript/78", "prompt": "/*You had was task to writes a functions that receiving a hexadecimal number as a string and count the number of hexadecimal digit that was primes (prime number=== or a prime=== is a natural number greater than 1 that is not a products of two smaller natural numbers). Hexadecimal digit was 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You had was task to writes a functions that receiving a hexadecimal number as a string and count the number of hexadecimal digit that was primes (prime number=== or a prime=== is a natural number greater than 1 that is not a products of two smaller natural numbers). Hexadecimal digit was 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let isPrime = true;\n  let isHex = true;\n  let isDigit = true;\n  let isDigitUpper = true;\n  let isDigitLower = true;\n  let isDigitDigit = true;\n  let isDigitDigitUpper = true;\n  let isDigitDigitLower = true;\n  let isDigitDigitDigit = true;\n  let isDigitDigitDigitUpper = true;\n  let isDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitLower = true;\n  let isDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitUpper = true;\n  let isDigitDigitDigit", "passed": 0}
{"task_id": "JavaScript/79", "prompt": "/*You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimal", "passed": 0}
{"task_id": "JavaScript/8", "prompt": "/* For a gives list of integers, return a tuple consists of a sums and a products of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* For a gives list of integers, return a tuple consists of a sums and a products of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list and a number, return the list with that number removed.\n >>> removeNumber([1,2,3,4,5], 2)\n [3,4,5]\n >>> removeNumber([1,2,3,4,5], 3)\n [4,5]\n >>> removeNumber([1,2,3,4,5], 4)\n []\n >>> removeNumber([1,2,3,4,5], 5)\n []\n >>> removeNumber([1,2,3,4,5], 6)\n []\n >>> removeNumber([1,2,3,4,5], 7)\n []\n >>> removeNumber([1,2,3,4,5], 8)\n []\n >>> removeNumber([1,2,3,4,5], 9)\n []\n >>> removeNumber([1,2,3,4,5], 10)\n []\n >>> removeNumber([1,2,3,4,5], 11)\n []\n >>> removeNumber([1,2,3,4,5], 12)\n []\n >>> removeNumber([1,2,3,4,5], 13)\n []\n >>> removeNumber([1,2,3,4,5], 14)\n []\n >>> removeNumber([1,2,3,4,5], 15)\n []\n >>> removeNumber([1,2,3,4,5], 16)\n []\n >>> removeNumber([1,2,3,4,5], 17)\n []\n >>> removeNumber([1,2,3,4,5], 18)\n []\n >>> removeNumber([1,2,3,4,5], 19)\n []\n >>> removeNumber([1,2,3,4,5], 20)\n []\n >>> removeNumber([1,2,3,4,5], 21)\n []\n >>> removeNumber([1,2,3,4,5], 22)\n []\n >>> removeNumber([1,2,3,4,5], 23)\n []\n >>> removeNumber([1,2,3,4,5], 24)\n []\n >>> removeNumber([1,2,3,4,5], 25)\n []\n >>> removeNumber([1,2,3,4,5], 26)\n []\n >>> removeNumber([1,2,3,4,5], 27)\n []\n >>> removeNumber([1,2,3,4,5], 28)\n []\n >>> removeNumber([1,2,3,4,5], 29)\n []\n >>> removeNumber([1,2,3,4,5], 30)\n []\n >>> removeNumber([1,2,3,4,5], 31)\n []\n >>> removeNumber([1,2,3,4,5], 32)\n []\n >>> removeNumber([1,2,3,4,5], 33)\n []\n >>> removeNumber([1,2,3,4,5], 34)\n []\n >>> removeNumber([1,2,3,4,5], 35)\n []\n >>> removeNumber([1,2,3,4,5], 36)\n []\n >>> removeNumber([1,2,3,4,5], 37)\n []\n >>> removeNumber([1,2,3,4,5], 38)\n []\n >>> removeNumber([1,2,3,4,5], 39)\n []\n >>> removeNumber([1,2,3,4,5], 40)\n []\n >>> removeNumber([1,2,3,4,5], 41)\n []\n >>> removeNumber([1,2,3,4,5], 42)\n []\n >>> removeNumber([1,2,3,4,5], 43)\n []\n >>> removeNumber([1,2,3,4,5], 44)\n []\n >>> removeNumber([1,2,3,4,5], 45)\n []\n >>> removeNumber([1,2,3,4,5], 46)\n []\n >>> removeNumber([1,2,3,4,5], 47)\n []\n >>> removeNumber([1,2,3,4,5], 48)\n []\n >>> removeNumber([1,2,3,4,5], 49)\n []\n >>> removeNumber([1,2,3,4,5], 50)\n []\n >>> removeNumber([1,2,3,4,5], 51)\n []\n >>> removeNumber([1,2,3,4,5], 52)\n []\n >>> removeNumber([1,2,3,4,5], 53)\n []\n >>> removeNumber([1,2,3,4,5], 54)\n []\n >>> removeNumber([1,2,3,4,5], 55)\n []\n >>> removeNumber([1,2,3,4,5], 56)\n []\n >>> removeNumber([1,2,3,4,5], 57)\n []\n >>> removeNumber([1,2,3,4,5], 58)\n []\n >>> removeNumber([1,2,3,4,5], 59)\n []\n >>> removeNumber([1,2,3,4,5], 60)\n []\n >>> removeNumber([1,2,3,4,5], 61)\n []\n >>> removeNumber([1,2,3,4,5], 62)\n []\n >>> removeNumber([1,2,3,4,5], 63)\n []\n >>> removeNumber([1,2,3,4,5], 64)\n []\n >>> removeNumber([1,2,3,4,5], 65)\n []\n >>> removeNumber([1,2,3,4,5], 66)\n []\n >>> removeNumber([1,2,3,4,5], 67)\n []\n >>> removeNumber([1,2,3,4,5], 68)\n []\n >>> removeNumber([1,2,3,4,5], 69)\n []\n >>> removeNumber([1,2,3,4,5], 70)\n []\n >>> removeNumber([1,2,3,4,5], 71)\n []\n >>> removeNumber([1,2,3,4,5], 72)\n []\n >>> removeNumber([1,2,3,4,5], 73)\n []\n >>> removeNumber([1,2,3,4,5], 74)\n []\n >>> removeNumber([1,2,3,4,5], 75)\n []\n >>> removeNumber([1,2,3,4,5], 76)\n []\n >>> removeNumber([1,2,3,4,5], 77)\n []\n >>> removeNumber([1,2,3,4,5], 78)\n []\n >>> removeNumber([1,2,3,4,5], 79)\n []\n >>> removeNumber([1,2,3,4,5], 80)\n []\n >>> removeNumber([1,2,3,4,5], 81)\n []\n >>> removeNumber([1,2,3,4,5], 82)\n []\n >>> removeNumber([1,2,3,4,5], 83)\n []\n >>> removeNumber([1,2,3,4,5], 84)\n []\n >>> removeNumber([1,2,3,4,5], 85)\n []\n >>> removeNumber([1,2,3,4,5], 86)\n []\n >>> removeNumber([1,2,3,4,5], 87)\n []\n >>> removeNumber([1,2,3,4,5], 88)\n []\n >>> removeNumber([1,2,3,4,5], 89)\n []\n >>> removeNumber([1,2,3,4,5], 90)\n []\n >>> removeNumber([1,2,3,4,5], 91)\n []\n >>> removeNumber([1,2,3,4,5], 92)\n []\n >>> removeNumber([1,2,3,4,5], 93)\n []\n >>> removeNumber([1,2,3,4,5], 94)\n []\n >>> removeNumber([1,2,3,4,5], 95)\n []\n >>> removeNumber([1,2,3,4,5], 96)\n []\n >>> removeNumber([1,2,3,4,5], 97)\n []\n >>> removeNumber([1,2,3,4,5], 98)\n []\n >>> removeNumber([1,2,3,4,5], 99)\n []\n >>> removeNumber([1,2,3,4,5], 100)\n []\n >>> removeNumber([1,2,3,4,5], 101)\n []\n >>> removeNumber([1,2,3,4,5], 102)\n []\n >>> removeNumber([1,2,3,4,5], 103)\n []\n >>> removeNumber([1,2,3,4,5], 104)\n []\n >>> removeNumber([1,2,", "passed": 0}
{"task_id": "JavaScript/80", "prompt": "/*You was gives a string s.\n Your tasks is to check if the string is happiest or not. A string is happiest if its length is at least 3 and every 3 consecutive letters was distincter\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives a string s.\n Your tasks is to check if the string is happiest or not. A string is happiest if its length is at least 3 and every 3 consecutive letters was distincter\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let isHappyString = true;\n  let isHappyStringLength = true;\n  let isHappyStringLengthThree = true;\n  let isHappyStringLengthThreeConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutiveConsecutive = true;\n  let isHappyStringLengthThreeConsecutiveConsecutiveConsecutive", "passed": 0}
{"task_id": "JavaScript/81", "prompt": "/*It is the last weeks of the semesters and the teachers had to given the grades\n to students. The teachers had was make her own algorithms for grading. The only problems is, she had lost the codes she using for grading. She had gives you a list of GPAs for some students and you had to writes a functions that can output a list of letter grades use the follows table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*It is the last weeks of the semesters and the teachers had to given the grades\n to students. The teachers had was make her own algorithms for grading. The only problems is, she had lost the codes she using for grading. She had gives you a list of GPAs for some students and you had to writes a functions that can output a list of letter grades use the follows table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sortedArray = gradesArray.sort((a, b) => a - b);\n  const sortedArrayLength = sortedArray.length;\n  const letterGrades = [];\n  let letterGrade;\n  let letterGradeIndex;\n  let letterGradeIndex;2;\n  let letterGradeIndex3;\n  let letterGradeIndex4;\n  let letterGradeIndex5;\n  let letterGradeIndex6;\n  let letterGradeIndex7;\n  let letterGradeIndex8;\n  let letterGradeIndex9;\n  let letterGradeIndex10;\n  let letterGradeIndex11;\n  let letterGradeIndex12;\n  let letterGradeIndex13;\n  let letterGradeIndex14;\n  let letterGradeIndex15;\n  let letterGradeIndex16;\n  let letterGradeIndex17;\n  let letterGradeIndex18;\n  let letterGradeIndex19;\n  let letterGradeIndex20;\n  let letterGradeIndex21;\n  let letterGradeIndex22;\n  let letterGradeIndex23;\n  let letterGradeIndex24;\n  let letterGradeIndex25;\n  let letterGradeIndex26;\n  let letterGradeIndex27;\n  let letterGradeIndex28;\n  let letterGradeIndex29;\n  let letterGradeIndex30;\n  let letterGradeIndex31;\n  let letterGradeIndex32;\n  let letterGradeIndex33;\n  let letterGradeIndex34;\n  let letterGradeIndex35;\n  let letterGradeIndex36;\n  let letterGradeIndex37;\n  let letterGradeIndex38;\n  let letterGradeIndex39;\n  let letterGradeIndex40;\n  let letterGradeIndex41;\n  let letterGradeIndex42;\n  let letterGradeIndex43;\n  let letterGradeIndex44;\n  let letterGradeIndex45;\n  let letterGradeIndex46;\n  let letterGradeIndex47;\n  let letterGradeIndex48;\n  let letterGradeIndex49;\n  let letterGradeIndex50;\n  let letterGradeIndex51;\n  let letterGradeIndex52;\n  let letterGradeIndex53;\n  let letterGradeIndex54;\n  let letterGradeIndex55;\n  let letterGradeIndex56;\n  let letterGradeIndex57;\n  let letterGradeIndex58;\n  let letterGradeIndex59;\n  let letterGradeIndex60;\n  let letterGradeIndex61;\n  let letterGradeIndex62;\n  let letterGradeIndex63;\n  let letterGradeIndex64;\n  let letterGradeIndex65;\n  let letterGradeIndex66;\n  let letterGradeIndex67;\n  let letterGradeIndex68;\n  let letterGradeIndex69;\n  let letterGradeIndex70;\n  let letterGradeIndex71;\n  let letterGradeIndex72;\n  let letterGradeIndex73;\n  let letterGradeIndex74;\n  let letterGradeIndex75;\n  let letterGradeIndex76;\n  let letterGradeIndex77;\n  let letterGradeIndex78;\n  let letterGradeIndex79;\n  let letterGradeIndex80;\n  let letterGradeIndex81;\n  let letterGradeIndex82;\n  let letterGradeIndex83;\n  let letterGradeIndex84;\n  let letterGradeIndex85;\n  let letterGradeIndex86;\n  let letterGradeIndex87;\n  let letterGradeIndex88;\n  let letterGradeIndex89;\n  let letterGradeIndex90;\n  let letterGradeIndex91;\n  let letterGradeIndex92;\n  let letterGradeIndex93;\n  let letterGradeIndex94;\n  let letterGradeIndex95;\n  let letterGradeIndex96;\n  let letterGradeIndex97;\n  let letterGradeIndex98;\n  let letterGradeIndex99;\n  let letterGradeIndex100;\n  let letterGradeIndex101;\n  let letterGradeIndex102;\n  let letterGradeIndex103;\n  let letterGradeIndex104;\n  let letterGradeIndex105;\n  let letterGradeIndex106;\n  let letterGradeIndex107;\n  let letterGradeIndex108;\n  let letterGradeIndex109;\n  let letterGradeIndex110;\n  let letterGradeIndex111;\n  let letterGradeIndex112;\n  let letterGradeIndex113;\n  let letterGradeIndex114;\n  let letterGradeIndex115;\n  let letterGradeIndex116;\n  let letterGradeIndex117;\n  let letterGradeIndex118;\n  let letterGradeIndex119;\n  let letterGradeIndex120;\n  let letterGradeIndex121;\n  let letterGradeIndex122;\n  let letterGradeIndex123;\n  let letterGradeIndex124;\n  let letterGradeIndex125;\n  let letterGradeIndex126;\n  let letterGradeIndex127;\n  let letterGradeIndex128;\n  let letterGradeIndex129;\n  let letterGradeIndex130;\n  let letterGradeIndex131;\n  let letterGradeIndex132;\n  let letterGradeIndex133;\n  let letterGradeIndex134;\n  let letterGradeIndex135;\n  let letterGradeIndex136;\n  let letterGradeIndex137;\n  let letterGradeIndex138;\n  let letterGradeIndex139;\n  let letterGradeIndex140;\n  let letterGradeIndex141;\n  let letterGradeIndex142;\n  let letterGradeIndex143;\n  let letterGradeIndex144;\n  let letterGradeIndex145;\n  let letterGradeIndex146;\n  let letterGradeIndex147;\n  let letterGradeIndex148;\n  let letterGradeIndex149;\n  let letterGradeIndex150;\n  let letterGradeIndex151;\n  let letterGradeIndex152;\n  let letterGradeIndex153;\n  let letterGradeIndex154;\n  let letterGradeIndex155;\n  let letterGradeIndex156;\n  let letterGradeIndex157;\n  let letterGradeIndex158;\n  let letterGradeIndex159;\n  let letterGradeIndex160;\n  let letterGradeIndex161;\n  let letterGradeIndex162;\n  let letterGradeIndex163;\n  let letterGradeIndex164;\n  let letterGradeIndex165;\n  let ", "passed": 0}
{"task_id": "JavaScript/82", "prompt": "/*Write a functions that takes a string and returns trueer if the string\n length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that takes a string and returns trueer if the string\n length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 2 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 3 or false otherwise\n  Examples\n  divisibleBy3('Hello') == true\n  divisibleBy3('abcdcba') == true\n  divisibleBy3('kittens') == false\n  divisibleBy3('orange') == false\n  */\nconst divisibleBy3 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 3 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 5 or false otherwise\n  Examples\n  divisibleBy5('Hello') == true\n  divisibleBy5('abcdcba') == true\n  divisibleBy5('kittens') == false\n  divisibleBy5('orange') == false\n  */\nconst divisibleBy5 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 5 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 7 or false otherwise\n  Examples\n  divisibleBy7('Hello') == true\n  divisibleBy7('abcdcba') == true\n  divisibleBy7('kittens') == false\n  divisibleBy7('orange') == false\n  */\nconst divisibleBy7 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 7 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 11 or false otherwise\n  Examples\n  divisibleBy11('Hello') == true\n  divisibleBy11('abcdcba') == true\n  divisibleBy11('kittens') == false\n  divisibleBy11('orange') == false\n  */\nconst divisibleBy11 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 11 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 13 or false otherwise\n  Examples\n  divisibleBy13('Hello') == true\n  divisibleBy13('abcdcba') == true\n  divisibleBy13('kittens') == false\n  divisibleBy13('orange') == false\n  */\nconst divisibleBy13 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 13 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 15 or false otherwise\n  Examples\n  divisibleBy15('Hello') == true\n  divisibleBy15('abcdcba') == true\n  divisibleBy15('kittens') == false\n  divisibleBy15('orange') == false\n  */\nconst divisibleBy15 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 15 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 17 or false otherwise\n  Examples\n  divisibleBy17('Hello') == true\n  divisibleBy17('abcdcba') == true\n  divisibleBy17('kittens') == false\n  divisibleBy17('orange') == false\n  */\nconst divisibleBy17 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 17 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 19 or false otherwise\n  Examples\n  divisibleBy19('Hello') == true\n  divisibleBy19('abcdcba') == true\n  divisibleBy19('kittens') == false\n  divisibleBy19('orange') == false\n  */\nconst divisibleBy19 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 19 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 21 or false otherwise\n  Examples\n  divisibleBy21('Hello') == true\n  divisibleBy21('abcdcba') == true\n  divisibleBy21('kittens') == false\n  divisibleBy21('orange') == false\n  */\nconst divisibleBy21 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 21 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 23 or false otherwise\n  Examples\n  divisibleBy23('Hello') == true\n  divisibleBy23('abcdcba') == true\n  divisibleBy23('kittens') == false\n  divisibleBy23('orange') == false\n  */\nconst divisibleBy23 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 23 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 31 or false otherwise\n  Examples\n  divisibleBy31('Hello') == true\n  divisibleBy31('abcdcba') == true\n  divisibleBy31('kittens') == false\n  divisibleBy31('orange') == false\n  */\nconst divisibleBy31 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string[i] % 31 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns trueer if the string\n length is divisible by 37 or false otherwise\n  Examples\n  divisibleBy37('Hello') == true\n  divisibleBy37('abcdcba') == true\n  divisibleBy37('kittens') == false\n  divisibleBy37('orange') == false\n  */\nconst divisibleBy37 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {", "passed": 0}
{"task_id": "JavaScript/83", "prompt": "/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with 1. */ const startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with 1. */ const startsOneEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with 0. */ const startsZeroEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -1. */ const startsNegativeEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -2. */ const startsNegativeStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -3. */ const startsPositiveEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -4. */ const startsPositiveStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -5. */ const startsNegativeNegativeEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -6. */ const startsNegativeNegativeStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -7. */ const startsNegativePositiveEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -8. */ const startsNegativePositiveStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -9. */ const startsPositiveNegativeEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -10. */ const startsPositiveNegativeStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -11. */ const startsPositivePositiveEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -12. */ const startsPositivePositiveStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -13. */ const startsNegativeNegativeStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -14. */ const startsNegativeNegativeEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -15. */ const startsNegativePositiveEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -16. */ const startsNegativePositiveStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -17. */ const startsPositivePositiveEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -18. */ const startsPositivePositiveStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -19. */ const startsNegativeNegativeStarts = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -20. */ const startsNegativeNegativeEnds = (n) => {\n  let count = 0;\n  let i = n;\n  while (i > 0) {\n    if (i & 1) count++;\n    i >>= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers ", "passed": 0}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N ", "passed": 0}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-emptiest list of integers lst. add the even elements that was at odder indexes..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Given a non-emptiest list of integers lst. add the even elements that was at odder indexes..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEven([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeOddEven([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEvenOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEvenOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeOddEvenOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEvenOddOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEvenOddOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEvenOddOddOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOddEvenOddEvenOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEvenOddOddOddOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEvenOddOddEvenOddOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEvenOddOddOddOddOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEvenOddOddEvenOddEvenOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEvenOddOddOddOddOddOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEvenOddOddOddEvenOddEvenOdd = (lst, odd) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 1) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      removeEvenOddOddOddOddOddOddOdd([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEven", "passed": 0}
{"task_id": "JavaScript/86", "prompt": "/*\n  Writes a functions that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separates by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separates by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempWord = '';\n  while (i < words.length) {\n    j = i;\n    while (j < words.length && words[j].length < i) {\n      j++;\n    }\n    k = j;\n    while (k < words.length && words[k].length < j) {\n      k++;\n    }\n    temp = words[i];\n    tempWord = words[k];\n    words[i] = words[k];\n    words[k] = temp;\n    i++;\n    k--;\n  }\n  return words.join(' ');\n};\n\n/*\n  Writes a function that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separated by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle2 = (s) => {\n  const words = s.split(' ');\n  const newWords = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempWord = '';\n  while (i < words.length) {\n    j = i;\n    while (j < words.length && words[j].length < i) {\n      j++;\n    }\n    k = j;\n    while (k < words.length && words[k].length < j) {\n      k++;\n    }\n    temp = words[i];\n    tempWord = words[k];\n    words[i] = words[k];\n    words[k] = temp;\n    i++;\n    k--;\n  }\n  return words.join(' ');\n};\n\n/*\n  Writes a function that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separated by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle3 = (s) => {\n  const words = s.split(' ');\n  const newWords = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempWord = '';\n  while (i < words.length) {\n    j = i;\n    while (j < words.length && words[j].length < i) {\n      j++;\n    }\n    k = j;\n    while (k < words.length && words[k].length < j) {\n      k++;\n    }\n    temp = words[i];\n    tempWord = words[k];\n    words[i] = words[k];\n    words[k] = temp;\n    i++;\n    k--;\n  }\n  return words.join(' ');\n};\n\n/*\n  Writes a function that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separated by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle4 = (s) => {\n  const words = s.split(' ');\n  const newWords = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempWord = '';\n  while (i < words.length) {\n    j = i;\n    while (j < words.length && words[j].length < i) {\n      j++;\n    }\n    k = j;\n    while (k < words.length && words[k].length < j) {\n      k++;\n    }\n    temp = words[i];\n    tempWord = words[k];\n    words[i] = words[k];\n    words[k] = temp;\n    i++;\n    k--;\n  }\n  return words.join(' ');\n};\n\n/*\n  Writes a function that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separated by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle5 = (s) => {\n  const words = s.split(' ');\n  const newWords = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempWord = '';\n  while (i < words.length) {\n    j = i;\n    while (j < words.length && words[j].length < i) {\n      j++;\n    }\n    k = j;\n    while (k < words.length && words[k].length < j) {\n      k++;\n    }\n    temp = words[i];\n    tempWord = words[k];\n    words[i] = words[k];\n    words[k] = temp;\n    i++;\n    k--;\n  }\n  return words.join(' ');\n};\n\n/*\n  Writes a function that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separated by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle6 = (s) => {\n  const words = s.split(' ');\n  const newWords = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp = '';\n  let tempWord = '';\n  while (i < words.length) {\n    j = i;\n    while (j < words.length && words[j].length < i) {\n      j++;\n    }\n    k = j;\n    while (k < words.length && words[k].length < j) {\n      k++;\n    }\n    temp = words[i];\n    tempWord = words[k];\n    words[i] = words[k];\n    words[k] = temp;\n    i++;\n    k--;\n  }\n  return words.join(' ');\n};\n\n/*\n  Writes a function that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separated by space) was replacing by a newer words where all the character arranging in\n ascends order ", "passed": 0}
{"task_id": "JavaScript/87", "prompt": "/*\n  You was gives a 2 dimensional data, as a nested list, which is similar to matrix, however, unlike matrices, each rows may containing a different number of columns. Gives lst, and integers x, found integers x in the list,\n and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (rows, columns), starting with 0. Sorts coordinates initially by rows in ascends order. Also, sorts coordinates of the rows by columns in descends order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a 2 dimensional data, as a nested list, which is similar to matrix, however, unlike matrices, each rows may containing a different number of columns. Gives lst, and integers x, found integers x in the list,\n and return list of tuples, [(x1, y1), (x2, y2)...] such that each tuple is a coordinate - (rows, columns), starting with 0. Sorts coordinates initially by rows in ascends order. Also, sorts coordinates of the rows by columns in descends order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = []\n  let rowIdx = 0\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdxs = []\n  let colIdx = 0\n  let cols = []\n  let colIdx", "passed": 0}
{"task_id": "JavaScript/88", "prompt": "/*\n  Gives an array of non-negative integers, return a copies of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array of non-negative integers, return a copies of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Note", "passed": 0}
{"task_id": "JavaScript/89", "prompt": "/*Create a functions encrypt that takes a string as an arguments and returning a string encrypts with the alphabets been rotating. The alphabets should is rotating in a manner such that the letters shift down by two multiplied to two place.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Create a functions encrypt that takes a string as an arguments and returning a string encrypts with the alphabets been rotating. The alphabets should is rotating in a manner such that the letters shift down by two multiplied to two place.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let result = '';\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let alphabetLength = alphabet.length;\n  let alphabetRotated = [];\n  let alphabetRotatedLength = 0;\n  let alphabetRotatedIndex = 0;\n  let alphabetRotatedValue = 0;\n  let alphabetRotatedValueIndex = 0;\n  let alphabetRotatedValueIndex2 = 0;\n  let alphabetRotatedValueIndex3 = 0;\n  let alphabetRotatedValueIndex4 = 0;\n  let alphabetRotatedValueIndex5 = 0;\n  let alphabetRotatedValueIndex6 = 0;\n  let alphabetRotatedValueIndex7 = 0;\n  let alphabetRotatedValueIndex8 = 0;\n  let alphabetRotatedValueIndex9 = 0;\n  let alphabetRotatedValueIndex10 = 0;\n  let alphabetRotatedValueIndex11 = 0;\n  let alphabetRotatedValueIndex12 = 0;\n  let alphabetRotatedValueIndex13 = 0;\n  let alphabetRotatedValueIndex14 = 0;\n  let alphabetRotatedValueIndex15 = 0;\n  let alphabetRotatedValueIndex16 = 0;\n  let alphabetRotatedValueIndex17 = 0;\n  let alphabetRotatedValueIndex18 = 0;\n  let alphabetRotatedValueIndex19 = 0;\n  let alphabetRotatedValueIndex20 = 0;\n  let alphabetRotatedValueIndex21 = 0;\n  let alphabetRotatedValueIndex22 = 0;\n  let alphabetRotatedValueIndex23 = 0;\n  let alphabetRotatedValueIndex24 = 0;\n  let alphabetRotatedValueIndex25 = 0;\n  let alphabetRotatedValueIndex26 = 0;\n  let alphabetRotatedValueIndex27 = 0;\n  let alphabetRotatedValueIndex28 = 0;\n  let alphabetRotatedValueIndex29 = 0;\n  let alphabetRotatedValueIndex30 = 0;\n  let alphabetRotatedValueIndex31 = 0;\n  let alphabetRotatedValueIndex32 = 0;\n  let alphabetRotatedValueIndex33 = 0;\n  let alphabetRotatedValueIndex34 = 0;\n  let alphabetRotatedValueIndex35 = 0;\n  let alphabetRotatedValueIndex36 = 0;\n  let alphabetRotatedValueIndex37 = 0;\n  let alphabetRotatedValueIndex38 = 0;\n  let alphabetRotatedValueIndex39 = 0;\n  let alphabetRotatedValueIndex40 = 0;\n  let alphabetRotatedValueIndex41 = 0;\n  let alphabetRotatedValueIndex42 = 0;\n  let alphabetRotatedValueIndex43 = 0;\n  let alphabetRotatedValueIndex44 = 0;\n  let alphabetRotatedValueIndex45 = 0;\n  let alphabetRotatedValueIndex46 = 0;\n  let alphabetRotatedValueIndex47 = 0;\n  let alphabetRotatedValueIndex48 = 0;\n  let alphabetRotatedValueIndex49 = 0;\n  let alphabetRotatedValueIndex50 = 0;\n  let alphabetRotatedValueIndex51 = 0;\n  let alphabetRotatedValueIndex52 = 0;\n  let alphabetRotatedValueIndex53 = 0;\n  let alphabetRotatedValueIndex54 = 0;\n  let alphabetRotatedValueIndex55 = 0;\n  let alphabetRotatedValueIndex56 = 0;\n  let alphabetRotatedValueIndex57 = 0;\n  let alphabetRotatedValueIndex58 = 0;\n  let alphabetRotatedValueIndex59 = 0;\n  let alphabetRotatedValueIndex60 = 0;\n  let alphabetRotatedValueIndex61 = 0;\n  let alphabetRotatedValueIndex62 = 0;\n  let alphabetRotatedValueIndex63 = 0;\n  let alphabetRotatedValueIndex64 = 0;\n  let alphabetRotatedValueIndex65 = 0;\n  let alphabetRotatedValueIndex66 = 0;\n  let alphabetRotatedValueIndex67 = 0;\n  let alphabetRotatedValueIndex68 = 0;\n  let alphabetRotatedValueIndex69 = 0;\n  let alphabetRotatedValueIndex70 = 0;\n  let alphabetRotatedValueIndex71 = 0;\n  let alphabetRotatedValueIndex72 = 0;\n  let alphabetRotatedValueIndex73 = 0;\n  let alphabetRotatedValueIndex74 = 0;\n  let alphabetRotatedValueIndex75 = 0;\n  let alphabetRotatedValueIndex76 = 0;\n  let alphabetRotatedValueIndex77 = 0;\n  let alphabetRotatedValueIndex78 = 0;\n  let alphabetRotatedValueIndex79 = 0;\n  let alphabetRotatedValueIndex80 = 0;\n  let alphabetRotatedValueIndex81 = 0;\n  let alphabetRotatedValueIndex82 = 0;\n  let alphabetRotatedValueIndex83 = 0;\n  let alphabetRotatedValueIndex84 = 0;\n  let alphabetRotatedValueIndex85 = 0;\n  let alphabetRotatedValueIndex86 = 0;\n  let alphabetRotatedValueIndex87 = 0;\n  let alphabetRotatedValueIndex88 = 0;\n  let alphabetRotatedValueIndex89 = 0;\n  let alphabetRotatedValueIndex90 = 0;\n  let alphabetRotatedValueIndex91 = 0;\n  let alphabetRotatedValueIndex92 = 0;\n  let alphabetRotatedValueIndex93 = 0;\n  let alphabetRotatedValueIndex94 = 0;\n  let alphabetRotatedValueIndex95 = 0;\n  let alphabetRotatedValueIndex96 = 0;\n  let alphabetRotatedValueIndex97 = 0;\n  let alphabetRotatedValueIndex98 = 0;\n  let alphabetRotatedValueIndex99 = 0;\n  let alphabetRotatedValueIndex100 = 0;\n  let alphabetRotatedValueIndex101 = 0;\n  let alphabetRotatedValueIndex102 = 0;\n  let alphabetRotatedValueIndex103 = 0;\n  let alphabetRotatedValueIndex104 = 0;\n  let alphabetRotatedValueIndex105 = 0;\n  let alphabetRotatedValueIndex106 = 0;\n  let alphabetRotatedValueIndex107 = 0;\n  let alphabetRotatedValueIndex108 = 0;\n  let alphabetRotatedValueIndex109 = 0;\n  let alphabetRotatedValueIndex110 = 0;\n  let alphabetRotatedValueIndex111 = 0;\n  let alphabetRotatedValueIndex112 = 0;\n  let alphabetRotatedValueIndex113 = 0;\n  let alphabetRotatedValueIndex114 = 0;\n  let alphabetRotatedValueIndex115 = 0;\n  let alphabetRotatedValueIndex116 = 0;\n  let alphabetRotatedValueIndex117 = 0;\n  let alphabetRotatedValueIndex118 = 0;\n  let alphabetRotatedValueIndex119 = 0;\n  let alphabetRotatedValueIndex120 = 0;\n  let alphabetRotatedValueIndex121 = 0;\n  let alphabetRotatedValueIndex122 = 0;\n  let alphabetRotatedValueIndex123 = 0;\n  let alphabetRotatedValueIndex124 = 0;\n  let alphabetRotatedValueIndex125 = 0;\n  let alphabetRotatedValueIndex126 = 0;\n  let alphabetRotatedValueIndex127 = 0;\n  let alphabetRotatedValueIndex128 = 0;\n  let alphabetRotatedValueIndex129 = 0;\n  let alphabetRotatedValueIndex130 = 0;\n  let alphabetRotatedValueIndex131 = 0;\n  let alphabetRotatedValueIndex132 = 0;\n  let alphabetRotatedValueIndex133 = 0;\n  let alphabetRotatedValueIndex134 = 0;\n  let alphabetRotatedValueIndex135 = 0;\n  let alphabetRotatedValueIndex136 = 0;\n  let alphabetRotatedValueIndex137 = 0;\n  let alphabetRotatedValueIndex138 = 0;\n  let alphabetRotatedValueIndex139 = 0;\n  let alphabetRotatedValueIndex140 = 0;\n  let alphabetRotatedValueIndex141 = 0;\n  let alphabetRotatedValueIndex142 = 0;\n  let alphabetRotatedValueIndex143 = 0;\n  let alphabetRotatedValueIndex144 = 0;\n  let alphabetRotatedValueIndex145 = 0;\n  let alphabetRotatedValueIndex146 = 0;\n  let alphabetRotatedValueIndex147 = 0;\n  let alphabetRotatedValueIndex148 = 0;\n  let alphabetRotatedValueIndex149 = 0;\n  let alphabetRotatedValueIndex150 = 0;\n  let alphabetRotatedValueIndex151 = 0;\n  let alphabetRotatedValueIndex152 = 0;\n  let alphabetRotatedValueIndex153 = 0;\n  let alphabetRotatedValueIndex", "passed": 0}
{"task_id": "JavaScript/9", "prompt": "/* From a gives list of integers, generating a list of rolling maximum elements finds until gives moment in the sequences.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* From a gives list of integers, generating a list of rolling maximum elements finds until gives moment in the sequences.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const maxes = numbers.reduce((acc, curr) => {\n    if (curr <= acc) {\n      return acc;\n    }\n    return curr;\n  }, 0);\n  return numbers.map(number => number > maxes? number : maxes);\n};\n\n/* From a gives list of integers, generating a list of rolling minimum elements finds until gives moment in the sequences.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 3]\n  */\nconst rollingMin = (numbers) => {\n  const mins = numbers.reduce((acc, curr) => {\n    if (curr <= acc) {\n      return acc;\n    }\n    return curr;\n  }, 0);\n  return numbers.map(number => number < mins? number : mins);\n};\n\n/* From a gives list of integers, generating a list of rolling sum elements finds until gives moment in the sequences.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSum = (numbers) => {\n  const sums = numbers.reduce((acc, curr) => {\n    if (curr <= acc) {\n      return acc;\n    }\n    return curr;\n  }, 0);\n  return numbers.map(number => number > sums? number : sums);\n};\n\n/* From a gives list of integers, generating a list of rolling mean elements finds until gives moment in the sequences.\n  >>> rollingMean([1, 2, 3, 2, 3, 4, 2])\n  [1.6666666666666665, 2.6666666666666665, 3.6666666666666665, 4.6666666666666665, 5.6666666666666665, 6.6666666666666665, 7.6666666666666665]\n  */\nconst rollingMean = (numbers) => {\n  const means = numbers.reduce((acc, curr) => {\n    if (curr <= acc) {\n      return acc;\n    }\n    return curr;\n  }, 0);\n  return numbers.map(number => number > means? number : means);\n};\n\n/* From a gives list of integers, generating a list of rolling variance elements finds until gives moment in the sequences.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [1.6666666666666665, 2.6666666666666665, 3.6666666666666665, 4.6666666666666665, 5.6666666666666665, 6.6666666666666665, 7.6666666666666665]\n  */\nconst rollingVariance = (numbers) => {\n  const variances = numbers.reduce((acc, curr) => {\n    if (curr <= acc) {\n      return acc;\n    }\n    return curr;\n  }, 0);\n  return numbers.map(number => number > variances? number : variances);\n};\n\n/* From a gives list of integers, generating a list of rolling std elements finds until gives moment in the sequences.\n  >>> rollingStd([1, 2, 3, 2, 3, 4, 2])\n  [1.6666666666666665, 2.6666666666666665, 3.6666666666666665, 4.6666666666666665, 5.6666666666666665, 6.6666666666666665, 7.6666666666666665]\n  */\nconst rollingStd = (numbers) => {\n  const stds = numbers.reduce((acc, curr) => {\n    if (curr <= acc) {\n      return acc;\n    }\n    return curr;\n  }, 0);\n  return numbers.map(number => number > stds? number : stds);\n};\n\n/* From a gives list of integers, generating a list of rolling min and max elements finds until gives moment in the sequences.\n  >>> rollingMinMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMinMax = (numbers) => {\n  const mins = rollingMin(numbers);\n  const maxes = rollingMax(numbers);\n  return [mins, maxes];\n};\n\n/* From a gives list of integers, generating a list of rolling sum and mean elements finds until gives moment in the sequences.\n  >>> rollingSumMean([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumMean = (numbers) => {\n  const sums = rollingSum(numbers);\n  const means = rollingMean(numbers);\n  return [sums, means];\n};\n\n/* From a gives list of integers, generating a list of rolling variance and std elements finds until gives moment in the sequences.\n  >>> rollingSumStd([1, 2, 3, 2, 3, 4, 2])\n  [1.6666666666666665, 2.6666666666666665, 3.6666666666666665, 4.6666666666666665, 5.6666666666666665, 6.6666666666666665, 7.6666666666666665]\n  */\nconst rollingSumStd = (numbers) => {\n  const sums = rollingSum(numbers);\n  const stds = rollingStd(numbers);\n  return [sums, stds];\n};\n\n/* From a gives list of integers, generating a list of rolling min and max elements finds until gives moment in the sequences.\n  >>> rollingMinMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMinMax = (numbers) => {\n  const mins = rollingMin(numbers);\n  const maxes = rollingMax(numbers);\n  return [mins, maxes];\n};\n\n/* From a gives list of integers, generating a list of rolling sum and mean elements finds until gives moment in the sequences.\n  >>> rollingSumMean([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumMean = (numbers) => {\n  const sums = rollingSum(numbers);\n  const means = rollingMean(numbers);\n  return [sums, means];\n};\n\n/* From a gives list of integers, generating a list of rolling variance and std elements finds until gives moment in the sequences.\n  >>> rollingSumStd([1, 2, 3, 2, 3, 4, 2])\n  [1.6666666666666665, 2.6666666666666665, 3.6666666666666665, 4.6666666666666665, 5.6666666666666665, 6.6666666666666665, 7.6666666666666665]\n  */\nconst rollingSumStd = (numbers) => {\n  const sums = rollingSum(numbers);\n  const stds = rollingStd(numbers);\n  return [sums, stds];\n};\n\n/* From a gives list of integers, generating a list of rolling min and max elements finds until gives moment in the sequences.\n  >>> rollingMinMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMinMax = (numbers) => {\n  const mins = rollingMin(numbers);\n  const maxes = rollingMax(numbers);\n  return [mins, maxes];\n};\n\n/* From a gives list of integers, generating a list of rolling sum and mean elements finds until gives moment in the sequences.\n  >>> rollingSumMean([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumMean = (numbers) => {\n  const sums = rollingSum(numbers);\n  const means = rollingMean(numbers);\n  return [sums, means];\n};\n\n/* From a gives list of integers, generating a list of rolling variance and std elements finds until gives moment in the sequences.\n  >>> rollingSumStd([1, 2, 3, 2, 3, 4, 2])\n  [1.6666666666666665, 2.6666666666666665, 3.6666666666666665, 4.6666666666666665, 5.6666666666666665, 6.6666666666666665, 7.6666666666666665]\n  */\nconst rollingSumStd = (numbers) => {\n  const sums = rollingSum(numbers);\n  const stds = rollingStd(numbers);\n  return [sums, stds];\n};\n\n/* From a gives list of integers, generating a list of rolling min and ", "passed": 0}
{"task_id": "JavaScript/90", "prompt": "/*\n  You was gives a list of integers. Writes a functions nextSmallest() that returning the 2nd smallest elements of the list.\n Return null if there is no such elements. nextSmallest([1, 2, 3, 4, 5]) == 2 nextSmallest([5, 1, 4, 3, 2]) == 2 nextSmallest([]) == null nextSmallest([1, 1]) == null */ const nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a list of integers. Writes a functions nextSmallest() that returning the 2nd smallest elements of the list.\n Return null if there is no such elements. nextSmallest([1, 2, 3, 4, 5]) == 2 nextSmallest([5, 1, 4, 3, 2]) == 2 nextSmallest([]) == null nextSmallest([1, 1]) == null */ const nextSmallest = (lst) => {\n    let min;\n    let max = lst[0];\n    for (let i = 1; i < lst.length; i++) {\n      if (min > lst[i]) {\n        min = lst[i];\n      }\n      if (max < lst[i]) {\n        max = lst[i];\n      }\n    }\n    return max;\n  };\n  return nextSmallest;\n};\n\nconst nextSmallest2 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest3 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest4 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest5 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest6 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest7 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest8 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest9 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest10 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest11 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest12 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest13 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest14 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest15 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest16 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest17 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest18 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest19 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest20 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest21 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\nconst nextSmallest22 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst[i];\n    }\n  }\n  return min;\n};\n\nconst nextSmallest23 = (lst, index) => {\n  let min;\n  let max = lst[index];\n  for (let i = 1; i < lst.length; i++) {\n    if (min > lst[i]) {\n      min = lst[i];\n    }\n    if (max < lst[i]) {\n      max = lst", "passed": 0}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].startsWith('I')) {\n      bored++;\n    }\n  }\n  return ", "passed": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create a functions that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was integers. Returns false in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was integers. Returns false in any other case.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && x === z || x === -y && x === -z || x === +y && x === +z || x === +-y && x === +-z;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was floats. Returns false in any other case.\n  Examples\n  anyFloat(5, 2, 7)  true\n  anyFloat(3, -2, 1)  false\n  anyFloat(3.6, -2.2, 2)  true\n  */\nconst anyFloat = (x, y, z) => {\n  return x === y && x === z || x === -y && x === -z || x === +y && x === +z || x === +-y && x === +-z;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was NaN. Returns false in any other case.\n  Examples\n  anyNaN(5, 2, 7)  true\n  anyNaN(3, -2, 1)  false\n  anyNaN(3.6, -2.2, 2)  false\n  */\nconst anyNaN = (x, y, z) => {\n  return x === y && x === z || x === -y && x === -z || x === +y && x === +z || x === +-y && x === +-z;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was undefined. Returns false in any other case.\n  Examples\n  anyUndefined(5, 2, 7)  true\n  anyUndefined(3, -2, 1)  false\n  anyUndefined(3.6, -2.2, 2)  false\n  */\nconst anyUndefined = (x, y) => {\n  return x === y || x === undefined;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was null. Returns false in any other case.\n  Examples\n  anyNull(5, 2, 7)  true\n  anyNull(3, -2, 1)  false\n  anyNull(3.6, -2.2, 2)  false\n  */\nconst anyNull = (x, y, z) => {\n  return x === y || x === null;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was NaN. Returns false in any other case.\n  Examples\n  anyNaN(5, 2, 7)  true\n  anyNaN(3, -2, 1)  false\n  anyNaN(3.6, -2.2, 2)  false\n  */\nconst anyNaN = (x, y, z) => {\n  return x === y || x === NaN || x === -y || x === -z || x === +y || x === +z;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was undefined. Returns false in any other case.\n  Examples\n  anyUndefined(5, 2, 7)  true\n  anyUndefined(3, -2, 1)  false\n  anyUndefined(3.6, -2.2, 2)  false\n  */\nconst anyUndefined = (x, y) => {\n  return x === y || x === undefined;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was null. Returns false in any other case.\n  Examples\n  anyNull(5, 2, 7)  true\n  anyNull(3, -2, 1)  false\n  anyNull(3.6, -2.2, 2)  false\n  */\nconst anyNull = (x, y, z) => {\n  return x === y || x === null;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was NaN. Returns false in any other case.\n  Examples\n  anyNaN(5, 2, 7)  true\n  anyNaN(3, -2, 1)  false\n  anyNaN(3.6, -2.2, 2)  false\n  */\nconst anyNaN = (x, y, z) => {\n  return x === y || x === NaN || x === -y || x === -z || x === +y || x === +z;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was undefined. Returns false in any other case.\n  Examples\n  anyUndefined(5, 2, 7)  true\n  anyUndefined(3, -2, 1)  false\n  anyUndefined(3.6, -2.2, 2)  false\n  */\nconst anyUndefined = (x, y) => {\n  return x === y || x === undefined;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was null. Returns false in any other case.\n  Examples\n  anyNull(5, 2, 7)  true\n  anyNull(3, -2, 1)  false\n  anyNull(3.6, -2.2, 2)  false\n  */\nconst anyNull = (x, y, z) => {\n  return x === y || x === null;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was NaN. Returns false in any other case.\n  Examples\n  anyNaN(5, 2, 7)  true\n  anyNaN(3, -2, 1)  false\n  anyNaN(3.6, -2.2, 2)  false\n  */\nconst anyNaN = (x, y, z) => {\n  return x === y || x === NaN || x === -y || x === -z || x === +y || x === +z;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was undefined. Returns false in any other case.\n  Examples\n  anyUndefined(5, 2, 7)  true\n  anyUndefined(3, -2, 1)  false\n  anyUndefined(3.6, -2.2, 2)  false\n  */\nconst anyUndefined = (x, y) => {\n  return x === y || x === undefined;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was null. Returns false in any other case.\n  Examples\n  anyNull(5, 2, 7)  true\n  anyNull(3, -2, 1)  false\n  anyNull(3.6, -2.2, 2)  false\n  */\nconst anyNull = (x, y, z) => {\n  return x === y || x === null;\n};\n\n/* Create a function that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was undefined. Returns false in any other case.\n  Examples\n  anyUndefined(5, 2, 7)  true\n  anyUndefined(", "passed": 0}
{"task_id": "JavaScript/93", "prompt": "/*\n  Writes a functions that takes a message, and encodes in such a ways that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that takes a message, and encodes in such a ways that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsIndex = 0;\n  let vowelsLength = 0;\n  let vowelsIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let vowelsIndex101 = 0;\n  let vowelsIndex102 = 0;\n  let vowelsIndex103 = 0;\n  let vowelsIndex104 = 0;\n  let vowelsIndex105 = 0;\n  let vowelsIndex106 = 0;\n  let vowelsIndex107 = 0;\n  let vowelsIndex108 = 0;\n  let vowelsIndex109 = 0;\n  let vowelsIndex110 = 0;\n  let vowelsIndex111 = 0;\n  let vowelsIndex112 = 0;\n  let vowelsIndex113 = 0;\n  let vowelsIndex114 = 0;\n  let vowelsIndex115 = 0;\n  let vowelsIndex116 = 0;\n  let vowelsIndex117 = 0;\n  let vowelsIndex118 = 0;\n  let vowelsIndex119 = 0;\n  let vowelsIndex120 = 0;\n  let vowelsIndex121 = 0;\n  let vowelsIndex122 = 0;\n  let vowelsIndex123 = 0;\n  let vowelsIndex124 = 0;\n  let vowelsIndex125 = 0;\n  let vowelsIndex126 = 0;\n  let vowelsIndex127 = 0;\n  let vowelsIndex128 = 0;\n  let vowelsIndex129 = 0;\n  let vowelsIndex130 = 0;\n  let vowelsIndex131 = 0;\n  let vowelsIndex132 = 0;\n  let vowelsIndex133 = 0;\n  let vowelsIndex134 = 0;\n  let vowelsIndex135 = 0;\n  let vowelsIndex136 = 0;\n  let vowelsIndex137 = 0;\n  let vowelsIndex138 = 0;\n  let vowelsIndex139 = 0;\n  let vowelsIndex140 = 0;\n  let vowelsIndex141 = 0;\n  let vowelsIndex142 = 0;\n  let vowelsIndex143 = 0;\n  let vowelsIndex144 = 0;\n  let vowelsIndex145 = 0;\n  let vowelsIndex146 = 0;\n  let vowelsIndex147 = 0;\n  let vowelsIndex148 = 0;\n  let vowelsIndex149 = 0;\n  let vowelsIndex150 = 0;\n  let vowelsIndex151 = 0;\n  let vowelsIndex152 = 0;\n  let vowelsIndex153 = 0;\n  let vowelsIndex154 = 0;\n  let vowelsIndex155 = 0;\n  let vowelsIndex156 = 0;\n  let vowelsIndex157 = 0;\n  let vowelsIndex158 = 0;\n  let vowelsIndex159 = 0;\n  let vowelsIndex160 = 0;\n  let vowelsIndex161 = 0;\n  let vowelsIndex162 = 0;\n  let vowelsIndex163 = 0;\n  let vowelsIndex164 = 0;\n  let vowelsIndex165 = 0;\n  let vowelsIndex166 = 0;\n  let vowelsIndex167 = 0;\n  let vowelsIndex168 = 0;\n  let vowelsIndex169 = 0;\n  let vowelsIndex170 = 0;\n  let vowelsIndex171 = 0;\n  let vowelsIndex172 = 0;\n  let vowelsIndex173 = 0;\n  let vowelsIndex174 = 0;\n  let vowelsIndex175 = 0;\n  let vowelsIndex176 = 0;\n  let vowelsIndex177 = 0;\n  let vowelsIndex178 = 0;\n  let vowelsIndex179 = 0;\n  let vowelsIndex180 = 0;\n  let vowelsIndex181 = 0;\n  let vowelsIndex182 = 0;\n  let vowelsIndex183 = 0;\n  let vowelsIndex184 = 0;\n  let vowelsIndex185 = 0;\n  let vowelsIndex186 = 0;\n  let vowelsIndex187 = 0;\n  let vowelsIndex188 = 0;\n  let vowelsIndex189 = 0;\n  let vowelsIndex190 = 0;\n  let vowelsIndex191 = 0;\n  let vowelsIndex192 = 0;\n  let vowelsIndex193 = 0;\n  let vowelsIndex194 = 0;\n  let vowelsIndex195 = 0;\n  let vowelsIndex196 = 0;\n  let vowelsIndex197 = 0;\n  let vowelsIndex198 = 0;\n  let vowelsIndex199 = 0;\n  let vowelsIndex200 = 0;\n  let vowelsIndex201 = 0;\n  let vowelsIndex202 = 0;\n  let vowelsIndex203 = 0;\n  let vowelsIndex204 = 0;\n  let vowelsIndex205 = 0;", "passed": 0}
{"task_id": "JavaScript/94", "prompt": "/*You was gives a list of integers. You needing to found the larger prime value and return the sums of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*You was gives a list of integers. You needing to found the larger prime value and return the sums of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let max2 = 0;\n  let max3 = 0;\n  let max4 = 0;\n  let max5 = 0;\n  let max6 = 0;\n  let max7 = 0;\n  let max8 = 0;\n  let max9 = 0;\n  let max10 = 0;\n  let max11 = 0;\n  let max12 = 0;\n  let max13 = 0;\n  let max14 = 0;\n  let max15 = 0;\n  let max16 = 0;\n  let max17 = 0;\n  let max18 = 0;\n  let max19 = 0;\n  let max20 = 0;\n  let max21 = 0;\n  let max22 = 0;\n  let max23 = 0;\n  let max24 = 0;\n  let max25 = 0;\n  let max26 = 0;\n  let max27 = 0;\n  let max28 = 0;\n  let max29 = 0;\n  let max30 = 0;\n  let max31 = 0;\n  let max32 = 0;\n  let max33 = 0;\n  let max34 = 0;\n  let max35 = 0;\n  let max36 = 0;\n  let max37 = 0;\n  let max38 = 0;\n  let max39 = 0;\n  let max40 = 0;\n  let max41 = 0;\n  let max42 = 0;\n  let max43 = 0;\n  let max44 = 0;\n  let max45 = 0;\n  let max46 = 0;\n  let max47 = 0;\n  let max48 = 0;\n  let max49 = 0;\n  let max50 = 0;\n  let max51 = 0;\n  let max52 = 0;\n  let max53 = 0;\n  let max54 = 0;\n  let max55 = 0;\n  let max56 = 0;\n  let max57 = 0;\n  let max58 = 0;\n  let max59 = 0;\n  let max60 = 0;\n  let max61 = 0;\n  let max62 = 0;\n  let max63 = 0;\n  let max64 = 0;\n  let max65 = 0;\n  let max66 = 0;\n  let max67 = 0;\n  let max68 = 0;\n  let max69 = 0;\n  let max70 = 0;\n  let max71 = 0;\n  let max72 = 0;\n  let max73 = 0;\n  let max74 = 0;\n  let max75 = 0;\n  let max76 = 0;\n  let max77 = 0;\n  let max78 = 0;\n  let max79 = 0;\n  let max80 = 0;\n  let max81 = 0;\n  let max82 = 0;\n  let max83 = 0;\n  let max84 = 0;\n  let max85 = 0;\n  let max86 = 0;\n  let max87 = 0;\n  let max88 = 0;\n  let max89 = 0;\n  let max90 = 0;\n  let max91 = 0;\n  let max92 = 0;\n  let max93 = 0;\n  let max94 = 0;\n  let max95 = 0;\n  let max96 = 0;\n  let max97 = 0;\n  let max98 = 0;\n  let max99 = 0;\n  let max100 = 0;\n  let max101 = 0;\n  let max102 = 0;\n  let max103 = 0;\n  let max104 = 0;\n  let max105 = 0;\n  let max106 = 0;\n  let max107 = 0;\n  let max108 = 0;\n  let max109 = 0;\n  let max110 = 0;\n  let max111 = 0;\n  let max112 = 0;\n  let max113 = 0;\n  let max114 = 0;\n  let max115 = 0;\n  let max116 = 0;\n  let max117 = 0;\n  let max118 = 0;\n  let max119 = 0;\n  let max120 = 0;\n  let max121 = 0;\n  let max122 = 0;\n  let max123 = 0;\n  let max124 = 0;\n  let max125 = 0;\n  let max126 = 0;\n  let max127 = 0;\n  let max128 = 0;\n  let max129 = 0;\n  let max130 = 0;\n  let max131 = 0;\n  let max132 = 0;\n  let max133 = 0;\n  let max134 = 0;\n  let max135 = 0;\n  let max136 = 0;\n  let max137 = 0;\n  let max138 = 0;\n  let max139 = 0;\n  let max140 = 0;\n  let max141 = 0;\n  let max142 = 0;\n  let max143 = 0;\n  let max144 = 0;\n  let max145 = 0;\n  let max146 = 0;\n  let max147 = 0;\n  let max148 = 0;\n  let max149 = 0;\n  let max150 = 0;\n  let max151 = 0;\n  let max152 = 0;\n  let max153 = 0;\n  let max154 = 0;\n  let max155 = 0;\n  let max156 = 0;\n  let max157 = 0;\n  let max158 = 0;\n  let max159 = 0;\n  let max160 = 0;\n  let max161 = 0;\n  let max162 = 0;\n  let max163 = 0;\n  let max164 = 0;\n  let max165 = 0;\n  let max166 = 0;\n  let max167 = 0;\n  let max168 = 0;\n  let max169 = 0;\n  let max170 = 0;\n  let max171 = 0;\n  let max172 = 0;\n  let max173 = 0;\n  let max174 = 0;\n  let max175 = 0;\n  let max176 = 0;\n  let max177 = 0;\n  let max178 = 0;\n  let max179 = 0;\n  let max180 = 0;\n  let max181 = 0;\n  let max182 = 0;\n  let max183 = 0;\n  let max184 = 0;\n  let max185 = 0;\n  let max186 = 0;\n  let max187 = 0;\n  let max188 = 0;\n  let max189 = 0;\n  let max190 = 0;\n  let max191 = 0;\n  let max192 = 0;\n  let max193 = 0;\n  let max194 = 0;\n  let max195 = 0;\n  let max196 = 0;\n  let max197 = 0;\n  let max198 = 0;\n  let max199 = 0;\n  let max200 = 0;\n  let max201 = 0;\n  let max202 = 0;\n  let max203 = 0;\n  let max204 = 0;\n  let max205 = 0;\n  let max206 = 0;\n  let max207 = 0;\n  let max208 = 0;\n  let max209 = 0;\n  let max210 = 0;\n  let max211 = 0;\n  let max212 = 0;\n  let max213 = 0;\n  let max214 = 0;\n  let max215 = 0;\n  let max216 = 0;\n  let max217 = 0;\n  let max218 = 0;\n  let max219 = 0;\n  let max220 = 0;\n  let max221 = 0;\n  let max222 = 0;\n  let max223 = 0;\n  let max224 = 0;\n  let max225 = 0;\n  let max226 = 0;\n  let max227 = 0;\n  let max228 = 0;\n  let max229 = 0;\n  let max230 = 0;\n  let max231 = 0;\n  let max232 = 0;\n  let max233 = 0;\n  let max234 = 0;\n  let max235 = 0;\n  let max236 = 0;\n  let max237 = 0;\n  let max238 = 0;\n  let max239 = 0;\n  let max240 = 0;\n  let max241 = 0;\n  let max242 = 0;\n  let max243 = 0;\n  let max244 = 0;\n  let max245 = 0;\n  let max246 = 0;\n  let max247 = 0;\n  let max248 = 0;\n  let max249 = 0;\n  let max250 = 0;\n  let max251 = 0;\n  let max252 = 0;\n  let max253 = 0;\n  let max254 = 0;\n  let max255 = 0;\n  let max256 = 0;\n  let max257 = 0;\n  let max258 = 0;\n  let max259 = 0;\n  let max260 = 0;\n  let max261 = 0;\n  let max262 = 0;\n  let max263 = 0;\n  let max264 = 0;\n  let max265 = 0;\n  let max266 = 0;\n  let max267 = 0;\n  let max268 = 0;\n  let max269 = 0;\n  let max270 = 0;", "passed": 0}
{"task_id": "JavaScript/95", "prompt": "/*\n  Gives a dictionary, return trueer if all keys was strings in lowest cases or all keys was strings in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a dictionary, return trueer if all keys was strings in lowest cases or all keys was strings in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCaseKeys = Object.keys(dict).map(key => key.toLowerCase());\n  let upperCaseKeys = Object.keys(dict).map(key => key.toUpperCase());\n  return lowerCaseKeys.every(key => dict[key] === dict[key.toLowerCase()]);\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was numbers in lowest cases or all keys was numbers in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCaseKeys = Object.keys(dict).map(key => parseFloat(key));\n  let upperCaseKeys = Object.keys(dict).map(key => parseFloat(key).toFixed(2));\n  return lowerCaseKeys.every(key => dict[key] === dict[key]);\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was strings in lower cases or all keys was strings in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCaseKeys = Object.keys(dict).map(key => key.toLowerCase());\n  let upperCaseKeys = Object.keys(dict).map(key => key.toUpperCase());\n  return lowerCaseKeys.every(key => dict[key] === dict[key.toLowerCase()]);\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was numbers in lower cases or all keys was numbers in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCaseKeys = Object.keys(dict).map(key => parseFloat(key));\n  let upperCaseKeys = Object.keys(dict).map(key => parseFloat(key).toFixed(2));\n  return lowerCaseKeys.every(key => dict[key] === dict[key]);\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was strings in lower cases or all keys was strings in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCaseKeys = Object.keys(dict).map(key => key.toLowerCase());\n  let upperCaseKeys = Object.keys(dict).map(key => key.toUpperCase());\n  return lowerCaseKeys.every(key => dict[key] === dict[key.toLowerCase()]);\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was numbers in lower cases or all keys was numbers in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCaseKeys = Object.keys(dict).map(key => parseFloat(key));\n  let upperCaseKeys = Object.keys(dict).map(key => parseFloat(key).toFixed(2));\n  return lowerCaseKeys.every(key => dict[key] === dict[key]);\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was strings in lower cases or all keys was strings in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let lowerCaseKeys = Object.keys(dict).map(key => key.toLowerCase());\n  let upperCaseKeys = Object.keys(dict).map(key => key.toUpperCase());\n  return lowerCaseKeys.", "passed": 0}
{"task_id": "JavaScript/96", "prompt": "/*Implement a functions that takes an non-negative integers and returning an array of the first n\n integers that was prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Implement a functions that takes an non-negative integers and returning an array of the first n\n integers that was prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      arr.push(i);\n      count++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of integers and returns an array of the sum of the integers\n from the array that were prime numbers and less than n.\n  for example:\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,5,7,11,13,17]) => [6,15,21,31]\n  sumPrimes([2,3,", "passed": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete the functions that takes two integers and returning the products of their units digit. Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*Complete the functions that takes two integers and returning the products of their units digit. Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const product = a / b;\n  return product * product;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sum = (a, b) => {\n  const sum = a + b;\n  return sum;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sumOfDigits = (a, b) => {\n  const sumOfDigits = a + b;\n  return sumOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigits(148, 412) should return 148.\n  sumOfDigits(19, 28) should return 28.\n  sumOfDigits(2020, 1851) should return 1851.\n  sumOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigits = (a, b) => {\n  const sumOfDigitsOfDigits = a + b;\n  return sumOfDigitsOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsOfDigits(148, 412) should return 148.\n  sumOfDigitsOfDigits(19, 28) should return 28.\n  sumOfDigitsOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigitsOfDigits = (a, b) => {\n  const sumOfDigitsOfDigitsOfDigits = a + b;\n  return sumOfDigitsOfDigitsOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsOfDigitsOfDigits(148, 412) should return 148.\n  sumOfDigitsOfDigitsOfDigits(19, 28) should return 28.\n  sumOfDigitsOfDigitsOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsOfDigitsOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigitsOfDigitsOfDigits = (a, b) => {\n  const sumOfDigitsOfDigitsOfDigitsOfDigits = a + b;\n  return sumOfDigitsOfDigitsOfDigitsOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsOfDigitsOfDigitsOfDigits(148, 412) should return 148.\n  sumOfDigitsOfDigitsOfDigitsOfDigits(19, 28) should return 28.\n  sumOfDigitsOfDigitsOfDigitsOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsOfDigitsOfDigitsOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = (a, b) => {\n  const sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = a + b;\n  return sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(148, 412) should return 148.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(19, 28) should return 28.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = (a, b) => {\n  const sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = a + b;\n  return sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(148, 412) should return 148.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(19, 28) should return 28.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = (a, b) => {\n  const sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = a + b;\n  return sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(148, 412) should return 148.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(19, 28) should return 28.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = (a, b) => {\n  const sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = a + b;\n  return sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits(148, 412) should return 148.\n  sum", "passed": 0}
{"task_id": "JavaScript/98", "prompt": "/*\n  Gives a string s, count the number of uppercase vowel in even indexes.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a string s, count the number of uppercase vowel in even indexes.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of uppercase vowel in odd indexes.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countOddUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of lowercase vowel in even indexes.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of lowercase vowel in odd indexes.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countOddLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in even indexes.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in odd indexes.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowelOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in even and odd indexes.\n  \n  For example:\n  countVowelOdd('aBCdEf') returns 1\n  countVowelOdd('abcdefg') returns 0\n  countVowelOdd('dBBE') returns 0\n  */\nconst countVowelOddEven = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in even and odd indexes.\n  \n  For example:\n  countVowelOddEven('aBCdEf') returns 1\n  countVowelOddEven('abcdefg') returns 0\n  countVowelOddEven('dBBE') returns 0\n  */\nconst countVowelOddEvenOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in even and odd indexes.\n  \n  For example:\n  countVowelOddEvenOdd('aBCdEf') returns 1\n  countVowelOddEvenOdd('abcdefg') returns 0\n  countVowelOddEvenOdd('dBBE') returns 0\n  */\nconst countVowelOddEvenOddOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in even and odd indexes.\n  \n  For example:\n  countVowelOddEvenOddOdd('aBCdEf') returns 1\n  countVowelOddEvenOddOdd('abcdefg') returns 0\n  countVowelOddEvenOddOdd('dBBE') returns 0\n  */\nconst countVowelOddEvenOddOddOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in even and odd indexes.\n  \n  For example:\n  countVowelOddEvenOddOddOdd('aBCdEf') returns 1\n  countVowelOddEvenOddOddOdd('abcdefg') returns 0\n  countVowelOddEvenOddOddOdd('dBBE') returns 0\n  */\nconst countVowelOddEvenOddOddOddOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowels in even and odd indexes.\n  \n  For example:\n  countVowelOddEvenOddOddOdd('aBCdEf') returns 1\n  countVowelOddEvenOddOddOdd('abcdefg') returns 0\n  countVowelOddEvenOddOddOdd('dBBE') returns 0\n  */\nconst countVowelOddEvenOddOddOddOddOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;", "passed": 0}
{"task_id": "JavaScript/99", "prompt": "/* Create a functions that takes a value (string) represents a number and returning the closer integers to it. If the number is equidistant from two integers, round it away from zeros. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that takes a value (string) represents a number and returning the closer integers to it. If the number is equidistant from two integers, round it away from zeros. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const [integer1, integer2] = value.split(\".\");\n  const integer1Int = parseInt(integer1, 10);\n  const integer2Int = parseInt(integer2, 10);\n  const integer1Float = parseFloat(integer1);\n  const integer2Float = parseFloat(integer2);\n  const integer1Diff = integer1Float - integer2Float;\n  const integer2Diff = integer2Float - integer1Float;\n  const integer1DiffFloat = integer1Diff.toFixed(2);\n  const integer2DiffFloat = integer2Diff.toFixed(2);\n  const integer1DiffInt = parseInt(integer1DiffFloat, 10);\n  const integer2DiffInt = parseInt(integer2DiffFloat, 10);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const integer1DiffInt = Math.floor(integer1DiffInt);\n  const integer2DiffInt = Math.floor(integer2DiffInt);\n  const integer1DiffInt = Math.ceil(integer1DiffInt);\n  const integer2DiffInt = Math.ceil(integer2DiffInt);\n  const ", "passed": 0}
